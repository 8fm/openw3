#include "build.h"
#include "wccVersionControl.h"
#include "../../common/redSystem/stringWriter.h"
#include "../../common/core/commandlet.h"
#include "../../common/core/dependencyLinker.h"
#include "../../common/core/depot.h"
#include "../../common/core/garbageCollector.h"
#include "../../common/core/sha256.h"
#include "../../common/redIO/redIO.h"

//////////////////////////////////////////////////////////////////////////

#ifndef WCC_LITE

#define HEADER_TEMPLATE \
TXT("/**\r\n")\
TXT("* Copyright (c) $year$ CD Projekt Red. All Rights Reserved.\r\n")\
TXT("*/\r\n")\
TXT("\r\n")\
TXT("#pragma once\r\n")\
TXT("\r\n")\
TXT("/* This file is automatically generated during the build process. Do not edit */\r\n")\
TXT("\r\n")\
TXT("const unsigned char SCRIPTS_HASH[] = $hash$;\r\n")

class CScriptsHashCommandlet : public ICommandlet
{
	DECLARE_ENGINE_CLASS( CScriptsHashCommandlet, ICommandlet, 0 );

public:
	CScriptsHashCommandlet();

	// Executes commandlet command
	virtual Bool Execute( const CommandletOptions& options );

	// Returns commandlet one-liner
	virtual const Char* GetOneLiner() const
	{
		return TXT("Scripts hasher");
	}

	// Prints commandlet help
	virtual void PrintHelp() const
	{
		LOG_WCC( TXT("Calculates scripts hash. Example usage: wcc.exe scriptshash --srcDir=z:\\dev\\src --scriptsFile=z:\\content\\content0\\cookedfinal.redscripts") );
	}
};

DEFINE_SIMPLE_RTTI_CLASS( CScriptsHashCommandlet, ICommandlet );
IMPLEMENT_ENGINE_CLASS( CScriptsHashCommandlet );

CScriptsHashCommandlet::CScriptsHashCommandlet()
{
	m_commandletName = CName( TXT("scriptshash") );
}

namespace ScriptCompilationHelpers
{
	Bool GetScriptsSha256( const String& scriptsFile, Ssha256& outHash );
}

Bool CScriptsHashCommandlet::Execute( const CommandletOptions& options )
{
	String srcDir;
	if ( !options.GetSingleOptionValue( TXT("srcDir"), srcDir) )
	{
		ERR_WCC( TXT("Missing srcDir arg") );
		return false;
	}
	srcDir.ReplaceAll(TXT('/'),TXT('\\'));
	if ( !srcDir.EndsWith( TXT("\\") ) )
		srcDir += TXT("\\");
	const String headerPath = srcDir + TXT("common\\engine\\scriptsHash.h");
	if ( !GFileManager->FileExist(headerPath) )
	{
		ERR_WCC(TXT("Header '%ls' not found"), headerPath.AsChar());
		return false;
	}

	if ( GFileManager->IsFileReadOnly( headerPath ) )
	{
		ERR_WCC(TXT("Header '%ls' is read-only"), headerPath.AsChar());
		return false;
	}

	String scriptsFile;
	if ( !options.GetSingleOptionValue( TXT("scriptsFile"), scriptsFile ) )
	{
		ERR_WCC( TXT("Missing scriptsFile arg") );
		return false;
	}
	scriptsFile.ReplaceAll(TXT('/'),TXT('\\'));

	if ( !scriptsFile.EndsWith(TXT(".redscripts")))
	{
		ERR_WCC(TXT("scriptsFile '%ls' should have .redscripts extension"), scriptsFile.AsChar());
		return false;
	}

	if ( !GFileManager->FileExist( scriptsFile ) )
	{
		ERR_WCC(TXT("Scripts '%ls' not found"), scriptsFile.AsChar());
		return false;
	}
	if ( GFileManager->GetFileSize( scriptsFile ) < 1 )
	{
		ERR_WCC(TXT("Scripts '%ls' empty"), scriptsFile.AsChar());
		return false;
	}

	Ssha256 hash;
	if ( !ScriptCompilationHelpers::GetScriptsSha256( scriptsFile, hash ) )
	{
		ERR_WCC(TXT("Failed call to CalculateSha256 for scriptsFile '%ls'"), scriptsFile.AsChar());
		return false;
	}

#ifdef RED_COMPILER_MSC
	const AnsiChar* year = &__DATE__[7]; // 'Mmm dd yyyy' format
#else
	const AnsiChar* year = "2015";
#endif

	Red::System::StackStringWriter< Char, 256 > hashWriter;
	hashWriter.Append(TXT("\""));
	for ( Uint32 i = 0; i < ARRAY_COUNT_U32(hash.m_value); ++i )
	{
		const Uint8 byteVal = hash.m_value[i];
		hashWriter.Appendf(TXT("\\x%02x"), byteVal);
	}
	hashWriter.Append(TXT("\""));

	String header(HEADER_TEMPLATE);
	header.Replace(TXT("$year$"), ANSI_TO_UNICODE(year));
	header.Replace(TXT("$hash$"), hashWriter.AsChar());

	if ( !GFileManager->SaveStringToFileWithUTF8( headerPath, header ) )
	{
		ERR_WCC(TXT("Failed to open header '%ls' for writing"), headerPath.AsChar());
		return false;
	}

	LOG_WCC(TXT("Header saved to to '%ls'"), headerPath.AsChar());
	LOG_WCC(TXT("%ls"), header.AsChar());

	return true;
}
#endif // !WCC_LITE
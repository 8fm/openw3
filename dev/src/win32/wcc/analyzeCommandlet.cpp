/**
* Copyright (c) 2014 CD Projekt Red. All Rights Reserved.
*/

#include "build.h"

#include "../../common/core/analyzer.h"
#include "../../common/core/bundledefinition.h"
#include "cookSeedFile.h"
#include "analyzeCommandlet.h"

IMPLEMENT_ENGINE_CLASS(CAnalyzeCommandlet)

CAnalyzeCommandlet::CAnalyzeCommandlet()
{
	m_commandletName = CName( TXT("analyze") );
}

CAnalyzeCommandlet::~CAnalyzeCommandlet()
{
}

Bool CAnalyzeCommandlet::Execute( const CommandletOptions& options )
{
	// first param is the analyzer name
	if ( options.GetFreeArguments().Size() < 1 )
	{
		ERR_WCC( TXT("Expecting analyzer name") );
		PrintHelp();
		return false;
	}

	// output file name
	String outputFilePath;
	if ( !options.GetSingleOptionValue( TXT("out"), outputFilePath ) )
	{
		ERR_WCC( TXT("Expecting absolute output file name to be specified with \"-out\" ") );
		return false;
	}

	// find the analyzer
	IAnalyzer* analyzerTool = NULL;
	const String analyzerName = options.GetFreeArguments()[0];
	{
		
		// use the RTTI to look up all analyzers
		TDynArray< CClass* > toolClasses;
		SRTTI::GetInstance().EnumClasses( ClassID< IAnalyzer >(), toolClasses );

		for ( Uint32 i=0; i<toolClasses.Size(); ++i )
		{
			CClass* toolClass = toolClasses[i];
			IAnalyzer* tool = toolClass->GetDefaultObject<IAnalyzer>();
			if ( analyzerName == tool->GetName() )
			{
				analyzerTool = tool;
				break;
			}
		}
	}

	// analyzer not found
	if ( !analyzerTool )
	{
		ERR_WCC( TXT("Analyzer '%ls' was not found"), analyzerName.AsChar() );
		return false;
	}

	// run the analyzer (pass the argument list intact)
	CAnalyzerOutputList fileOutputList;
	if ( !analyzerTool->DoAnalyze( options, fileOutputList ) )
	{
		ERR_WCC( TXT("Analyzer tool '%ls' has failed"), analyzerName.AsChar() );
		return false;
	}

	// let's get this sorted
	fileOutputList.SortEntries( );

	// create the seed file using the analyzer output
	CCookerSeedFile seedFile;
	if ( !seedFile.Initialize( fileOutputList ) )
	{
		ERR_WCC( TXT("Error converting analyzer '%ls' output data into cooker seed file"), analyzerName.AsChar() );
		return false;
	}

	// save to JSON file
	if ( !seedFile.SaveToFile( outputFilePath ) )
	{
		ERR_WCC( TXT("Failed to save bundle definition file '%ls' generated by tool '%ls'"), 
			outputFilePath.AsChar(), analyzerName.AsChar() );
		return false;
	}

	// saved
	return true;
}

const Char* CAnalyzeCommandlet::GetOneLiner() const
{
	return TXT("Analyze game and engine data and output cook lists");
}

void CAnalyzeCommandlet::PrintHelp() const
{
	LOG_WCC( TXT( "Usage: " ) );
	LOG_WCC( TXT( "  analyze <name> -out <absolutepath> [optional params]" ) );
	LOG_WCC( TXT( "" ) );

	TDynArray< CClass* > toolClasses;
	SRTTI::GetInstance().EnumClasses( ClassID< IAnalyzer >(), toolClasses );
	if ( !toolClasses.Empty() )
	{
		LOG_WCC( TXT( "Avaiable analyzers:" ) );

		for ( Uint32 i=0; i<toolClasses.Size(); ++i )
		{
			CClass* toolClass = toolClasses[i];
			const IAnalyzer* tool = toolClass->GetDefaultObject<IAnalyzer>();

			LOG_WCC( TXT( "  %s - %s" ),
				tool->GetName(), tool->GetDescription() );
		}
	}
	else
	{
		LOG_WCC( TXT("No public analyzers avaiable") );
	}	
}

/**
* Copyright (c) 2014 CD Projekt Red. All Rights Reserved.
*/

#pragma once
#ifndef __COOK_OUTPUT_LIST_H__
#define __COOK_OUTPUT_LIST_H__

#include "../../common/core/resourceid.h"

#include "jsonFileHelper.h"

/// Cooker generated DB
/// This file is generated by the cooker and represents our knowledge of ALL the assets used in the game:
///
/// Contains:
///   All of the files used by the game
/// For every resource we have:
///   Conformed depot path (lower case, normalized path separators)
///   Import count (how many times the resource was visited: as both soft and hard dependency)
///   Seed flag (was the file initially in the seed list generated by the analyzer i.e. root file)
///   Hard dependencies (files directly imported)
///   Soft dependencies (files that may be loaded asynchronously)
///   Estimated main memory usage (estimation only, should not vary per platform)
///   GPU memory usage (actual, per platform)
///   Spatial usage list, per world (if possible)
///	  Resource tree depth (maximum dependency level, counting from seed file)
/// For every resource usage entry:
///     World name
///     Layer name
///     Entity name
///		Entity class
///     Component name
///		Component class
///     XYZ position

//////////////////////////
// Cook DB container for usage information
class CCookerResourceUsageEntry
{
public:
	Vector			m_position;
	Float			m_visibilityDistance;

	CName			m_worldName;
	CName			m_layerName;
	CName			m_entityName;
	CName			m_entityClass;
	CName			m_componentName;
	CName			m_componentClass;

	CCookerResourceUsageEntry();

	void Setup(const class CComponent* component);
	void Setup(const class CEntity* entity);
	void Setup(const class CLayer* layer);
	void Setup(const class CWorld* layer);

	const Uint64 CalcRuntimeHash() const;	// DO NOT STORE !
};


//////////////////////////
// Cook DB container for file information
class CCookerResourceEntry
{
public:
	typedef Red::Core::ResourceManagement::CResourceId	TResourceID;

	CCookerResourceEntry();

	RED_INLINE const TResourceID& GetFileId() const { return m_fileId; }
	RED_INLINE const StringAnsi& GetFilePath() const { return m_filePath; }
	RED_INLINE const Uint32 GetGroupIndex() const { return m_groupIndex; }

protected:
	TResourceID		m_fileId;
	StringAnsi		m_filePath;

public:
	Uint32			m_groupIndex;
};

//////////////////////////
// DB container
class CCookerDataBase : public JSONFileHelper
{
public:
	CCookerDataBase();
	~CCookerDataBase();

	// Reset data base
	void Reset();

	// Load cooker data base from file
	Bool LoadFromFile( const String& absoluteFilePath, const Bool includeAdditionalFiles = false );

	// Load cooker data base from file list
	Bool LoadFromFile( const TList<String>& cookDBFilePaths, const Bool includeAdditionalFiles = false );

	// Save cooker data base to file
	Bool SaveToFile( const String& absoluteFilePath, const Uint32 groupIndexToSave = 0 );

	//////////////////////////
	// Data base building

	typedef Uint64 TCookerDataBaseID;
	static const TCookerDataBaseID NO_ENTRY = 0;

	typedef TDynArray< CName > TChunkIDs;

	// Get data base file ID for given depot path (slow)
	TCookerDataBaseID GetFileEntry( const String& depotPath ) const;

	// Get data base file ID for given depot path (slow)
	TCookerDataBaseID GetFileEntry( const StringAnsi& depotPath ) const;

	// Get data base file ID for given depot path (slow)
	TCookerDataBaseID GetFileEntry( const Red::Core::ResourceManagement::CResourceId& resId ) const;

	// Add file info
	TCookerDataBaseID AddFileEntry( const String& depotPath );

	// Remove all inplace dependencies
	void RemoveInplaceDependencies( TCookerDataBaseID baseFile );

	// Add hard file dependency
	void AddFileHardDependency( TCookerDataBaseID baseFile, TCookerDataBaseID dependencyFile );

	// Add soft file dependency
	void AddFileSoftDependency( TCookerDataBaseID baseFile, TCookerDataBaseID dependencyFile );

	// Add inplace file dependency
	void AddFileInplaceDependency( TCookerDataBaseID baseFile, TCookerDataBaseID dependencyFile );

	// Set file estimated memory usage
	void SetFileMemoryUsageCPU( TCookerDataBaseID baseFile, const Uint32 estimatedMemoryUsage );

	// Set file estimated memory usage
	void SetFileMemoryUsageGPU( TCookerDataBaseID baseFile, const Uint32 estimatedMemoryUsage );

	// Set file disk size (accurate, may vary per platform, note: 4GB file size limit)
	void SetFileDiskSize(TCookerDataBaseID baseFile, const Uint32 fileDiskSize);

	// Set file resource class
	void SetFileResourceClass(TCookerDataBaseID baseFile, const CName& className);

	// Set/Clear the "buffer" flag for file entry
	void SetFileBufferFlag(TCookerDataBaseID baseFile, const Bool isBuffer);

	// Set/Clear the "consumed" flag for file entry
	void SetFileConsumedFlag(TCookerDataBaseID baseFile, const Bool isConsumed);

	// Set/Clear the "additional" flag for file entry
	void SetFileAdditionalFlag(TCookerDataBaseID baseFile, const Bool isAdditional);

	// Set/Clear the "seed" flag for file entry
	void SetFileSeedFlag(TCookerDataBaseID baseFile, const Bool isSeedFile);

	// Add file usage information
	void AddFileUsage( TCookerDataBaseID baseFile, const CCookerResourceUsageEntry& entry );

	// (SLOW) Get all entries from the data base (copy, slow)
	void GetFileEntries( TDynArray<CCookerResourceEntry>& outEntries ) const;

	// Get file entry for ID
	Bool GetFileEntry( TCookerDataBaseID baseFile, CCookerResourceEntry& outEntry ) const;

	// (SLOW) Enumerate file dependencies, beware of shitty interface with TDynArray output :(, returns false if the files does not exist in the cooking DB
	Bool GetFileDependencies( TCookerDataBaseID baseFile, TDynArray<CCookerResourceEntry>& outHardDependencies, TDynArray<CCookerResourceEntry>& outSoftDependencies, TDynArray<CCookerResourceEntry>& outInplaceDependencies ) const;

	// Get resource class for given file
	Bool GetFileResourceClass( TCookerDataBaseID baseFile, CName& outClassName ) const;

	// Get resource disk size
	Bool GetFileDiskSize( TCookerDataBaseID baseFile, Uint32& outDiskSize ) const;

	// Get resource CPU memory usage
	Bool GetFileMemoryUsageCPU( TCookerDataBaseID baseFile, Uint32& outMemoryUsage ) const;

	// Get resource GPU memory usage
	Bool GetFileMemoryUsageGPU( TCookerDataBaseID baseFile, Uint32& outMemoryUsage ) const;

	// Get the buffer flag for file, NOTE: do not confuse the function result with flag value
	Bool GetFileBufferFlag( TCookerDataBaseID baseFile, Bool& outBufferFlag ) const;

	// Get the seed flag for file, NOTE: do not confuse the function result with flag value
	Bool GetFileSeedFlag( TCookerDataBaseID baseFile, Bool& outSeedFlag ) const;

	// Get the consumed flag for file, NOTE: do not confuse the function result with flag value
	Bool GetFileConsumedFlag( TCookerDataBaseID baseFile, Bool& outConsumedFlag ) const;

	//////////////////////////
	// Data base queries (deterministic, threadsafe)

	// get all resources 
	template< typename Visitor >
	Bool QueryResourcesUnfiltered( Visitor& visitor ) const 
	{
		for ( const FileEntry* entry : m_entries )
		{
			if ( !visitor( *this, *entry ) )
				return false; // propagate result
		}

		return true;
	}

	// get resources matching given filter
	template< typename Visitor, typename Filter >
	Bool QueryResources( Visitor& visitor, const Filter& filter ) const 
	{
		for ( const FileEntry* entry : m_entries )
		{
			if ( filter( *this, *entry ) )
			{
				if ( !visitor( *this, *entry ) )
					return false; // propagate result
			}
		}

		return true;
	}

	// get all dependencies of the given resource, not recursive
	template< typename Visitor, typename Filter >
	Bool QueryHardDependencies( const TCookerDataBaseID file, Visitor& visitor, const Filter& filter ) const 
	{
		if ( file == NO_ENTRY )
			return false;

		const FileEntry* entry = FromID( file );

		// hard dependencies
		for ( const FileEntry* entry : entry->m_hardDependencies )
		{
			if ( filter( *this, *entry ) )
			{
				if ( !visitor( *this, *entry ) )
					return false; // propagate result
			}
		}

		return true;
	}

	// get all soft dependencies of the given resource, not recursive
	template< typename Visitor, typename Filter >
	Bool QuerySoftDependencies( const TCookerDataBaseID file, Visitor& visitor, const Filter& filter ) const 
	{
		if ( file == NO_ENTRY )
			return false;

		const FileEntry* entry = FromID( file );

		// soft dependencies
		for ( const FileEntry* entry : entry->m_softDependencies )
		{
			if ( filter( *this, *entry ) )
			{
				if ( !visitor( *this, *entry ) )
					return false; // propagate result
			}
		}

		return true;
	}

	// get all inplace dependencies of the given resource, not recursive
	template< typename Visitor, typename Filter >
	Bool QueryInplaceDependencies( const TCookerDataBaseID file, Visitor& visitor, const Filter& filter ) const 
	{
		if ( file == NO_ENTRY )
			return false;

		const FileEntry* entry = FromID( file );

		// soft dependencies
		for ( const FileEntry* entry : entry->m_inplaceDependencies )
		{
			if ( filter( *this, *entry ) )
			{
				if ( !visitor( *this, *entry ) )
					return false; // propagate result
			}
		}

		return true;
	}

private:
	struct FileEntry;
	struct UsageEntry;

	typedef THashMap< Red::Core::ResourceManagement::CResourceId, FileEntry* >		TEntriesMap;
	typedef TDynArray< FileEntry* >													TEntries;

	// file usage entry
	struct UsageEntry : public CCookerResourceUsageEntry
	{
		UsageEntry();
		UsageEntry(const CCookerResourceUsageEntry& entry);

		void Write(JSONWriter& writer) const;
		static UsageEntry* Parse( const JSONValue& val );
	};

	// file description
	struct FileEntry : public CCookerResourceEntry
	{
		Uint8		m_flagIsSeedFile:1;		// file is a seed file generated by the content analyzer, it is the root file of the resource tree being explored during cooking
		Uint8		m_flagIsBufferFile:1;	// file is a buffer size generated during cooking, there's no source file for this file in the depot
		Uint8		m_flagIsConsumed:1;		// file is a dependency but it's fully consumed and it's not outputed directly to the cooked directory (for example: png texture that are sucked into the texture cache)
		Uint8		m_flagIsAdditional:1;	// file is an additional file entry (like main content file in a DLC cook.db, it's reported only so we get the full picture but IS NOT part of the cook. Such files are filtered out unless the includeAdditionalFiles flag is set when loading the cook.db)

		Uint32		m_diskSize;

		Uint32		m_memoryCPU;
		Uint32		m_memoryGPU;

		CName		m_className; // resource class name (only valid resources)

		typedef TDynArray< FileEntry* >  TDependencies;
		TDependencies	m_softDependencies;
		TDependencies	m_hardDependencies;
		TDependencies	m_inplaceDependencies;

		typedef TDynArray< TResourceID > TUnresolvedDependencies;
		TUnresolvedDependencies	m_unresolvedSoftDependencies;
		TUnresolvedDependencies	m_unresolvedHardDependencies;
		TUnresolvedDependencies	m_unresolvedInplaceDependencies;

		typedef THashMap< Uint64, UsageEntry* > TUsageEntries;
		TUsageEntries	m_usage;

		// those are updated before saving
		Uint32		m_numImportedAsSoftDependency;
		Uint32		m_numImportedAsHardDependency;
		Uint32		m_numImportedAsInplaceDependency;
		Int32		m_dependencyLevel;

		FileEntry( const StringAnsi& filePath );

		void ResolveUnresolvedDependencies(const TEntriesMap& depList);
		void ResolveDepenencyOrder(const Int32 level);

		static FileEntry* Parse( const JSONValue& val );
		static void ParseDependencies( const JSONValue& val, TUnresolvedDependencies& outDependencies );

		void Write(JSONWriter& writer) const;
	};

	// file map
	TEntriesMap		m_entriesMap;
	TEntries		m_entries;

	TCookerDataBaseID ToID( FileEntry* entry ) const
	{
		if ( !entry ) return NO_ENTRY;
		return reinterpret_cast<TCookerDataBaseID>( entry );
	}

	FileEntry* FromID( TCookerDataBaseID id ) const
	{
		if ( id == NO_ENTRY ) return NULL;
		return reinterpret_cast<FileEntry*>( id);
	}
};

#endif
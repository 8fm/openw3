/**
 * Copyright © 2014 CD Projekt Red. All Rights Reserved.
 */

#include "build.h"

#include "inputDeviceTabletWintab.h"

#ifndef NO_TABLET_INPUT_SUPPORT

#include "inputLibWintab.h"

CInputDeviceTabletWintab::CInputDeviceTabletWintab()
	: m_contextHandle( nullptr )
	, m_activeCursor( 0 )
	, m_oldCursor( Uint32(-1) )
	, m_pressureButton( 0 )
	, m_pressureYesButtonOrg( 0 )
	, m_pressureYesButtonExt( 0 )
	, m_pressureNoButtonOrg( 0 )
	, m_pressureNoButtonExt( 0 )
	, m_vkLeftMouseButton( VK_LBUTTON )
	, m_prevPressure( 0.f )
	, m_pressure( 0.f )
	, m_prevLeftMouseButtonDown( false )
	, m_invert( false )
	, m_enabled( false )
{
	if ( ::GetSystemMetrics( SM_SWAPBUTTON ) != 0 )
	{
		m_vkLeftMouseButton = VK_RBUTTON;
	}
}

CInputDeviceTabletWintab::~CInputDeviceTabletWintab()
{
	Cleanup();
}

Bool CInputDeviceTabletWintab::Init( HWND hWnd )
{
	LOGCONTEXT lcMine;

	/* get default region */
	LibWintab::Info( WTI_DEFSYSCTX, 0, &lcMine );

	/* init the data structure */
	TabletSetup(&lcMine);

	/* open the region */
	m_contextHandle = LibWintab::Open( hWnd, &lcMine, TRUE );
	if ( ! m_contextHandle )
	{
		return false;
	}

	/* Q size set needs error-checking, but skipped here for */
	/* simplicity's sake. */
	LibWintab::QueueSizeSet( m_contextHandle, NPACKETQSIZE );

	SetEnabled( true );

	return true;
}

/* enforces context rules even if we didn't save the context. */
void CInputDeviceTabletWintab::TabletSetup( PLOGCONTEXT pLc )
{
	/* modify the digitizing region */
	Red::System::SNPrintF(pLc->lcName, LCNAMELEN, TXT("Lava Digitizing %x"), ::GetCurrentProcessId());
	pLc->lcPktData = PACKETDATA;
	pLc->lcPktMode = PACKETMODE;
	pLc->lcMoveMask = PACKETDATA;
	pLc->lcBtnUpMask = pLc->lcBtnDnMask;

	/* x & y match mouse points. */
	pLc->lcOutOrgX = 0;
	pLc->lcOutExtX = ::GetSystemMetrics(SM_CXSCREEN);
	pLc->lcOutOrgY = 0;
	/* the negative sign here reverses the sense of the Y axis. */
	/* WinTab uses a lower-left origin; MM_TEXT uses upper left. */
	pLc->lcOutExtY = -::GetSystemMetrics(SM_CYSCREEN);
}

void CInputDeviceTabletWintab::Reset()
{
	// Do nothing
}

void CInputDeviceTabletWintab::Update( BufferedInput& outBufferedInput )
{
	RED_UNUSED( outBufferedInput );

	m_prevPressure = m_pressure;
	m_pressure = UpdatePressure();

	const Bool leftButtonDown = ( ::GetAsyncKeyState( m_vkLeftMouseButton ) & 0x8000 ) != 0;
	
	// Released button
	if ( ( m_prevLeftMouseButtonDown ^ leftButtonDown ) && ! leftButtonDown )
	{
		m_invert = false;
	}
	m_prevLeftMouseButtonDown = leftButtonDown;
}

Float CInputDeviceTabletWintab::UpdatePressure()
{
	PACKET localPacketBuf[NPACKETQSIZE];

	Int32 packets = LibWintab::PacketsGet( m_contextHandle, NPACKETQSIZE, &localPacketBuf );

	Int32 pressure = 0;
	if ( packets ) 
	{
		for ( Int32 iPacket = 0; iPacket < packets; iPacket++ )
		{
			Int32 packetPressure = GetPressure( localPacketBuf[iPacket] );
			pressure = Max( pressure, packetPressure );
			m_invert = localPacketBuf[iPacket].pkOrientation.orAltitude < 0;
		}
	}
	else 
	{
		pressure = 255;
	}

	if ( m_invert ) pressure = -pressure;

	return pressure / 255.f;
}

Uint32 CInputDeviceTabletWintab::GetPressure( const PACKET& packet )
{
	Uint32 result = 0;

	m_activeCursor = packet.pkCursor;
	if ( m_activeCursor != m_oldCursor ) 
	{
		/* re-init on cursor change. */
		PressureInit();
		m_oldCursor = m_activeCursor;
	}

	/* scaling output range is 0-255 */

	if ( packet.pkButtons & ( 1 << m_pressureButton ) ) 
	{
		/* if pressure-activated button is down, */
		/* scale pressure output to compensate btn marks */
		result = packet.pkNormalPressure - m_pressureYesButtonOrg;
		result = MulDiv( result, 255, m_pressureYesButtonExt );
	}
	else 
	{
		/* if pressure-activated button is not down, */
		/* scale pressure output directly */
		result = packet.pkNormalPressure - m_pressureNoButtonOrg;
		result = MulDiv( result, 255, m_pressureNoButtonExt );
	}

	return result;
}

void CInputDeviceTabletWintab::PressureInit()
{
	/* browse WinTab's many info items to discover pressure handling. */
	AXIS np;
	LOGCONTEXT lc;
	BYTE logBtns[32];
	UINT btnMarks[2];
	UINT size;

	/* discover the LOGICAL button generated by the pressure channel. */
	/* get the PHYSICAL button from the cursor category and run it */
	/* through that cursor's button map (usually the identity map). */
	m_pressureButton = (BYTE)-1;
	LibWintab::Info(WTI_CURSORS + m_activeCursor, CSR_NPBUTTON, &m_pressureButton);
	size = LibWintab::Info(WTI_CURSORS + m_activeCursor, CSR_BUTTONMAP, &logBtns);
	if ((UINT)m_pressureButton < size)
		m_pressureButton = logBtns[m_pressureButton];

	/* get the current context for its device variable. */
	LibWintab::Get( m_contextHandle, &lc );

	/* get the size of the pressure axis. */
	LibWintab::Info(WTI_DEVICES + lc.lcDevice, DVC_NPRESSURE, &np);
	m_pressureNoButtonOrg = (UINT)np.axMin;
	m_pressureNoButtonExt = (UINT)np.axMax - (UINT)np.axMin;

	/* get the button marks (up & down generation thresholds) */
	/* and calculate what pressure range we get when pressure-button is down. */
	btnMarks[1] = 0; /* default if info item not present. */
	LibWintab::Info(WTI_CURSORS + m_activeCursor, CSR_NPBTNMARKS, btnMarks);
	m_pressureYesButtonOrg = btnMarks[1];
	m_pressureYesButtonExt = (UINT)np.axMax - btnMarks[1];
}

void CInputDeviceTabletWintab::SetEnabled( Bool enabled )
{
	RED_ASSERT( ::SIsMainThread() );

	if ( m_enabled != enabled )
	{
		m_enabled = enabled;

		LibWintab::Overlap( m_contextHandle, enabled );
		m_prevPressure = 0.f;
		m_pressure = 0.f;
		m_prevLeftMouseButtonDown = false;
	}
}

void CInputDeviceTabletWintab::Cleanup()
{
	if ( m_contextHandle )
	{
		LibWintab::Close( m_contextHandle );
		m_contextHandle = nullptr;
	}
}

#endif // NO_TABLET_INPUT_SUPPORT
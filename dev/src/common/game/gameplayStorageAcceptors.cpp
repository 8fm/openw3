/*
* Copyright © 2014 CD Projekt Red. All Rights Reserved.
*/

#include "build.h"
#include "gameplayStorageAcceptors.h"

using namespace GameplayStorageAcceptors;

namespace
{
	//! Get box point nearest to the given position
	RED_INLINE Vector GetNearestPoint( const Box& box, const Vector& position )
	{
		return Vector::Min4( box.Max, Vector::Max4( box.Min, position ) );
	}

	RED_INLINE Bool IsInRange2D( const Vector& diff, const Vector& range )
	{
		return ( MAbs( diff.X ) < range.X && MAbs( diff.Y ) < range.Y );
	}

	RED_INLINE Bool IsInRange2D( const Vector& a, const Vector& b, const Vector& range )
	{
		return IsInRange2D( a - b, range );
	}		
}

//////////////////////////////////////////////////////////////////////////

SphereAcceptor::SphereAcceptor( const Vector& position, Float radius )
	: m_position( position )
	, m_radius( radius )
	, m_radiusSquare( radius * radius )
{
}

Bool SphereAcceptor::operator()( const CGameplayEntity* entity ) const
{
	return ( entity->GetWorldPositionRef() - m_position ).SquareMag3() <= m_radiusSquare;
}

Bool SphereAcceptor::operator()( const AACylinder& cylinder ) const
{
	// If sphere's center lies between cylinder bottom and top (on Z axis)
	// we only need to check 2D distance (XY) between two center points.
	if ( m_position.Z >= cylinder.m_positionAndRadius.Z && m_position.Z <= cylinder.m_positionAndRadius.Z + cylinder.m_height )
	{
		return ( ( cylinder.m_positionAndRadius - m_position ).Mag2() <= m_radius + cylinder.m_positionAndRadius.W );
	}
	// Otherwise, since both objects are "solids of revolution" we can "cut" the space with
	// a plane generated by Z axis and vector connecting two centers and obtain 2D problem
	// of checking intersection between rect and a circle.
	else
	{
		const Vector diff = cylinder.GetPosition() - m_position;
		const Vector boxCenter2D( diff.Mag2(), diff.Z + cylinder.m_height * 0.5f, 0.0f );
		const Vector boxExtents2D( cylinder.m_positionAndRadius.W, cylinder.m_height * 0.5f, 0.0f );
		// We find the point on the box closest to the circle center (which is origin in our case)
		// and then check if its distance from the center is smaller than radius.
		const Vector nearest = GetNearestPoint( Box( boxCenter2D - boxExtents2D, boxCenter2D + boxExtents2D ), Vector::ZERO_3D_POINT );
		return ( nearest.SquareMag2() <= m_radiusSquare );
	}
}

//////////////////////////////////////////////////////////////////////////

CylinderAcceptor::CylinderAcceptor( const Vector& position, Float radius, Float height )
	: m_position( position )
	, m_radius( radius )
	, m_radiusSquare( radius * radius )
	, m_height( height )
{
}

Bool CylinderAcceptor::operator()( const CGameplayEntity* entity ) const
{
	Vector pos = entity->GetWorldPositionRef();
	// Z-axis test
	if ( m_position.Z > pos.Z || m_position.Z + m_height < pos.Z )
	{
		return false;
	}
	return ( ( pos - m_position ).SquareMag2() <= m_radiusSquare );
}

Bool CylinderAcceptor::operator()( const AACylinder& cylinder ) const
{
	// Z-axis test
	if ( m_position.Z > cylinder.m_positionAndRadius.Z + cylinder.m_height || m_position.Z + m_height < cylinder.m_positionAndRadius.Z )
	{
		return false;
	}
	return ( ( m_position - cylinder.m_positionAndRadius ).Mag2() <= m_radius + cylinder.m_positionAndRadius.W );
}

//////////////////////////////////////////////////////////////////////////

ConeAcceptor::ConeAcceptor( const Vector& position, Float coneDir, Float coneAngle, Float radius, Float height )
	: m_position( position )
	, m_radius( radius )
	, m_radiusSquare( radius * radius )
	, m_height( height )
{
	m_heading = EulerAngles::YawToVector( coneDir );
	Vector v = EulerAngles::YawToVector( coneDir + coneAngle * 0.5f );
	m_leftEdgeNormal = Vector( -v.Y, v.X, 0.0f );
	v = EulerAngles::YawToVector( coneDir - coneAngle * 0.5f );
	m_rightEdgeNormal = Vector( -v.Y, v.X, 0.0f );
	m_halfAngleCos = MCos( DEG2RAD_HALF( coneAngle ) );
}

Bool ConeAcceptor::operator()( const CGameplayEntity* entity ) const
{
	Vector pos = entity->GetWorldPositionRef();
	
	// Z-axis test
	if ( m_position.Z + m_height * 0.5f < pos.Z || m_position.Z - m_height * 0.5f > pos.Z )
	{
		return false;
	}

	// 2D cone
	const Vector diff = entity->GetWorldPositionRef() - m_position;
	const Float distSquare = diff.SquareMag2();
	if ( distSquare <= m_radiusSquare )
	{
		if ( m_heading.Dot2( diff * ( 1.0f / MSqrt( distSquare ) ) ) >= m_halfAngleCos )
		{
			return true;
		}
	}
	return false;
}

Bool ConeAcceptor::operator()( const AACylinder& cylinder ) const
{
	// Z-axis test
	if ( m_position.Z + m_height * 0.5f < cylinder.m_positionAndRadius.Z || m_position.Z - m_height * 0.5f > cylinder.m_positionAndRadius.Z + cylinder.m_height )
	{
		return false;
	}
	
	// We're now in 2D setting, checking if there's intersection between circle slice (cone) and other circle.
	// The cone is placed at the origin of new coordinate system.

	const Float cylinderRadius = cylinder.m_positionAndRadius.W;
	const Vector cylinderPos = cylinder.GetPosition() - m_position;
	const Vector normalizedConeToCylinder = cylinderPos.Normalized2();
	const Float coneToCylinderDist = cylinderPos.Mag2();

	if ( coneToCylinderDist > cylinderRadius + m_radius )
	{
		return false;
	}

	// First let's check the simplest case -> cone center is within circle range.
	if ( coneToCylinderDist <= cylinderRadius )
	{
		return true;
	}

	// Next, let's check if the circle center is within cone range.
	// If yes, the distance between two centers should be less than sum of both radii
	const Float headingDot = m_heading.Dot2( normalizedConeToCylinder );
	if ( headingDot >= m_halfAngleCos )
	{
		return true;
	}

	// Finally, we know that circle center is outside cone and cone center is outside circle.
	// Let's check then if circle intersects any of cone edges (in the front of cone position).
	if ( headingDot >= 0 )
	{
		if ( MAbs( m_leftEdgeNormal.Dot2( cylinderPos ) ) <= cylinderRadius )
		{
			return true;
		}
		if ( MAbs( m_rightEdgeNormal.Dot2( cylinderPos ) ) <= cylinderRadius )
		{
			return true;
		}	
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////

BoxAcceptor::BoxAcceptor( const Vector& position, const Box& boxLS, Float boxYaw )
	: m_position( position )
	, m_boxLS( boxLS )
{
	Matrix rot = EulerAngles( 0, 0, boxYaw ).ToMatrix();
	m_right = rot.GetAxisX();
	m_forward = rot.GetAxisY();
}

Bool BoxAcceptor::operator()( const CGameplayEntity* entity ) const
{
	const Vector localPos = entity->GetWorldPositionRef() - m_position;
	if ( m_right.X == 1.0f ) // not rotated
	{
		return m_boxLS.Contains( localPos );
	}
	// Since box can be rotated we need to transform entity's position into "non-rotated" AABox space.
	// To do this, we take localPos and "project" it onto box "rotation space".
	const Vector localPosRotated = Vector( m_right.Dot2( localPos ), m_forward.Dot2( localPos ), localPos.Z );
	return m_boxLS.Contains( localPosRotated );
}

Bool BoxAcceptor::operator()( const AACylinder& cylinder ) const
{
	const Vector localPos = cylinder.GetPosition() - m_position;
	
	// Z-axis test
	if ( m_boxLS.Max.Z < localPos.Z || m_boxLS.Min.Z > localPos.Z + cylinder.m_height )
	{
		return false;
	}

	// Since box can be rotated we need to transform cylinder's position into "non-rotated" AABox space.
	// To do this, we take localPos and "project" it onto box "rotation space".
	const Vector localPosRotated = Vector( m_right.Dot2( localPos ), m_forward.Dot2( localPos ), localPos.Z );

	// All we have to do now is to check 2D circle-rect intersection.
	// We find the point on the box that is closest to the rotated cylinder's position
	// and then check if its distance form cylinder's center is smaller than cylinder's radius.
	Vector nearest = GetNearestPoint( m_boxLS, localPosRotated );
	return ( nearest - localPosRotated ).Mag2() <= cylinder.m_positionAndRadius.W;
}

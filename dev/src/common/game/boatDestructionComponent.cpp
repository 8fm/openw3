#include "build.h"
#include "boatDestructionComponent.h"
#include "gameWorld.h"
#include "../engine/mesh.h"
#include "../physics/physicsWrapper.h"
#include "../engine/gameTimeManager.h"
#include "../engine/tickManager.h"
#include "../engine/rigidMeshComponent.h"
#include "../engine/renderFrame.h"
#include "boatBodyComponent.h"
#include "BoatComponent.h"
#include "boatConfig.h"

//////////////////////////////////////////////////////////////////////////

IMPLEMENT_ENGINE_CLASS( CBoatDestructionComponent );

//////////////////////////////////////////////////////////////////////////

RED_DEFINE_STATIC_NAME( BoatDestruction );
RED_DEFINE_STATIC_NAME( BoatSide );

RED_DEFINE_STATIC_NAME(boatDestructionSave);
RED_DEFINE_STATIC_NAME(boatDestructionNoVolumes);
RED_DEFINE_STATIC_NAME(boatDestructionVolumeHealth);

RED_DEFINE_STATIC_NAME(OnLoadGameDropDestructableParts);

//////////////////////////////////////////////////////////////////////////

CBoatDestructionComponent::CBoatDestructionComponent(void)
    :   m_hBoatBodyRigidMesh( )
    ,   m_hBoatComponent()
    ,   m_autoGeneratedVolumesX( 2 )
    ,   m_autoGeneratedVolumesY( 3 )
    ,   m_autoGeneratorVolumesResizer( 1.1f )
    ,   m_lastCollisionTimeout( -1.0f )
    ,   m_wasSaveRestored(false)
{
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnTickPrePhysics( Float deltaTime )
{
	PC_SCOPE( CBoatDestructionComponent_OnTickPrePhysics );

    // Find floating component and set collision callback
    CEntity* ent = GetEntity();    
    ASSERT(ent);
    if( ent == nullptr )
    {
        return;
    }

    //////////////////////////////////////////////////////////////////////////
    // Is boat body mesh present
    if( m_hBoatBodyRigidMesh.Get() == nullptr )
    {
        // Safe check if something went wrong in attachment code
        CBoatBodyComponent* body = GetEntity()->FindComponent<CBoatBodyComponent>();
        m_hBoatBodyRigidMesh = (CRigidMeshComponent*)body;
        return;
    }

    // Check is valid object
    if( m_hBoatBodyRigidMesh.Get() == nullptr || !IsValidObject( m_hBoatBodyRigidMesh ) )
    {
        // Another safe check to be sure the handle was not invalidated
        m_hBoatBodyRigidMesh = nullptr;
        return;
    }

    //////////////////////////////////////////////////////////////////////////
    // Is boat body component present
    if( m_hBoatComponent.Get() == nullptr )
    {
        // Safe check if something went wrong in attachment code
        CBoatComponent* body = GetEntity()->FindComponent<CBoatComponent>();
        m_hBoatComponent = (CBoatComponent*)body;
        return;
    }

    // Check is valid object
    if( !IsValidObject( m_hBoatComponent ) )
    {
        // Another safe check to be sure the handle was not invalidated
        m_hBoatComponent = nullptr;
        return;
    }

    CPhysicsWrapperInterface* wrapp = m_hBoatBodyRigidMesh->GetPhysicsRigidBodyWrapper();
    ASSERT(wrapp);
    if( wrapp == nullptr)
    {
        return;
    }

    wrapp->SetCodeCallback( CPhysicsWrapperInterface::EPCCT_OnCollision, this, this );
    wrapp->SetFlag( PRBW_DetailedConntactInfo, true );

    // Auto generate destruction volumes if none set
    if( m_destructionVolumes.Empty() )
    {
        CMesh* mesh = m_hBoatBodyRigidMesh->GetMeshNow();
        if( mesh == nullptr )
        {
            return;
        }

        Box bbox = mesh->GetBoundingBox();

        // Resize volume
        bbox.Min *= m_autoGeneratorVolumesResizer;
        bbox.Max *= m_autoGeneratorVolumesResizer;

        const Vector extent = bbox.CalcSize();
        const Vector corners( extent.X / (Float)m_autoGeneratedVolumesX, extent.Y / (Float)m_autoGeneratedVolumesY, extent.Z );

        for( Uint32 x=0; x<m_autoGeneratedVolumesX; ++x )
        {
            for( Uint32 y=0; y<m_autoGeneratedVolumesY; ++y )
            {
                SBoatDestructionVolume volume;
                volume.m_volumeCorners          = corners;
                volume.m_volumeLocalPosition.X  = bbox.Min.X + corners.X * 0.5f + corners.X * x;
                volume.m_volumeLocalPosition.Y  = bbox.Min.Y + corners.Y * 0.5f + corners.Y * y;
                volume.m_volumeLocalPosition.Z  = bbox.Min.Z + corners.Z * 0.5f;

                m_destructionVolumes.PushBack(volume);
            }
        }
    }

    // Restore boat status from save game
    if( m_wasSaveRestored )
    {
        const Uint32 num = m_destructionVolumes.Size();
        for(Uint32 i=0; i<num; ++i)
        {
            // Drop parts in scripts
            if( m_destructionVolumes[i].m_areaHealth < SBoatDestructionVolume::DEFAULT_HEALTH )
                CallEvent( CNAME(OnLoadGameDropDestructableParts), i );
        }

        m_wasSaveRestored = false;
    }

    // Call scripts init
	CallEvent( CNAME( OnComponentAttached ) );

    // If initialized remove from tick
    GetWorld()->GetTickManager()->RemoveFromGroup( this, TICK_PrePhysics );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnAttached( CWorld* world )
{
    TBaseClass::OnAttached( world );

    world->GetEditorFragmentsFilter().RegisterEditorFragment( this, SHOW_BoatDestruction );
    world->GetTickManager()->AddToGroup( this, TICK_PrePhysics );    
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnDetached( CWorld* world )
{
    TBaseClass::OnDetached( world );

    world->GetEditorFragmentsFilter().UnregisterEditorFragment( this, SHOW_BoatDestruction );

    // Remove collision callback
    if( m_hBoatBodyRigidMesh.Get() != nullptr )
    {
        CPhysicsWrapperInterface* wrapp = m_hBoatBodyRigidMesh->GetPhysicsRigidBodyWrapper();

        if( wrapp == nullptr)
        {
            ASSERT(false);
            return;
        }

        wrapp->SetCodeCallback( CPhysicsWrapperInterface::EPCCT_OnCollision, nullptr, nullptr );
        wrapp->SetFlag( PRBW_DetailedConntactInfo, false );

        m_hBoatBodyRigidMesh = nullptr;
    }
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnParentAttachmentAdded( IAttachment* attachment )
{
    TBaseClass::OnParentAttachmentAdded(attachment);

    CNode* parent = attachment->GetParent();
    if( parent->IsA<CRigidMeshComponent>() )
    {
        m_hBoatBodyRigidMesh = (CRigidMeshComponent*)parent;
    }
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnParentAttachmentBroken( IAttachment* attachment )
{
    TBaseClass::OnParentAttachmentBroken(attachment);
    CNode* parent = attachment->GetParent();

    if( m_hBoatBodyRigidMesh.Get() != nullptr )
    {
        if( m_hBoatBodyRigidMesh.Get() == parent )
        {
            m_hBoatBodyRigidMesh = nullptr;
        }
    }
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnGenerateEditorFragments( CRenderFrame* frame, EShowFlags flags )
{
    TBaseClass::OnGenerateEditorFragments( frame, flags );

    if( flags != SHOW_BoatDestruction )
        return;

#ifndef FINAL
    // Collision hits
    const Float deltaTime = GGame->GetTimeManager()->GetLastTickTime();
    Int32 areaNum = -1;
    for( Uint32 i=0; i<DBG_collisionHits.Size(); ++i )
    {
        SPointNormalTimeout& ht = DBG_collisionHits[i];
        ht.totalDrawTime += deltaTime;
        if( ht.totalDrawTime >= BoatConfig::cvBoatDestructionHitsAcceptTimeout.Get() )
        {
            DBG_collisionHits.Erase( DBG_collisionHits.Begin() + i );

            if( i > 0)
                --i;
        }
        else
        {
            //Vector normalized = ht.normal;
            //Float length = normalized.Normalize3();            
            //length = log10f( 1.0f + length );

            Matrix ltw;
            GetEntity()->GetLocalToWorld(ltw);
            const Vector globalPos = ltw.TransformPoint(ht.hitPos);

            //frame->AddDebug3DArrow( globalPos, normalized, length, 0.015f, 0.045f, 0.12f, Color::RED, Color::LIGHT_RED );
            frame->AddDebugSphere( globalPos, 0.2f, Matrix::IDENTITY, Color::RED );
            frame->AddDebugText( globalPos, String::Printf(TXT( "HIT %i"), ht.temp & 0x0000FFFF ), 0, 0, true );

            areaNum = ht.temp >> 16;
        }
    }
#endif

    // Draw area volumes
    const Uint32 count = m_destructionVolumes.Size();
    if( count )
    {
        const Matrix ltw = GetEntity()->GetLocalToWorld();
        for( Uint32 i=0; i<count; ++i )
        {
            SBoatDestructionVolume& vol = m_destructionVolumes[i];

            const Box box( vol.m_volumeLocalPosition - vol.m_volumeCorners * 0.5f, vol.m_volumeLocalPosition + vol.m_volumeCorners * 0.5f);

#ifndef FINAL
            if( i == areaNum )
                frame->AddDebugBox( box, ltw, Color::LIGHT_RED );
            else
                frame->AddDebugBox( box, ltw, Color::LIGHT_GREEN );
#else
            frame->AddDebugBox( box, ltw, Color::LIGHT_GREEN );
#endif

            const Vector globalPos = ltw.TransformPoint( vol.m_volumeLocalPosition + Vector(0, 0, 1.0f ) );
            frame->AddDebugText( globalPos, String::Printf( TXT("%.2f"), vol.m_areaHealth ), 0, 0 );
        }
    }
}

////////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::LocalSpaceExternalCollision( const Vector& localHit, const Vector& forceNormal, EBoatCollisionSource collisionSource )
{
    Matrix ltw;
    GetEntity()->GetLocalToWorld(ltw);
    const Vector globalHit = ltw.TransformPoint(localHit);
    SelectDestructionAreaAndTriggerScript( localHit, globalHit, forceNormal, collisionSource );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::GlobalSpaceExternalCollision( const Vector& globalHit, const Vector& forceNormal, EBoatCollisionSource collisionSource )
{
    Matrix wtl;
    GetEntity()->GetWorldToLocal(wtl);
    const Vector localHit = wtl.TransformPoint(globalHit) * 0.8f; // use down scalling to be sure point will fall under destruction area volume
    SelectDestructionAreaAndTriggerScript( localHit, globalHit, forceNormal, collisionSource );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::DisableCollisionCallback()
{
    if( m_hBoatBodyRigidMesh.Get() == nullptr )
        return;

    CPhysicsWrapperInterface* wrapper = m_hBoatBodyRigidMesh->GetPhysicsRigidBodyWrapper();

    if( wrapper == nullptr )
        return;

    // Turn off collision callback
    wrapper->SetCodeCallback( CPhysicsWrapperInterface::EPCCT_OnCollision, nullptr, nullptr );
    wrapper->SetFlag( PRBW_DetailedConntactInfo, false );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::SelectDestructionAreaAndTriggerScript( const Vector& localHit, const Vector& globalHit, const Vector& forceNormal, EBoatCollisionSource collisionSource )
{
    if( m_destructionVolumes.Empty() || !BoatConfig::cvBoatDrowningEnabled.Get() )
    {
        return;
    }

    if( m_hBoatComponent.Get() == nullptr )
    {
        return;
    }

    // Cancel all collisions from gear 1
    if( m_hBoatComponent->GetCurrentGear() < 2 )
    {
        return;
    }

    const Int32 gear = m_hBoatComponent->GetGearFromXYVelocity();

    // Ignore hits separated by 3 seconds offset
    const Float currentTime = Float( GEngine->GetRawEngineTime() );

    if( m_lastCollisionTimeout > 0 && currentTime - m_lastCollisionTimeout < BoatConfig::cvBoatDestructionHitsAcceptTimeout.Get() )
    {
        return;
    }
    else
    {
        m_lastCollisionTimeout = currentTime;
    }
    

    const Uint32 size = m_destructionVolumes.Size();
    for( Uint32 i=0; i<size; ++i )
    {
        // Find collision volume
        SBoatDestructionVolume& vol = m_destructionVolumes[i];
        if( vol.IsLocalPointInVolume( localHit ) )
        {
#ifndef FINAL
            // Add collision point
            SPointNormalTimeout point( localHit, forceNormal );
            point.temp = gear;
            point.temp |= i << 16;
            DBG_collisionHits.PushBack(point);
#endif
            // Call scripts
            const Float appForce = (gear-1) + fabsf( Vector::Dot2( forceNormal, GetEntity()->GetLocalToWorld().GetAxisY() ) );
            CallEvent( CNAME(OnBoatDestructionVolumeHit), globalHit, appForce, i );

            // If damage was dealt, save destruction status
            if( m_destructionVolumes[i].m_areaHealth < SBoatDestructionVolume::DEFAULT_HEALTH )
            {
                SetShouldSave( true );
            }

            m_hBoatComponent->BoatBodyStruck( forceNormal * appForce, globalHit, collisionSource );
            return;
        }
    }
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::onCollision( const SPhysicalCollisionInfo& info )
{   
    if( m_hBoatComponent.Get() == nullptr || info.m_otherBody == nullptr )
    {
        return;
    }

    // Test if self collision occurs
    // Since entity is constructed in fucked up way we have to test self collision due to:
    // - boat parts are hard attached to boat body
    // - there is lot of transform update lag
    //   * physx updates main body
    //   * rigid component is updated
    //   * all attached components are updated
    //   * wrappers of those updated components are updated
    // - during rapid movement on waves some of hard attached components might not get updated fast enough and cause self collision
    // Test if collider's entity is the same as this CBoatDestructionComponent's entity
    CComponent* colliderComponent = nullptr;
    if( info.m_otherBody->GetParent<CComponent>(colliderComponent) )
    {
        CEntity* boatEnt = GetEntity();
        if( boatEnt == nullptr && colliderComponent->GetEntity() != nullptr && boatEnt == colliderComponent->GetEntity() )
        {
            ASSERT( false, TXT("Boat self collision due to framerate instability!!") );
            return;
        }
    }
    

//     const static CPhysicsEngine::CollisionMask GROUP_BIT_BoatDestruction = GPhysicEngine->GetCollisionTypeBit( CNAME(BoatDestruction) );
//     const static CPhysicsEngine::CollisionMask GROUP_BIT_BoatSide        = GPhysicEngine->GetCollisionTypeBit( CNAME(BoatSide) );
//     const static CPhysicsEngine::CollisionMask GROUP_BIT_Platforms       = GPhysicEngine->GetCollisionTypeBit( CNAME(Platforms) );
//     const        CPhysicsEngine::CollisionMask combinedMask              = GROUP_BIT_BoatDestruction | GROUP_BIT_BoatSide | GROUP_BIT_Platforms;
//     
//     const CPhysicsEngine::CollisionMask collider = info.m_otherBody->GetCollisionTypesBits( info.m_otherBodyIndex.m_actorIndex, info.m_otherBodyIndex.m_shapeIndex );
// 
//     if( collider & combinedMask )
//     {
//         return;
//     }

    // Call collisions
    GlobalSpaceExternalCollision( info.m_position, info.m_force.Normalized3(), EBCS_PhysxCollider );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnSaveGameplayState( IGameSaver* saver )
{
    TBaseClass::OnSaveGameplayState(saver);

    saver->BeginBlock( CNAME(boatDestructionSave) );
    {
        const Uint32 num = m_destructionVolumes.Size();
        saver->WriteValue( CNAME(boatDestructionNoVolumes), num );

        for(Uint32 i=0; i<num; ++i)
        {
            const Float health = m_destructionVolumes[i].m_areaHealth;
            saver->WriteValue( CNAME(boatDestructionVolumeHealth), health );
        }
    }
    saver->EndBlock( CNAME(boatDestructionSave) );
}

//////////////////////////////////////////////////////////////////////////

void CBoatDestructionComponent::OnLoadGameplayState( IGameLoader* loader )
{
    TBaseClass::OnLoadGameplayState(loader);

    loader->BeginBlock( CNAME(boatDestructionSave) );
    {
        Uint32 num = 0;
        loader->ReadValue( CNAME(boatDestructionNoVolumes), num );

        m_wasSaveRestored = false;

        if( !m_destructionVolumes.Empty() && m_destructionVolumes.Size() == num )
        {
            for(Uint32 i=0; i<num; ++i)
            {
                Float health = 0.0f;
                loader->ReadValue( CNAME(boatDestructionVolumeHealth), health );

                m_destructionVolumes[i].m_areaHealth = health;

                // Mark as needed to restore
                if( health < SBoatDestructionVolume::DEFAULT_HEALTH && !m_wasSaveRestored )
                    m_wasSaveRestored = true;
            }
        }
    }
    loader->EndBlock( CNAME(boatDestructionSave) );
}

//////////////////////////////////////////////////////////////////////////

/**
* Copyright © 2009 CD Projekt Red. All Rights Reserved.
*/
#pragma once

/// Agent
#include "../game/movingAgentComponent.h"

// PAKSAS TODO: dependencies inversion
#include "../game/actor.h"

/// New NPC
#include "newNpcState.h"
#include "../game/newNpcNoticedObject.h"
#include "../game/newNpcSense.h"
#include "../game/newNpcSenseVision.h"
#include "newNpcSchedule.h"
//#include "communitySystem.h"
#include "../game/aiProfile.h"
#include "../game/interestPointComponent.h"
#include "../game/questPhase.h"
#include "../game/questGraphBlock.h"

class CInterestPointInstance;
class CAIReaction;
class IWorkQuery;
enum EFindAPResult;

///////////////////////////////////////////////////////////////////////////////

class IReactionsDebugListener
{
public:
	virtual void UpdateDelayed() = 0;
	virtual void UpdateAffecting() = 0;
};

///////////////////////////////////////////////////////////////////////////////

/// Quest lock on NPC
class NPCQuestLock
{
private:
	Bool							m_lockState;		//!< True if lock, false if unlock
	THandle< CQuestPhase >			m_phase;			//!< Phase this NPC was locked in
	THandle< CQuestGraphBlock >		m_block;			//!< Block that was locking this NPC in this phase

public:
	//! Get lock state
	RED_INLINE Bool GetLockState() const { return m_lockState; }

	//! Get quest phase
	RED_INLINE CQuestPhase* GetQuestPhase() const { return m_phase.Get(); }

	//! Get quest block
	RED_INLINE CQuestGraphBlock* GetQuestBlock() const { return m_block.Get(); }

public:
	NPCQuestLock( Bool lockState, const CQuestPhase* phase, const CQuestGraphBlock* block );
	~NPCQuestLock();
};

///////////////////////////////////////////////////////////////////////////////
enum ENPCGroupType
{
	ENGT_Enemy,
	ENGT_Commoner,
	ENGT_Quest,
	ENGT_Guard
};

BEGIN_ENUM_RTTI( ENPCGroupType )
	ENUM_OPTION( ENGT_Enemy );
	ENUM_OPTION( ENGT_Commoner );
	ENUM_OPTION( ENGT_Quest );
	ENUM_OPTION( ENGT_Guard );
END_ENUM_RTTI()

//These values are copied from scripts/game/types.ws
enum EMonsterCategory
{
	MC_NotSet,
	MC_Relic,
	MC_Necrophage,
	MC_Cursed,
	MC_Beast,
	MC_Insectoid,
	MC_Vampire,
	MC_Specter,
	MC_Draconide,
	MC_Hybrid,
	MC_Troll,
	MC_Human,
	MC_Unused,
	MC_Magicals,
	MC_Animal
};



/// Light-weight NPC
class CNewNPC : public CActor
{
	DECLARE_ENGINE_CLASS( CNewNPC, CActor, 0 );

protected:
	Bool											m_aiEnabled;				//!< Is AI enabled
	Bool											m_isCurrentlyWorkingInAP;	//!< True if NPC is playing animation in AP. When NPC is moving to AP, this is false.
	Bool											m_isStartingInAP;			//!< True if NPC should be already in AP
	Bool											m_suppressBroadcastingReactions;		//!< Directly moved from scripts. NOTICE: Property might get changed in the scripts.

	NewNPCSchedule*									m_defaultSchedule;
	NewNPCScheduleProxy								m_scheduleProxy;			//!< Schedule data for action points support
	TActionPointID									m_currentAP;

	TagList											m_despawnTags;				//!< NPC should despawn at place with this tags

	//! Combat
	EngineTime										m_berserkTime;				//!< Berserker active time

	//! Senses
	CNewNPCSenseVision								m_senses;					//!< Vision and aboslute senses
	TNoticedObjects									m_noticedObjects;			//!< Objects noticed by senses

	CName											m_currentActionCategory;	//!< Category generated by last FindRandomActionCategoryAndLayerName call
	EFindAPResult									m_lastFindAPResult;			//!< Status of the last find action point call

	//! Quest locks
	TDynArray< NPCQuestLock* >						m_questLocksHistory;		//!< Quest locks ( history )
	Int32											m_questLockCount;			//!< Quest lock count
	
	Int32											m_isInInterior;				//!< Processed by the r4interiorAreaComponent
	ENPCGroupType									m_npcGroupType;
	// Reactions

	Int32											m_monsterCategory;			//Cached value of the npc type, e.g. human, monster, animal...doesn't have to be a monster
	Bool											m_didChangeMimicProperties;

public:
	struct InterestPointReactionData
	{
		enum EIPDelayedStatus
		{
			IPDS_Invalid,
			IPDS_InProgress,
			IPDS_Passed,
			IPDS_Failed,
			IDPS_Remove
		};

		THandle< CInterestPointInstance >	m_interestPoint;
		Uint32								m_reactionIndex;
		EIPDelayedStatus					m_delayedStatus;

		InterestPointReactionData()
			: m_interestPoint( NULL )
			, m_reactionIndex( ::NumericLimits< Uint32 >::Max() )
			, m_delayedStatus( IPDS_Invalid )
		{
		}

		InterestPointReactionData( const THandle< CInterestPointInstance >& ip, Uint32 reactionIndex, EIPDelayedStatus delayedStatus = IPDS_Invalid )
			: m_interestPoint( ip )
			, m_reactionIndex( reactionIndex )
			, m_delayedStatus( delayedStatus )
		{
		}

		bool operator==( const InterestPointReactionData& other ) const
		{
			return ( m_interestPoint == other.m_interestPoint && m_reactionIndex == other.m_reactionIndex );
		}
	};

	// Returns whether the npc has afraid behavior (see CBehTreeDecoratorAfraidInstance)
	Bool IsAfraid() const { return m_isAfraid; }
	
	//Register the afraid state of an npc behavior
	void SetAfraid(Bool val);

protected:
	struct CachedReaction
	{
		CachedReaction()
			: m_reaction( NULL )
			, m_lastTimeActivated( 0.0f )
			, m_lastTimeVoicesetPlayed( 0.0f )
		{
		}

		CachedReaction( const CAIReaction* reaction )
			: m_reaction( reaction )
			, m_lastTimeActivated( 0.0f )
			, m_lastTimeVoicesetPlayed( 0.0f )
		{
		}

		const CAIReaction*	m_reaction;
		Float				m_lastTimeActivated;
		Float				m_lastTimeVoicesetPlayed;
	};

	TDynArray< CachedReaction >				m_reactionsCache;
	TDynArray< InterestPointReactionData >	m_affectingInterestPoints;
	TDynArray< InterestPointReactionData >	m_delayedInterestPoints;
	typedef TPair< const CAIReaction*, CInterestPointInstance* > TDelayedTestId;
	typedef TSortedMap< TDelayedTestId, VisibilityQueryId > TDelayedTests;
	TDelayedTests							m_delayedVisibilityTests;

	Bool									m_isAfraid;				// Describes whether the npc has afraid behavior (see CBehTreeDecoratorAfraidInstance)

#ifdef EDITOR_AI_DEBUG
	IReactionsDebugListener*				m_reactionsDebugListener;
#endif

public:
	//! Sets a new work schedule to be used by the NPC
	void SetWorkSchedule( NewNPCSchedule& schedule );

	//! Clears work schedule and sets default
	void ClearWorkSchedule();

	//! Sets whether the NPC is in an interior or not (r4interiorAreaComponent.cpp)
	void SetInInterior(Int32 delta) { m_isInInterior += delta; }

	RED_INLINE ENPCGroupType GetGroupType(){ return m_npcGroupType; }

	//! Is NPC in an interior?
	RED_INLINE Bool IsInInterior() const { return (m_isInInterior > 0); }

	//! Is NPC locked by quests ?
	RED_INLINE Bool IsLockedByQuests() const { return m_questLockCount > 0; }

	//! Get the list of quest locks
	RED_INLINE const TDynArray< NPCQuestLock* >& GetQuestLockHistory() const { return m_questLocksHistory; }


	//! Is AI enabled
	RED_INLINE Bool IsAIEnabled() const { return m_aiEnabled; }

	RED_INLINE Bool IsSuppressingBroadcastingReactions() const { return m_suppressBroadcastingReactions; }

	//! Get current NPC state
	RED_INLINE CNewNPCStateBase* GetCurrentState() const { return Cast< CNewNPCStateBase >( IScriptable::GetCurrentState() ); }

	//! Tells that the NPC is currently occupying and working in an AP
	RED_INLINE Bool IsWorkingInAP() const { return m_isCurrentlyWorkingInAP; }
	RED_INLINE TActionPointID GetCurrentActionPoint() { return m_currentAP; }

	//! Sets info that the NPC is currently occupying and working in an AP
	RED_INLINE void SetCurrentlyWorkingInAP( TActionPointID currentAP ) { m_isCurrentlyWorkingInAP = true; m_currentAP =  currentAP; }
	RED_INLINE void SetCurrentlyNotWorkingInAP() { m_isCurrentlyWorkingInAP = false; }

	//! Flag npc to ommit activities like approaching AP and executing PREjob animation
	RED_INLINE void SetIsStartingInAP( Bool isStartingInAp ) { m_isStartingInAP = isStartingInAp; }

	//! Returns the AI profile of this NPC
	void GetAIProfiles( TDynArray< CAIProfile* >& profiles ) const;

	// Is berserker active
	Bool IsBerserkActive() const { return GGame->GetEngineTime() < m_berserkTime; }

	//! Is NPC unconscious
	Bool IsUnconscious() const { return GetCurrentStateName() == CNAME(Unconscious); }

	//! Tell if NPC is going to be despawned, this process can be interrupted by calling CancelDespawning()
	Bool IsDespawning() const { return GetCurrentStateName() == CNAME(Despawning); }

	//! Return NPC action points schedule
	RED_INLINE const NewNPCScheduleProxy& GetActionSchedule() const { return m_scheduleProxy; }
	RED_INLINE NewNPCScheduleProxy& GetActionSchedule() { return m_scheduleProxy; }

	//! Returns true if AP has been found
	Bool FindActionPoint( TActionPointID &apIDOut /* inout */, CName &categoryNameOut /* inout */ );

	void SetDespawnTags( const TagList &despawnTags ) { m_despawnTags = despawnTags; }

	//! Get noticed objects
	TDynArray< NewNPCNoticedObject >& GetNoticedObjects() { return m_noticedObjects; }

	//! Get noticed objects
	const TDynArray< NewNPCNoticedObject >& GetNoticedObjects() const { return m_noticedObjects; }

	//! Does npc detect a hostile object
	const CActor*const IsInDanger();

	//! Does npc detect a hostile object
	const CActor*const IsSeeingNonFriendlyNPC();

	//! Get noticed object
	CActor* GetNoticedObject(const Uint32 index) const;

	//! Cache sense params
	CEntityTemplate* CacheSenseParams( EAISenseType senseType );

	//! Cache sense params
	CAISenseParams* GetSenseParams( EAISenseType senseType );

	//! Force actor noticed
	void NoticeActor( CActor* actor );

	//! Has actor been noticed recently?
	Bool HasActorBeenNoticed( CActor * actor, Float time = 1.0f );

	//! Deletes the actor from the noticed object list
	void ForgetActor( const CActor *const actorToForget );

	//! Deletes all actors from noticed object list
	void ForgetAllActors();

	//! Get delayed interest points
	const TDynArray< InterestPointReactionData >& GetDelayedInterestPoints() const { return m_delayedInterestPoints; }

	//! Get affecting interest points
	const TDynArray< InterestPointReactionData >& GetAffectingInterestPoints() const { return m_affectingInterestPoints; }

	//! Set reactions debug listener
	void SetReactionsDebugListener( IReactionsDebugListener* listener )
	{
#ifdef EDITOR_AI_DEBUG
		m_reactionsDebugListener = listener;
#endif
	}

	//! For debug - Is npc in quest scene
	Bool IsInQuestScene() const;

	//! Be aware of an actor like he's inside of guard area even if he's not - but, for example, has provided us some damage from long-ranged weapon
	void NoticeActorInGuardArea( CActor* const actor );

	//! Test if we can safely pool actor
	Bool OnPoolRequest() override;

public:
	CNewNPC();
	~CNewNPC();

	// Entity was initialized
	virtual void OnInitialized();

	// Entity was uninitialized
	virtual void OnUninitialized();

	//! Attaching to world
	virtual void OnAttached( CWorld* world );

	//! Detaching from world
	virtual void OnDetached( CWorld* world );

	// All components of entity has been attached
	virtual void OnAttachFinished( CWorld* world );

	//! Tick
	virtual void OnTick( Float timeDelta );

#ifdef USE_ANSEL
	//! LOD Tick
	virtual void HACK_ANSEL_OnLODTick();
#endif // USE_ANSEL

	//! Generate debug fragments
	virtual void GenerateDebugFragments( CRenderFrame* frame );

	//! Generate debug info
	void DebugDraw( IDebugFrame& debugFrame ) const;

	//! Serialize(GC)
	virtual void OnSerialize( IFile& file );

	//! NPCs have higher streaming priority than rest of the entities types
	virtual EJobPriority GetStreamingPriority() const override { return JP_StreamingNPC; }

public:
	virtual Int32 GetCurrentActionPriority() const;

	String GetLastFindAPFriendlyResult() const;

	Int32 GetAvailableActionPointsCount( Bool onlyFree, CEntity* excludeApOwner );

public:
	//! Set quest lock on this NPC
	void QuestLock( const CQuestPhase* phase, const CQuestGraphBlock* block );

	//! Remove quest lock on this NPC
	void QuestUnlock( const CQuestPhase* phase, const CQuestGraphBlock* block );

public:
	//! Enter despawning state
	void EnterForcedDespawn();

	//! Get senses info
	String GetSensesInfo() const;

	Bool IsInLeaveAction();
public:
	// -------------------------------------------------------------------------
	// Interest points system
	// -------------------------------------------------------------------------
	Bool OnInterestPoint( CInterestPointInstance* interestPoint, Bool forceNoVisibilityTest = false );

	//! Can NPC react now?
	Bool CanReact();

	//! Reacts to an interest point
	void ReactTo( const THandle< CInterestPointInstance >& interestPoint, Uint32 reactionIndex );

	//! Looks for a reaction that corresponds to the specified interest point.
	const CAIReaction* FindReaction( CInterestPointInstance* interestPoint ) const;

	//! Looks for a reaction that corresponds to the specified field.
	const CAIReaction* FindReaction( CName fieldName ) const;

	//! Looks for a reactions that corresponds to the specified interest point.
	void FindReactions( CInterestPointInstance* interestPoint, TStaticArray< Uint32, 16 >& outReactionIndices ) const;

	//! Looks for a reactions that corresponds to the specified field.
	void FindReactions( CName fieldName, TStaticArray< Uint32, 16 >& outReactionIndices ) const;

	//! Get reaction for specified index
	RED_INLINE const CAIReaction* GetReaction( Uint32 idx ) const { return m_reactionsCache[idx].m_reaction; }

	//! Get reaction for specified index
	RED_INLINE Float GetReactionLastActivationTime( Uint32 idx ) const { return m_reactionsCache[idx].m_lastTimeActivated; }

	//! Get reaction for specified index
	RED_INLINE void SetReactionLastActivationTime( Uint32 idx, Float time ) { m_reactionsCache[idx].m_lastTimeActivated = time; }

	//! Get last time voiseset was played by reaction
	RED_INLINE Float GetReactionLastVoicesetPlayedTime( Uint32 idx ) const { return m_reactionsCache[idx].m_lastTimeVoicesetPlayed; }

	//! Set last time voiseset was played by reaction
	RED_INLINE void SetReactionLastVoicesetPlayedTime( Uint32 idx, Float time ) { m_reactionsCache[idx].m_lastTimeVoicesetPlayed = time; }

	//! Process interest points
	void ProcessDelayedInterestPoints();

	//Returns the npc type (relatively heavy first time, uses cached value after)
	EMonsterCategory GetMonsterCategory();
	
	//Returns the cached monster category; if GetMonsterCategory hasn't already been called
	//returns -1
	Int32 GetCachedMonsterCategory() const { return m_monsterCategory; }
	void SetCachedMonsterCategory(Int32 cat) { m_monsterCategory = cat; }

	void OnLevelUpscalingChanged( Bool upscaleEnabled );

protected:
	// Processes reactions
	void ProcessReactions();
	void ProcessReaction( Uint32 reactionIndex, CInterestPointInstance* interestPointInstance );

	// Cache reactions
	void CacheReactions();
protected:

	//! Update NPC senses
	NewNPCSenseUpdateFlags UpdateSenses( Float timeDelta );

	//! Update state machine
	void UpdateStateMachine( Float timeDelta );

	//! Initialize senses
	void InitializeSenses();

	//! Call community initializers
	void CallCommunityInitializers( Bool storyPhaseInitializers = false );

	virtual Bool CanStealOtherActor( const CActor* const other ) const override;

	// ----------------------------------------------------------------------------
	// Game saves
	// ----------------------------------------------------------------------------

	//! Part of loading gameplay state, but dealing only with placement data, which may be processed differently for some classes
	virtual void OnLoadPlacementInfo( IGameLoader* loader );

private:
	CBehTreeGuardAreaData* GetGuardAreaData() const;

protected:
	// ----------------------------------------------------------------------------
	// Scripting support
	// ----------------------------------------------------------------------------
	void funcIsInInterior( CScriptStackFrame& stack, void* result );
	void funcIsInDanger( CScriptStackFrame& stack, void* result );
	void funcIsSeeingNonFriendlyNPC( CScriptStackFrame& stack, void* result );
	void funcIsAIEnabled( CScriptStackFrame& stack, void* result );
	void funcFindActionPoint( CScriptStackFrame& stack, void* result );
	void funcGetDefaultDespawnPoint( CScriptStackFrame& stack, void* result );
	void funcNoticeActor( CScriptStackFrame& stack, void* result );
	void funcForgetActor( CScriptStackFrame& stack, void* result );
	void funcForgetAllActors( CScriptStackFrame& stack, void* result );
	void funcGetNoticedObject( CScriptStackFrame& stack, void* result );
	void funcGetActiveActionPoint( CScriptStackFrame& stack, void* result );
	void funcPlayDialog( CScriptStackFrame& stack, void* result );
	void funcGetPerceptionRange( CScriptStackFrame& stack, void* result );
	void funcSetWristWrestlingParams( CScriptStackFrame& stack, void* result );
	void funcGetReactionScript( CScriptStackFrame& stack, void* result );
	void funcForceKnowledgeUpdate	( CScriptStackFrame& stack, void* result );
	void funcIsNoticedObjectVisible	( CScriptStackFrame& stack, void* result );
	void funcGetLastKnownPosition	( CScriptStackFrame& stack, void* result );
	void funcIfCanSeePlayer( CScriptStackFrame& stack, void* result );
	void funcGetGuardArea( CScriptStackFrame& stack, void* result );
	void funcSetGuardArea( CScriptStackFrame& stack, void* result );
	void funcDeriveGuardArea( CScriptStackFrame& stack, void* result );
	void funcIsConsciousAtWork( CScriptStackFrame& stack, void* result );
	void funcGetCurrentJTType( CScriptStackFrame& stack, void* result );
	void funcIsInLeaveAction( CScriptStackFrame& stack, void* result );
	void funcIsSittingAtWork( CScriptStackFrame& stack, void* result );	
	void funcIsAtWork( CScriptStackFrame& stack, void* result );	
	void funcIsPlayingChatScene( CScriptStackFrame& stack, void* result );	
	void funcCanUseChatInCurrentAP( CScriptStackFrame& stack, void* result );	
	void funcNoticeActorInGuardArea( CScriptStackFrame& stack, void* result );
};

BEGIN_CLASS_RTTI( CNewNPC );
	PARENT_CLASS( CActor );
	PROPERTY_EDIT( m_aiEnabled, TXT("AI enabled") );
	PROPERTY_EDIT( m_suppressBroadcastingReactions, TXT("Suppress reactions broadcasting.") );
	PROPERTY( m_berserkTime );	
	PROPERTY( m_npcGroupType );
	NATIVE_FUNCTION( "IsInInterior"				, funcIsInInterior );
	NATIVE_FUNCTION( "IsInDanger"				, funcIsInDanger );
	NATIVE_FUNCTION( "IsSeeingNonFriendlyNPC"	, funcIsSeeingNonFriendlyNPC );
	NATIVE_FUNCTION( "IsAIEnabled"				, funcIsAIEnabled );
	NATIVE_FUNCTION( "FindActionPoint"			, funcFindActionPoint );
	NATIVE_FUNCTION( "GetDefaultDespawnPoint"	, funcGetDefaultDespawnPoint );
	NATIVE_FUNCTION( "NoticeActor"				, funcNoticeActor );
	NATIVE_FUNCTION( "ForgetActor"				, funcForgetActor );
	NATIVE_FUNCTION( "ForgetAllActors"			, funcForgetAllActors );
	NATIVE_FUNCTION( "GetNoticedObject"			, funcGetNoticedObject );
	NATIVE_FUNCTION( "GetActiveActionPoint"		, funcGetActiveActionPoint );
	NATIVE_FUNCTION( "PlayDialog"				, funcPlayDialog );
	NATIVE_FUNCTION( "GetPerceptionRange"		, funcGetPerceptionRange );
	NATIVE_FUNCTION( "SetWristWrestlingParams"	, funcSetWristWrestlingParams );
	NATIVE_FUNCTION( "GetReactionScript"		, funcGetReactionScript );
	NATIVE_FUNCTION( "IfCanSeePlayer"			, funcIfCanSeePlayer );
	NATIVE_FUNCTION( "GetGuardArea"				, funcGetGuardArea );
	NATIVE_FUNCTION( "SetGuardArea"				, funcSetGuardArea );
	NATIVE_FUNCTION( "DeriveGuardArea"			, funcDeriveGuardArea );
	NATIVE_FUNCTION( "IsConsciousAtWork"		, funcIsConsciousAtWork );
	NATIVE_FUNCTION( "GetCurrentJTType"			, funcGetCurrentJTType );	
	NATIVE_FUNCTION( "IsSittingAtWork"			, funcIsSittingAtWork );
	NATIVE_FUNCTION( "IsAtWork"					, funcIsAtWork );	
	NATIVE_FUNCTION( "IsPlayingChatScene"		, funcIsPlayingChatScene );
	NATIVE_FUNCTION( "CanUseChatInCurrentAP"	, funcCanUseChatInCurrentAP );	
	NATIVE_FUNCTION( "NoticeActorInGuardArea"	, funcNoticeActorInGuardArea );
	NATIVE_FUNCTION( "IsInLeaveAction"			, funcIsInLeaveAction );	

	NATIVE_FUNCTION( "I_ForceKnowledgeUpdate"	, funcForceKnowledgeUpdate		);
	NATIVE_FUNCTION( "I_IsNoticedObjectVisible"	, funcIsNoticedObjectVisible	);
	NATIVE_FUNCTION( "I_GetLastKnownPosition"	, funcGetLastKnownPosition		);
END_CLASS_RTTI();

namespace RedMath
{
	namespace SIMD
	{
		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar()
			: V( _mm_setzero_ps() )
		{
		}
		
		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const Red::System::Float _f )
			: V( _mm_set1_ps( _f ) )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const RedScalar& _v )
			: V( _v.V )
		{	
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const Red::System::Float* _f )
			: V( _mm_load1_ps( _f ) )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( SIMDVector _v )
			: V( _v )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::~RedScalar()
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar& RedScalar::operator = ( const RedScalar& _v )
		{
			V = _v.V;
			return *this;
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::operator float() const
		{ 
			return X; 
		}

		//////////////////////////////////////////////////////////////////////////
		const Red::System::Float* RedScalar::AsFloat() const
		{
			return &X;
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( Red::System::Float _f )
		{
			V = _mm_set1_ps( _f );
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( const RedScalar& _v )
		{
			V = _v.V;
		}
		
		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( const Red::System::Float* _f )
		{
			V = _mm_load1_ps( _f );
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::SetZeros()
		{
			V = _mm_setzero_ps();
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::SetOnes()
		{
			V = _mm_set1_ps( 1.0f );
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar& RedScalar::Negate()
		{
			V = _mm_xor_ps( V, SIGN_MASK ); 
			return *this;
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar RedScalar::Negated() const
		{
			SIMDVector negVal = _mm_xor_ps( V, SIGN_MASK );
			return RedScalar( negVal );
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar RedScalar::Abs() const
		{
			SIMDVector absVal = _mm_max_ps( _mm_sub_ps( _mm_setzero_ps(), V), V);
			return RedScalar( absVal );
		}

		//////////////////////////////////////////////////////////////////////////
		Red::System::Bool RedScalar::IsZero() const
		{
			RedScalar test( _mm_cmpeq_ps( _mm_setzero_ps(), V ) );
			return ( test.Xi != 0 );
		}

		//////////////////////////////////////////////////////////////////////////
		Red::System::Bool RedScalar::IsAlmostZero( const SIMDVector _epsilon ) const
		{
			SIMDVector absVal = _mm_max_ps(_mm_sub_ps(_mm_setzero_ps(), V), V);
			RedScalar test( _mm_cmpge_ps( _epsilon, absVal ) );
			return ( test.Xi != 0 );
		}
	}
}
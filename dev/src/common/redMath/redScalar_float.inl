namespace RedMath
{
	namespace FLOAT
	{
		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar()
			: X( 0.0f )
			, Y( 0.0f )
			, Z( 0.0f )
			, W( 0.0f )
		{

		}
		
		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const float _f ) 
			: X( _f )
			, Y( _f )
			, Z( _f )
			, W( _f )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const RedScalar& _v )
			: X( _v.X )
			, Y( _v.X )
			, Z( _v.X )
			, W( _v.X )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::RedScalar( const Red::System::Float* _f )
			: X( _f[0] )
			, Y( _f[0] )
			, Z( _f[0] )
			, W( _f[0] )
		{
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar::~RedScalar()
		{
		}

		//////////////////////////////////////////////////////////////////////////
		const Red::System::Float* RedScalar::AsFloat() const
		{
			return &V[0];
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar& RedScalar::operator = ( const RedScalar& _v )
		{
			X = _v.X;
			Y = _v.Y;
			Z = _v.Z;
			W = _v.W;
			return *this;
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( Red::System::Float _f )
		{
			X = _f;
			Y = _f;
			Z = _f;
			W = _f;
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( const RedScalar& _v )
		{
			X = _v.X;
			Y = _v.Y;
			Z = _v.Z;
			W = _v.W;
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::Set( const Red::System::Float* _f )
		{
			X = _f[0];
			Y = _f[0];
			Z = _f[0];
			W = _f[0];
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::SetZeros()
		{
			X = 0.0f;
			Y = 0.0f;
			Z = 0.0f;
			W = 0.0f;
		}

		//////////////////////////////////////////////////////////////////////////
		void RedScalar::SetOnes()
		{
			X = 1.0f;
			Y = 1.0f;
			Z = 1.0f;
			W = 1.0f;
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar& RedScalar::Negate()
		{
			X = -X;
			Y = -Y;
			Z = -Z;
			W = -W;
			return *this;
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar RedScalar::Negated() const
		{
			return RedScalar( -X );
		}

		//////////////////////////////////////////////////////////////////////////
		RedScalar RedScalar::Abs() const
		{
			return std::move( RedScalar( Red::Math::NumericalUtils::Abs( X ) ) );
		}

		//////////////////////////////////////////////////////////////////////////
		bool RedScalar::IsZero() const
		{
			return ( X == 0.0f );
		}

		//////////////////////////////////////////////////////////////////////////
		bool RedScalar::IsAlmostZero( Red::System::Float _epsilon ) const
		{	
			return ( Red::Math::NumericalUtils::Abs( X ) <= _epsilon );
		}
	}
}

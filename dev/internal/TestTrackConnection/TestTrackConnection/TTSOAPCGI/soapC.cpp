/* soapC.cpp
   Generated by gSOAP 2.8.14 from ttsoapcgi.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.14 2013-02-26 01:38:32 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__CItemHyperlinkContainer:
		return soap_in_ns1__CItemHyperlinkContainer(soap, NULL, NULL, "ns1:CItemHyperlinkContainer");
	case SOAP_TYPE_ns1__CDocumentTreeNode:
		return soap_in_ns1__CDocumentTreeNode(soap, NULL, NULL, "ns1:CDocumentTreeNode");
	case SOAP_TYPE_ArrayOfCTreeNodeSoap:
		return soap_in_ArrayOfCTreeNodeSoap(soap, NULL, NULL, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_ns1__CTreeNodeSoap:
		return soap_in_ns1__CTreeNodeSoap(soap, NULL, NULL, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_ns1__CRequirementDocument:
		return soap_in_ns1__CRequirementDocument(soap, NULL, NULL, "ns1:CRequirementDocument");
	case SOAP_TYPE_ns1__CRequirement:
		return soap_in_ns1__CRequirement(soap, NULL, NULL, "ns1:CRequirement");
	case SOAP_TYPE_ArrayOfCSnapshotInfo:
		return soap_in_ArrayOfCSnapshotInfo(soap, NULL, NULL, "ns1:CSnapshotInfo");
	case SOAP_TYPE_ns1__CSnapshotInfo:
		return soap_in_ns1__CSnapshotInfo(soap, NULL, NULL, "ns1:CSnapshotInfo");
	case SOAP_TYPE_ArrayOfCVersionInfo:
		return soap_in_ArrayOfCVersionInfo(soap, NULL, NULL, "ns1:CVersionInfo");
	case SOAP_TYPE_ns1__CVersionInfo:
		return soap_in_ns1__CVersionInfo(soap, NULL, NULL, "ns1:CVersionInfo");
	case SOAP_TYPE_ArrayOfCFolderItem:
		return soap_in_ArrayOfCFolderItem(soap, NULL, NULL, "ns1:CFolderItem");
	case SOAP_TYPE_ArrayOfCFolder:
		return soap_in_ArrayOfCFolder(soap, NULL, NULL, "ns1:CFolder");
	case SOAP_TYPE_ns1__CFolderItem:
		return soap_in_ns1__CFolderItem(soap, NULL, NULL, "ns1:CFolderItem");
	case SOAP_TYPE_ns1__CFolder:
		return soap_in_ns1__CFolder(soap, NULL, NULL, "ns1:CFolder");
	case SOAP_TYPE_ArrayOfCFolderType:
		return soap_in_ArrayOfCFolderType(soap, NULL, NULL, "ns1:CFolderType");
	case SOAP_TYPE_ns1__CFolderType:
		return soap_in_ns1__CFolderType(soap, NULL, NULL, "ns1:CFolderType");
	case SOAP_TYPE_ns1__CScheduleInfo:
		return soap_in_ns1__CScheduleInfo(soap, NULL, NULL, "ns1:CScheduleInfo");
	case SOAP_TYPE_ArrayOfCItemToTrack:
		return soap_in_ArrayOfCItemToTrack(soap, NULL, NULL, "ns1:CItemToTrack");
	case SOAP_TYPE_ns1__CTestRun:
		return soap_in_ns1__CTestRun(soap, NULL, NULL, "ns1:CTestRun");
	case SOAP_TYPE_ns1__CTestCase:
		return soap_in_ns1__CTestCase(soap, NULL, NULL, "ns1:CTestCase");
	case SOAP_TYPE_ArrayOfCLink:
		return soap_in_ArrayOfCLink(soap, NULL, NULL, "ns1:CLink");
	case SOAP_TYPE_ns1__CLink:
		return soap_in_ns1__CLink(soap, NULL, NULL, "ns1:CLink");
	case SOAP_TYPE_ArrayOfCLinkHistoryItem:
		return soap_in_ArrayOfCLinkHistoryItem(soap, NULL, NULL, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_ns1__CLinkHistoryItem:
		return soap_in_ns1__CLinkHistoryItem(soap, NULL, NULL, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_ArrayOfCLinkedItem:
		return soap_in_ArrayOfCLinkedItem(soap, NULL, NULL, "ns1:CLinkedItem");
	case SOAP_TYPE_ns1__CLinkedItem:
		return soap_in_ns1__CLinkedItem(soap, NULL, NULL, "ns1:CLinkedItem");
	case SOAP_TYPE_ArrayOfCUserLicense:
		return soap_in_ArrayOfCUserLicense(soap, NULL, NULL, "ns1:CUserLicense");
	case SOAP_TYPE_ns1__CUserLicense:
		return soap_in_ns1__CUserLicense(soap, NULL, NULL, "ns1:CUserLicense");
	case SOAP_TYPE_ArrayOfCGlobalUser:
		return soap_in_ArrayOfCGlobalUser(soap, NULL, NULL, "ns1:CGlobalUser");
	case SOAP_TYPE_ns1__CGlobalUser:
		return soap_in_ns1__CGlobalUser(soap, NULL, NULL, "ns1:CGlobalUser");
	case SOAP_TYPE_ns1__CUser:
		return soap_in_ns1__CUser(soap, NULL, NULL, "ns1:CUser");
	case SOAP_TYPE_ns1__PhoneNumber:
		return soap_in_ns1__PhoneNumber(soap, NULL, NULL, "ns1:PhoneNumber");
	case SOAP_TYPE_ns1__CTask:
		return soap_in_ns1__CTask(soap, NULL, NULL, "ns1:CTask");
	case SOAP_TYPE_ns1__CDefect:
		return soap_in_ns1__CDefect(soap, NULL, NULL, "ns1:CDefect");
	case SOAP_TYPE_ArrayOfCDefectEventDefinition:
		return soap_in_ArrayOfCDefectEventDefinition(soap, NULL, NULL, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_ns1__CDefectEventDefinition:
		return soap_in_ns1__CDefectEventDefinition(soap, NULL, NULL, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_ArrayOfCEventDefinition:
		return soap_in_ArrayOfCEventDefinition(soap, NULL, NULL, "ns1:CEventDefinition");
	case SOAP_TYPE_ns1__CEventDefinition:
		return soap_in_ns1__CEventDefinition(soap, NULL, NULL, "ns1:CEventDefinition");
	case SOAP_TYPE_ArrayOfCDefectEvent:
		return soap_in_ArrayOfCDefectEvent(soap, NULL, NULL, "ns1:CDefectEvent");
	case SOAP_TYPE_ns1__CDefectEvent:
		return soap_in_ns1__CDefectEvent(soap, NULL, NULL, "ns1:CDefectEvent");
	case SOAP_TYPE_ArrayOfCEvent:
		return soap_in_ArrayOfCEvent(soap, NULL, NULL, "ns1:CEvent");
	case SOAP_TYPE_ns1__CEvent:
		return soap_in_ns1__CEvent(soap, NULL, NULL, "ns1:CEvent");
	case SOAP_TYPE_ArrayOfCTestCaseVariantField:
		return soap_in_ArrayOfCTestCaseVariantField(soap, NULL, NULL, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_ArrayOfCTestRunVariantField:
		return soap_in_ArrayOfCTestRunVariantField(soap, NULL, NULL, "ns1:CTestRunVariantField");
	case SOAP_TYPE_ArrayOfCField:
		return soap_in_ArrayOfCField(soap, NULL, NULL, "ns1:CField");
	case SOAP_TYPE_ns1__CTimespanField:
		return soap_in_ns1__CTimespanField(soap, NULL, NULL, "ns1:CTimespanField");
	case SOAP_TYPE_ns1__CVersionField:
		return soap_in_ns1__CVersionField(soap, NULL, NULL, "ns1:CVersionField");
	case SOAP_TYPE_ns1__CTestCaseVariantField:
		return soap_in_ns1__CTestCaseVariantField(soap, NULL, NULL, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_ns1__CTestRunVariantField:
		return soap_in_ns1__CTestRunVariantField(soap, NULL, NULL, "ns1:CTestRunVariantField");
	case SOAP_TYPE_ns1__CMultiSelectDropdownField:
		return soap_in_ns1__CMultiSelectDropdownField(soap, NULL, NULL, "ns1:CMultiSelectDropdownField");
	case SOAP_TYPE_ns1__CDropdownField:
		return soap_in_ns1__CDropdownField(soap, NULL, NULL, "ns1:CDropdownField");
	case SOAP_TYPE_ns1__CDateTimeField:
		return soap_in_ns1__CDateTimeField(soap, NULL, NULL, "ns1:CDateTimeField");
	case SOAP_TYPE_ns1__CDateField:
		return soap_in_ns1__CDateField(soap, NULL, NULL, "ns1:CDateField");
	case SOAP_TYPE_ns1__CBooleanField:
		return soap_in_ns1__CBooleanField(soap, NULL, NULL, "ns1:CBooleanField");
	case SOAP_TYPE_ns1__CDecimalField:
		return soap_in_ns1__CDecimalField(soap, NULL, NULL, "ns1:CDecimalField");
	case SOAP_TYPE_ns1__CIntegerField:
		return soap_in_ns1__CIntegerField(soap, NULL, NULL, "ns1:CIntegerField");
	case SOAP_TYPE_ns1__CStringField:
		return soap_in_ns1__CStringField(soap, NULL, NULL, "ns1:CStringField");
	case SOAP_TYPE_ns1__CField:
		return soap_in_ns1__CField(soap, NULL, NULL, "ns1:CField");
	case SOAP_TYPE_ArrayOfCReportedByRecord:
		return soap_in_ArrayOfCReportedByRecord(soap, NULL, NULL, "ns1:CReportedByRecord");
	case SOAP_TYPE_ns1__CReportedByRecord:
		return soap_in_ns1__CReportedByRecord(soap, NULL, NULL, "ns1:CReportedByRecord");
	case SOAP_TYPE_ArrayOfCFileAttachment:
		return soap_in_ArrayOfCFileAttachment(soap, NULL, NULL, "ns1:CFileAttachment");
	case SOAP_TYPE_ns1__CFileAttachment:
		return soap_in_ns1__CFileAttachment(soap, NULL, NULL, "ns1:CFileAttachment");
	case SOAP_TYPE_ns1__CReportRunResults:
		return soap_in_ns1__CReportRunResults(soap, NULL, NULL, "ns1:CReportRunResults");
	case SOAP_TYPE_ArrayOfCFile:
		return soap_in_ArrayOfCFile(soap, NULL, NULL, "ns1:CFile");
	case SOAP_TYPE_ns1__CFile:
		return soap_in_ns1__CFile(soap, NULL, NULL, "ns1:CFile");
	case SOAP_TYPE_ArrayOfCSCCFileRecord:
		return soap_in_ArrayOfCSCCFileRecord(soap, NULL, NULL, "ns1:CSCCFileRecord");
	case SOAP_TYPE_ns1__CSCCFileRecord:
		return soap_in_ns1__CSCCFileRecord(soap, NULL, NULL, "ns1:CSCCFileRecord");
	case SOAP_TYPE_ns1__CSystem:
		return soap_in_ns1__CSystem(soap, NULL, NULL, "ns1:CSystem");
	case SOAP_TYPE_ns1__CSystemBase:
		return soap_in_ns1__CSystemBase(soap, NULL, NULL, "ns1:CSystemBase");
	case SOAP_TYPE_ns1__COrderedItemWithDBRecordId:
		return soap_in_ns1__COrderedItemWithDBRecordId(soap, NULL, NULL, "ns1:COrderedItemWithDBRecordId");
	case SOAP_TYPE_ns1__CItemToTrack:
		return soap_in_ns1__CItemToTrack(soap, NULL, NULL, "ns1:CItemToTrack");
	case SOAP_TYPE_ns1__CItemWithDBRecordId:
		return soap_in_ns1__CItemWithDBRecordId(soap, NULL, NULL, "ns1:CItemWithDBRecordId");
	case SOAP_TYPE_ns1__CRecordListSoap:
		return soap_in_ns1__CRecordListSoap(soap, NULL, NULL, "ns1:CRecordListSoap");
	case SOAP_TYPE_ArrayOfCRecordRowSoap:
		return soap_in_ArrayOfCRecordRowSoap(soap, NULL, NULL, "ns1:CRecordRowSoap");
	case SOAP_TYPE_ns1__CRecordRowSoap:
		return soap_in_ns1__CRecordRowSoap(soap, NULL, NULL, "ns1:CRecordRowSoap");
	case SOAP_TYPE_ArrayOfCRecordData:
		return soap_in_ArrayOfCRecordData(soap, NULL, NULL, "ns1:CRecordData");
	case SOAP_TYPE_ns1__CRecordData:
		return soap_in_ns1__CRecordData(soap, NULL, NULL, "ns1:CRecordData");
	case SOAP_TYPE_ArrayOfCFilter:
		return soap_in_ArrayOfCFilter(soap, NULL, NULL, "ns1:CFilter");
	case SOAP_TYPE_ns1__CFilter:
		return soap_in_ns1__CFilter(soap, NULL, NULL, "ns1:CFilter");
	case SOAP_TYPE_ArrayOfCTableColumn:
		return soap_in_ArrayOfCTableColumn(soap, NULL, NULL, "ns1:CTableColumn");
	case SOAP_TYPE_ns1__CTableColumn:
		return soap_in_ns1__CTableColumn(soap, NULL, NULL, "ns1:CTableColumn");
	case SOAP_TYPE_ArrayOfCFieldValue:
		return soap_in_ArrayOfCFieldValue(soap, NULL, NULL, "ns1:CFieldValue");
	case SOAP_TYPE_ns1__CFieldValue:
		return soap_in_ns1__CFieldValue(soap, NULL, NULL, "ns1:CFieldValue");
	case SOAP_TYPE_ArrayOfCTableField:
		return soap_in_ArrayOfCTableField(soap, NULL, NULL, "ns1:CTableField");
	case SOAP_TYPE_ns1__CTableField:
		return soap_in_ns1__CTableField(soap, NULL, NULL, "ns1:CTableField");
	case SOAP_TYPE_ArrayOfCDatabaseTable:
		return soap_in_ArrayOfCDatabaseTable(soap, NULL, NULL, "ns1:CDatabaseTable");
	case SOAP_TYPE_ns1__CDatabaseTable:
		return soap_in_ns1__CDatabaseTable(soap, NULL, NULL, "ns1:CDatabaseTable");
	case SOAP_TYPE_ArrayOfCProject:
		return soap_in_ArrayOfCProject(soap, NULL, NULL, "ns1:CProject");
	case SOAP_TYPE_ns1__CProject:
		return soap_in_ns1__CProject(soap, NULL, NULL, "ns1:CProject");
	case SOAP_TYPE_ArrayOfCProjectDataOption:
		return soap_in_ArrayOfCProjectDataOption(soap, NULL, NULL, "ns1:CProjectDataOption");
	case SOAP_TYPE_ns1__CProjectDataOption:
		return soap_in_ns1__CProjectDataOption(soap, NULL, NULL, "ns1:CProjectDataOption");
	case SOAP_TYPE_ArrayOfCDatabase:
		return soap_in_ArrayOfCDatabase(soap, NULL, NULL, "ns1:CDatabase");
	case SOAP_TYPE_ns1__CDatabase:
		return soap_in_ns1__CDatabase(soap, NULL, NULL, "ns1:CDatabase");
	case SOAP_TYPE_ArrayOflong:
		return soap_in_ArrayOflong(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_ArrayOfstring:
		return soap_in_ArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_ns1__getItemHyperlinks:
		return soap_in_ns1__getItemHyperlinks(soap, NULL, NULL, "ns1:getItemHyperlinks");
	case SOAP_TYPE_ns1__getItemHyperlinksResponse:
		return soap_in_ns1__getItemHyperlinksResponse(soap, NULL, NULL, "ns1:getItemHyperlinksResponse");
	case SOAP_TYPE_ns1__getFolderTree:
		return soap_in_ns1__getFolderTree(soap, NULL, NULL, "ns1:getFolderTree");
	case SOAP_TYPE_ns1__getFolderTreeResponse:
		return soap_in_ns1__getFolderTreeResponse(soap, NULL, NULL, "ns1:getFolderTreeResponse");
	case SOAP_TYPE_ns1__getFolderTreeByRecordID:
		return soap_in_ns1__getFolderTreeByRecordID(soap, NULL, NULL, "ns1:getFolderTreeByRecordID");
	case SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse:
		return soap_in_ns1__getFolderTreeByRecordIDResponse(soap, NULL, NULL, "ns1:getFolderTreeByRecordIDResponse");
	case SOAP_TYPE_ns1__getDocumentTree:
		return soap_in_ns1__getDocumentTree(soap, NULL, NULL, "ns1:getDocumentTree");
	case SOAP_TYPE_ns1__getDocumentTreeResponse:
		return soap_in_ns1__getDocumentTreeResponse(soap, NULL, NULL, "ns1:getDocumentTreeResponse");
	case SOAP_TYPE_ns1__getRequirementIDsForDocument:
		return soap_in_ns1__getRequirementIDsForDocument(soap, NULL, NULL, "ns1:getRequirementIDsForDocument");
	case SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse:
		return soap_in_ns1__getRequirementIDsForDocumentResponse(soap, NULL, NULL, "ns1:getRequirementIDsForDocumentResponse");
	case SOAP_TYPE_ns1__createSnapshot:
		return soap_in_ns1__createSnapshot(soap, NULL, NULL, "ns1:createSnapshot");
	case SOAP_TYPE_ns1__createSnapshotResponse:
		return soap_in_ns1__createSnapshotResponse(soap, NULL, NULL, "ns1:createSnapshotResponse");
	case SOAP_TYPE_ns1__cancelSaveRequirementDocument:
		return soap_in_ns1__cancelSaveRequirementDocument(soap, NULL, NULL, "ns1:cancelSaveRequirementDocument");
	case SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse:
		return soap_in_ns1__cancelSaveRequirementDocumentResponse(soap, NULL, NULL, "ns1:cancelSaveRequirementDocumentResponse");
	case SOAP_TYPE_ns1__saveRequirementDocument:
		return soap_in_ns1__saveRequirementDocument(soap, NULL, NULL, "ns1:saveRequirementDocument");
	case SOAP_TYPE_ns1__saveRequirementDocumentResponse:
		return soap_in_ns1__saveRequirementDocumentResponse(soap, NULL, NULL, "ns1:saveRequirementDocumentResponse");
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordID:
		return soap_in_ns1__editRequirementDocumentByRecordID(soap, NULL, NULL, "ns1:editRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse:
		return soap_in_ns1__editRequirementDocumentByRecordIDResponse(soap, NULL, NULL, "ns1:editRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__editRequirementDocument:
		return soap_in_ns1__editRequirementDocument(soap, NULL, NULL, "ns1:editRequirementDocument");
	case SOAP_TYPE_ns1__editRequirementDocumentResponse:
		return soap_in_ns1__editRequirementDocumentResponse(soap, NULL, NULL, "ns1:editRequirementDocumentResponse");
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID:
		return soap_in_ns1__deleteRequirementDocumentByRecordID(soap, NULL, NULL, "ns1:deleteRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse:
		return soap_in_ns1__deleteRequirementDocumentByRecordIDResponse(soap, NULL, NULL, "ns1:deleteRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteRequirementDocument:
		return soap_in_ns1__deleteRequirementDocument(soap, NULL, NULL, "ns1:deleteRequirementDocument");
	case SOAP_TYPE_ns1__deleteRequirementDocumentResponse:
		return soap_in_ns1__deleteRequirementDocumentResponse(soap, NULL, NULL, "ns1:deleteRequirementDocumentResponse");
	case SOAP_TYPE_ns1__addRequirementDocument:
		return soap_in_ns1__addRequirementDocument(soap, NULL, NULL, "ns1:addRequirementDocument");
	case SOAP_TYPE_ns1__addRequirementDocumentResponse:
		return soap_in_ns1__addRequirementDocumentResponse(soap, NULL, NULL, "ns1:addRequirementDocumentResponse");
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordID:
		return soap_in_ns1__getRequirementDocumentByRecordID(soap, NULL, NULL, "ns1:getRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse:
		return soap_in_ns1__getRequirementDocumentByRecordIDResponse(soap, NULL, NULL, "ns1:getRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__getRequirementDocument:
		return soap_in_ns1__getRequirementDocument(soap, NULL, NULL, "ns1:getRequirementDocument");
	case SOAP_TYPE_ns1__getRequirementDocumentResponse:
		return soap_in_ns1__getRequirementDocumentResponse(soap, NULL, NULL, "ns1:getRequirementDocumentResponse");
	case SOAP_TYPE_ns1__changeRequirementType:
		return soap_in_ns1__changeRequirementType(soap, NULL, NULL, "ns1:changeRequirementType");
	case SOAP_TYPE_ns1__changeRequirementTypeResponse:
		return soap_in_ns1__changeRequirementTypeResponse(soap, NULL, NULL, "ns1:changeRequirementTypeResponse");
	case SOAP_TYPE_ns1__getDocumentIDsForRequirement:
		return soap_in_ns1__getDocumentIDsForRequirement(soap, NULL, NULL, "ns1:getDocumentIDsForRequirement");
	case SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse:
		return soap_in_ns1__getDocumentIDsForRequirementResponse(soap, NULL, NULL, "ns1:getDocumentIDsForRequirementResponse");
	case SOAP_TYPE_ns1__appendToRequirementDocument:
		return soap_in_ns1__appendToRequirementDocument(soap, NULL, NULL, "ns1:appendToRequirementDocument");
	case SOAP_TYPE_ns1__appendToRequirementDocumentResponse:
		return soap_in_ns1__appendToRequirementDocumentResponse(soap, NULL, NULL, "ns1:appendToRequirementDocumentResponse");
	case SOAP_TYPE_ns1__cancelSaveRequirement:
		return soap_in_ns1__cancelSaveRequirement(soap, NULL, NULL, "ns1:cancelSaveRequirement");
	case SOAP_TYPE_ns1__cancelSaveRequirementResponse:
		return soap_in_ns1__cancelSaveRequirementResponse(soap, NULL, NULL, "ns1:cancelSaveRequirementResponse");
	case SOAP_TYPE_ns1__saveRequirement:
		return soap_in_ns1__saveRequirement(soap, NULL, NULL, "ns1:saveRequirement");
	case SOAP_TYPE_ns1__saveRequirementResponse:
		return soap_in_ns1__saveRequirementResponse(soap, NULL, NULL, "ns1:saveRequirementResponse");
	case SOAP_TYPE_ns1__editRequirementByRecordID:
		return soap_in_ns1__editRequirementByRecordID(soap, NULL, NULL, "ns1:editRequirementByRecordID");
	case SOAP_TYPE_ns1__editRequirementByRecordIDResponse:
		return soap_in_ns1__editRequirementByRecordIDResponse(soap, NULL, NULL, "ns1:editRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__editRequirement:
		return soap_in_ns1__editRequirement(soap, NULL, NULL, "ns1:editRequirement");
	case SOAP_TYPE_ns1__editRequirementResponse:
		return soap_in_ns1__editRequirementResponse(soap, NULL, NULL, "ns1:editRequirementResponse");
	case SOAP_TYPE_ns1__deleteRequirementByRecordID:
		return soap_in_ns1__deleteRequirementByRecordID(soap, NULL, NULL, "ns1:deleteRequirementByRecordID");
	case SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse:
		return soap_in_ns1__deleteRequirementByRecordIDResponse(soap, NULL, NULL, "ns1:deleteRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteRequirement:
		return soap_in_ns1__deleteRequirement(soap, NULL, NULL, "ns1:deleteRequirement");
	case SOAP_TYPE_ns1__deleteRequirementResponse:
		return soap_in_ns1__deleteRequirementResponse(soap, NULL, NULL, "ns1:deleteRequirementResponse");
	case SOAP_TYPE_ns1__addRequirement:
		return soap_in_ns1__addRequirement(soap, NULL, NULL, "ns1:addRequirement");
	case SOAP_TYPE_ns1__addRequirementResponse:
		return soap_in_ns1__addRequirementResponse(soap, NULL, NULL, "ns1:addRequirementResponse");
	case SOAP_TYPE_ns1__getRequirementByRecordID:
		return soap_in_ns1__getRequirementByRecordID(soap, NULL, NULL, "ns1:getRequirementByRecordID");
	case SOAP_TYPE_ns1__getRequirementByRecordIDResponse:
		return soap_in_ns1__getRequirementByRecordIDResponse(soap, NULL, NULL, "ns1:getRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__getRequirement:
		return soap_in_ns1__getRequirement(soap, NULL, NULL, "ns1:getRequirement");
	case SOAP_TYPE_ns1__getRequirementResponse:
		return soap_in_ns1__getRequirementResponse(soap, NULL, NULL, "ns1:getRequirementResponse");
	case SOAP_TYPE_ns1__cancelSaveFolderItemRank:
		return soap_in_ns1__cancelSaveFolderItemRank(soap, NULL, NULL, "ns1:cancelSaveFolderItemRank");
	case SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse:
		return soap_in_ns1__cancelSaveFolderItemRankResponse(soap, NULL, NULL, "ns1:cancelSaveFolderItemRankResponse");
	case SOAP_TYPE_ns1__saveFolderItemRank:
		return soap_in_ns1__saveFolderItemRank(soap, NULL, NULL, "ns1:saveFolderItemRank");
	case SOAP_TYPE_ns1__saveFolderItemRankResponse:
		return soap_in_ns1__saveFolderItemRankResponse(soap, NULL, NULL, "ns1:saveFolderItemRankResponse");
	case SOAP_TYPE_ns1__editFolderItemRank:
		return soap_in_ns1__editFolderItemRank(soap, NULL, NULL, "ns1:editFolderItemRank");
	case SOAP_TYPE_ns1__editFolderItemRankResponse:
		return soap_in_ns1__editFolderItemRankResponse(soap, NULL, NULL, "ns1:editFolderItemRankResponse");
	case SOAP_TYPE_ns1__getRootPrivateFolderPath:
		return soap_in_ns1__getRootPrivateFolderPath(soap, NULL, NULL, "ns1:getRootPrivateFolderPath");
	case SOAP_TYPE_ns1__getRootPrivateFolderPathResponse:
		return soap_in_ns1__getRootPrivateFolderPathResponse(soap, NULL, NULL, "ns1:getRootPrivateFolderPathResponse");
	case SOAP_TYPE_ns1__getRootPublicFolderPath:
		return soap_in_ns1__getRootPublicFolderPath(soap, NULL, NULL, "ns1:getRootPublicFolderPath");
	case SOAP_TYPE_ns1__getRootPublicFolderPathResponse:
		return soap_in_ns1__getRootPublicFolderPathResponse(soap, NULL, NULL, "ns1:getRootPublicFolderPathResponse");
	case SOAP_TYPE_ns1__getFolderPathSeparator:
		return soap_in_ns1__getFolderPathSeparator(soap, NULL, NULL, "ns1:getFolderPathSeparator");
	case SOAP_TYPE_ns1__getFolderPathSeparatorResponse:
		return soap_in_ns1__getFolderPathSeparatorResponse(soap, NULL, NULL, "ns1:getFolderPathSeparatorResponse");
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordID:
		return soap_in_ns1__getFolderListForEntityByRecordID(soap, NULL, NULL, "ns1:getFolderListForEntityByRecordID");
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse:
		return soap_in_ns1__getFolderListForEntityByRecordIDResponse(soap, NULL, NULL, "ns1:getFolderListForEntityByRecordIDResponse");
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordID:
		return soap_in_ns1__getEntityListForFolderByRecordID(soap, NULL, NULL, "ns1:getEntityListForFolderByRecordID");
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse:
		return soap_in_ns1__getEntityListForFolderByRecordIDResponse(soap, NULL, NULL, "ns1:getEntityListForFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordID:
		return soap_in_ns1__removeEntityFromFolderByRecordID(soap, NULL, NULL, "ns1:removeEntityFromFolderByRecordID");
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse:
		return soap_in_ns1__removeEntityFromFolderByRecordIDResponse(soap, NULL, NULL, "ns1:removeEntityFromFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__addEntityToFolderByRecordID:
		return soap_in_ns1__addEntityToFolderByRecordID(soap, NULL, NULL, "ns1:addEntityToFolderByRecordID");
	case SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse:
		return soap_in_ns1__addEntityToFolderByRecordIDResponse(soap, NULL, NULL, "ns1:addEntityToFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteFolderByRecordID:
		return soap_in_ns1__deleteFolderByRecordID(soap, NULL, NULL, "ns1:deleteFolderByRecordID");
	case SOAP_TYPE_ns1__deleteFolderByRecordIDResponse:
		return soap_in_ns1__deleteFolderByRecordIDResponse(soap, NULL, NULL, "ns1:deleteFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteFolder:
		return soap_in_ns1__deleteFolder(soap, NULL, NULL, "ns1:deleteFolder");
	case SOAP_TYPE_ns1__deleteFolderResponse:
		return soap_in_ns1__deleteFolderResponse(soap, NULL, NULL, "ns1:deleteFolderResponse");
	case SOAP_TYPE_ns1__getFolderByRecordID:
		return soap_in_ns1__getFolderByRecordID(soap, NULL, NULL, "ns1:getFolderByRecordID");
	case SOAP_TYPE_ns1__getFolderByRecordIDResponse:
		return soap_in_ns1__getFolderByRecordIDResponse(soap, NULL, NULL, "ns1:getFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__getFolder:
		return soap_in_ns1__getFolder(soap, NULL, NULL, "ns1:getFolder");
	case SOAP_TYPE_ns1__getFolderResponse:
		return soap_in_ns1__getFolderResponse(soap, NULL, NULL, "ns1:getFolderResponse");
	case SOAP_TYPE_ns1__cancelSaveFolder:
		return soap_in_ns1__cancelSaveFolder(soap, NULL, NULL, "ns1:cancelSaveFolder");
	case SOAP_TYPE_ns1__cancelSaveFolderResponse:
		return soap_in_ns1__cancelSaveFolderResponse(soap, NULL, NULL, "ns1:cancelSaveFolderResponse");
	case SOAP_TYPE_ns1__saveFolder:
		return soap_in_ns1__saveFolder(soap, NULL, NULL, "ns1:saveFolder");
	case SOAP_TYPE_ns1__saveFolderResponse:
		return soap_in_ns1__saveFolderResponse(soap, NULL, NULL, "ns1:saveFolderResponse");
	case SOAP_TYPE_ns1__editFolderByRecordID:
		return soap_in_ns1__editFolderByRecordID(soap, NULL, NULL, "ns1:editFolderByRecordID");
	case SOAP_TYPE_ns1__editFolderByRecordIDResponse:
		return soap_in_ns1__editFolderByRecordIDResponse(soap, NULL, NULL, "ns1:editFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__editFolder:
		return soap_in_ns1__editFolder(soap, NULL, NULL, "ns1:editFolder");
	case SOAP_TYPE_ns1__editFolderResponse:
		return soap_in_ns1__editFolderResponse(soap, NULL, NULL, "ns1:editFolderResponse");
	case SOAP_TYPE_ns1__addFolder:
		return soap_in_ns1__addFolder(soap, NULL, NULL, "ns1:addFolder");
	case SOAP_TYPE_ns1__addFolderResponse:
		return soap_in_ns1__addFolderResponse(soap, NULL, NULL, "ns1:addFolderResponse");
	case SOAP_TYPE_ns1__getFolderTypeList:
		return soap_in_ns1__getFolderTypeList(soap, NULL, NULL, "ns1:getFolderTypeList");
	case SOAP_TYPE_ns1__getFolderTypeListResponse:
		return soap_in_ns1__getFolderTypeListResponse(soap, NULL, NULL, "ns1:getFolderTypeListResponse");
	case SOAP_TYPE_ns1__getFolderTypeByName:
		return soap_in_ns1__getFolderTypeByName(soap, NULL, NULL, "ns1:getFolderTypeByName");
	case SOAP_TYPE_ns1__getFolderTypeByNameResponse:
		return soap_in_ns1__getFolderTypeByNameResponse(soap, NULL, NULL, "ns1:getFolderTypeByNameResponse");
	case SOAP_TYPE_ns1__generateTestRuns:
		return soap_in_ns1__generateTestRuns(soap, NULL, NULL, "ns1:generateTestRuns");
	case SOAP_TYPE_ns1__generateTestRunsResponse:
		return soap_in_ns1__generateTestRunsResponse(soap, NULL, NULL, "ns1:generateTestRunsResponse");
	case SOAP_TYPE_ns1__createDefectForTestRun:
		return soap_in_ns1__createDefectForTestRun(soap, NULL, NULL, "ns1:createDefectForTestRun");
	case SOAP_TYPE_ns1__createDefectForTestRunResponse:
		return soap_in_ns1__createDefectForTestRunResponse(soap, NULL, NULL, "ns1:createDefectForTestRunResponse");
	case SOAP_TYPE_ns1__cancelSaveTestRun:
		return soap_in_ns1__cancelSaveTestRun(soap, NULL, NULL, "ns1:cancelSaveTestRun");
	case SOAP_TYPE_ns1__cancelSaveTestRunResponse:
		return soap_in_ns1__cancelSaveTestRunResponse(soap, NULL, NULL, "ns1:cancelSaveTestRunResponse");
	case SOAP_TYPE_ns1__saveTestRun:
		return soap_in_ns1__saveTestRun(soap, NULL, NULL, "ns1:saveTestRun");
	case SOAP_TYPE_ns1__saveTestRunResponse:
		return soap_in_ns1__saveTestRunResponse(soap, NULL, NULL, "ns1:saveTestRunResponse");
	case SOAP_TYPE_ns1__editTestRunByRecordID:
		return soap_in_ns1__editTestRunByRecordID(soap, NULL, NULL, "ns1:editTestRunByRecordID");
	case SOAP_TYPE_ns1__editTestRunByRecordIDResponse:
		return soap_in_ns1__editTestRunByRecordIDResponse(soap, NULL, NULL, "ns1:editTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestRun:
		return soap_in_ns1__editTestRun(soap, NULL, NULL, "ns1:editTestRun");
	case SOAP_TYPE_ns1__editTestRunResponse:
		return soap_in_ns1__editTestRunResponse(soap, NULL, NULL, "ns1:editTestRunResponse");
	case SOAP_TYPE_ns1__deleteTestRunByRecordID:
		return soap_in_ns1__deleteTestRunByRecordID(soap, NULL, NULL, "ns1:deleteTestRunByRecordID");
	case SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse:
		return soap_in_ns1__deleteTestRunByRecordIDResponse(soap, NULL, NULL, "ns1:deleteTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestRun:
		return soap_in_ns1__deleteTestRun(soap, NULL, NULL, "ns1:deleteTestRun");
	case SOAP_TYPE_ns1__deleteTestRunResponse:
		return soap_in_ns1__deleteTestRunResponse(soap, NULL, NULL, "ns1:deleteTestRunResponse");
	case SOAP_TYPE_ns1__getTestRunByRecordID:
		return soap_in_ns1__getTestRunByRecordID(soap, NULL, NULL, "ns1:getTestRunByRecordID");
	case SOAP_TYPE_ns1__getTestRunByRecordIDResponse:
		return soap_in_ns1__getTestRunByRecordIDResponse(soap, NULL, NULL, "ns1:getTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestRun:
		return soap_in_ns1__getTestRun(soap, NULL, NULL, "ns1:getTestRun");
	case SOAP_TYPE_ns1__getTestRunResponse:
		return soap_in_ns1__getTestRunResponse(soap, NULL, NULL, "ns1:getTestRunResponse");
	case SOAP_TYPE_ns1__cancelSaveTestCase:
		return soap_in_ns1__cancelSaveTestCase(soap, NULL, NULL, "ns1:cancelSaveTestCase");
	case SOAP_TYPE_ns1__cancelSaveTestCaseResponse:
		return soap_in_ns1__cancelSaveTestCaseResponse(soap, NULL, NULL, "ns1:cancelSaveTestCaseResponse");
	case SOAP_TYPE_ns1__saveTestCase:
		return soap_in_ns1__saveTestCase(soap, NULL, NULL, "ns1:saveTestCase");
	case SOAP_TYPE_ns1__saveTestCaseResponse:
		return soap_in_ns1__saveTestCaseResponse(soap, NULL, NULL, "ns1:saveTestCaseResponse");
	case SOAP_TYPE_ns1__editTestCaseByRecordID:
		return soap_in_ns1__editTestCaseByRecordID(soap, NULL, NULL, "ns1:editTestCaseByRecordID");
	case SOAP_TYPE_ns1__editTestCaseByRecordIDResponse:
		return soap_in_ns1__editTestCaseByRecordIDResponse(soap, NULL, NULL, "ns1:editTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestCase:
		return soap_in_ns1__editTestCase(soap, NULL, NULL, "ns1:editTestCase");
	case SOAP_TYPE_ns1__editTestCaseResponse:
		return soap_in_ns1__editTestCaseResponse(soap, NULL, NULL, "ns1:editTestCaseResponse");
	case SOAP_TYPE_ns1__deleteTestCaseByRecordID:
		return soap_in_ns1__deleteTestCaseByRecordID(soap, NULL, NULL, "ns1:deleteTestCaseByRecordID");
	case SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse:
		return soap_in_ns1__deleteTestCaseByRecordIDResponse(soap, NULL, NULL, "ns1:deleteTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestCase:
		return soap_in_ns1__deleteTestCase(soap, NULL, NULL, "ns1:deleteTestCase");
	case SOAP_TYPE_ns1__deleteTestCaseResponse:
		return soap_in_ns1__deleteTestCaseResponse(soap, NULL, NULL, "ns1:deleteTestCaseResponse");
	case SOAP_TYPE_ns1__addTestCase:
		return soap_in_ns1__addTestCase(soap, NULL, NULL, "ns1:addTestCase");
	case SOAP_TYPE_ns1__addTestCaseResponse:
		return soap_in_ns1__addTestCaseResponse(soap, NULL, NULL, "ns1:addTestCaseResponse");
	case SOAP_TYPE_ns1__getTestCaseByRecordID:
		return soap_in_ns1__getTestCaseByRecordID(soap, NULL, NULL, "ns1:getTestCaseByRecordID");
	case SOAP_TYPE_ns1__getTestCaseByRecordIDResponse:
		return soap_in_ns1__getTestCaseByRecordIDResponse(soap, NULL, NULL, "ns1:getTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestCase:
		return soap_in_ns1__getTestCase(soap, NULL, NULL, "ns1:getTestCase");
	case SOAP_TYPE_ns1__getTestCaseResponse:
		return soap_in_ns1__getTestCaseResponse(soap, NULL, NULL, "ns1:getTestCaseResponse");
	case SOAP_TYPE_ns1__getTestRunStepsModes:
		return soap_in_ns1__getTestRunStepsModes(soap, NULL, NULL, "ns1:getTestRunStepsModes");
	case SOAP_TYPE_ns1__getTestRunStepsModesResponse:
		return soap_in_ns1__getTestRunStepsModesResponse(soap, NULL, NULL, "ns1:getTestRunStepsModesResponse");
	case SOAP_TYPE_ns1__getTestVariantTypes:
		return soap_in_ns1__getTestVariantTypes(soap, NULL, NULL, "ns1:getTestVariantTypes");
	case SOAP_TYPE_ns1__getTestVariantTypesResponse:
		return soap_in_ns1__getTestVariantTypesResponse(soap, NULL, NULL, "ns1:getTestVariantTypesResponse");
	case SOAP_TYPE_ns1__cancelSaveLink:
		return soap_in_ns1__cancelSaveLink(soap, NULL, NULL, "ns1:cancelSaveLink");
	case SOAP_TYPE_ns1__cancelSaveLinkResponse:
		return soap_in_ns1__cancelSaveLinkResponse(soap, NULL, NULL, "ns1:cancelSaveLinkResponse");
	case SOAP_TYPE_ns1__saveLink:
		return soap_in_ns1__saveLink(soap, NULL, NULL, "ns1:saveLink");
	case SOAP_TYPE_ns1__saveLinkResponse:
		return soap_in_ns1__saveLinkResponse(soap, NULL, NULL, "ns1:saveLinkResponse");
	case SOAP_TYPE_ns1__editLink:
		return soap_in_ns1__editLink(soap, NULL, NULL, "ns1:editLink");
	case SOAP_TYPE_ns1__editLinkResponse:
		return soap_in_ns1__editLinkResponse(soap, NULL, NULL, "ns1:editLinkResponse");
	case SOAP_TYPE_ns1__deleteLink:
		return soap_in_ns1__deleteLink(soap, NULL, NULL, "ns1:deleteLink");
	case SOAP_TYPE_ns1__deleteLinkResponse:
		return soap_in_ns1__deleteLinkResponse(soap, NULL, NULL, "ns1:deleteLinkResponse");
	case SOAP_TYPE_ns1__addLink:
		return soap_in_ns1__addLink(soap, NULL, NULL, "ns1:addLink");
	case SOAP_TYPE_ns1__addLinkResponse:
		return soap_in_ns1__addLinkResponse(soap, NULL, NULL, "ns1:addLinkResponse");
	case SOAP_TYPE_ns1__getLink:
		return soap_in_ns1__getLink(soap, NULL, NULL, "ns1:getLink");
	case SOAP_TYPE_ns1__getLinkResponse:
		return soap_in_ns1__getLinkResponse(soap, NULL, NULL, "ns1:getLinkResponse");
	case SOAP_TYPE_ns1__getLinksForDefect:
		return soap_in_ns1__getLinksForDefect(soap, NULL, NULL, "ns1:getLinksForDefect");
	case SOAP_TYPE_ns1__getLinksForDefectResponse:
		return soap_in_ns1__getLinksForDefectResponse(soap, NULL, NULL, "ns1:getLinksForDefectResponse");
	case SOAP_TYPE_ns1__getLinksForItem:
		return soap_in_ns1__getLinksForItem(soap, NULL, NULL, "ns1:getLinksForItem");
	case SOAP_TYPE_ns1__getLinksForItemResponse:
		return soap_in_ns1__getLinksForItemResponse(soap, NULL, NULL, "ns1:getLinksForItemResponse");
	case SOAP_TYPE_ns1__addGlobalCustomer:
		return soap_in_ns1__addGlobalCustomer(soap, NULL, NULL, "ns1:addGlobalCustomer");
	case SOAP_TYPE_ns1__addGlobalCustomerResponse:
		return soap_in_ns1__addGlobalCustomerResponse(soap, NULL, NULL, "ns1:addGlobalCustomerResponse");
	case SOAP_TYPE_ns1__promoteCustomer:
		return soap_in_ns1__promoteCustomer(soap, NULL, NULL, "ns1:promoteCustomer");
	case SOAP_TYPE_ns1__promoteCustomerResponse:
		return soap_in_ns1__promoteCustomerResponse(soap, NULL, NULL, "ns1:promoteCustomerResponse");
	case SOAP_TYPE_ns1__cancelSaveCustomer:
		return soap_in_ns1__cancelSaveCustomer(soap, NULL, NULL, "ns1:cancelSaveCustomer");
	case SOAP_TYPE_ns1__cancelSaveCustomerResponse:
		return soap_in_ns1__cancelSaveCustomerResponse(soap, NULL, NULL, "ns1:cancelSaveCustomerResponse");
	case SOAP_TYPE_ns1__deleteCustomerByRecordID:
		return soap_in_ns1__deleteCustomerByRecordID(soap, NULL, NULL, "ns1:deleteCustomerByRecordID");
	case SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse:
		return soap_in_ns1__deleteCustomerByRecordIDResponse(soap, NULL, NULL, "ns1:deleteCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteCustomer:
		return soap_in_ns1__deleteCustomer(soap, NULL, NULL, "ns1:deleteCustomer");
	case SOAP_TYPE_ns1__deleteCustomerResponse:
		return soap_in_ns1__deleteCustomerResponse(soap, NULL, NULL, "ns1:deleteCustomerResponse");
	case SOAP_TYPE_ns1__saveCustomer:
		return soap_in_ns1__saveCustomer(soap, NULL, NULL, "ns1:saveCustomer");
	case SOAP_TYPE_ns1__saveCustomerResponse:
		return soap_in_ns1__saveCustomerResponse(soap, NULL, NULL, "ns1:saveCustomerResponse");
	case SOAP_TYPE_ns1__editCustomerByRecordID:
		return soap_in_ns1__editCustomerByRecordID(soap, NULL, NULL, "ns1:editCustomerByRecordID");
	case SOAP_TYPE_ns1__editCustomerByRecordIDResponse:
		return soap_in_ns1__editCustomerByRecordIDResponse(soap, NULL, NULL, "ns1:editCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__editCustomer:
		return soap_in_ns1__editCustomer(soap, NULL, NULL, "ns1:editCustomer");
	case SOAP_TYPE_ns1__editCustomerResponse:
		return soap_in_ns1__editCustomerResponse(soap, NULL, NULL, "ns1:editCustomerResponse");
	case SOAP_TYPE_ns1__addCustomer:
		return soap_in_ns1__addCustomer(soap, NULL, NULL, "ns1:addCustomer");
	case SOAP_TYPE_ns1__addCustomerResponse:
		return soap_in_ns1__addCustomerResponse(soap, NULL, NULL, "ns1:addCustomerResponse");
	case SOAP_TYPE_ns1__getCustomerByRecordID:
		return soap_in_ns1__getCustomerByRecordID(soap, NULL, NULL, "ns1:getCustomerByRecordID");
	case SOAP_TYPE_ns1__getCustomerByRecordIDResponse:
		return soap_in_ns1__getCustomerByRecordIDResponse(soap, NULL, NULL, "ns1:getCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__getCustomer:
		return soap_in_ns1__getCustomer(soap, NULL, NULL, "ns1:getCustomer");
	case SOAP_TYPE_ns1__getCustomerResponse:
		return soap_in_ns1__getCustomerResponse(soap, NULL, NULL, "ns1:getCustomerResponse");
	case SOAP_TYPE_ns1__addGlobalUser:
		return soap_in_ns1__addGlobalUser(soap, NULL, NULL, "ns1:addGlobalUser");
	case SOAP_TYPE_ns1__addGlobalUserResponse:
		return soap_in_ns1__addGlobalUserResponse(soap, NULL, NULL, "ns1:addGlobalUserResponse");
	case SOAP_TYPE_ns1__promoteUser:
		return soap_in_ns1__promoteUser(soap, NULL, NULL, "ns1:promoteUser");
	case SOAP_TYPE_ns1__promoteUserResponse:
		return soap_in_ns1__promoteUserResponse(soap, NULL, NULL, "ns1:promoteUserResponse");
	case SOAP_TYPE_ns1__cancelSaveUser:
		return soap_in_ns1__cancelSaveUser(soap, NULL, NULL, "ns1:cancelSaveUser");
	case SOAP_TYPE_ns1__cancelSaveUserResponse:
		return soap_in_ns1__cancelSaveUserResponse(soap, NULL, NULL, "ns1:cancelSaveUserResponse");
	case SOAP_TYPE_ns1__deleteUserByRecordID:
		return soap_in_ns1__deleteUserByRecordID(soap, NULL, NULL, "ns1:deleteUserByRecordID");
	case SOAP_TYPE_ns1__deleteUserByRecordIDResponse:
		return soap_in_ns1__deleteUserByRecordIDResponse(soap, NULL, NULL, "ns1:deleteUserByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteUser:
		return soap_in_ns1__deleteUser(soap, NULL, NULL, "ns1:deleteUser");
	case SOAP_TYPE_ns1__deleteUserResponse:
		return soap_in_ns1__deleteUserResponse(soap, NULL, NULL, "ns1:deleteUserResponse");
	case SOAP_TYPE_ns1__saveUser:
		return soap_in_ns1__saveUser(soap, NULL, NULL, "ns1:saveUser");
	case SOAP_TYPE_ns1__saveUserResponse:
		return soap_in_ns1__saveUserResponse(soap, NULL, NULL, "ns1:saveUserResponse");
	case SOAP_TYPE_ns1__editUserByRecordID:
		return soap_in_ns1__editUserByRecordID(soap, NULL, NULL, "ns1:editUserByRecordID");
	case SOAP_TYPE_ns1__editUserByRecordIDResponse:
		return soap_in_ns1__editUserByRecordIDResponse(soap, NULL, NULL, "ns1:editUserByRecordIDResponse");
	case SOAP_TYPE_ns1__editUser:
		return soap_in_ns1__editUser(soap, NULL, NULL, "ns1:editUser");
	case SOAP_TYPE_ns1__editUserResponse:
		return soap_in_ns1__editUserResponse(soap, NULL, NULL, "ns1:editUserResponse");
	case SOAP_TYPE_ns1__addUser:
		return soap_in_ns1__addUser(soap, NULL, NULL, "ns1:addUser");
	case SOAP_TYPE_ns1__addUserResponse:
		return soap_in_ns1__addUserResponse(soap, NULL, NULL, "ns1:addUserResponse");
	case SOAP_TYPE_ns1__getUserForCurrentSession:
		return soap_in_ns1__getUserForCurrentSession(soap, NULL, NULL, "ns1:getUserForCurrentSession");
	case SOAP_TYPE_ns1__getUserForCurrentSessionResponse:
		return soap_in_ns1__getUserForCurrentSessionResponse(soap, NULL, NULL, "ns1:getUserForCurrentSessionResponse");
	case SOAP_TYPE_ns1__getUserByRecordID:
		return soap_in_ns1__getUserByRecordID(soap, NULL, NULL, "ns1:getUserByRecordID");
	case SOAP_TYPE_ns1__getUserByRecordIDResponse:
		return soap_in_ns1__getUserByRecordIDResponse(soap, NULL, NULL, "ns1:getUserByRecordIDResponse");
	case SOAP_TYPE_ns1__getUser:
		return soap_in_ns1__getUser(soap, NULL, NULL, "ns1:getUser");
	case SOAP_TYPE_ns1__getUserResponse:
		return soap_in_ns1__getUserResponse(soap, NULL, NULL, "ns1:getUserResponse");
	case SOAP_TYPE_ns1__getUserLicenseList:
		return soap_in_ns1__getUserLicenseList(soap, NULL, NULL, "ns1:getUserLicenseList");
	case SOAP_TYPE_ns1__getUserLicenseListResponse:
		return soap_in_ns1__getUserLicenseListResponse(soap, NULL, NULL, "ns1:getUserLicenseListResponse");
	case SOAP_TYPE_ns1__getGlobalCustomerList:
		return soap_in_ns1__getGlobalCustomerList(soap, NULL, NULL, "ns1:getGlobalCustomerList");
	case SOAP_TYPE_ns1__getGlobalCustomerListResponse:
		return soap_in_ns1__getGlobalCustomerListResponse(soap, NULL, NULL, "ns1:getGlobalCustomerListResponse");
	case SOAP_TYPE_ns1__getGlobalUserList:
		return soap_in_ns1__getGlobalUserList(soap, NULL, NULL, "ns1:getGlobalUserList");
	case SOAP_TYPE_ns1__getGlobalUserListResponse:
		return soap_in_ns1__getGlobalUserListResponse(soap, NULL, NULL, "ns1:getGlobalUserListResponse");
	case SOAP_TYPE_ns1__cancelSaveTask:
		return soap_in_ns1__cancelSaveTask(soap, NULL, NULL, "ns1:cancelSaveTask");
	case SOAP_TYPE_ns1__cancelSaveTaskResponse:
		return soap_in_ns1__cancelSaveTaskResponse(soap, NULL, NULL, "ns1:cancelSaveTaskResponse");
	case SOAP_TYPE_ns1__saveTask:
		return soap_in_ns1__saveTask(soap, NULL, NULL, "ns1:saveTask");
	case SOAP_TYPE_ns1__saveTaskResponse:
		return soap_in_ns1__saveTaskResponse(soap, NULL, NULL, "ns1:saveTaskResponse");
	case SOAP_TYPE_ns1__editTaskByRecordID:
		return soap_in_ns1__editTaskByRecordID(soap, NULL, NULL, "ns1:editTaskByRecordID");
	case SOAP_TYPE_ns1__editTaskByRecordIDResponse:
		return soap_in_ns1__editTaskByRecordIDResponse(soap, NULL, NULL, "ns1:editTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__editTask:
		return soap_in_ns1__editTask(soap, NULL, NULL, "ns1:editTask");
	case SOAP_TYPE_ns1__editTaskResponse:
		return soap_in_ns1__editTaskResponse(soap, NULL, NULL, "ns1:editTaskResponse");
	case SOAP_TYPE_ns1__deleteTaskByRecordID:
		return soap_in_ns1__deleteTaskByRecordID(soap, NULL, NULL, "ns1:deleteTaskByRecordID");
	case SOAP_TYPE_ns1__deleteTaskByRecordIDResponse:
		return soap_in_ns1__deleteTaskByRecordIDResponse(soap, NULL, NULL, "ns1:deleteTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTask:
		return soap_in_ns1__deleteTask(soap, NULL, NULL, "ns1:deleteTask");
	case SOAP_TYPE_ns1__deleteTaskResponse:
		return soap_in_ns1__deleteTaskResponse(soap, NULL, NULL, "ns1:deleteTaskResponse");
	case SOAP_TYPE_ns1__addTask:
		return soap_in_ns1__addTask(soap, NULL, NULL, "ns1:addTask");
	case SOAP_TYPE_ns1__addTaskResponse:
		return soap_in_ns1__addTaskResponse(soap, NULL, NULL, "ns1:addTaskResponse");
	case SOAP_TYPE_ns1__getTaskByRecordID:
		return soap_in_ns1__getTaskByRecordID(soap, NULL, NULL, "ns1:getTaskByRecordID");
	case SOAP_TYPE_ns1__getTaskByRecordIDResponse:
		return soap_in_ns1__getTaskByRecordIDResponse(soap, NULL, NULL, "ns1:getTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__getTask:
		return soap_in_ns1__getTask(soap, NULL, NULL, "ns1:getTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return soap_in_ns1__getTaskResponse(soap, NULL, NULL, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getDefectAttachment:
		return soap_in_ns1__getDefectAttachment(soap, NULL, NULL, "ns1:getDefectAttachment");
	case SOAP_TYPE_ns1__getDefectAttachmentResponse:
		return soap_in_ns1__getDefectAttachmentResponse(soap, NULL, NULL, "ns1:getDefectAttachmentResponse");
	case SOAP_TYPE_ns1__getAttachment:
		return soap_in_ns1__getAttachment(soap, NULL, NULL, "ns1:getAttachment");
	case SOAP_TYPE_ns1__getAttachmentResponse:
		return soap_in_ns1__getAttachmentResponse(soap, NULL, NULL, "ns1:getAttachmentResponse");
	case SOAP_TYPE_ns1__cancelSaveDefect:
		return soap_in_ns1__cancelSaveDefect(soap, NULL, NULL, "ns1:cancelSaveDefect");
	case SOAP_TYPE_ns1__cancelSaveDefectResponse:
		return soap_in_ns1__cancelSaveDefectResponse(soap, NULL, NULL, "ns1:cancelSaveDefectResponse");
	case SOAP_TYPE_ns1__saveDefect:
		return soap_in_ns1__saveDefect(soap, NULL, NULL, "ns1:saveDefect");
	case SOAP_TYPE_ns1__saveDefectResponse:
		return soap_in_ns1__saveDefectResponse(soap, NULL, NULL, "ns1:saveDefectResponse");
	case SOAP_TYPE_ns1__editDefectByRecordID:
		return soap_in_ns1__editDefectByRecordID(soap, NULL, NULL, "ns1:editDefectByRecordID");
	case SOAP_TYPE_ns1__editDefectByRecordIDResponse:
		return soap_in_ns1__editDefectByRecordIDResponse(soap, NULL, NULL, "ns1:editDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__editDefect:
		return soap_in_ns1__editDefect(soap, NULL, NULL, "ns1:editDefect");
	case SOAP_TYPE_ns1__editDefectResponse:
		return soap_in_ns1__editDefectResponse(soap, NULL, NULL, "ns1:editDefectResponse");
	case SOAP_TYPE_ns1__deleteDefectByRecordID:
		return soap_in_ns1__deleteDefectByRecordID(soap, NULL, NULL, "ns1:deleteDefectByRecordID");
	case SOAP_TYPE_ns1__deleteDefectByRecordIDResponse:
		return soap_in_ns1__deleteDefectByRecordIDResponse(soap, NULL, NULL, "ns1:deleteDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteDefect:
		return soap_in_ns1__deleteDefect(soap, NULL, NULL, "ns1:deleteDefect");
	case SOAP_TYPE_ns1__deleteDefectResponse:
		return soap_in_ns1__deleteDefectResponse(soap, NULL, NULL, "ns1:deleteDefectResponse");
	case SOAP_TYPE_ns1__addDefectWithLink:
		return soap_in_ns1__addDefectWithLink(soap, NULL, NULL, "ns1:addDefectWithLink");
	case SOAP_TYPE_ns1__addDefectWithLinkResponse:
		return soap_in_ns1__addDefectWithLinkResponse(soap, NULL, NULL, "ns1:addDefectWithLinkResponse");
	case SOAP_TYPE_ns1__addDefect:
		return soap_in_ns1__addDefect(soap, NULL, NULL, "ns1:addDefect");
	case SOAP_TYPE_ns1__addDefectResponse:
		return soap_in_ns1__addDefectResponse(soap, NULL, NULL, "ns1:addDefectResponse");
	case SOAP_TYPE_ns1__getDefectByRecordID:
		return soap_in_ns1__getDefectByRecordID(soap, NULL, NULL, "ns1:getDefectByRecordID");
	case SOAP_TYPE_ns1__getDefectByRecordIDResponse:
		return soap_in_ns1__getDefectByRecordIDResponse(soap, NULL, NULL, "ns1:getDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__getDefect:
		return soap_in_ns1__getDefect(soap, NULL, NULL, "ns1:getDefect");
	case SOAP_TYPE_ns1__getDefectResponse:
		return soap_in_ns1__getDefectResponse(soap, NULL, NULL, "ns1:getDefectResponse");
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList:
		return soap_in_ns1__getDefectCustomFieldsDefinitionList(soap, NULL, NULL, "ns1:getDefectCustomFieldsDefinitionList");
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse:
		return soap_in_ns1__getDefectCustomFieldsDefinitionListResponse(soap, NULL, NULL, "ns1:getDefectCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionList:
		return soap_in_ns1__getCustomFieldsDefinitionList(soap, NULL, NULL, "ns1:getCustomFieldsDefinitionList");
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse:
		return soap_in_ns1__getCustomFieldsDefinitionListResponse(soap, NULL, NULL, "ns1:getCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_ns1__getDefectEventDefinitionList:
		return soap_in_ns1__getDefectEventDefinitionList(soap, NULL, NULL, "ns1:getDefectEventDefinitionList");
	case SOAP_TYPE_ns1__getDefectEventDefinitionListResponse:
		return soap_in_ns1__getDefectEventDefinitionListResponse(soap, NULL, NULL, "ns1:getDefectEventDefinitionListResponse");
	case SOAP_TYPE_ns1__getEventDefinitionList:
		return soap_in_ns1__getEventDefinitionList(soap, NULL, NULL, "ns1:getEventDefinitionList");
	case SOAP_TYPE_ns1__getEventDefinitionListResponse:
		return soap_in_ns1__getEventDefinitionListResponse(soap, NULL, NULL, "ns1:getEventDefinitionListResponse");
	case SOAP_TYPE_ns1__getReportRunResultsByRecordID:
		return soap_in_ns1__getReportRunResultsByRecordID(soap, NULL, NULL, "ns1:getReportRunResultsByRecordID");
	case SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse:
		return soap_in_ns1__getReportRunResultsByRecordIDResponse(soap, NULL, NULL, "ns1:getReportRunResultsByRecordIDResponse");
	case SOAP_TYPE_ns1__getReportRunResultsByName:
		return soap_in_ns1__getReportRunResultsByName(soap, NULL, NULL, "ns1:getReportRunResultsByName");
	case SOAP_TYPE_ns1__getReportRunResultsByNameResponse:
		return soap_in_ns1__getReportRunResultsByNameResponse(soap, NULL, NULL, "ns1:getReportRunResultsByNameResponse");
	case SOAP_TYPE_ns1__getAttachmentTypes:
		return soap_in_ns1__getAttachmentTypes(soap, NULL, NULL, "ns1:getAttachmentTypes");
	case SOAP_TYPE_ns1__getAttachmentTypesResponse:
		return soap_in_ns1__getAttachmentTypesResponse(soap, NULL, NULL, "ns1:getAttachmentTypesResponse");
	case SOAP_TYPE_ns1__cancelSaveTestConfig:
		return soap_in_ns1__cancelSaveTestConfig(soap, NULL, NULL, "ns1:cancelSaveTestConfig");
	case SOAP_TYPE_ns1__cancelSaveTestConfigResponse:
		return soap_in_ns1__cancelSaveTestConfigResponse(soap, NULL, NULL, "ns1:cancelSaveTestConfigResponse");
	case SOAP_TYPE_ns1__deleteTestConfigByRecordID:
		return soap_in_ns1__deleteTestConfigByRecordID(soap, NULL, NULL, "ns1:deleteTestConfigByRecordID");
	case SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse:
		return soap_in_ns1__deleteTestConfigByRecordIDResponse(soap, NULL, NULL, "ns1:deleteTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestConfig:
		return soap_in_ns1__deleteTestConfig(soap, NULL, NULL, "ns1:deleteTestConfig");
	case SOAP_TYPE_ns1__deleteTestConfigResponse:
		return soap_in_ns1__deleteTestConfigResponse(soap, NULL, NULL, "ns1:deleteTestConfigResponse");
	case SOAP_TYPE_ns1__saveTestConfig:
		return soap_in_ns1__saveTestConfig(soap, NULL, NULL, "ns1:saveTestConfig");
	case SOAP_TYPE_ns1__saveTestConfigResponse:
		return soap_in_ns1__saveTestConfigResponse(soap, NULL, NULL, "ns1:saveTestConfigResponse");
	case SOAP_TYPE_ns1__editTestConfigByRecordID:
		return soap_in_ns1__editTestConfigByRecordID(soap, NULL, NULL, "ns1:editTestConfigByRecordID");
	case SOAP_TYPE_ns1__editTestConfigByRecordIDResponse:
		return soap_in_ns1__editTestConfigByRecordIDResponse(soap, NULL, NULL, "ns1:editTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestConfig:
		return soap_in_ns1__editTestConfig(soap, NULL, NULL, "ns1:editTestConfig");
	case SOAP_TYPE_ns1__editTestConfigResponse:
		return soap_in_ns1__editTestConfigResponse(soap, NULL, NULL, "ns1:editTestConfigResponse");
	case SOAP_TYPE_ns1__addTestConfig:
		return soap_in_ns1__addTestConfig(soap, NULL, NULL, "ns1:addTestConfig");
	case SOAP_TYPE_ns1__addTestConfigResponse:
		return soap_in_ns1__addTestConfigResponse(soap, NULL, NULL, "ns1:addTestConfigResponse");
	case SOAP_TYPE_ns1__getTestConfigByRecordID:
		return soap_in_ns1__getTestConfigByRecordID(soap, NULL, NULL, "ns1:getTestConfigByRecordID");
	case SOAP_TYPE_ns1__getTestConfigByRecordIDResponse:
		return soap_in_ns1__getTestConfigByRecordIDResponse(soap, NULL, NULL, "ns1:getTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestConfig:
		return soap_in_ns1__getTestConfig(soap, NULL, NULL, "ns1:getTestConfig");
	case SOAP_TYPE_ns1__getTestConfigResponse:
		return soap_in_ns1__getTestConfigResponse(soap, NULL, NULL, "ns1:getTestConfigResponse");
	case SOAP_TYPE_ns1__getRecordListForTable:
		return soap_in_ns1__getRecordListForTable(soap, NULL, NULL, "ns1:getRecordListForTable");
	case SOAP_TYPE_ns1__getRecordListForTableResponse:
		return soap_in_ns1__getRecordListForTableResponse(soap, NULL, NULL, "ns1:getRecordListForTableResponse");
	case SOAP_TYPE_ns1__getFilterListForTable:
		return soap_in_ns1__getFilterListForTable(soap, NULL, NULL, "ns1:getFilterListForTable");
	case SOAP_TYPE_ns1__getFilterListForTableResponse:
		return soap_in_ns1__getFilterListForTableResponse(soap, NULL, NULL, "ns1:getFilterListForTableResponse");
	case SOAP_TYPE_ns1__getFilterList:
		return soap_in_ns1__getFilterList(soap, NULL, NULL, "ns1:getFilterList");
	case SOAP_TYPE_ns1__getFilterListResponse:
		return soap_in_ns1__getFilterListResponse(soap, NULL, NULL, "ns1:getFilterListResponse");
	case SOAP_TYPE_ns1__getColumnsForTable:
		return soap_in_ns1__getColumnsForTable(soap, NULL, NULL, "ns1:getColumnsForTable");
	case SOAP_TYPE_ns1__getColumnsForTableResponse:
		return soap_in_ns1__getColumnsForTableResponse(soap, NULL, NULL, "ns1:getColumnsForTableResponse");
	case SOAP_TYPE_ns1__GetLinkDefinitionValues:
		return soap_in_ns1__GetLinkDefinitionValues(soap, NULL, NULL, "ns1:GetLinkDefinitionValues");
	case SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse:
		return soap_in_ns1__GetLinkDefinitionValuesResponse(soap, NULL, NULL, "ns1:GetLinkDefinitionValuesResponse");
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTable:
		return soap_in_ns1__addDropdownFieldValuesForTable(soap, NULL, NULL, "ns1:addDropdownFieldValuesForTable");
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse:
		return soap_in_ns1__addDropdownFieldValuesForTableResponse(soap, NULL, NULL, "ns1:addDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTable:
		return soap_in_ns1__getDropdownFieldValuesForTable(soap, NULL, NULL, "ns1:getDropdownFieldValuesForTable");
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse:
		return soap_in_ns1__getDropdownFieldValuesForTableResponse(soap, NULL, NULL, "ns1:getDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_ns1__getDropdownFieldForTable:
		return soap_in_ns1__getDropdownFieldForTable(soap, NULL, NULL, "ns1:getDropdownFieldForTable");
	case SOAP_TYPE_ns1__getDropdownFieldForTableResponse:
		return soap_in_ns1__getDropdownFieldForTableResponse(soap, NULL, NULL, "ns1:getDropdownFieldForTableResponse");
	case SOAP_TYPE_ns1__getTableList:
		return soap_in_ns1__getTableList(soap, NULL, NULL, "ns1:getTableList");
	case SOAP_TYPE_ns1__getTableListResponse:
		return soap_in_ns1__getTableListResponse(soap, NULL, NULL, "ns1:getTableListResponse");
	case SOAP_TYPE_ns1__formattedTextSupport:
		return soap_in_ns1__formattedTextSupport(soap, NULL, NULL, "ns1:formattedTextSupport");
	case SOAP_TYPE_ns1__formattedTextSupportResponse:
		return soap_in_ns1__formattedTextSupportResponse(soap, NULL, NULL, "ns1:formattedTextSupportResponse");
	case SOAP_TYPE_ns1__DatabaseLogoff:
		return soap_in_ns1__DatabaseLogoff(soap, NULL, NULL, "ns1:DatabaseLogoff");
	case SOAP_TYPE_ns1__DatabaseLogoffResponse:
		return soap_in_ns1__DatabaseLogoffResponse(soap, NULL, NULL, "ns1:DatabaseLogoffResponse");
	case SOAP_TYPE_ns1__ProjectLogon:
		return soap_in_ns1__ProjectLogon(soap, NULL, NULL, "ns1:ProjectLogon");
	case SOAP_TYPE_ns1__ProjectLogonResponse:
		return soap_in_ns1__ProjectLogonResponse(soap, NULL, NULL, "ns1:ProjectLogonResponse");
	case SOAP_TYPE_ns1__DatabaseLogon:
		return soap_in_ns1__DatabaseLogon(soap, NULL, NULL, "ns1:DatabaseLogon");
	case SOAP_TYPE_ns1__DatabaseLogonResponse:
		return soap_in_ns1__DatabaseLogonResponse(soap, NULL, NULL, "ns1:DatabaseLogonResponse");
	case SOAP_TYPE_ns1__getProjectDataOptionList:
		return soap_in_ns1__getProjectDataOptionList(soap, NULL, NULL, "ns1:getProjectDataOptionList");
	case SOAP_TYPE_ns1__getProjectDataOptionListResponse:
		return soap_in_ns1__getProjectDataOptionListResponse(soap, NULL, NULL, "ns1:getProjectDataOptionListResponse");
	case SOAP_TYPE_ns1__getProjectList:
		return soap_in_ns1__getProjectList(soap, NULL, NULL, "ns1:getProjectList");
	case SOAP_TYPE_ns1__getProjectListResponse:
		return soap_in_ns1__getProjectListResponse(soap, NULL, NULL, "ns1:getProjectListResponse");
	case SOAP_TYPE_ns1__getDatabaseList:
		return soap_in_ns1__getDatabaseList(soap, NULL, NULL, "ns1:getDatabaseList");
	case SOAP_TYPE_ns1__getDatabaseListResponse:
		return soap_in_ns1__getDatabaseListResponse(soap, NULL, NULL, "ns1:getDatabaseListResponse");
	case SOAP_TYPE_PointerTons1__CItemHyperlinkContainer:
		return soap_in_PointerTons1__CItemHyperlinkContainer(soap, NULL, NULL, "ns1:CItemHyperlinkContainer");
	case SOAP_TYPE_PointerTons1__CRequirementDocument:
		return soap_in_PointerTons1__CRequirementDocument(soap, NULL, NULL, "ns1:CRequirementDocument");
	case SOAP_TYPE_PointerToArrayOflong:
		return soap_in_PointerToArrayOflong(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons1__CRequirement:
		return soap_in_PointerTons1__CRequirement(soap, NULL, NULL, "ns1:CRequirement");
	case SOAP_TYPE_PointerToArrayOfCFolder:
		return soap_in_PointerToArrayOfCFolder(soap, NULL, NULL, "ns1:CFolder");
	case SOAP_TYPE_PointerToArrayOfCFolderItem:
		return soap_in_PointerToArrayOfCFolderItem(soap, NULL, NULL, "ns1:CFolderItem");
	case SOAP_TYPE_PointerToArrayOfCFolderType:
		return soap_in_PointerToArrayOfCFolderType(soap, NULL, NULL, "ns1:CFolderType");
	case SOAP_TYPE_PointerToArrayOfCTestRunVariantField:
		return soap_in_PointerToArrayOfCTestRunVariantField(soap, NULL, NULL, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerToArrayOfCItemToTrack:
		return soap_in_PointerToArrayOfCItemToTrack(soap, NULL, NULL, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerTons1__CTestRun:
		return soap_in_PointerTons1__CTestRun(soap, NULL, NULL, "ns1:CTestRun");
	case SOAP_TYPE_PointerTons1__CTestCase:
		return soap_in_PointerTons1__CTestCase(soap, NULL, NULL, "ns1:CTestCase");
	case SOAP_TYPE_PointerToArrayOfCLink:
		return soap_in_PointerToArrayOfCLink(soap, NULL, NULL, "ns1:CLink");
	case SOAP_TYPE_PointerTons1__CUser:
		return soap_in_PointerTons1__CUser(soap, NULL, NULL, "ns1:CUser");
	case SOAP_TYPE_PointerToArrayOfCUserLicense:
		return soap_in_PointerToArrayOfCUserLicense(soap, NULL, NULL, "ns1:CUserLicense");
	case SOAP_TYPE_PointerToArrayOfCGlobalUser:
		return soap_in_PointerToArrayOfCGlobalUser(soap, NULL, NULL, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerTons1__CTask:
		return soap_in_PointerTons1__CTask(soap, NULL, NULL, "ns1:CTask");
	case SOAP_TYPE_PointerTons1__CDefect:
		return soap_in_PointerTons1__CDefect(soap, NULL, NULL, "ns1:CDefect");
	case SOAP_TYPE_PointerToArrayOfCDefectEventDefinition:
		return soap_in_PointerToArrayOfCDefectEventDefinition(soap, NULL, NULL, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToArrayOfCEventDefinition:
		return soap_in_PointerToArrayOfCEventDefinition(soap, NULL, NULL, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerTons1__CReportRunResults:
		return soap_in_PointerTons1__CReportRunResults(soap, NULL, NULL, "ns1:CReportRunResults");
	case SOAP_TYPE_PointerTons1__CRecordListSoap:
		return soap_in_PointerTons1__CRecordListSoap(soap, NULL, NULL, "ns1:CRecordListSoap");
	case SOAP_TYPE_PointerToArrayOfCFilter:
		return soap_in_PointerToArrayOfCFilter(soap, NULL, NULL, "ns1:CFilter");
	case SOAP_TYPE_PointerToArrayOfCTableField:
		return soap_in_PointerToArrayOfCTableField(soap, NULL, NULL, "ns1:CTableField");
	case SOAP_TYPE_PointerToArrayOfCDatabaseTable:
		return soap_in_PointerToArrayOfCDatabaseTable(soap, NULL, NULL, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerToArrayOfCProject:
		return soap_in_PointerToArrayOfCProject(soap, NULL, NULL, "ns1:CProject");
	case SOAP_TYPE_PointerToArrayOfCDatabase:
		return soap_in_PointerToArrayOfCDatabase(soap, NULL, NULL, "ns1:CDatabase");
	case SOAP_TYPE_PointerToArrayOfCSnapshotInfo:
		return soap_in_PointerToArrayOfCSnapshotInfo(soap, NULL, NULL, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerToArrayOfCVersionInfo:
		return soap_in_PointerToArrayOfCVersionInfo(soap, NULL, NULL, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerTons1__CScheduleInfo:
		return soap_in_PointerTons1__CScheduleInfo(soap, NULL, NULL, "ns1:CScheduleInfo");
	case SOAP_TYPE_PointerToArrayOfCTestCaseVariantField:
		return soap_in_PointerToArrayOfCTestCaseVariantField(soap, NULL, NULL, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToArrayOfCLinkHistoryItem:
		return soap_in_PointerToArrayOfCLinkHistoryItem(soap, NULL, NULL, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToArrayOfCLinkedItem:
		return soap_in_PointerToArrayOfCLinkedItem(soap, NULL, NULL, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		return soap_in_PointerTons1__PhoneNumber(soap, NULL, NULL, "ns1:PhoneNumber");
	case SOAP_TYPE_PointerToArrayOfCSCCFileRecord:
		return soap_in_PointerToArrayOfCSCCFileRecord(soap, NULL, NULL, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerToArrayOfCEvent:
		return soap_in_PointerToArrayOfCEvent(soap, NULL, NULL, "ns1:CEvent");
	case SOAP_TYPE_PointerToArrayOfCReportedByRecord:
		return soap_in_PointerToArrayOfCReportedByRecord(soap, NULL, NULL, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerToPointerTons1__CTreeNodeSoap:
		return soap_in_PointerToPointerTons1__CTreeNodeSoap(soap, NULL, NULL, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerTons1__CTreeNodeSoap:
		return soap_in_PointerTons1__CTreeNodeSoap(soap, NULL, NULL, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerToPointerTons1__CSnapshotInfo:
		return soap_in_PointerToPointerTons1__CSnapshotInfo(soap, NULL, NULL, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerTons1__CSnapshotInfo:
		return soap_in_PointerTons1__CSnapshotInfo(soap, NULL, NULL, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerToPointerTons1__CVersionInfo:
		return soap_in_PointerToPointerTons1__CVersionInfo(soap, NULL, NULL, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerTons1__CVersionInfo:
		return soap_in_PointerTons1__CVersionInfo(soap, NULL, NULL, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerToPointerTons1__CFolderItem:
		return soap_in_PointerToPointerTons1__CFolderItem(soap, NULL, NULL, "ns1:CFolderItem");
	case SOAP_TYPE_PointerTons1__CFolderItem:
		return soap_in_PointerTons1__CFolderItem(soap, NULL, NULL, "ns1:CFolderItem");
	case SOAP_TYPE_PointerToPointerTons1__CFolder:
		return soap_in_PointerToPointerTons1__CFolder(soap, NULL, NULL, "ns1:CFolder");
	case SOAP_TYPE_PointerTons1__CFolder:
		return soap_in_PointerTons1__CFolder(soap, NULL, NULL, "ns1:CFolder");
	case SOAP_TYPE_PointerToPointerTons1__CFolderType:
		return soap_in_PointerToPointerTons1__CFolderType(soap, NULL, NULL, "ns1:CFolderType");
	case SOAP_TYPE_PointerTons1__CFolderType:
		return soap_in_PointerTons1__CFolderType(soap, NULL, NULL, "ns1:CFolderType");
	case SOAP_TYPE_PointerToPointerTons1__CItemToTrack:
		return soap_in_PointerToPointerTons1__CItemToTrack(soap, NULL, NULL, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerTons1__CItemToTrack:
		return soap_in_PointerTons1__CItemToTrack(soap, NULL, NULL, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerToPointerTons1__CLink:
		return soap_in_PointerToPointerTons1__CLink(soap, NULL, NULL, "ns1:CLink");
	case SOAP_TYPE_PointerTons1__CLink:
		return soap_in_PointerTons1__CLink(soap, NULL, NULL, "ns1:CLink");
	case SOAP_TYPE_PointerToPointerTons1__CLinkHistoryItem:
		return soap_in_PointerToPointerTons1__CLinkHistoryItem(soap, NULL, NULL, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerTons1__CLinkHistoryItem:
		return soap_in_PointerTons1__CLinkHistoryItem(soap, NULL, NULL, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToPointerTons1__CLinkedItem:
		return soap_in_PointerToPointerTons1__CLinkedItem(soap, NULL, NULL, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerTons1__CLinkedItem:
		return soap_in_PointerTons1__CLinkedItem(soap, NULL, NULL, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerToPointerTons1__CUserLicense:
		return soap_in_PointerToPointerTons1__CUserLicense(soap, NULL, NULL, "ns1:CUserLicense");
	case SOAP_TYPE_PointerTons1__CUserLicense:
		return soap_in_PointerTons1__CUserLicense(soap, NULL, NULL, "ns1:CUserLicense");
	case SOAP_TYPE_PointerToPointerTons1__CGlobalUser:
		return soap_in_PointerToPointerTons1__CGlobalUser(soap, NULL, NULL, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerTons1__CGlobalUser:
		return soap_in_PointerTons1__CGlobalUser(soap, NULL, NULL, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerToPointerTons1__CDefectEventDefinition:
		return soap_in_PointerToPointerTons1__CDefectEventDefinition(soap, NULL, NULL, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerTons1__CDefectEventDefinition:
		return soap_in_PointerTons1__CDefectEventDefinition(soap, NULL, NULL, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToPointerTons1__CEventDefinition:
		return soap_in_PointerToPointerTons1__CEventDefinition(soap, NULL, NULL, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerTons1__CEventDefinition:
		return soap_in_PointerTons1__CEventDefinition(soap, NULL, NULL, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerToPointerTons1__CDefectEvent:
		return soap_in_PointerToPointerTons1__CDefectEvent(soap, NULL, NULL, "ns1:CDefectEvent");
	case SOAP_TYPE_PointerTons1__CDefectEvent:
		return soap_in_PointerTons1__CDefectEvent(soap, NULL, NULL, "ns1:CDefectEvent");
	case SOAP_TYPE_PointerToPointerTons1__CEvent:
		return soap_in_PointerToPointerTons1__CEvent(soap, NULL, NULL, "ns1:CEvent");
	case SOAP_TYPE_PointerTons1__CEvent:
		return soap_in_PointerTons1__CEvent(soap, NULL, NULL, "ns1:CEvent");
	case SOAP_TYPE_PointerToArrayOfstring:
		return soap_in_PointerToArrayOfstring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__CTestCaseVariantField:
		return soap_in_PointerToPointerTons1__CTestCaseVariantField(soap, NULL, NULL, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerTons1__CTestCaseVariantField:
		return soap_in_PointerTons1__CTestCaseVariantField(soap, NULL, NULL, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToPointerTons1__CTestRunVariantField:
		return soap_in_PointerToPointerTons1__CTestRunVariantField(soap, NULL, NULL, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerTons1__CTestRunVariantField:
		return soap_in_PointerTons1__CTestRunVariantField(soap, NULL, NULL, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerToPointerTons1__CField:
		return soap_in_PointerToPointerTons1__CField(soap, NULL, NULL, "ns1:CField");
	case SOAP_TYPE_PointerTons1__CField:
		return soap_in_PointerTons1__CField(soap, NULL, NULL, "ns1:CField");
	case SOAP_TYPE_PointerToPointerTons1__CReportedByRecord:
		return soap_in_PointerToPointerTons1__CReportedByRecord(soap, NULL, NULL, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerTons1__CReportedByRecord:
		return soap_in_PointerTons1__CReportedByRecord(soap, NULL, NULL, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerToshort:
		return soap_in_PointerToshort(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_PointerTons1__CSystem:
		return soap_in_PointerTons1__CSystem(soap, NULL, NULL, "ns1:CSystem");
	case SOAP_TYPE_PointerToArrayOfCFileAttachment:
		return soap_in_PointerToArrayOfCFileAttachment(soap, NULL, NULL, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerTons1__CFileAttachment:
		return soap_in_PointerToPointerTons1__CFileAttachment(soap, NULL, NULL, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerTons1__CFileAttachment:
		return soap_in_PointerTons1__CFileAttachment(soap, NULL, NULL, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerTons1__CFile:
		return soap_in_PointerToPointerTons1__CFile(soap, NULL, NULL, "ns1:CFile");
	case SOAP_TYPE_PointerTons1__CFile:
		return soap_in_PointerTons1__CFile(soap, NULL, NULL, "ns1:CFile");
	case SOAP_TYPE_PointerToPointerTons1__CSCCFileRecord:
		return soap_in_PointerToPointerTons1__CSCCFileRecord(soap, NULL, NULL, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerTons1__CSCCFileRecord:
		return soap_in_PointerTons1__CSCCFileRecord(soap, NULL, NULL, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons1__CRecordRowSoap:
		return soap_in_PointerToPointerTons1__CRecordRowSoap(soap, NULL, NULL, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerTons1__CRecordRowSoap:
		return soap_in_PointerTons1__CRecordRowSoap(soap, NULL, NULL, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerToPointerTons1__CRecordData:
		return soap_in_PointerToPointerTons1__CRecordData(soap, NULL, NULL, "ns1:CRecordData");
	case SOAP_TYPE_PointerTons1__CRecordData:
		return soap_in_PointerTons1__CRecordData(soap, NULL, NULL, "ns1:CRecordData");
	case SOAP_TYPE_PointerToPointerTons1__CFilter:
		return soap_in_PointerToPointerTons1__CFilter(soap, NULL, NULL, "ns1:CFilter");
	case SOAP_TYPE_PointerTons1__CFilter:
		return soap_in_PointerTons1__CFilter(soap, NULL, NULL, "ns1:CFilter");
	case SOAP_TYPE_PointerToPointerTons1__CTableColumn:
		return soap_in_PointerToPointerTons1__CTableColumn(soap, NULL, NULL, "ns1:CTableColumn");
	case SOAP_TYPE_PointerTons1__CTableColumn:
		return soap_in_PointerTons1__CTableColumn(soap, NULL, NULL, "ns1:CTableColumn");
	case SOAP_TYPE_PointerToPointerTons1__CFieldValue:
		return soap_in_PointerToPointerTons1__CFieldValue(soap, NULL, NULL, "ns1:CFieldValue");
	case SOAP_TYPE_PointerTons1__CFieldValue:
		return soap_in_PointerTons1__CFieldValue(soap, NULL, NULL, "ns1:CFieldValue");
	case SOAP_TYPE_PointerToPointerTons1__CTableField:
		return soap_in_PointerToPointerTons1__CTableField(soap, NULL, NULL, "ns1:CTableField");
	case SOAP_TYPE_PointerTons1__CTableField:
		return soap_in_PointerTons1__CTableField(soap, NULL, NULL, "ns1:CTableField");
	case SOAP_TYPE_PointerToPointerTons1__CDatabaseTable:
		return soap_in_PointerToPointerTons1__CDatabaseTable(soap, NULL, NULL, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerTons1__CDatabaseTable:
		return soap_in_PointerTons1__CDatabaseTable(soap, NULL, NULL, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerToPointerTons1__CProject:
		return soap_in_PointerToPointerTons1__CProject(soap, NULL, NULL, "ns1:CProject");
	case SOAP_TYPE_PointerTons1__CProject:
		return soap_in_PointerTons1__CProject(soap, NULL, NULL, "ns1:CProject");
	case SOAP_TYPE_PointerToPointerTons1__CProjectDataOption:
		return soap_in_PointerToPointerTons1__CProjectDataOption(soap, NULL, NULL, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerTons1__CProjectDataOption:
		return soap_in_PointerTons1__CProjectDataOption(soap, NULL, NULL, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerToPointerTons1__CDatabase:
		return soap_in_PointerToPointerTons1__CDatabase(soap, NULL, NULL, "ns1:CDatabase");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToArrayOfCTreeNodeSoap:
		return soap_in_PointerToArrayOfCTreeNodeSoap(soap, NULL, NULL, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerToLONG64:
		return soap_in_PointerToLONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToArrayOfCField:
		return soap_in_PointerToArrayOfCField(soap, NULL, NULL, "ns1:CField");
	case SOAP_TYPE_PointerToArrayOfCFieldValue:
		return soap_in_PointerToArrayOfCFieldValue(soap, NULL, NULL, "ns1:CFieldValue");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerToArrayOfCFile:
		return soap_in_PointerToArrayOfCFile(soap, NULL, NULL, "ns1:CFile");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerToArrayOfCRecordRowSoap:
		return soap_in_PointerToArrayOfCRecordRowSoap(soap, NULL, NULL, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerToArrayOfCTableColumn:
		return soap_in_PointerToArrayOfCTableColumn(soap, NULL, NULL, "ns1:CTableColumn");
	case SOAP_TYPE_PointerToArrayOfCRecordData:
		return soap_in_PointerToArrayOfCRecordData(soap, NULL, NULL, "ns1:CRecordData");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfCProjectDataOption:
		return soap_in_PointerToArrayOfCProjectDataOption(soap, NULL, NULL, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerTons1__CDatabase:
		return soap_in_PointerTons1__CDatabase(soap, NULL, NULL, "ns1:CDatabase");
	case SOAP_TYPE_xsd__date:
	{	char **s;
		s = soap_in_xsd__date(soap, NULL, NULL, "xsd:date");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CItemHyperlinkContainer"))
		{	*type = SOAP_TYPE_ns1__CItemHyperlinkContainer;
			return soap_in_ns1__CItemHyperlinkContainer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDocumentTreeNode"))
		{	*type = SOAP_TYPE_ns1__CDocumentTreeNode;
			return soap_in_ns1__CDocumentTreeNode(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTreeNodeSoap"))
		{	*type = SOAP_TYPE_ArrayOfCTreeNodeSoap;
			return soap_in_ArrayOfCTreeNodeSoap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTreeNodeSoap"))
		{	*type = SOAP_TYPE_ns1__CTreeNodeSoap;
			return soap_in_ns1__CTreeNodeSoap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__CRequirementDocument;
			return soap_in_ns1__CRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CRequirement"))
		{	*type = SOAP_TYPE_ns1__CRequirement;
			return soap_in_ns1__CRequirement(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CSnapshotInfo"))
		{	*type = SOAP_TYPE_ArrayOfCSnapshotInfo;
			return soap_in_ArrayOfCSnapshotInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CSnapshotInfo"))
		{	*type = SOAP_TYPE_ns1__CSnapshotInfo;
			return soap_in_ns1__CSnapshotInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CVersionInfo"))
		{	*type = SOAP_TYPE_ArrayOfCVersionInfo;
			return soap_in_ArrayOfCVersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CVersionInfo"))
		{	*type = SOAP_TYPE_ns1__CVersionInfo;
			return soap_in_ns1__CVersionInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFolderItem"))
		{	*type = SOAP_TYPE_ArrayOfCFolderItem;
			return soap_in_ArrayOfCFolderItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFolder"))
		{	*type = SOAP_TYPE_ArrayOfCFolder;
			return soap_in_ArrayOfCFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFolderItem"))
		{	*type = SOAP_TYPE_ns1__CFolderItem;
			return soap_in_ns1__CFolderItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFolder"))
		{	*type = SOAP_TYPE_ns1__CFolder;
			return soap_in_ns1__CFolder(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFolderType"))
		{	*type = SOAP_TYPE_ArrayOfCFolderType;
			return soap_in_ArrayOfCFolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFolderType"))
		{	*type = SOAP_TYPE_ns1__CFolderType;
			return soap_in_ns1__CFolderType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CScheduleInfo"))
		{	*type = SOAP_TYPE_ns1__CScheduleInfo;
			return soap_in_ns1__CScheduleInfo(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CItemToTrack"))
		{	*type = SOAP_TYPE_ArrayOfCItemToTrack;
			return soap_in_ArrayOfCItemToTrack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTestRun"))
		{	*type = SOAP_TYPE_ns1__CTestRun;
			return soap_in_ns1__CTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTestCase"))
		{	*type = SOAP_TYPE_ns1__CTestCase;
			return soap_in_ns1__CTestCase(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CLink"))
		{	*type = SOAP_TYPE_ArrayOfCLink;
			return soap_in_ArrayOfCLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CLink"))
		{	*type = SOAP_TYPE_ns1__CLink;
			return soap_in_ns1__CLink(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CLinkHistoryItem"))
		{	*type = SOAP_TYPE_ArrayOfCLinkHistoryItem;
			return soap_in_ArrayOfCLinkHistoryItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CLinkHistoryItem"))
		{	*type = SOAP_TYPE_ns1__CLinkHistoryItem;
			return soap_in_ns1__CLinkHistoryItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CLinkedItem"))
		{	*type = SOAP_TYPE_ArrayOfCLinkedItem;
			return soap_in_ArrayOfCLinkedItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CLinkedItem"))
		{	*type = SOAP_TYPE_ns1__CLinkedItem;
			return soap_in_ns1__CLinkedItem(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CUserLicense"))
		{	*type = SOAP_TYPE_ArrayOfCUserLicense;
			return soap_in_ArrayOfCUserLicense(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CUserLicense"))
		{	*type = SOAP_TYPE_ns1__CUserLicense;
			return soap_in_ns1__CUserLicense(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CGlobalUser"))
		{	*type = SOAP_TYPE_ArrayOfCGlobalUser;
			return soap_in_ArrayOfCGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CGlobalUser"))
		{	*type = SOAP_TYPE_ns1__CGlobalUser;
			return soap_in_ns1__CGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CUser"))
		{	*type = SOAP_TYPE_ns1__CUser;
			return soap_in_ns1__CUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PhoneNumber"))
		{	*type = SOAP_TYPE_ns1__PhoneNumber;
			return soap_in_ns1__PhoneNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTask"))
		{	*type = SOAP_TYPE_ns1__CTask;
			return soap_in_ns1__CTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDefect"))
		{	*type = SOAP_TYPE_ns1__CDefect;
			return soap_in_ns1__CDefect(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CDefectEventDefinition"))
		{	*type = SOAP_TYPE_ArrayOfCDefectEventDefinition;
			return soap_in_ArrayOfCDefectEventDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDefectEventDefinition"))
		{	*type = SOAP_TYPE_ns1__CDefectEventDefinition;
			return soap_in_ns1__CDefectEventDefinition(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CEventDefinition"))
		{	*type = SOAP_TYPE_ArrayOfCEventDefinition;
			return soap_in_ArrayOfCEventDefinition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CEventDefinition"))
		{	*type = SOAP_TYPE_ns1__CEventDefinition;
			return soap_in_ns1__CEventDefinition(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CDefectEvent"))
		{	*type = SOAP_TYPE_ArrayOfCDefectEvent;
			return soap_in_ArrayOfCDefectEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDefectEvent"))
		{	*type = SOAP_TYPE_ns1__CDefectEvent;
			return soap_in_ns1__CDefectEvent(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CEvent"))
		{	*type = SOAP_TYPE_ArrayOfCEvent;
			return soap_in_ArrayOfCEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CEvent"))
		{	*type = SOAP_TYPE_ns1__CEvent;
			return soap_in_ns1__CEvent(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTestCaseVariantField"))
		{	*type = SOAP_TYPE_ArrayOfCTestCaseVariantField;
			return soap_in_ArrayOfCTestCaseVariantField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTestRunVariantField"))
		{	*type = SOAP_TYPE_ArrayOfCTestRunVariantField;
			return soap_in_ArrayOfCTestRunVariantField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CField"))
		{	*type = SOAP_TYPE_ArrayOfCField;
			return soap_in_ArrayOfCField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTimespanField"))
		{	*type = SOAP_TYPE_ns1__CTimespanField;
			return soap_in_ns1__CTimespanField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CVersionField"))
		{	*type = SOAP_TYPE_ns1__CVersionField;
			return soap_in_ns1__CVersionField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTestCaseVariantField"))
		{	*type = SOAP_TYPE_ns1__CTestCaseVariantField;
			return soap_in_ns1__CTestCaseVariantField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTestRunVariantField"))
		{	*type = SOAP_TYPE_ns1__CTestRunVariantField;
			return soap_in_ns1__CTestRunVariantField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CMultiSelectDropdownField"))
		{	*type = SOAP_TYPE_ns1__CMultiSelectDropdownField;
			return soap_in_ns1__CMultiSelectDropdownField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDropdownField"))
		{	*type = SOAP_TYPE_ns1__CDropdownField;
			return soap_in_ns1__CDropdownField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDateTimeField"))
		{	*type = SOAP_TYPE_ns1__CDateTimeField;
			return soap_in_ns1__CDateTimeField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDateField"))
		{	*type = SOAP_TYPE_ns1__CDateField;
			return soap_in_ns1__CDateField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CBooleanField"))
		{	*type = SOAP_TYPE_ns1__CBooleanField;
			return soap_in_ns1__CBooleanField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDecimalField"))
		{	*type = SOAP_TYPE_ns1__CDecimalField;
			return soap_in_ns1__CDecimalField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CIntegerField"))
		{	*type = SOAP_TYPE_ns1__CIntegerField;
			return soap_in_ns1__CIntegerField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CStringField"))
		{	*type = SOAP_TYPE_ns1__CStringField;
			return soap_in_ns1__CStringField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CField"))
		{	*type = SOAP_TYPE_ns1__CField;
			return soap_in_ns1__CField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CReportedByRecord"))
		{	*type = SOAP_TYPE_ArrayOfCReportedByRecord;
			return soap_in_ArrayOfCReportedByRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CReportedByRecord"))
		{	*type = SOAP_TYPE_ns1__CReportedByRecord;
			return soap_in_ns1__CReportedByRecord(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFileAttachment"))
		{	*type = SOAP_TYPE_ArrayOfCFileAttachment;
			return soap_in_ArrayOfCFileAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFileAttachment"))
		{	*type = SOAP_TYPE_ns1__CFileAttachment;
			return soap_in_ns1__CFileAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CReportRunResults"))
		{	*type = SOAP_TYPE_ns1__CReportRunResults;
			return soap_in_ns1__CReportRunResults(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFile"))
		{	*type = SOAP_TYPE_ArrayOfCFile;
			return soap_in_ArrayOfCFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFile"))
		{	*type = SOAP_TYPE_ns1__CFile;
			return soap_in_ns1__CFile(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CSCCFileRecord"))
		{	*type = SOAP_TYPE_ArrayOfCSCCFileRecord;
			return soap_in_ArrayOfCSCCFileRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CSCCFileRecord"))
		{	*type = SOAP_TYPE_ns1__CSCCFileRecord;
			return soap_in_ns1__CSCCFileRecord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CSystem"))
		{	*type = SOAP_TYPE_ns1__CSystem;
			return soap_in_ns1__CSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CSystemBase"))
		{	*type = SOAP_TYPE_ns1__CSystemBase;
			return soap_in_ns1__CSystemBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:COrderedItemWithDBRecordId"))
		{	*type = SOAP_TYPE_ns1__COrderedItemWithDBRecordId;
			return soap_in_ns1__COrderedItemWithDBRecordId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CItemToTrack"))
		{	*type = SOAP_TYPE_ns1__CItemToTrack;
			return soap_in_ns1__CItemToTrack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CItemWithDBRecordId"))
		{	*type = SOAP_TYPE_ns1__CItemWithDBRecordId;
			return soap_in_ns1__CItemWithDBRecordId(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CRecordListSoap"))
		{	*type = SOAP_TYPE_ns1__CRecordListSoap;
			return soap_in_ns1__CRecordListSoap(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CRecordRowSoap"))
		{	*type = SOAP_TYPE_ArrayOfCRecordRowSoap;
			return soap_in_ArrayOfCRecordRowSoap(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CRecordRowSoap"))
		{	*type = SOAP_TYPE_ns1__CRecordRowSoap;
			return soap_in_ns1__CRecordRowSoap(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CRecordData"))
		{	*type = SOAP_TYPE_ArrayOfCRecordData;
			return soap_in_ArrayOfCRecordData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CRecordData"))
		{	*type = SOAP_TYPE_ns1__CRecordData;
			return soap_in_ns1__CRecordData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFilter"))
		{	*type = SOAP_TYPE_ArrayOfCFilter;
			return soap_in_ArrayOfCFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFilter"))
		{	*type = SOAP_TYPE_ns1__CFilter;
			return soap_in_ns1__CFilter(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTableColumn"))
		{	*type = SOAP_TYPE_ArrayOfCTableColumn;
			return soap_in_ArrayOfCTableColumn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTableColumn"))
		{	*type = SOAP_TYPE_ns1__CTableColumn;
			return soap_in_ns1__CTableColumn(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CFieldValue"))
		{	*type = SOAP_TYPE_ArrayOfCFieldValue;
			return soap_in_ArrayOfCFieldValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CFieldValue"))
		{	*type = SOAP_TYPE_ns1__CFieldValue;
			return soap_in_ns1__CFieldValue(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTableField"))
		{	*type = SOAP_TYPE_ArrayOfCTableField;
			return soap_in_ArrayOfCTableField(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTableField"))
		{	*type = SOAP_TYPE_ns1__CTableField;
			return soap_in_ns1__CTableField(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CDatabaseTable"))
		{	*type = SOAP_TYPE_ArrayOfCDatabaseTable;
			return soap_in_ArrayOfCDatabaseTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDatabaseTable"))
		{	*type = SOAP_TYPE_ns1__CDatabaseTable;
			return soap_in_ns1__CDatabaseTable(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CProject"))
		{	*type = SOAP_TYPE_ArrayOfCProject;
			return soap_in_ArrayOfCProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CProject"))
		{	*type = SOAP_TYPE_ns1__CProject;
			return soap_in_ns1__CProject(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CProjectDataOption"))
		{	*type = SOAP_TYPE_ArrayOfCProjectDataOption;
			return soap_in_ArrayOfCProjectDataOption(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CProjectDataOption"))
		{	*type = SOAP_TYPE_ns1__CProjectDataOption;
			return soap_in_ns1__CProjectDataOption(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CDatabase"))
		{	*type = SOAP_TYPE_ArrayOfCDatabase;
			return soap_in_ArrayOfCDatabase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CDatabase"))
		{	*type = SOAP_TYPE_ns1__CDatabase;
			return soap_in_ns1__CDatabase(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:long"))
		{	*type = SOAP_TYPE_ArrayOflong;
			return soap_in_ArrayOflong(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOfstring;
			return soap_in_ArrayOfstring(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemHyperlinks"))
		{	*type = SOAP_TYPE_ns1__getItemHyperlinks;
			return soap_in_ns1__getItemHyperlinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getItemHyperlinksResponse"))
		{	*type = SOAP_TYPE_ns1__getItemHyperlinksResponse;
			return soap_in_ns1__getItemHyperlinksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTree"))
		{	*type = SOAP_TYPE_ns1__getFolderTree;
			return soap_in_ns1__getFolderTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTreeResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderTreeResponse;
			return soap_in_ns1__getFolderTreeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTreeByRecordID"))
		{	*type = SOAP_TYPE_ns1__getFolderTreeByRecordID;
			return soap_in_ns1__getFolderTreeByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTreeByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse;
			return soap_in_ns1__getFolderTreeByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocumentTree"))
		{	*type = SOAP_TYPE_ns1__getDocumentTree;
			return soap_in_ns1__getDocumentTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocumentTreeResponse"))
		{	*type = SOAP_TYPE_ns1__getDocumentTreeResponse;
			return soap_in_ns1__getDocumentTreeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementIDsForDocument"))
		{	*type = SOAP_TYPE_ns1__getRequirementIDsForDocument;
			return soap_in_ns1__getRequirementIDsForDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementIDsForDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse;
			return soap_in_ns1__getRequirementIDsForDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createSnapshot"))
		{	*type = SOAP_TYPE_ns1__createSnapshot;
			return soap_in_ns1__createSnapshot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createSnapshotResponse"))
		{	*type = SOAP_TYPE_ns1__createSnapshotResponse;
			return soap_in_ns1__createSnapshotResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__cancelSaveRequirementDocument;
			return soap_in_ns1__cancelSaveRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse;
			return soap_in_ns1__cancelSaveRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__saveRequirementDocument;
			return soap_in_ns1__saveRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__saveRequirementDocumentResponse;
			return soap_in_ns1__saveRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementDocumentByRecordID"))
		{	*type = SOAP_TYPE_ns1__editRequirementDocumentByRecordID;
			return soap_in_ns1__editRequirementDocumentByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementDocumentByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse;
			return soap_in_ns1__editRequirementDocumentByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__editRequirementDocument;
			return soap_in_ns1__editRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__editRequirementDocumentResponse;
			return soap_in_ns1__editRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementDocumentByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID;
			return soap_in_ns1__deleteRequirementDocumentByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementDocumentByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse;
			return soap_in_ns1__deleteRequirementDocumentByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementDocument;
			return soap_in_ns1__deleteRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementDocumentResponse;
			return soap_in_ns1__deleteRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__addRequirementDocument;
			return soap_in_ns1__addRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__addRequirementDocumentResponse;
			return soap_in_ns1__addRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementDocumentByRecordID"))
		{	*type = SOAP_TYPE_ns1__getRequirementDocumentByRecordID;
			return soap_in_ns1__getRequirementDocumentByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementDocumentByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse;
			return soap_in_ns1__getRequirementDocumentByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__getRequirementDocument;
			return soap_in_ns1__getRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__getRequirementDocumentResponse;
			return soap_in_ns1__getRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changeRequirementType"))
		{	*type = SOAP_TYPE_ns1__changeRequirementType;
			return soap_in_ns1__changeRequirementType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:changeRequirementTypeResponse"))
		{	*type = SOAP_TYPE_ns1__changeRequirementTypeResponse;
			return soap_in_ns1__changeRequirementTypeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocumentIDsForRequirement"))
		{	*type = SOAP_TYPE_ns1__getDocumentIDsForRequirement;
			return soap_in_ns1__getDocumentIDsForRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocumentIDsForRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse;
			return soap_in_ns1__getDocumentIDsForRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:appendToRequirementDocument"))
		{	*type = SOAP_TYPE_ns1__appendToRequirementDocument;
			return soap_in_ns1__appendToRequirementDocument(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:appendToRequirementDocumentResponse"))
		{	*type = SOAP_TYPE_ns1__appendToRequirementDocumentResponse;
			return soap_in_ns1__appendToRequirementDocumentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveRequirement"))
		{	*type = SOAP_TYPE_ns1__cancelSaveRequirement;
			return soap_in_ns1__cancelSaveRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveRequirementResponse;
			return soap_in_ns1__cancelSaveRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveRequirement"))
		{	*type = SOAP_TYPE_ns1__saveRequirement;
			return soap_in_ns1__saveRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__saveRequirementResponse;
			return soap_in_ns1__saveRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementByRecordID"))
		{	*type = SOAP_TYPE_ns1__editRequirementByRecordID;
			return soap_in_ns1__editRequirementByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editRequirementByRecordIDResponse;
			return soap_in_ns1__editRequirementByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirement"))
		{	*type = SOAP_TYPE_ns1__editRequirement;
			return soap_in_ns1__editRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__editRequirementResponse;
			return soap_in_ns1__editRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementByRecordID;
			return soap_in_ns1__deleteRequirementByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse;
			return soap_in_ns1__deleteRequirementByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirement"))
		{	*type = SOAP_TYPE_ns1__deleteRequirement;
			return soap_in_ns1__deleteRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__deleteRequirementResponse;
			return soap_in_ns1__deleteRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addRequirement"))
		{	*type = SOAP_TYPE_ns1__addRequirement;
			return soap_in_ns1__addRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__addRequirementResponse;
			return soap_in_ns1__addRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementByRecordID"))
		{	*type = SOAP_TYPE_ns1__getRequirementByRecordID;
			return soap_in_ns1__getRequirementByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getRequirementByRecordIDResponse;
			return soap_in_ns1__getRequirementByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirement"))
		{	*type = SOAP_TYPE_ns1__getRequirement;
			return soap_in_ns1__getRequirement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRequirementResponse"))
		{	*type = SOAP_TYPE_ns1__getRequirementResponse;
			return soap_in_ns1__getRequirementResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveFolderItemRank"))
		{	*type = SOAP_TYPE_ns1__cancelSaveFolderItemRank;
			return soap_in_ns1__cancelSaveFolderItemRank(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveFolderItemRankResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse;
			return soap_in_ns1__cancelSaveFolderItemRankResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveFolderItemRank"))
		{	*type = SOAP_TYPE_ns1__saveFolderItemRank;
			return soap_in_ns1__saveFolderItemRank(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveFolderItemRankResponse"))
		{	*type = SOAP_TYPE_ns1__saveFolderItemRankResponse;
			return soap_in_ns1__saveFolderItemRankResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolderItemRank"))
		{	*type = SOAP_TYPE_ns1__editFolderItemRank;
			return soap_in_ns1__editFolderItemRank(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolderItemRankResponse"))
		{	*type = SOAP_TYPE_ns1__editFolderItemRankResponse;
			return soap_in_ns1__editFolderItemRankResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootPrivateFolderPath"))
		{	*type = SOAP_TYPE_ns1__getRootPrivateFolderPath;
			return soap_in_ns1__getRootPrivateFolderPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootPrivateFolderPathResponse"))
		{	*type = SOAP_TYPE_ns1__getRootPrivateFolderPathResponse;
			return soap_in_ns1__getRootPrivateFolderPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootPublicFolderPath"))
		{	*type = SOAP_TYPE_ns1__getRootPublicFolderPath;
			return soap_in_ns1__getRootPublicFolderPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRootPublicFolderPathResponse"))
		{	*type = SOAP_TYPE_ns1__getRootPublicFolderPathResponse;
			return soap_in_ns1__getRootPublicFolderPathResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderPathSeparator"))
		{	*type = SOAP_TYPE_ns1__getFolderPathSeparator;
			return soap_in_ns1__getFolderPathSeparator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderPathSeparatorResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderPathSeparatorResponse;
			return soap_in_ns1__getFolderPathSeparatorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderListForEntityByRecordID"))
		{	*type = SOAP_TYPE_ns1__getFolderListForEntityByRecordID;
			return soap_in_ns1__getFolderListForEntityByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderListForEntityByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse;
			return soap_in_ns1__getFolderListForEntityByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityListForFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__getEntityListForFolderByRecordID;
			return soap_in_ns1__getEntityListForFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityListForFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse;
			return soap_in_ns1__getEntityListForFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntityFromFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__removeEntityFromFolderByRecordID;
			return soap_in_ns1__removeEntityFromFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntityFromFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse;
			return soap_in_ns1__removeEntityFromFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addEntityToFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__addEntityToFolderByRecordID;
			return soap_in_ns1__addEntityToFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addEntityToFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse;
			return soap_in_ns1__addEntityToFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteFolderByRecordID;
			return soap_in_ns1__deleteFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteFolderByRecordIDResponse;
			return soap_in_ns1__deleteFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteFolder"))
		{	*type = SOAP_TYPE_ns1__deleteFolder;
			return soap_in_ns1__deleteFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteFolderResponse"))
		{	*type = SOAP_TYPE_ns1__deleteFolderResponse;
			return soap_in_ns1__deleteFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__getFolderByRecordID;
			return soap_in_ns1__getFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderByRecordIDResponse;
			return soap_in_ns1__getFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolder"))
		{	*type = SOAP_TYPE_ns1__getFolder;
			return soap_in_ns1__getFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderResponse;
			return soap_in_ns1__getFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveFolder"))
		{	*type = SOAP_TYPE_ns1__cancelSaveFolder;
			return soap_in_ns1__cancelSaveFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveFolderResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveFolderResponse;
			return soap_in_ns1__cancelSaveFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveFolder"))
		{	*type = SOAP_TYPE_ns1__saveFolder;
			return soap_in_ns1__saveFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveFolderResponse"))
		{	*type = SOAP_TYPE_ns1__saveFolderResponse;
			return soap_in_ns1__saveFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolderByRecordID"))
		{	*type = SOAP_TYPE_ns1__editFolderByRecordID;
			return soap_in_ns1__editFolderByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolderByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editFolderByRecordIDResponse;
			return soap_in_ns1__editFolderByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolder"))
		{	*type = SOAP_TYPE_ns1__editFolder;
			return soap_in_ns1__editFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editFolderResponse"))
		{	*type = SOAP_TYPE_ns1__editFolderResponse;
			return soap_in_ns1__editFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addFolder"))
		{	*type = SOAP_TYPE_ns1__addFolder;
			return soap_in_ns1__addFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addFolderResponse"))
		{	*type = SOAP_TYPE_ns1__addFolderResponse;
			return soap_in_ns1__addFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTypeList"))
		{	*type = SOAP_TYPE_ns1__getFolderTypeList;
			return soap_in_ns1__getFolderTypeList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTypeListResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderTypeListResponse;
			return soap_in_ns1__getFolderTypeListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTypeByName"))
		{	*type = SOAP_TYPE_ns1__getFolderTypeByName;
			return soap_in_ns1__getFolderTypeByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderTypeByNameResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderTypeByNameResponse;
			return soap_in_ns1__getFolderTypeByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:generateTestRuns"))
		{	*type = SOAP_TYPE_ns1__generateTestRuns;
			return soap_in_ns1__generateTestRuns(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:generateTestRunsResponse"))
		{	*type = SOAP_TYPE_ns1__generateTestRunsResponse;
			return soap_in_ns1__generateTestRunsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDefectForTestRun"))
		{	*type = SOAP_TYPE_ns1__createDefectForTestRun;
			return soap_in_ns1__createDefectForTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:createDefectForTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__createDefectForTestRunResponse;
			return soap_in_ns1__createDefectForTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestRun"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestRun;
			return soap_in_ns1__cancelSaveTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestRunResponse;
			return soap_in_ns1__cancelSaveTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestRun"))
		{	*type = SOAP_TYPE_ns1__saveTestRun;
			return soap_in_ns1__saveTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__saveTestRunResponse;
			return soap_in_ns1__saveTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestRunByRecordID"))
		{	*type = SOAP_TYPE_ns1__editTestRunByRecordID;
			return soap_in_ns1__editTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editTestRunByRecordIDResponse;
			return soap_in_ns1__editTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestRun"))
		{	*type = SOAP_TYPE_ns1__editTestRun;
			return soap_in_ns1__editTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__editTestRunResponse;
			return soap_in_ns1__editTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestRunByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteTestRunByRecordID;
			return soap_in_ns1__deleteTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse;
			return soap_in_ns1__deleteTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestRun"))
		{	*type = SOAP_TYPE_ns1__deleteTestRun;
			return soap_in_ns1__deleteTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestRunResponse;
			return soap_in_ns1__deleteTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRunByRecordID"))
		{	*type = SOAP_TYPE_ns1__getTestRunByRecordID;
			return soap_in_ns1__getTestRunByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRunByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getTestRunByRecordIDResponse;
			return soap_in_ns1__getTestRunByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRun"))
		{	*type = SOAP_TYPE_ns1__getTestRun;
			return soap_in_ns1__getTestRun(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRunResponse"))
		{	*type = SOAP_TYPE_ns1__getTestRunResponse;
			return soap_in_ns1__getTestRunResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestCase"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestCase;
			return soap_in_ns1__cancelSaveTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestCaseResponse;
			return soap_in_ns1__cancelSaveTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestCase"))
		{	*type = SOAP_TYPE_ns1__saveTestCase;
			return soap_in_ns1__saveTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__saveTestCaseResponse;
			return soap_in_ns1__saveTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestCaseByRecordID"))
		{	*type = SOAP_TYPE_ns1__editTestCaseByRecordID;
			return soap_in_ns1__editTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editTestCaseByRecordIDResponse;
			return soap_in_ns1__editTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestCase"))
		{	*type = SOAP_TYPE_ns1__editTestCase;
			return soap_in_ns1__editTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__editTestCaseResponse;
			return soap_in_ns1__editTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestCaseByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteTestCaseByRecordID;
			return soap_in_ns1__deleteTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse;
			return soap_in_ns1__deleteTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestCase"))
		{	*type = SOAP_TYPE_ns1__deleteTestCase;
			return soap_in_ns1__deleteTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestCaseResponse;
			return soap_in_ns1__deleteTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTestCase"))
		{	*type = SOAP_TYPE_ns1__addTestCase;
			return soap_in_ns1__addTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__addTestCaseResponse;
			return soap_in_ns1__addTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestCaseByRecordID"))
		{	*type = SOAP_TYPE_ns1__getTestCaseByRecordID;
			return soap_in_ns1__getTestCaseByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestCaseByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getTestCaseByRecordIDResponse;
			return soap_in_ns1__getTestCaseByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestCase"))
		{	*type = SOAP_TYPE_ns1__getTestCase;
			return soap_in_ns1__getTestCase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestCaseResponse"))
		{	*type = SOAP_TYPE_ns1__getTestCaseResponse;
			return soap_in_ns1__getTestCaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRunStepsModes"))
		{	*type = SOAP_TYPE_ns1__getTestRunStepsModes;
			return soap_in_ns1__getTestRunStepsModes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestRunStepsModesResponse"))
		{	*type = SOAP_TYPE_ns1__getTestRunStepsModesResponse;
			return soap_in_ns1__getTestRunStepsModesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestVariantTypes"))
		{	*type = SOAP_TYPE_ns1__getTestVariantTypes;
			return soap_in_ns1__getTestVariantTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestVariantTypesResponse"))
		{	*type = SOAP_TYPE_ns1__getTestVariantTypesResponse;
			return soap_in_ns1__getTestVariantTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveLink"))
		{	*type = SOAP_TYPE_ns1__cancelSaveLink;
			return soap_in_ns1__cancelSaveLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveLinkResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveLinkResponse;
			return soap_in_ns1__cancelSaveLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveLink"))
		{	*type = SOAP_TYPE_ns1__saveLink;
			return soap_in_ns1__saveLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveLinkResponse"))
		{	*type = SOAP_TYPE_ns1__saveLinkResponse;
			return soap_in_ns1__saveLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLink"))
		{	*type = SOAP_TYPE_ns1__editLink;
			return soap_in_ns1__editLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editLinkResponse"))
		{	*type = SOAP_TYPE_ns1__editLinkResponse;
			return soap_in_ns1__editLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteLink"))
		{	*type = SOAP_TYPE_ns1__deleteLink;
			return soap_in_ns1__deleteLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteLinkResponse"))
		{	*type = SOAP_TYPE_ns1__deleteLinkResponse;
			return soap_in_ns1__deleteLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLink"))
		{	*type = SOAP_TYPE_ns1__addLink;
			return soap_in_ns1__addLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addLinkResponse"))
		{	*type = SOAP_TYPE_ns1__addLinkResponse;
			return soap_in_ns1__addLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLink"))
		{	*type = SOAP_TYPE_ns1__getLink;
			return soap_in_ns1__getLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLinkResponse"))
		{	*type = SOAP_TYPE_ns1__getLinkResponse;
			return soap_in_ns1__getLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLinksForDefect"))
		{	*type = SOAP_TYPE_ns1__getLinksForDefect;
			return soap_in_ns1__getLinksForDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLinksForDefectResponse"))
		{	*type = SOAP_TYPE_ns1__getLinksForDefectResponse;
			return soap_in_ns1__getLinksForDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLinksForItem"))
		{	*type = SOAP_TYPE_ns1__getLinksForItem;
			return soap_in_ns1__getLinksForItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLinksForItemResponse"))
		{	*type = SOAP_TYPE_ns1__getLinksForItemResponse;
			return soap_in_ns1__getLinksForItemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addGlobalCustomer"))
		{	*type = SOAP_TYPE_ns1__addGlobalCustomer;
			return soap_in_ns1__addGlobalCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addGlobalCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__addGlobalCustomerResponse;
			return soap_in_ns1__addGlobalCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:promoteCustomer"))
		{	*type = SOAP_TYPE_ns1__promoteCustomer;
			return soap_in_ns1__promoteCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:promoteCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__promoteCustomerResponse;
			return soap_in_ns1__promoteCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveCustomer"))
		{	*type = SOAP_TYPE_ns1__cancelSaveCustomer;
			return soap_in_ns1__cancelSaveCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveCustomerResponse;
			return soap_in_ns1__cancelSaveCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteCustomerByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteCustomerByRecordID;
			return soap_in_ns1__deleteCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse;
			return soap_in_ns1__deleteCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteCustomer"))
		{	*type = SOAP_TYPE_ns1__deleteCustomer;
			return soap_in_ns1__deleteCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__deleteCustomerResponse;
			return soap_in_ns1__deleteCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveCustomer"))
		{	*type = SOAP_TYPE_ns1__saveCustomer;
			return soap_in_ns1__saveCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__saveCustomerResponse;
			return soap_in_ns1__saveCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editCustomerByRecordID"))
		{	*type = SOAP_TYPE_ns1__editCustomerByRecordID;
			return soap_in_ns1__editCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editCustomerByRecordIDResponse;
			return soap_in_ns1__editCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editCustomer"))
		{	*type = SOAP_TYPE_ns1__editCustomer;
			return soap_in_ns1__editCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__editCustomerResponse;
			return soap_in_ns1__editCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCustomer"))
		{	*type = SOAP_TYPE_ns1__addCustomer;
			return soap_in_ns1__addCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__addCustomerResponse;
			return soap_in_ns1__addCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomerByRecordID"))
		{	*type = SOAP_TYPE_ns1__getCustomerByRecordID;
			return soap_in_ns1__getCustomerByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomerByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getCustomerByRecordIDResponse;
			return soap_in_ns1__getCustomerByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomer"))
		{	*type = SOAP_TYPE_ns1__getCustomer;
			return soap_in_ns1__getCustomer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomerResponse"))
		{	*type = SOAP_TYPE_ns1__getCustomerResponse;
			return soap_in_ns1__getCustomerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addGlobalUser"))
		{	*type = SOAP_TYPE_ns1__addGlobalUser;
			return soap_in_ns1__addGlobalUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addGlobalUserResponse"))
		{	*type = SOAP_TYPE_ns1__addGlobalUserResponse;
			return soap_in_ns1__addGlobalUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:promoteUser"))
		{	*type = SOAP_TYPE_ns1__promoteUser;
			return soap_in_ns1__promoteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:promoteUserResponse"))
		{	*type = SOAP_TYPE_ns1__promoteUserResponse;
			return soap_in_ns1__promoteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveUser"))
		{	*type = SOAP_TYPE_ns1__cancelSaveUser;
			return soap_in_ns1__cancelSaveUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveUserResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveUserResponse;
			return soap_in_ns1__cancelSaveUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUserByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteUserByRecordID;
			return soap_in_ns1__deleteUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteUserByRecordIDResponse;
			return soap_in_ns1__deleteUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUser"))
		{	*type = SOAP_TYPE_ns1__deleteUser;
			return soap_in_ns1__deleteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteUserResponse"))
		{	*type = SOAP_TYPE_ns1__deleteUserResponse;
			return soap_in_ns1__deleteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUser"))
		{	*type = SOAP_TYPE_ns1__saveUser;
			return soap_in_ns1__saveUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveUserResponse"))
		{	*type = SOAP_TYPE_ns1__saveUserResponse;
			return soap_in_ns1__saveUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserByRecordID"))
		{	*type = SOAP_TYPE_ns1__editUserByRecordID;
			return soap_in_ns1__editUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editUserByRecordIDResponse;
			return soap_in_ns1__editUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUser"))
		{	*type = SOAP_TYPE_ns1__editUser;
			return soap_in_ns1__editUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editUserResponse"))
		{	*type = SOAP_TYPE_ns1__editUserResponse;
			return soap_in_ns1__editUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addUser"))
		{	*type = SOAP_TYPE_ns1__addUser;
			return soap_in_ns1__addUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addUserResponse"))
		{	*type = SOAP_TYPE_ns1__addUserResponse;
			return soap_in_ns1__addUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserForCurrentSession"))
		{	*type = SOAP_TYPE_ns1__getUserForCurrentSession;
			return soap_in_ns1__getUserForCurrentSession(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserForCurrentSessionResponse"))
		{	*type = SOAP_TYPE_ns1__getUserForCurrentSessionResponse;
			return soap_in_ns1__getUserForCurrentSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserByRecordID"))
		{	*type = SOAP_TYPE_ns1__getUserByRecordID;
			return soap_in_ns1__getUserByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getUserByRecordIDResponse;
			return soap_in_ns1__getUserByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUser"))
		{	*type = SOAP_TYPE_ns1__getUser;
			return soap_in_ns1__getUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserResponse"))
		{	*type = SOAP_TYPE_ns1__getUserResponse;
			return soap_in_ns1__getUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserLicenseList"))
		{	*type = SOAP_TYPE_ns1__getUserLicenseList;
			return soap_in_ns1__getUserLicenseList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getUserLicenseListResponse"))
		{	*type = SOAP_TYPE_ns1__getUserLicenseListResponse;
			return soap_in_ns1__getUserLicenseListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalCustomerList"))
		{	*type = SOAP_TYPE_ns1__getGlobalCustomerList;
			return soap_in_ns1__getGlobalCustomerList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalCustomerListResponse"))
		{	*type = SOAP_TYPE_ns1__getGlobalCustomerListResponse;
			return soap_in_ns1__getGlobalCustomerListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalUserList"))
		{	*type = SOAP_TYPE_ns1__getGlobalUserList;
			return soap_in_ns1__getGlobalUserList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalUserListResponse"))
		{	*type = SOAP_TYPE_ns1__getGlobalUserListResponse;
			return soap_in_ns1__getGlobalUserListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTask"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTask;
			return soap_in_ns1__cancelSaveTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTaskResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTaskResponse;
			return soap_in_ns1__cancelSaveTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTask"))
		{	*type = SOAP_TYPE_ns1__saveTask;
			return soap_in_ns1__saveTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTaskResponse"))
		{	*type = SOAP_TYPE_ns1__saveTaskResponse;
			return soap_in_ns1__saveTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTaskByRecordID"))
		{	*type = SOAP_TYPE_ns1__editTaskByRecordID;
			return soap_in_ns1__editTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editTaskByRecordIDResponse;
			return soap_in_ns1__editTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTask"))
		{	*type = SOAP_TYPE_ns1__editTask;
			return soap_in_ns1__editTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTaskResponse"))
		{	*type = SOAP_TYPE_ns1__editTaskResponse;
			return soap_in_ns1__editTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTaskByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteTaskByRecordID;
			return soap_in_ns1__deleteTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTaskByRecordIDResponse;
			return soap_in_ns1__deleteTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTask"))
		{	*type = SOAP_TYPE_ns1__deleteTask;
			return soap_in_ns1__deleteTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTaskResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTaskResponse;
			return soap_in_ns1__deleteTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTask"))
		{	*type = SOAP_TYPE_ns1__addTask;
			return soap_in_ns1__addTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTaskResponse"))
		{	*type = SOAP_TYPE_ns1__addTaskResponse;
			return soap_in_ns1__addTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskByRecordID"))
		{	*type = SOAP_TYPE_ns1__getTaskByRecordID;
			return soap_in_ns1__getTaskByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getTaskByRecordIDResponse;
			return soap_in_ns1__getTaskByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTask"))
		{	*type = SOAP_TYPE_ns1__getTask;
			return soap_in_ns1__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskResponse"))
		{	*type = SOAP_TYPE_ns1__getTaskResponse;
			return soap_in_ns1__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectAttachment"))
		{	*type = SOAP_TYPE_ns1__getDefectAttachment;
			return soap_in_ns1__getDefectAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectAttachmentResponse"))
		{	*type = SOAP_TYPE_ns1__getDefectAttachmentResponse;
			return soap_in_ns1__getDefectAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachment"))
		{	*type = SOAP_TYPE_ns1__getAttachment;
			return soap_in_ns1__getAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachmentResponse"))
		{	*type = SOAP_TYPE_ns1__getAttachmentResponse;
			return soap_in_ns1__getAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveDefect"))
		{	*type = SOAP_TYPE_ns1__cancelSaveDefect;
			return soap_in_ns1__cancelSaveDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveDefectResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveDefectResponse;
			return soap_in_ns1__cancelSaveDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveDefect"))
		{	*type = SOAP_TYPE_ns1__saveDefect;
			return soap_in_ns1__saveDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveDefectResponse"))
		{	*type = SOAP_TYPE_ns1__saveDefectResponse;
			return soap_in_ns1__saveDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDefectByRecordID"))
		{	*type = SOAP_TYPE_ns1__editDefectByRecordID;
			return soap_in_ns1__editDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editDefectByRecordIDResponse;
			return soap_in_ns1__editDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDefect"))
		{	*type = SOAP_TYPE_ns1__editDefect;
			return soap_in_ns1__editDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editDefectResponse"))
		{	*type = SOAP_TYPE_ns1__editDefectResponse;
			return soap_in_ns1__editDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDefectByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteDefectByRecordID;
			return soap_in_ns1__deleteDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDefectByRecordIDResponse;
			return soap_in_ns1__deleteDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDefect"))
		{	*type = SOAP_TYPE_ns1__deleteDefect;
			return soap_in_ns1__deleteDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteDefectResponse"))
		{	*type = SOAP_TYPE_ns1__deleteDefectResponse;
			return soap_in_ns1__deleteDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDefectWithLink"))
		{	*type = SOAP_TYPE_ns1__addDefectWithLink;
			return soap_in_ns1__addDefectWithLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDefectWithLinkResponse"))
		{	*type = SOAP_TYPE_ns1__addDefectWithLinkResponse;
			return soap_in_ns1__addDefectWithLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDefect"))
		{	*type = SOAP_TYPE_ns1__addDefect;
			return soap_in_ns1__addDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDefectResponse"))
		{	*type = SOAP_TYPE_ns1__addDefectResponse;
			return soap_in_ns1__addDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectByRecordID"))
		{	*type = SOAP_TYPE_ns1__getDefectByRecordID;
			return soap_in_ns1__getDefectByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getDefectByRecordIDResponse;
			return soap_in_ns1__getDefectByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefect"))
		{	*type = SOAP_TYPE_ns1__getDefect;
			return soap_in_ns1__getDefect(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectResponse"))
		{	*type = SOAP_TYPE_ns1__getDefectResponse;
			return soap_in_ns1__getDefectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectCustomFieldsDefinitionList"))
		{	*type = SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList;
			return soap_in_ns1__getDefectCustomFieldsDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectCustomFieldsDefinitionListResponse"))
		{	*type = SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse;
			return soap_in_ns1__getDefectCustomFieldsDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomFieldsDefinitionList"))
		{	*type = SOAP_TYPE_ns1__getCustomFieldsDefinitionList;
			return soap_in_ns1__getCustomFieldsDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomFieldsDefinitionListResponse"))
		{	*type = SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse;
			return soap_in_ns1__getCustomFieldsDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectEventDefinitionList"))
		{	*type = SOAP_TYPE_ns1__getDefectEventDefinitionList;
			return soap_in_ns1__getDefectEventDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDefectEventDefinitionListResponse"))
		{	*type = SOAP_TYPE_ns1__getDefectEventDefinitionListResponse;
			return soap_in_ns1__getDefectEventDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventDefinitionList"))
		{	*type = SOAP_TYPE_ns1__getEventDefinitionList;
			return soap_in_ns1__getEventDefinitionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventDefinitionListResponse"))
		{	*type = SOAP_TYPE_ns1__getEventDefinitionListResponse;
			return soap_in_ns1__getEventDefinitionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReportRunResultsByRecordID"))
		{	*type = SOAP_TYPE_ns1__getReportRunResultsByRecordID;
			return soap_in_ns1__getReportRunResultsByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReportRunResultsByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse;
			return soap_in_ns1__getReportRunResultsByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReportRunResultsByName"))
		{	*type = SOAP_TYPE_ns1__getReportRunResultsByName;
			return soap_in_ns1__getReportRunResultsByName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getReportRunResultsByNameResponse"))
		{	*type = SOAP_TYPE_ns1__getReportRunResultsByNameResponse;
			return soap_in_ns1__getReportRunResultsByNameResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachmentTypes"))
		{	*type = SOAP_TYPE_ns1__getAttachmentTypes;
			return soap_in_ns1__getAttachmentTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAttachmentTypesResponse"))
		{	*type = SOAP_TYPE_ns1__getAttachmentTypesResponse;
			return soap_in_ns1__getAttachmentTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestConfig"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestConfig;
			return soap_in_ns1__cancelSaveTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cancelSaveTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__cancelSaveTestConfigResponse;
			return soap_in_ns1__cancelSaveTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestConfigByRecordID"))
		{	*type = SOAP_TYPE_ns1__deleteTestConfigByRecordID;
			return soap_in_ns1__deleteTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse;
			return soap_in_ns1__deleteTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestConfig"))
		{	*type = SOAP_TYPE_ns1__deleteTestConfig;
			return soap_in_ns1__deleteTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__deleteTestConfigResponse;
			return soap_in_ns1__deleteTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestConfig"))
		{	*type = SOAP_TYPE_ns1__saveTestConfig;
			return soap_in_ns1__saveTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__saveTestConfigResponse;
			return soap_in_ns1__saveTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestConfigByRecordID"))
		{	*type = SOAP_TYPE_ns1__editTestConfigByRecordID;
			return soap_in_ns1__editTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__editTestConfigByRecordIDResponse;
			return soap_in_ns1__editTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestConfig"))
		{	*type = SOAP_TYPE_ns1__editTestConfig;
			return soap_in_ns1__editTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:editTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__editTestConfigResponse;
			return soap_in_ns1__editTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTestConfig"))
		{	*type = SOAP_TYPE_ns1__addTestConfig;
			return soap_in_ns1__addTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__addTestConfigResponse;
			return soap_in_ns1__addTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestConfigByRecordID"))
		{	*type = SOAP_TYPE_ns1__getTestConfigByRecordID;
			return soap_in_ns1__getTestConfigByRecordID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestConfigByRecordIDResponse"))
		{	*type = SOAP_TYPE_ns1__getTestConfigByRecordIDResponse;
			return soap_in_ns1__getTestConfigByRecordIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestConfig"))
		{	*type = SOAP_TYPE_ns1__getTestConfig;
			return soap_in_ns1__getTestConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTestConfigResponse"))
		{	*type = SOAP_TYPE_ns1__getTestConfigResponse;
			return soap_in_ns1__getTestConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRecordListForTable"))
		{	*type = SOAP_TYPE_ns1__getRecordListForTable;
			return soap_in_ns1__getRecordListForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getRecordListForTableResponse"))
		{	*type = SOAP_TYPE_ns1__getRecordListForTableResponse;
			return soap_in_ns1__getRecordListForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFilterListForTable"))
		{	*type = SOAP_TYPE_ns1__getFilterListForTable;
			return soap_in_ns1__getFilterListForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFilterListForTableResponse"))
		{	*type = SOAP_TYPE_ns1__getFilterListForTableResponse;
			return soap_in_ns1__getFilterListForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFilterList"))
		{	*type = SOAP_TYPE_ns1__getFilterList;
			return soap_in_ns1__getFilterList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFilterListResponse"))
		{	*type = SOAP_TYPE_ns1__getFilterListResponse;
			return soap_in_ns1__getFilterListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getColumnsForTable"))
		{	*type = SOAP_TYPE_ns1__getColumnsForTable;
			return soap_in_ns1__getColumnsForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getColumnsForTableResponse"))
		{	*type = SOAP_TYPE_ns1__getColumnsForTableResponse;
			return soap_in_ns1__getColumnsForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkDefinitionValues"))
		{	*type = SOAP_TYPE_ns1__GetLinkDefinitionValues;
			return soap_in_ns1__GetLinkDefinitionValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLinkDefinitionValuesResponse"))
		{	*type = SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse;
			return soap_in_ns1__GetLinkDefinitionValuesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDropdownFieldValuesForTable"))
		{	*type = SOAP_TYPE_ns1__addDropdownFieldValuesForTable;
			return soap_in_ns1__addDropdownFieldValuesForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDropdownFieldValuesForTableResponse"))
		{	*type = SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse;
			return soap_in_ns1__addDropdownFieldValuesForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDropdownFieldValuesForTable"))
		{	*type = SOAP_TYPE_ns1__getDropdownFieldValuesForTable;
			return soap_in_ns1__getDropdownFieldValuesForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDropdownFieldValuesForTableResponse"))
		{	*type = SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse;
			return soap_in_ns1__getDropdownFieldValuesForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDropdownFieldForTable"))
		{	*type = SOAP_TYPE_ns1__getDropdownFieldForTable;
			return soap_in_ns1__getDropdownFieldForTable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDropdownFieldForTableResponse"))
		{	*type = SOAP_TYPE_ns1__getDropdownFieldForTableResponse;
			return soap_in_ns1__getDropdownFieldForTableResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTableList"))
		{	*type = SOAP_TYPE_ns1__getTableList;
			return soap_in_ns1__getTableList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTableListResponse"))
		{	*type = SOAP_TYPE_ns1__getTableListResponse;
			return soap_in_ns1__getTableListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:formattedTextSupport"))
		{	*type = SOAP_TYPE_ns1__formattedTextSupport;
			return soap_in_ns1__formattedTextSupport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:formattedTextSupportResponse"))
		{	*type = SOAP_TYPE_ns1__formattedTextSupportResponse;
			return soap_in_ns1__formattedTextSupportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DatabaseLogoff"))
		{	*type = SOAP_TYPE_ns1__DatabaseLogoff;
			return soap_in_ns1__DatabaseLogoff(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DatabaseLogoffResponse"))
		{	*type = SOAP_TYPE_ns1__DatabaseLogoffResponse;
			return soap_in_ns1__DatabaseLogoffResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProjectLogon"))
		{	*type = SOAP_TYPE_ns1__ProjectLogon;
			return soap_in_ns1__ProjectLogon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ProjectLogonResponse"))
		{	*type = SOAP_TYPE_ns1__ProjectLogonResponse;
			return soap_in_ns1__ProjectLogonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DatabaseLogon"))
		{	*type = SOAP_TYPE_ns1__DatabaseLogon;
			return soap_in_ns1__DatabaseLogon(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DatabaseLogonResponse"))
		{	*type = SOAP_TYPE_ns1__DatabaseLogonResponse;
			return soap_in_ns1__DatabaseLogonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProjectDataOptionList"))
		{	*type = SOAP_TYPE_ns1__getProjectDataOptionList;
			return soap_in_ns1__getProjectDataOptionList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProjectDataOptionListResponse"))
		{	*type = SOAP_TYPE_ns1__getProjectDataOptionListResponse;
			return soap_in_ns1__getProjectDataOptionListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProjectList"))
		{	*type = SOAP_TYPE_ns1__getProjectList;
			return soap_in_ns1__getProjectList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getProjectListResponse"))
		{	*type = SOAP_TYPE_ns1__getProjectListResponse;
			return soap_in_ns1__getProjectListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatabaseList"))
		{	*type = SOAP_TYPE_ns1__getDatabaseList;
			return soap_in_ns1__getDatabaseList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDatabaseListResponse"))
		{	*type = SOAP_TYPE_ns1__getDatabaseListResponse;
			return soap_in_ns1__getDatabaseListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:date"))
		{	char **s;
			*type = SOAP_TYPE_xsd__date;
			s = soap_in_xsd__date(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__CItemHyperlinkContainer:
		return ((ns1__CItemHyperlinkContainer *)ptr)->soap_out(soap, tag, id, "ns1:CItemHyperlinkContainer");
	case SOAP_TYPE_ns1__CDocumentTreeNode:
		return ((ns1__CDocumentTreeNode *)ptr)->soap_out(soap, tag, id, "ns1:CDocumentTreeNode");
	case SOAP_TYPE_ArrayOfCTreeNodeSoap:
		return ((ArrayOfCTreeNodeSoap *)ptr)->soap_out(soap, tag, id, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_ns1__CTreeNodeSoap:
		return ((ns1__CTreeNodeSoap *)ptr)->soap_out(soap, tag, id, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_ns1__CRequirementDocument:
		return ((ns1__CRequirementDocument *)ptr)->soap_out(soap, tag, id, "ns1:CRequirementDocument");
	case SOAP_TYPE_ns1__CRequirement:
		return ((ns1__CRequirement *)ptr)->soap_out(soap, tag, id, "ns1:CRequirement");
	case SOAP_TYPE_ArrayOfCSnapshotInfo:
		return ((ArrayOfCSnapshotInfo *)ptr)->soap_out(soap, tag, id, "ns1:CSnapshotInfo");
	case SOAP_TYPE_ns1__CSnapshotInfo:
		return ((ns1__CSnapshotInfo *)ptr)->soap_out(soap, tag, id, "ns1:CSnapshotInfo");
	case SOAP_TYPE_ArrayOfCVersionInfo:
		return ((ArrayOfCVersionInfo *)ptr)->soap_out(soap, tag, id, "ns1:CVersionInfo");
	case SOAP_TYPE_ns1__CVersionInfo:
		return ((ns1__CVersionInfo *)ptr)->soap_out(soap, tag, id, "ns1:CVersionInfo");
	case SOAP_TYPE_ArrayOfCFolderItem:
		return ((ArrayOfCFolderItem *)ptr)->soap_out(soap, tag, id, "ns1:CFolderItem");
	case SOAP_TYPE_ArrayOfCFolder:
		return ((ArrayOfCFolder *)ptr)->soap_out(soap, tag, id, "ns1:CFolder");
	case SOAP_TYPE_ns1__CFolderItem:
		return ((ns1__CFolderItem *)ptr)->soap_out(soap, tag, id, "ns1:CFolderItem");
	case SOAP_TYPE_ns1__CFolder:
		return ((ns1__CFolder *)ptr)->soap_out(soap, tag, id, "ns1:CFolder");
	case SOAP_TYPE_ArrayOfCFolderType:
		return ((ArrayOfCFolderType *)ptr)->soap_out(soap, tag, id, "ns1:CFolderType");
	case SOAP_TYPE_ns1__CFolderType:
		return ((ns1__CFolderType *)ptr)->soap_out(soap, tag, id, "ns1:CFolderType");
	case SOAP_TYPE_ns1__CScheduleInfo:
		return ((ns1__CScheduleInfo *)ptr)->soap_out(soap, tag, id, "ns1:CScheduleInfo");
	case SOAP_TYPE_ArrayOfCItemToTrack:
		return ((ArrayOfCItemToTrack *)ptr)->soap_out(soap, tag, id, "ns1:CItemToTrack");
	case SOAP_TYPE_ns1__CTestRun:
		return ((ns1__CTestRun *)ptr)->soap_out(soap, tag, id, "ns1:CTestRun");
	case SOAP_TYPE_ns1__CTestCase:
		return ((ns1__CTestCase *)ptr)->soap_out(soap, tag, id, "ns1:CTestCase");
	case SOAP_TYPE_ArrayOfCLink:
		return ((ArrayOfCLink *)ptr)->soap_out(soap, tag, id, "ns1:CLink");
	case SOAP_TYPE_ns1__CLink:
		return ((ns1__CLink *)ptr)->soap_out(soap, tag, id, "ns1:CLink");
	case SOAP_TYPE_ArrayOfCLinkHistoryItem:
		return ((ArrayOfCLinkHistoryItem *)ptr)->soap_out(soap, tag, id, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_ns1__CLinkHistoryItem:
		return ((ns1__CLinkHistoryItem *)ptr)->soap_out(soap, tag, id, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_ArrayOfCLinkedItem:
		return ((ArrayOfCLinkedItem *)ptr)->soap_out(soap, tag, id, "ns1:CLinkedItem");
	case SOAP_TYPE_ns1__CLinkedItem:
		return ((ns1__CLinkedItem *)ptr)->soap_out(soap, tag, id, "ns1:CLinkedItem");
	case SOAP_TYPE_ArrayOfCUserLicense:
		return ((ArrayOfCUserLicense *)ptr)->soap_out(soap, tag, id, "ns1:CUserLicense");
	case SOAP_TYPE_ns1__CUserLicense:
		return ((ns1__CUserLicense *)ptr)->soap_out(soap, tag, id, "ns1:CUserLicense");
	case SOAP_TYPE_ArrayOfCGlobalUser:
		return ((ArrayOfCGlobalUser *)ptr)->soap_out(soap, tag, id, "ns1:CGlobalUser");
	case SOAP_TYPE_ns1__CGlobalUser:
		return ((ns1__CGlobalUser *)ptr)->soap_out(soap, tag, id, "ns1:CGlobalUser");
	case SOAP_TYPE_ns1__CUser:
		return ((ns1__CUser *)ptr)->soap_out(soap, tag, id, "ns1:CUser");
	case SOAP_TYPE_ns1__PhoneNumber:
		return ((ns1__PhoneNumber *)ptr)->soap_out(soap, tag, id, "ns1:PhoneNumber");
	case SOAP_TYPE_ns1__CTask:
		return ((ns1__CTask *)ptr)->soap_out(soap, tag, id, "ns1:CTask");
	case SOAP_TYPE_ns1__CDefect:
		return ((ns1__CDefect *)ptr)->soap_out(soap, tag, id, "ns1:CDefect");
	case SOAP_TYPE_ArrayOfCDefectEventDefinition:
		return ((ArrayOfCDefectEventDefinition *)ptr)->soap_out(soap, tag, id, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_ns1__CDefectEventDefinition:
		return ((ns1__CDefectEventDefinition *)ptr)->soap_out(soap, tag, id, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_ArrayOfCEventDefinition:
		return ((ArrayOfCEventDefinition *)ptr)->soap_out(soap, tag, id, "ns1:CEventDefinition");
	case SOAP_TYPE_ns1__CEventDefinition:
		return ((ns1__CEventDefinition *)ptr)->soap_out(soap, tag, id, "ns1:CEventDefinition");
	case SOAP_TYPE_ArrayOfCDefectEvent:
		return ((ArrayOfCDefectEvent *)ptr)->soap_out(soap, tag, id, "ns1:CDefectEvent");
	case SOAP_TYPE_ns1__CDefectEvent:
		return ((ns1__CDefectEvent *)ptr)->soap_out(soap, tag, id, "ns1:CDefectEvent");
	case SOAP_TYPE_ArrayOfCEvent:
		return ((ArrayOfCEvent *)ptr)->soap_out(soap, tag, id, "ns1:CEvent");
	case SOAP_TYPE_ns1__CEvent:
		return ((ns1__CEvent *)ptr)->soap_out(soap, tag, id, "ns1:CEvent");
	case SOAP_TYPE_ArrayOfCTestCaseVariantField:
		return ((ArrayOfCTestCaseVariantField *)ptr)->soap_out(soap, tag, id, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_ArrayOfCTestRunVariantField:
		return ((ArrayOfCTestRunVariantField *)ptr)->soap_out(soap, tag, id, "ns1:CTestRunVariantField");
	case SOAP_TYPE_ArrayOfCField:
		return ((ArrayOfCField *)ptr)->soap_out(soap, tag, id, "ns1:CField");
	case SOAP_TYPE_ns1__CTimespanField:
		return ((ns1__CTimespanField *)ptr)->soap_out(soap, tag, id, "ns1:CTimespanField");
	case SOAP_TYPE_ns1__CVersionField:
		return ((ns1__CVersionField *)ptr)->soap_out(soap, tag, id, "ns1:CVersionField");
	case SOAP_TYPE_ns1__CTestCaseVariantField:
		return ((ns1__CTestCaseVariantField *)ptr)->soap_out(soap, tag, id, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_ns1__CTestRunVariantField:
		return ((ns1__CTestRunVariantField *)ptr)->soap_out(soap, tag, id, "ns1:CTestRunVariantField");
	case SOAP_TYPE_ns1__CMultiSelectDropdownField:
		return ((ns1__CMultiSelectDropdownField *)ptr)->soap_out(soap, tag, id, "ns1:CMultiSelectDropdownField");
	case SOAP_TYPE_ns1__CDropdownField:
		return ((ns1__CDropdownField *)ptr)->soap_out(soap, tag, id, "ns1:CDropdownField");
	case SOAP_TYPE_ns1__CDateTimeField:
		return ((ns1__CDateTimeField *)ptr)->soap_out(soap, tag, id, "ns1:CDateTimeField");
	case SOAP_TYPE_ns1__CDateField:
		return ((ns1__CDateField *)ptr)->soap_out(soap, tag, id, "ns1:CDateField");
	case SOAP_TYPE_ns1__CBooleanField:
		return ((ns1__CBooleanField *)ptr)->soap_out(soap, tag, id, "ns1:CBooleanField");
	case SOAP_TYPE_ns1__CDecimalField:
		return ((ns1__CDecimalField *)ptr)->soap_out(soap, tag, id, "ns1:CDecimalField");
	case SOAP_TYPE_ns1__CIntegerField:
		return ((ns1__CIntegerField *)ptr)->soap_out(soap, tag, id, "ns1:CIntegerField");
	case SOAP_TYPE_ns1__CStringField:
		return ((ns1__CStringField *)ptr)->soap_out(soap, tag, id, "ns1:CStringField");
	case SOAP_TYPE_ns1__CField:
		return ((ns1__CField *)ptr)->soap_out(soap, tag, id, "ns1:CField");
	case SOAP_TYPE_ArrayOfCReportedByRecord:
		return ((ArrayOfCReportedByRecord *)ptr)->soap_out(soap, tag, id, "ns1:CReportedByRecord");
	case SOAP_TYPE_ns1__CReportedByRecord:
		return ((ns1__CReportedByRecord *)ptr)->soap_out(soap, tag, id, "ns1:CReportedByRecord");
	case SOAP_TYPE_ArrayOfCFileAttachment:
		return ((ArrayOfCFileAttachment *)ptr)->soap_out(soap, tag, id, "ns1:CFileAttachment");
	case SOAP_TYPE_ns1__CFileAttachment:
		return ((ns1__CFileAttachment *)ptr)->soap_out(soap, tag, id, "ns1:CFileAttachment");
	case SOAP_TYPE_ns1__CReportRunResults:
		return ((ns1__CReportRunResults *)ptr)->soap_out(soap, tag, id, "ns1:CReportRunResults");
	case SOAP_TYPE_ArrayOfCFile:
		return ((ArrayOfCFile *)ptr)->soap_out(soap, tag, id, "ns1:CFile");
	case SOAP_TYPE_ns1__CFile:
		return ((ns1__CFile *)ptr)->soap_out(soap, tag, id, "ns1:CFile");
	case SOAP_TYPE_ArrayOfCSCCFileRecord:
		return ((ArrayOfCSCCFileRecord *)ptr)->soap_out(soap, tag, id, "ns1:CSCCFileRecord");
	case SOAP_TYPE_ns1__CSCCFileRecord:
		return ((ns1__CSCCFileRecord *)ptr)->soap_out(soap, tag, id, "ns1:CSCCFileRecord");
	case SOAP_TYPE_ns1__CSystem:
		return ((ns1__CSystem *)ptr)->soap_out(soap, tag, id, "ns1:CSystem");
	case SOAP_TYPE_ns1__CSystemBase:
		return ((ns1__CSystemBase *)ptr)->soap_out(soap, tag, id, "ns1:CSystemBase");
	case SOAP_TYPE_ns1__COrderedItemWithDBRecordId:
		return ((ns1__COrderedItemWithDBRecordId *)ptr)->soap_out(soap, tag, id, "ns1:COrderedItemWithDBRecordId");
	case SOAP_TYPE_ns1__CItemToTrack:
		return ((ns1__CItemToTrack *)ptr)->soap_out(soap, tag, id, "ns1:CItemToTrack");
	case SOAP_TYPE_ns1__CItemWithDBRecordId:
		return ((ns1__CItemWithDBRecordId *)ptr)->soap_out(soap, tag, id, "ns1:CItemWithDBRecordId");
	case SOAP_TYPE_ns1__CRecordListSoap:
		return ((ns1__CRecordListSoap *)ptr)->soap_out(soap, tag, id, "ns1:CRecordListSoap");
	case SOAP_TYPE_ArrayOfCRecordRowSoap:
		return ((ArrayOfCRecordRowSoap *)ptr)->soap_out(soap, tag, id, "ns1:CRecordRowSoap");
	case SOAP_TYPE_ns1__CRecordRowSoap:
		return ((ns1__CRecordRowSoap *)ptr)->soap_out(soap, tag, id, "ns1:CRecordRowSoap");
	case SOAP_TYPE_ArrayOfCRecordData:
		return ((ArrayOfCRecordData *)ptr)->soap_out(soap, tag, id, "ns1:CRecordData");
	case SOAP_TYPE_ns1__CRecordData:
		return ((ns1__CRecordData *)ptr)->soap_out(soap, tag, id, "ns1:CRecordData");
	case SOAP_TYPE_ArrayOfCFilter:
		return ((ArrayOfCFilter *)ptr)->soap_out(soap, tag, id, "ns1:CFilter");
	case SOAP_TYPE_ns1__CFilter:
		return ((ns1__CFilter *)ptr)->soap_out(soap, tag, id, "ns1:CFilter");
	case SOAP_TYPE_ArrayOfCTableColumn:
		return ((ArrayOfCTableColumn *)ptr)->soap_out(soap, tag, id, "ns1:CTableColumn");
	case SOAP_TYPE_ns1__CTableColumn:
		return ((ns1__CTableColumn *)ptr)->soap_out(soap, tag, id, "ns1:CTableColumn");
	case SOAP_TYPE_ArrayOfCFieldValue:
		return ((ArrayOfCFieldValue *)ptr)->soap_out(soap, tag, id, "ns1:CFieldValue");
	case SOAP_TYPE_ns1__CFieldValue:
		return ((ns1__CFieldValue *)ptr)->soap_out(soap, tag, id, "ns1:CFieldValue");
	case SOAP_TYPE_ArrayOfCTableField:
		return ((ArrayOfCTableField *)ptr)->soap_out(soap, tag, id, "ns1:CTableField");
	case SOAP_TYPE_ns1__CTableField:
		return ((ns1__CTableField *)ptr)->soap_out(soap, tag, id, "ns1:CTableField");
	case SOAP_TYPE_ArrayOfCDatabaseTable:
		return ((ArrayOfCDatabaseTable *)ptr)->soap_out(soap, tag, id, "ns1:CDatabaseTable");
	case SOAP_TYPE_ns1__CDatabaseTable:
		return ((ns1__CDatabaseTable *)ptr)->soap_out(soap, tag, id, "ns1:CDatabaseTable");
	case SOAP_TYPE_ArrayOfCProject:
		return ((ArrayOfCProject *)ptr)->soap_out(soap, tag, id, "ns1:CProject");
	case SOAP_TYPE_ns1__CProject:
		return ((ns1__CProject *)ptr)->soap_out(soap, tag, id, "ns1:CProject");
	case SOAP_TYPE_ArrayOfCProjectDataOption:
		return ((ArrayOfCProjectDataOption *)ptr)->soap_out(soap, tag, id, "ns1:CProjectDataOption");
	case SOAP_TYPE_ns1__CProjectDataOption:
		return ((ns1__CProjectDataOption *)ptr)->soap_out(soap, tag, id, "ns1:CProjectDataOption");
	case SOAP_TYPE_ArrayOfCDatabase:
		return ((ArrayOfCDatabase *)ptr)->soap_out(soap, tag, id, "ns1:CDatabase");
	case SOAP_TYPE_ns1__CDatabase:
		return ((ns1__CDatabase *)ptr)->soap_out(soap, tag, id, "ns1:CDatabase");
	case SOAP_TYPE_ArrayOflong:
		return ((ArrayOflong *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_ArrayOfstring:
		return ((ArrayOfstring *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_ns1__getItemHyperlinks:
		return soap_out_ns1__getItemHyperlinks(soap, tag, id, (const struct ns1__getItemHyperlinks *)ptr, "ns1:getItemHyperlinks");
	case SOAP_TYPE_ns1__getItemHyperlinksResponse:
		return soap_out_ns1__getItemHyperlinksResponse(soap, tag, id, (const struct ns1__getItemHyperlinksResponse *)ptr, "ns1:getItemHyperlinksResponse");
	case SOAP_TYPE_ns1__getFolderTree:
		return soap_out_ns1__getFolderTree(soap, tag, id, (const struct ns1__getFolderTree *)ptr, "ns1:getFolderTree");
	case SOAP_TYPE_ns1__getFolderTreeResponse:
		return soap_out_ns1__getFolderTreeResponse(soap, tag, id, (const struct ns1__getFolderTreeResponse *)ptr, "ns1:getFolderTreeResponse");
	case SOAP_TYPE_ns1__getFolderTreeByRecordID:
		return soap_out_ns1__getFolderTreeByRecordID(soap, tag, id, (const struct ns1__getFolderTreeByRecordID *)ptr, "ns1:getFolderTreeByRecordID");
	case SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse:
		return soap_out_ns1__getFolderTreeByRecordIDResponse(soap, tag, id, (const struct ns1__getFolderTreeByRecordIDResponse *)ptr, "ns1:getFolderTreeByRecordIDResponse");
	case SOAP_TYPE_ns1__getDocumentTree:
		return soap_out_ns1__getDocumentTree(soap, tag, id, (const struct ns1__getDocumentTree *)ptr, "ns1:getDocumentTree");
	case SOAP_TYPE_ns1__getDocumentTreeResponse:
		return soap_out_ns1__getDocumentTreeResponse(soap, tag, id, (const struct ns1__getDocumentTreeResponse *)ptr, "ns1:getDocumentTreeResponse");
	case SOAP_TYPE_ns1__getRequirementIDsForDocument:
		return soap_out_ns1__getRequirementIDsForDocument(soap, tag, id, (const struct ns1__getRequirementIDsForDocument *)ptr, "ns1:getRequirementIDsForDocument");
	case SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse:
		return soap_out_ns1__getRequirementIDsForDocumentResponse(soap, tag, id, (const struct ns1__getRequirementIDsForDocumentResponse *)ptr, "ns1:getRequirementIDsForDocumentResponse");
	case SOAP_TYPE_ns1__createSnapshot:
		return soap_out_ns1__createSnapshot(soap, tag, id, (const struct ns1__createSnapshot *)ptr, "ns1:createSnapshot");
	case SOAP_TYPE_ns1__createSnapshotResponse:
		return soap_out_ns1__createSnapshotResponse(soap, tag, id, (const struct ns1__createSnapshotResponse *)ptr, "ns1:createSnapshotResponse");
	case SOAP_TYPE_ns1__cancelSaveRequirementDocument:
		return soap_out_ns1__cancelSaveRequirementDocument(soap, tag, id, (const struct ns1__cancelSaveRequirementDocument *)ptr, "ns1:cancelSaveRequirementDocument");
	case SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse:
		return soap_out_ns1__cancelSaveRequirementDocumentResponse(soap, tag, id, (const struct ns1__cancelSaveRequirementDocumentResponse *)ptr, "ns1:cancelSaveRequirementDocumentResponse");
	case SOAP_TYPE_ns1__saveRequirementDocument:
		return soap_out_ns1__saveRequirementDocument(soap, tag, id, (const struct ns1__saveRequirementDocument *)ptr, "ns1:saveRequirementDocument");
	case SOAP_TYPE_ns1__saveRequirementDocumentResponse:
		return soap_out_ns1__saveRequirementDocumentResponse(soap, tag, id, (const struct ns1__saveRequirementDocumentResponse *)ptr, "ns1:saveRequirementDocumentResponse");
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordID:
		return soap_out_ns1__editRequirementDocumentByRecordID(soap, tag, id, (const struct ns1__editRequirementDocumentByRecordID *)ptr, "ns1:editRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse:
		return soap_out_ns1__editRequirementDocumentByRecordIDResponse(soap, tag, id, (const struct ns1__editRequirementDocumentByRecordIDResponse *)ptr, "ns1:editRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__editRequirementDocument:
		return soap_out_ns1__editRequirementDocument(soap, tag, id, (const struct ns1__editRequirementDocument *)ptr, "ns1:editRequirementDocument");
	case SOAP_TYPE_ns1__editRequirementDocumentResponse:
		return soap_out_ns1__editRequirementDocumentResponse(soap, tag, id, (const struct ns1__editRequirementDocumentResponse *)ptr, "ns1:editRequirementDocumentResponse");
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID:
		return soap_out_ns1__deleteRequirementDocumentByRecordID(soap, tag, id, (const struct ns1__deleteRequirementDocumentByRecordID *)ptr, "ns1:deleteRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse:
		return soap_out_ns1__deleteRequirementDocumentByRecordIDResponse(soap, tag, id, (const struct ns1__deleteRequirementDocumentByRecordIDResponse *)ptr, "ns1:deleteRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteRequirementDocument:
		return soap_out_ns1__deleteRequirementDocument(soap, tag, id, (const struct ns1__deleteRequirementDocument *)ptr, "ns1:deleteRequirementDocument");
	case SOAP_TYPE_ns1__deleteRequirementDocumentResponse:
		return soap_out_ns1__deleteRequirementDocumentResponse(soap, tag, id, (const struct ns1__deleteRequirementDocumentResponse *)ptr, "ns1:deleteRequirementDocumentResponse");
	case SOAP_TYPE_ns1__addRequirementDocument:
		return soap_out_ns1__addRequirementDocument(soap, tag, id, (const struct ns1__addRequirementDocument *)ptr, "ns1:addRequirementDocument");
	case SOAP_TYPE_ns1__addRequirementDocumentResponse:
		return soap_out_ns1__addRequirementDocumentResponse(soap, tag, id, (const struct ns1__addRequirementDocumentResponse *)ptr, "ns1:addRequirementDocumentResponse");
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordID:
		return soap_out_ns1__getRequirementDocumentByRecordID(soap, tag, id, (const struct ns1__getRequirementDocumentByRecordID *)ptr, "ns1:getRequirementDocumentByRecordID");
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse:
		return soap_out_ns1__getRequirementDocumentByRecordIDResponse(soap, tag, id, (const struct ns1__getRequirementDocumentByRecordIDResponse *)ptr, "ns1:getRequirementDocumentByRecordIDResponse");
	case SOAP_TYPE_ns1__getRequirementDocument:
		return soap_out_ns1__getRequirementDocument(soap, tag, id, (const struct ns1__getRequirementDocument *)ptr, "ns1:getRequirementDocument");
	case SOAP_TYPE_ns1__getRequirementDocumentResponse:
		return soap_out_ns1__getRequirementDocumentResponse(soap, tag, id, (const struct ns1__getRequirementDocumentResponse *)ptr, "ns1:getRequirementDocumentResponse");
	case SOAP_TYPE_ns1__changeRequirementType:
		return soap_out_ns1__changeRequirementType(soap, tag, id, (const struct ns1__changeRequirementType *)ptr, "ns1:changeRequirementType");
	case SOAP_TYPE_ns1__changeRequirementTypeResponse:
		return soap_out_ns1__changeRequirementTypeResponse(soap, tag, id, (const struct ns1__changeRequirementTypeResponse *)ptr, "ns1:changeRequirementTypeResponse");
	case SOAP_TYPE_ns1__getDocumentIDsForRequirement:
		return soap_out_ns1__getDocumentIDsForRequirement(soap, tag, id, (const struct ns1__getDocumentIDsForRequirement *)ptr, "ns1:getDocumentIDsForRequirement");
	case SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse:
		return soap_out_ns1__getDocumentIDsForRequirementResponse(soap, tag, id, (const struct ns1__getDocumentIDsForRequirementResponse *)ptr, "ns1:getDocumentIDsForRequirementResponse");
	case SOAP_TYPE_ns1__appendToRequirementDocument:
		return soap_out_ns1__appendToRequirementDocument(soap, tag, id, (const struct ns1__appendToRequirementDocument *)ptr, "ns1:appendToRequirementDocument");
	case SOAP_TYPE_ns1__appendToRequirementDocumentResponse:
		return soap_out_ns1__appendToRequirementDocumentResponse(soap, tag, id, (const struct ns1__appendToRequirementDocumentResponse *)ptr, "ns1:appendToRequirementDocumentResponse");
	case SOAP_TYPE_ns1__cancelSaveRequirement:
		return soap_out_ns1__cancelSaveRequirement(soap, tag, id, (const struct ns1__cancelSaveRequirement *)ptr, "ns1:cancelSaveRequirement");
	case SOAP_TYPE_ns1__cancelSaveRequirementResponse:
		return soap_out_ns1__cancelSaveRequirementResponse(soap, tag, id, (const struct ns1__cancelSaveRequirementResponse *)ptr, "ns1:cancelSaveRequirementResponse");
	case SOAP_TYPE_ns1__saveRequirement:
		return soap_out_ns1__saveRequirement(soap, tag, id, (const struct ns1__saveRequirement *)ptr, "ns1:saveRequirement");
	case SOAP_TYPE_ns1__saveRequirementResponse:
		return soap_out_ns1__saveRequirementResponse(soap, tag, id, (const struct ns1__saveRequirementResponse *)ptr, "ns1:saveRequirementResponse");
	case SOAP_TYPE_ns1__editRequirementByRecordID:
		return soap_out_ns1__editRequirementByRecordID(soap, tag, id, (const struct ns1__editRequirementByRecordID *)ptr, "ns1:editRequirementByRecordID");
	case SOAP_TYPE_ns1__editRequirementByRecordIDResponse:
		return soap_out_ns1__editRequirementByRecordIDResponse(soap, tag, id, (const struct ns1__editRequirementByRecordIDResponse *)ptr, "ns1:editRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__editRequirement:
		return soap_out_ns1__editRequirement(soap, tag, id, (const struct ns1__editRequirement *)ptr, "ns1:editRequirement");
	case SOAP_TYPE_ns1__editRequirementResponse:
		return soap_out_ns1__editRequirementResponse(soap, tag, id, (const struct ns1__editRequirementResponse *)ptr, "ns1:editRequirementResponse");
	case SOAP_TYPE_ns1__deleteRequirementByRecordID:
		return soap_out_ns1__deleteRequirementByRecordID(soap, tag, id, (const struct ns1__deleteRequirementByRecordID *)ptr, "ns1:deleteRequirementByRecordID");
	case SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse:
		return soap_out_ns1__deleteRequirementByRecordIDResponse(soap, tag, id, (const struct ns1__deleteRequirementByRecordIDResponse *)ptr, "ns1:deleteRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteRequirement:
		return soap_out_ns1__deleteRequirement(soap, tag, id, (const struct ns1__deleteRequirement *)ptr, "ns1:deleteRequirement");
	case SOAP_TYPE_ns1__deleteRequirementResponse:
		return soap_out_ns1__deleteRequirementResponse(soap, tag, id, (const struct ns1__deleteRequirementResponse *)ptr, "ns1:deleteRequirementResponse");
	case SOAP_TYPE_ns1__addRequirement:
		return soap_out_ns1__addRequirement(soap, tag, id, (const struct ns1__addRequirement *)ptr, "ns1:addRequirement");
	case SOAP_TYPE_ns1__addRequirementResponse:
		return soap_out_ns1__addRequirementResponse(soap, tag, id, (const struct ns1__addRequirementResponse *)ptr, "ns1:addRequirementResponse");
	case SOAP_TYPE_ns1__getRequirementByRecordID:
		return soap_out_ns1__getRequirementByRecordID(soap, tag, id, (const struct ns1__getRequirementByRecordID *)ptr, "ns1:getRequirementByRecordID");
	case SOAP_TYPE_ns1__getRequirementByRecordIDResponse:
		return soap_out_ns1__getRequirementByRecordIDResponse(soap, tag, id, (const struct ns1__getRequirementByRecordIDResponse *)ptr, "ns1:getRequirementByRecordIDResponse");
	case SOAP_TYPE_ns1__getRequirement:
		return soap_out_ns1__getRequirement(soap, tag, id, (const struct ns1__getRequirement *)ptr, "ns1:getRequirement");
	case SOAP_TYPE_ns1__getRequirementResponse:
		return soap_out_ns1__getRequirementResponse(soap, tag, id, (const struct ns1__getRequirementResponse *)ptr, "ns1:getRequirementResponse");
	case SOAP_TYPE_ns1__cancelSaveFolderItemRank:
		return soap_out_ns1__cancelSaveFolderItemRank(soap, tag, id, (const struct ns1__cancelSaveFolderItemRank *)ptr, "ns1:cancelSaveFolderItemRank");
	case SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse:
		return soap_out_ns1__cancelSaveFolderItemRankResponse(soap, tag, id, (const struct ns1__cancelSaveFolderItemRankResponse *)ptr, "ns1:cancelSaveFolderItemRankResponse");
	case SOAP_TYPE_ns1__saveFolderItemRank:
		return soap_out_ns1__saveFolderItemRank(soap, tag, id, (const struct ns1__saveFolderItemRank *)ptr, "ns1:saveFolderItemRank");
	case SOAP_TYPE_ns1__saveFolderItemRankResponse:
		return soap_out_ns1__saveFolderItemRankResponse(soap, tag, id, (const struct ns1__saveFolderItemRankResponse *)ptr, "ns1:saveFolderItemRankResponse");
	case SOAP_TYPE_ns1__editFolderItemRank:
		return soap_out_ns1__editFolderItemRank(soap, tag, id, (const struct ns1__editFolderItemRank *)ptr, "ns1:editFolderItemRank");
	case SOAP_TYPE_ns1__editFolderItemRankResponse:
		return soap_out_ns1__editFolderItemRankResponse(soap, tag, id, (const struct ns1__editFolderItemRankResponse *)ptr, "ns1:editFolderItemRankResponse");
	case SOAP_TYPE_ns1__getRootPrivateFolderPath:
		return soap_out_ns1__getRootPrivateFolderPath(soap, tag, id, (const struct ns1__getRootPrivateFolderPath *)ptr, "ns1:getRootPrivateFolderPath");
	case SOAP_TYPE_ns1__getRootPrivateFolderPathResponse:
		return soap_out_ns1__getRootPrivateFolderPathResponse(soap, tag, id, (const struct ns1__getRootPrivateFolderPathResponse *)ptr, "ns1:getRootPrivateFolderPathResponse");
	case SOAP_TYPE_ns1__getRootPublicFolderPath:
		return soap_out_ns1__getRootPublicFolderPath(soap, tag, id, (const struct ns1__getRootPublicFolderPath *)ptr, "ns1:getRootPublicFolderPath");
	case SOAP_TYPE_ns1__getRootPublicFolderPathResponse:
		return soap_out_ns1__getRootPublicFolderPathResponse(soap, tag, id, (const struct ns1__getRootPublicFolderPathResponse *)ptr, "ns1:getRootPublicFolderPathResponse");
	case SOAP_TYPE_ns1__getFolderPathSeparator:
		return soap_out_ns1__getFolderPathSeparator(soap, tag, id, (const struct ns1__getFolderPathSeparator *)ptr, "ns1:getFolderPathSeparator");
	case SOAP_TYPE_ns1__getFolderPathSeparatorResponse:
		return soap_out_ns1__getFolderPathSeparatorResponse(soap, tag, id, (const struct ns1__getFolderPathSeparatorResponse *)ptr, "ns1:getFolderPathSeparatorResponse");
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordID:
		return soap_out_ns1__getFolderListForEntityByRecordID(soap, tag, id, (const struct ns1__getFolderListForEntityByRecordID *)ptr, "ns1:getFolderListForEntityByRecordID");
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse:
		return soap_out_ns1__getFolderListForEntityByRecordIDResponse(soap, tag, id, (const struct ns1__getFolderListForEntityByRecordIDResponse *)ptr, "ns1:getFolderListForEntityByRecordIDResponse");
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordID:
		return soap_out_ns1__getEntityListForFolderByRecordID(soap, tag, id, (const struct ns1__getEntityListForFolderByRecordID *)ptr, "ns1:getEntityListForFolderByRecordID");
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse:
		return soap_out_ns1__getEntityListForFolderByRecordIDResponse(soap, tag, id, (const struct ns1__getEntityListForFolderByRecordIDResponse *)ptr, "ns1:getEntityListForFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordID:
		return soap_out_ns1__removeEntityFromFolderByRecordID(soap, tag, id, (const struct ns1__removeEntityFromFolderByRecordID *)ptr, "ns1:removeEntityFromFolderByRecordID");
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse:
		return soap_out_ns1__removeEntityFromFolderByRecordIDResponse(soap, tag, id, (const struct ns1__removeEntityFromFolderByRecordIDResponse *)ptr, "ns1:removeEntityFromFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__addEntityToFolderByRecordID:
		return soap_out_ns1__addEntityToFolderByRecordID(soap, tag, id, (const struct ns1__addEntityToFolderByRecordID *)ptr, "ns1:addEntityToFolderByRecordID");
	case SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse:
		return soap_out_ns1__addEntityToFolderByRecordIDResponse(soap, tag, id, (const struct ns1__addEntityToFolderByRecordIDResponse *)ptr, "ns1:addEntityToFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteFolderByRecordID:
		return soap_out_ns1__deleteFolderByRecordID(soap, tag, id, (const struct ns1__deleteFolderByRecordID *)ptr, "ns1:deleteFolderByRecordID");
	case SOAP_TYPE_ns1__deleteFolderByRecordIDResponse:
		return soap_out_ns1__deleteFolderByRecordIDResponse(soap, tag, id, (const struct ns1__deleteFolderByRecordIDResponse *)ptr, "ns1:deleteFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteFolder:
		return soap_out_ns1__deleteFolder(soap, tag, id, (const struct ns1__deleteFolder *)ptr, "ns1:deleteFolder");
	case SOAP_TYPE_ns1__deleteFolderResponse:
		return soap_out_ns1__deleteFolderResponse(soap, tag, id, (const struct ns1__deleteFolderResponse *)ptr, "ns1:deleteFolderResponse");
	case SOAP_TYPE_ns1__getFolderByRecordID:
		return soap_out_ns1__getFolderByRecordID(soap, tag, id, (const struct ns1__getFolderByRecordID *)ptr, "ns1:getFolderByRecordID");
	case SOAP_TYPE_ns1__getFolderByRecordIDResponse:
		return soap_out_ns1__getFolderByRecordIDResponse(soap, tag, id, (const struct ns1__getFolderByRecordIDResponse *)ptr, "ns1:getFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__getFolder:
		return soap_out_ns1__getFolder(soap, tag, id, (const struct ns1__getFolder *)ptr, "ns1:getFolder");
	case SOAP_TYPE_ns1__getFolderResponse:
		return soap_out_ns1__getFolderResponse(soap, tag, id, (const struct ns1__getFolderResponse *)ptr, "ns1:getFolderResponse");
	case SOAP_TYPE_ns1__cancelSaveFolder:
		return soap_out_ns1__cancelSaveFolder(soap, tag, id, (const struct ns1__cancelSaveFolder *)ptr, "ns1:cancelSaveFolder");
	case SOAP_TYPE_ns1__cancelSaveFolderResponse:
		return soap_out_ns1__cancelSaveFolderResponse(soap, tag, id, (const struct ns1__cancelSaveFolderResponse *)ptr, "ns1:cancelSaveFolderResponse");
	case SOAP_TYPE_ns1__saveFolder:
		return soap_out_ns1__saveFolder(soap, tag, id, (const struct ns1__saveFolder *)ptr, "ns1:saveFolder");
	case SOAP_TYPE_ns1__saveFolderResponse:
		return soap_out_ns1__saveFolderResponse(soap, tag, id, (const struct ns1__saveFolderResponse *)ptr, "ns1:saveFolderResponse");
	case SOAP_TYPE_ns1__editFolderByRecordID:
		return soap_out_ns1__editFolderByRecordID(soap, tag, id, (const struct ns1__editFolderByRecordID *)ptr, "ns1:editFolderByRecordID");
	case SOAP_TYPE_ns1__editFolderByRecordIDResponse:
		return soap_out_ns1__editFolderByRecordIDResponse(soap, tag, id, (const struct ns1__editFolderByRecordIDResponse *)ptr, "ns1:editFolderByRecordIDResponse");
	case SOAP_TYPE_ns1__editFolder:
		return soap_out_ns1__editFolder(soap, tag, id, (const struct ns1__editFolder *)ptr, "ns1:editFolder");
	case SOAP_TYPE_ns1__editFolderResponse:
		return soap_out_ns1__editFolderResponse(soap, tag, id, (const struct ns1__editFolderResponse *)ptr, "ns1:editFolderResponse");
	case SOAP_TYPE_ns1__addFolder:
		return soap_out_ns1__addFolder(soap, tag, id, (const struct ns1__addFolder *)ptr, "ns1:addFolder");
	case SOAP_TYPE_ns1__addFolderResponse:
		return soap_out_ns1__addFolderResponse(soap, tag, id, (const struct ns1__addFolderResponse *)ptr, "ns1:addFolderResponse");
	case SOAP_TYPE_ns1__getFolderTypeList:
		return soap_out_ns1__getFolderTypeList(soap, tag, id, (const struct ns1__getFolderTypeList *)ptr, "ns1:getFolderTypeList");
	case SOAP_TYPE_ns1__getFolderTypeListResponse:
		return soap_out_ns1__getFolderTypeListResponse(soap, tag, id, (const struct ns1__getFolderTypeListResponse *)ptr, "ns1:getFolderTypeListResponse");
	case SOAP_TYPE_ns1__getFolderTypeByName:
		return soap_out_ns1__getFolderTypeByName(soap, tag, id, (const struct ns1__getFolderTypeByName *)ptr, "ns1:getFolderTypeByName");
	case SOAP_TYPE_ns1__getFolderTypeByNameResponse:
		return soap_out_ns1__getFolderTypeByNameResponse(soap, tag, id, (const struct ns1__getFolderTypeByNameResponse *)ptr, "ns1:getFolderTypeByNameResponse");
	case SOAP_TYPE_ns1__generateTestRuns:
		return soap_out_ns1__generateTestRuns(soap, tag, id, (const struct ns1__generateTestRuns *)ptr, "ns1:generateTestRuns");
	case SOAP_TYPE_ns1__generateTestRunsResponse:
		return soap_out_ns1__generateTestRunsResponse(soap, tag, id, (const struct ns1__generateTestRunsResponse *)ptr, "ns1:generateTestRunsResponse");
	case SOAP_TYPE_ns1__createDefectForTestRun:
		return soap_out_ns1__createDefectForTestRun(soap, tag, id, (const struct ns1__createDefectForTestRun *)ptr, "ns1:createDefectForTestRun");
	case SOAP_TYPE_ns1__createDefectForTestRunResponse:
		return soap_out_ns1__createDefectForTestRunResponse(soap, tag, id, (const struct ns1__createDefectForTestRunResponse *)ptr, "ns1:createDefectForTestRunResponse");
	case SOAP_TYPE_ns1__cancelSaveTestRun:
		return soap_out_ns1__cancelSaveTestRun(soap, tag, id, (const struct ns1__cancelSaveTestRun *)ptr, "ns1:cancelSaveTestRun");
	case SOAP_TYPE_ns1__cancelSaveTestRunResponse:
		return soap_out_ns1__cancelSaveTestRunResponse(soap, tag, id, (const struct ns1__cancelSaveTestRunResponse *)ptr, "ns1:cancelSaveTestRunResponse");
	case SOAP_TYPE_ns1__saveTestRun:
		return soap_out_ns1__saveTestRun(soap, tag, id, (const struct ns1__saveTestRun *)ptr, "ns1:saveTestRun");
	case SOAP_TYPE_ns1__saveTestRunResponse:
		return soap_out_ns1__saveTestRunResponse(soap, tag, id, (const struct ns1__saveTestRunResponse *)ptr, "ns1:saveTestRunResponse");
	case SOAP_TYPE_ns1__editTestRunByRecordID:
		return soap_out_ns1__editTestRunByRecordID(soap, tag, id, (const struct ns1__editTestRunByRecordID *)ptr, "ns1:editTestRunByRecordID");
	case SOAP_TYPE_ns1__editTestRunByRecordIDResponse:
		return soap_out_ns1__editTestRunByRecordIDResponse(soap, tag, id, (const struct ns1__editTestRunByRecordIDResponse *)ptr, "ns1:editTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestRun:
		return soap_out_ns1__editTestRun(soap, tag, id, (const struct ns1__editTestRun *)ptr, "ns1:editTestRun");
	case SOAP_TYPE_ns1__editTestRunResponse:
		return soap_out_ns1__editTestRunResponse(soap, tag, id, (const struct ns1__editTestRunResponse *)ptr, "ns1:editTestRunResponse");
	case SOAP_TYPE_ns1__deleteTestRunByRecordID:
		return soap_out_ns1__deleteTestRunByRecordID(soap, tag, id, (const struct ns1__deleteTestRunByRecordID *)ptr, "ns1:deleteTestRunByRecordID");
	case SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse:
		return soap_out_ns1__deleteTestRunByRecordIDResponse(soap, tag, id, (const struct ns1__deleteTestRunByRecordIDResponse *)ptr, "ns1:deleteTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestRun:
		return soap_out_ns1__deleteTestRun(soap, tag, id, (const struct ns1__deleteTestRun *)ptr, "ns1:deleteTestRun");
	case SOAP_TYPE_ns1__deleteTestRunResponse:
		return soap_out_ns1__deleteTestRunResponse(soap, tag, id, (const struct ns1__deleteTestRunResponse *)ptr, "ns1:deleteTestRunResponse");
	case SOAP_TYPE_ns1__getTestRunByRecordID:
		return soap_out_ns1__getTestRunByRecordID(soap, tag, id, (const struct ns1__getTestRunByRecordID *)ptr, "ns1:getTestRunByRecordID");
	case SOAP_TYPE_ns1__getTestRunByRecordIDResponse:
		return soap_out_ns1__getTestRunByRecordIDResponse(soap, tag, id, (const struct ns1__getTestRunByRecordIDResponse *)ptr, "ns1:getTestRunByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestRun:
		return soap_out_ns1__getTestRun(soap, tag, id, (const struct ns1__getTestRun *)ptr, "ns1:getTestRun");
	case SOAP_TYPE_ns1__getTestRunResponse:
		return soap_out_ns1__getTestRunResponse(soap, tag, id, (const struct ns1__getTestRunResponse *)ptr, "ns1:getTestRunResponse");
	case SOAP_TYPE_ns1__cancelSaveTestCase:
		return soap_out_ns1__cancelSaveTestCase(soap, tag, id, (const struct ns1__cancelSaveTestCase *)ptr, "ns1:cancelSaveTestCase");
	case SOAP_TYPE_ns1__cancelSaveTestCaseResponse:
		return soap_out_ns1__cancelSaveTestCaseResponse(soap, tag, id, (const struct ns1__cancelSaveTestCaseResponse *)ptr, "ns1:cancelSaveTestCaseResponse");
	case SOAP_TYPE_ns1__saveTestCase:
		return soap_out_ns1__saveTestCase(soap, tag, id, (const struct ns1__saveTestCase *)ptr, "ns1:saveTestCase");
	case SOAP_TYPE_ns1__saveTestCaseResponse:
		return soap_out_ns1__saveTestCaseResponse(soap, tag, id, (const struct ns1__saveTestCaseResponse *)ptr, "ns1:saveTestCaseResponse");
	case SOAP_TYPE_ns1__editTestCaseByRecordID:
		return soap_out_ns1__editTestCaseByRecordID(soap, tag, id, (const struct ns1__editTestCaseByRecordID *)ptr, "ns1:editTestCaseByRecordID");
	case SOAP_TYPE_ns1__editTestCaseByRecordIDResponse:
		return soap_out_ns1__editTestCaseByRecordIDResponse(soap, tag, id, (const struct ns1__editTestCaseByRecordIDResponse *)ptr, "ns1:editTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestCase:
		return soap_out_ns1__editTestCase(soap, tag, id, (const struct ns1__editTestCase *)ptr, "ns1:editTestCase");
	case SOAP_TYPE_ns1__editTestCaseResponse:
		return soap_out_ns1__editTestCaseResponse(soap, tag, id, (const struct ns1__editTestCaseResponse *)ptr, "ns1:editTestCaseResponse");
	case SOAP_TYPE_ns1__deleteTestCaseByRecordID:
		return soap_out_ns1__deleteTestCaseByRecordID(soap, tag, id, (const struct ns1__deleteTestCaseByRecordID *)ptr, "ns1:deleteTestCaseByRecordID");
	case SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse:
		return soap_out_ns1__deleteTestCaseByRecordIDResponse(soap, tag, id, (const struct ns1__deleteTestCaseByRecordIDResponse *)ptr, "ns1:deleteTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestCase:
		return soap_out_ns1__deleteTestCase(soap, tag, id, (const struct ns1__deleteTestCase *)ptr, "ns1:deleteTestCase");
	case SOAP_TYPE_ns1__deleteTestCaseResponse:
		return soap_out_ns1__deleteTestCaseResponse(soap, tag, id, (const struct ns1__deleteTestCaseResponse *)ptr, "ns1:deleteTestCaseResponse");
	case SOAP_TYPE_ns1__addTestCase:
		return soap_out_ns1__addTestCase(soap, tag, id, (const struct ns1__addTestCase *)ptr, "ns1:addTestCase");
	case SOAP_TYPE_ns1__addTestCaseResponse:
		return soap_out_ns1__addTestCaseResponse(soap, tag, id, (const struct ns1__addTestCaseResponse *)ptr, "ns1:addTestCaseResponse");
	case SOAP_TYPE_ns1__getTestCaseByRecordID:
		return soap_out_ns1__getTestCaseByRecordID(soap, tag, id, (const struct ns1__getTestCaseByRecordID *)ptr, "ns1:getTestCaseByRecordID");
	case SOAP_TYPE_ns1__getTestCaseByRecordIDResponse:
		return soap_out_ns1__getTestCaseByRecordIDResponse(soap, tag, id, (const struct ns1__getTestCaseByRecordIDResponse *)ptr, "ns1:getTestCaseByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestCase:
		return soap_out_ns1__getTestCase(soap, tag, id, (const struct ns1__getTestCase *)ptr, "ns1:getTestCase");
	case SOAP_TYPE_ns1__getTestCaseResponse:
		return soap_out_ns1__getTestCaseResponse(soap, tag, id, (const struct ns1__getTestCaseResponse *)ptr, "ns1:getTestCaseResponse");
	case SOAP_TYPE_ns1__getTestRunStepsModes:
		return soap_out_ns1__getTestRunStepsModes(soap, tag, id, (const struct ns1__getTestRunStepsModes *)ptr, "ns1:getTestRunStepsModes");
	case SOAP_TYPE_ns1__getTestRunStepsModesResponse:
		return soap_out_ns1__getTestRunStepsModesResponse(soap, tag, id, (const struct ns1__getTestRunStepsModesResponse *)ptr, "ns1:getTestRunStepsModesResponse");
	case SOAP_TYPE_ns1__getTestVariantTypes:
		return soap_out_ns1__getTestVariantTypes(soap, tag, id, (const struct ns1__getTestVariantTypes *)ptr, "ns1:getTestVariantTypes");
	case SOAP_TYPE_ns1__getTestVariantTypesResponse:
		return soap_out_ns1__getTestVariantTypesResponse(soap, tag, id, (const struct ns1__getTestVariantTypesResponse *)ptr, "ns1:getTestVariantTypesResponse");
	case SOAP_TYPE_ns1__cancelSaveLink:
		return soap_out_ns1__cancelSaveLink(soap, tag, id, (const struct ns1__cancelSaveLink *)ptr, "ns1:cancelSaveLink");
	case SOAP_TYPE_ns1__cancelSaveLinkResponse:
		return soap_out_ns1__cancelSaveLinkResponse(soap, tag, id, (const struct ns1__cancelSaveLinkResponse *)ptr, "ns1:cancelSaveLinkResponse");
	case SOAP_TYPE_ns1__saveLink:
		return soap_out_ns1__saveLink(soap, tag, id, (const struct ns1__saveLink *)ptr, "ns1:saveLink");
	case SOAP_TYPE_ns1__saveLinkResponse:
		return soap_out_ns1__saveLinkResponse(soap, tag, id, (const struct ns1__saveLinkResponse *)ptr, "ns1:saveLinkResponse");
	case SOAP_TYPE_ns1__editLink:
		return soap_out_ns1__editLink(soap, tag, id, (const struct ns1__editLink *)ptr, "ns1:editLink");
	case SOAP_TYPE_ns1__editLinkResponse:
		return soap_out_ns1__editLinkResponse(soap, tag, id, (const struct ns1__editLinkResponse *)ptr, "ns1:editLinkResponse");
	case SOAP_TYPE_ns1__deleteLink:
		return soap_out_ns1__deleteLink(soap, tag, id, (const struct ns1__deleteLink *)ptr, "ns1:deleteLink");
	case SOAP_TYPE_ns1__deleteLinkResponse:
		return soap_out_ns1__deleteLinkResponse(soap, tag, id, (const struct ns1__deleteLinkResponse *)ptr, "ns1:deleteLinkResponse");
	case SOAP_TYPE_ns1__addLink:
		return soap_out_ns1__addLink(soap, tag, id, (const struct ns1__addLink *)ptr, "ns1:addLink");
	case SOAP_TYPE_ns1__addLinkResponse:
		return soap_out_ns1__addLinkResponse(soap, tag, id, (const struct ns1__addLinkResponse *)ptr, "ns1:addLinkResponse");
	case SOAP_TYPE_ns1__getLink:
		return soap_out_ns1__getLink(soap, tag, id, (const struct ns1__getLink *)ptr, "ns1:getLink");
	case SOAP_TYPE_ns1__getLinkResponse:
		return soap_out_ns1__getLinkResponse(soap, tag, id, (const struct ns1__getLinkResponse *)ptr, "ns1:getLinkResponse");
	case SOAP_TYPE_ns1__getLinksForDefect:
		return soap_out_ns1__getLinksForDefect(soap, tag, id, (const struct ns1__getLinksForDefect *)ptr, "ns1:getLinksForDefect");
	case SOAP_TYPE_ns1__getLinksForDefectResponse:
		return soap_out_ns1__getLinksForDefectResponse(soap, tag, id, (const struct ns1__getLinksForDefectResponse *)ptr, "ns1:getLinksForDefectResponse");
	case SOAP_TYPE_ns1__getLinksForItem:
		return soap_out_ns1__getLinksForItem(soap, tag, id, (const struct ns1__getLinksForItem *)ptr, "ns1:getLinksForItem");
	case SOAP_TYPE_ns1__getLinksForItemResponse:
		return soap_out_ns1__getLinksForItemResponse(soap, tag, id, (const struct ns1__getLinksForItemResponse *)ptr, "ns1:getLinksForItemResponse");
	case SOAP_TYPE_ns1__addGlobalCustomer:
		return soap_out_ns1__addGlobalCustomer(soap, tag, id, (const struct ns1__addGlobalCustomer *)ptr, "ns1:addGlobalCustomer");
	case SOAP_TYPE_ns1__addGlobalCustomerResponse:
		return soap_out_ns1__addGlobalCustomerResponse(soap, tag, id, (const struct ns1__addGlobalCustomerResponse *)ptr, "ns1:addGlobalCustomerResponse");
	case SOAP_TYPE_ns1__promoteCustomer:
		return soap_out_ns1__promoteCustomer(soap, tag, id, (const struct ns1__promoteCustomer *)ptr, "ns1:promoteCustomer");
	case SOAP_TYPE_ns1__promoteCustomerResponse:
		return soap_out_ns1__promoteCustomerResponse(soap, tag, id, (const struct ns1__promoteCustomerResponse *)ptr, "ns1:promoteCustomerResponse");
	case SOAP_TYPE_ns1__cancelSaveCustomer:
		return soap_out_ns1__cancelSaveCustomer(soap, tag, id, (const struct ns1__cancelSaveCustomer *)ptr, "ns1:cancelSaveCustomer");
	case SOAP_TYPE_ns1__cancelSaveCustomerResponse:
		return soap_out_ns1__cancelSaveCustomerResponse(soap, tag, id, (const struct ns1__cancelSaveCustomerResponse *)ptr, "ns1:cancelSaveCustomerResponse");
	case SOAP_TYPE_ns1__deleteCustomerByRecordID:
		return soap_out_ns1__deleteCustomerByRecordID(soap, tag, id, (const struct ns1__deleteCustomerByRecordID *)ptr, "ns1:deleteCustomerByRecordID");
	case SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse:
		return soap_out_ns1__deleteCustomerByRecordIDResponse(soap, tag, id, (const struct ns1__deleteCustomerByRecordIDResponse *)ptr, "ns1:deleteCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteCustomer:
		return soap_out_ns1__deleteCustomer(soap, tag, id, (const struct ns1__deleteCustomer *)ptr, "ns1:deleteCustomer");
	case SOAP_TYPE_ns1__deleteCustomerResponse:
		return soap_out_ns1__deleteCustomerResponse(soap, tag, id, (const struct ns1__deleteCustomerResponse *)ptr, "ns1:deleteCustomerResponse");
	case SOAP_TYPE_ns1__saveCustomer:
		return soap_out_ns1__saveCustomer(soap, tag, id, (const struct ns1__saveCustomer *)ptr, "ns1:saveCustomer");
	case SOAP_TYPE_ns1__saveCustomerResponse:
		return soap_out_ns1__saveCustomerResponse(soap, tag, id, (const struct ns1__saveCustomerResponse *)ptr, "ns1:saveCustomerResponse");
	case SOAP_TYPE_ns1__editCustomerByRecordID:
		return soap_out_ns1__editCustomerByRecordID(soap, tag, id, (const struct ns1__editCustomerByRecordID *)ptr, "ns1:editCustomerByRecordID");
	case SOAP_TYPE_ns1__editCustomerByRecordIDResponse:
		return soap_out_ns1__editCustomerByRecordIDResponse(soap, tag, id, (const struct ns1__editCustomerByRecordIDResponse *)ptr, "ns1:editCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__editCustomer:
		return soap_out_ns1__editCustomer(soap, tag, id, (const struct ns1__editCustomer *)ptr, "ns1:editCustomer");
	case SOAP_TYPE_ns1__editCustomerResponse:
		return soap_out_ns1__editCustomerResponse(soap, tag, id, (const struct ns1__editCustomerResponse *)ptr, "ns1:editCustomerResponse");
	case SOAP_TYPE_ns1__addCustomer:
		return soap_out_ns1__addCustomer(soap, tag, id, (const struct ns1__addCustomer *)ptr, "ns1:addCustomer");
	case SOAP_TYPE_ns1__addCustomerResponse:
		return soap_out_ns1__addCustomerResponse(soap, tag, id, (const struct ns1__addCustomerResponse *)ptr, "ns1:addCustomerResponse");
	case SOAP_TYPE_ns1__getCustomerByRecordID:
		return soap_out_ns1__getCustomerByRecordID(soap, tag, id, (const struct ns1__getCustomerByRecordID *)ptr, "ns1:getCustomerByRecordID");
	case SOAP_TYPE_ns1__getCustomerByRecordIDResponse:
		return soap_out_ns1__getCustomerByRecordIDResponse(soap, tag, id, (const struct ns1__getCustomerByRecordIDResponse *)ptr, "ns1:getCustomerByRecordIDResponse");
	case SOAP_TYPE_ns1__getCustomer:
		return soap_out_ns1__getCustomer(soap, tag, id, (const struct ns1__getCustomer *)ptr, "ns1:getCustomer");
	case SOAP_TYPE_ns1__getCustomerResponse:
		return soap_out_ns1__getCustomerResponse(soap, tag, id, (const struct ns1__getCustomerResponse *)ptr, "ns1:getCustomerResponse");
	case SOAP_TYPE_ns1__addGlobalUser:
		return soap_out_ns1__addGlobalUser(soap, tag, id, (const struct ns1__addGlobalUser *)ptr, "ns1:addGlobalUser");
	case SOAP_TYPE_ns1__addGlobalUserResponse:
		return soap_out_ns1__addGlobalUserResponse(soap, tag, id, (const struct ns1__addGlobalUserResponse *)ptr, "ns1:addGlobalUserResponse");
	case SOAP_TYPE_ns1__promoteUser:
		return soap_out_ns1__promoteUser(soap, tag, id, (const struct ns1__promoteUser *)ptr, "ns1:promoteUser");
	case SOAP_TYPE_ns1__promoteUserResponse:
		return soap_out_ns1__promoteUserResponse(soap, tag, id, (const struct ns1__promoteUserResponse *)ptr, "ns1:promoteUserResponse");
	case SOAP_TYPE_ns1__cancelSaveUser:
		return soap_out_ns1__cancelSaveUser(soap, tag, id, (const struct ns1__cancelSaveUser *)ptr, "ns1:cancelSaveUser");
	case SOAP_TYPE_ns1__cancelSaveUserResponse:
		return soap_out_ns1__cancelSaveUserResponse(soap, tag, id, (const struct ns1__cancelSaveUserResponse *)ptr, "ns1:cancelSaveUserResponse");
	case SOAP_TYPE_ns1__deleteUserByRecordID:
		return soap_out_ns1__deleteUserByRecordID(soap, tag, id, (const struct ns1__deleteUserByRecordID *)ptr, "ns1:deleteUserByRecordID");
	case SOAP_TYPE_ns1__deleteUserByRecordIDResponse:
		return soap_out_ns1__deleteUserByRecordIDResponse(soap, tag, id, (const struct ns1__deleteUserByRecordIDResponse *)ptr, "ns1:deleteUserByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteUser:
		return soap_out_ns1__deleteUser(soap, tag, id, (const struct ns1__deleteUser *)ptr, "ns1:deleteUser");
	case SOAP_TYPE_ns1__deleteUserResponse:
		return soap_out_ns1__deleteUserResponse(soap, tag, id, (const struct ns1__deleteUserResponse *)ptr, "ns1:deleteUserResponse");
	case SOAP_TYPE_ns1__saveUser:
		return soap_out_ns1__saveUser(soap, tag, id, (const struct ns1__saveUser *)ptr, "ns1:saveUser");
	case SOAP_TYPE_ns1__saveUserResponse:
		return soap_out_ns1__saveUserResponse(soap, tag, id, (const struct ns1__saveUserResponse *)ptr, "ns1:saveUserResponse");
	case SOAP_TYPE_ns1__editUserByRecordID:
		return soap_out_ns1__editUserByRecordID(soap, tag, id, (const struct ns1__editUserByRecordID *)ptr, "ns1:editUserByRecordID");
	case SOAP_TYPE_ns1__editUserByRecordIDResponse:
		return soap_out_ns1__editUserByRecordIDResponse(soap, tag, id, (const struct ns1__editUserByRecordIDResponse *)ptr, "ns1:editUserByRecordIDResponse");
	case SOAP_TYPE_ns1__editUser:
		return soap_out_ns1__editUser(soap, tag, id, (const struct ns1__editUser *)ptr, "ns1:editUser");
	case SOAP_TYPE_ns1__editUserResponse:
		return soap_out_ns1__editUserResponse(soap, tag, id, (const struct ns1__editUserResponse *)ptr, "ns1:editUserResponse");
	case SOAP_TYPE_ns1__addUser:
		return soap_out_ns1__addUser(soap, tag, id, (const struct ns1__addUser *)ptr, "ns1:addUser");
	case SOAP_TYPE_ns1__addUserResponse:
		return soap_out_ns1__addUserResponse(soap, tag, id, (const struct ns1__addUserResponse *)ptr, "ns1:addUserResponse");
	case SOAP_TYPE_ns1__getUserForCurrentSession:
		return soap_out_ns1__getUserForCurrentSession(soap, tag, id, (const struct ns1__getUserForCurrentSession *)ptr, "ns1:getUserForCurrentSession");
	case SOAP_TYPE_ns1__getUserForCurrentSessionResponse:
		return soap_out_ns1__getUserForCurrentSessionResponse(soap, tag, id, (const struct ns1__getUserForCurrentSessionResponse *)ptr, "ns1:getUserForCurrentSessionResponse");
	case SOAP_TYPE_ns1__getUserByRecordID:
		return soap_out_ns1__getUserByRecordID(soap, tag, id, (const struct ns1__getUserByRecordID *)ptr, "ns1:getUserByRecordID");
	case SOAP_TYPE_ns1__getUserByRecordIDResponse:
		return soap_out_ns1__getUserByRecordIDResponse(soap, tag, id, (const struct ns1__getUserByRecordIDResponse *)ptr, "ns1:getUserByRecordIDResponse");
	case SOAP_TYPE_ns1__getUser:
		return soap_out_ns1__getUser(soap, tag, id, (const struct ns1__getUser *)ptr, "ns1:getUser");
	case SOAP_TYPE_ns1__getUserResponse:
		return soap_out_ns1__getUserResponse(soap, tag, id, (const struct ns1__getUserResponse *)ptr, "ns1:getUserResponse");
	case SOAP_TYPE_ns1__getUserLicenseList:
		return soap_out_ns1__getUserLicenseList(soap, tag, id, (const struct ns1__getUserLicenseList *)ptr, "ns1:getUserLicenseList");
	case SOAP_TYPE_ns1__getUserLicenseListResponse:
		return soap_out_ns1__getUserLicenseListResponse(soap, tag, id, (const struct ns1__getUserLicenseListResponse *)ptr, "ns1:getUserLicenseListResponse");
	case SOAP_TYPE_ns1__getGlobalCustomerList:
		return soap_out_ns1__getGlobalCustomerList(soap, tag, id, (const struct ns1__getGlobalCustomerList *)ptr, "ns1:getGlobalCustomerList");
	case SOAP_TYPE_ns1__getGlobalCustomerListResponse:
		return soap_out_ns1__getGlobalCustomerListResponse(soap, tag, id, (const struct ns1__getGlobalCustomerListResponse *)ptr, "ns1:getGlobalCustomerListResponse");
	case SOAP_TYPE_ns1__getGlobalUserList:
		return soap_out_ns1__getGlobalUserList(soap, tag, id, (const struct ns1__getGlobalUserList *)ptr, "ns1:getGlobalUserList");
	case SOAP_TYPE_ns1__getGlobalUserListResponse:
		return soap_out_ns1__getGlobalUserListResponse(soap, tag, id, (const struct ns1__getGlobalUserListResponse *)ptr, "ns1:getGlobalUserListResponse");
	case SOAP_TYPE_ns1__cancelSaveTask:
		return soap_out_ns1__cancelSaveTask(soap, tag, id, (const struct ns1__cancelSaveTask *)ptr, "ns1:cancelSaveTask");
	case SOAP_TYPE_ns1__cancelSaveTaskResponse:
		return soap_out_ns1__cancelSaveTaskResponse(soap, tag, id, (const struct ns1__cancelSaveTaskResponse *)ptr, "ns1:cancelSaveTaskResponse");
	case SOAP_TYPE_ns1__saveTask:
		return soap_out_ns1__saveTask(soap, tag, id, (const struct ns1__saveTask *)ptr, "ns1:saveTask");
	case SOAP_TYPE_ns1__saveTaskResponse:
		return soap_out_ns1__saveTaskResponse(soap, tag, id, (const struct ns1__saveTaskResponse *)ptr, "ns1:saveTaskResponse");
	case SOAP_TYPE_ns1__editTaskByRecordID:
		return soap_out_ns1__editTaskByRecordID(soap, tag, id, (const struct ns1__editTaskByRecordID *)ptr, "ns1:editTaskByRecordID");
	case SOAP_TYPE_ns1__editTaskByRecordIDResponse:
		return soap_out_ns1__editTaskByRecordIDResponse(soap, tag, id, (const struct ns1__editTaskByRecordIDResponse *)ptr, "ns1:editTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__editTask:
		return soap_out_ns1__editTask(soap, tag, id, (const struct ns1__editTask *)ptr, "ns1:editTask");
	case SOAP_TYPE_ns1__editTaskResponse:
		return soap_out_ns1__editTaskResponse(soap, tag, id, (const struct ns1__editTaskResponse *)ptr, "ns1:editTaskResponse");
	case SOAP_TYPE_ns1__deleteTaskByRecordID:
		return soap_out_ns1__deleteTaskByRecordID(soap, tag, id, (const struct ns1__deleteTaskByRecordID *)ptr, "ns1:deleteTaskByRecordID");
	case SOAP_TYPE_ns1__deleteTaskByRecordIDResponse:
		return soap_out_ns1__deleteTaskByRecordIDResponse(soap, tag, id, (const struct ns1__deleteTaskByRecordIDResponse *)ptr, "ns1:deleteTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTask:
		return soap_out_ns1__deleteTask(soap, tag, id, (const struct ns1__deleteTask *)ptr, "ns1:deleteTask");
	case SOAP_TYPE_ns1__deleteTaskResponse:
		return soap_out_ns1__deleteTaskResponse(soap, tag, id, (const struct ns1__deleteTaskResponse *)ptr, "ns1:deleteTaskResponse");
	case SOAP_TYPE_ns1__addTask:
		return soap_out_ns1__addTask(soap, tag, id, (const struct ns1__addTask *)ptr, "ns1:addTask");
	case SOAP_TYPE_ns1__addTaskResponse:
		return soap_out_ns1__addTaskResponse(soap, tag, id, (const struct ns1__addTaskResponse *)ptr, "ns1:addTaskResponse");
	case SOAP_TYPE_ns1__getTaskByRecordID:
		return soap_out_ns1__getTaskByRecordID(soap, tag, id, (const struct ns1__getTaskByRecordID *)ptr, "ns1:getTaskByRecordID");
	case SOAP_TYPE_ns1__getTaskByRecordIDResponse:
		return soap_out_ns1__getTaskByRecordIDResponse(soap, tag, id, (const struct ns1__getTaskByRecordIDResponse *)ptr, "ns1:getTaskByRecordIDResponse");
	case SOAP_TYPE_ns1__getTask:
		return soap_out_ns1__getTask(soap, tag, id, (const struct ns1__getTask *)ptr, "ns1:getTask");
	case SOAP_TYPE_ns1__getTaskResponse:
		return soap_out_ns1__getTaskResponse(soap, tag, id, (const struct ns1__getTaskResponse *)ptr, "ns1:getTaskResponse");
	case SOAP_TYPE_ns1__getDefectAttachment:
		return soap_out_ns1__getDefectAttachment(soap, tag, id, (const struct ns1__getDefectAttachment *)ptr, "ns1:getDefectAttachment");
	case SOAP_TYPE_ns1__getDefectAttachmentResponse:
		return soap_out_ns1__getDefectAttachmentResponse(soap, tag, id, (const struct ns1__getDefectAttachmentResponse *)ptr, "ns1:getDefectAttachmentResponse");
	case SOAP_TYPE_ns1__getAttachment:
		return soap_out_ns1__getAttachment(soap, tag, id, (const struct ns1__getAttachment *)ptr, "ns1:getAttachment");
	case SOAP_TYPE_ns1__getAttachmentResponse:
		return soap_out_ns1__getAttachmentResponse(soap, tag, id, (const struct ns1__getAttachmentResponse *)ptr, "ns1:getAttachmentResponse");
	case SOAP_TYPE_ns1__cancelSaveDefect:
		return soap_out_ns1__cancelSaveDefect(soap, tag, id, (const struct ns1__cancelSaveDefect *)ptr, "ns1:cancelSaveDefect");
	case SOAP_TYPE_ns1__cancelSaveDefectResponse:
		return soap_out_ns1__cancelSaveDefectResponse(soap, tag, id, (const struct ns1__cancelSaveDefectResponse *)ptr, "ns1:cancelSaveDefectResponse");
	case SOAP_TYPE_ns1__saveDefect:
		return soap_out_ns1__saveDefect(soap, tag, id, (const struct ns1__saveDefect *)ptr, "ns1:saveDefect");
	case SOAP_TYPE_ns1__saveDefectResponse:
		return soap_out_ns1__saveDefectResponse(soap, tag, id, (const struct ns1__saveDefectResponse *)ptr, "ns1:saveDefectResponse");
	case SOAP_TYPE_ns1__editDefectByRecordID:
		return soap_out_ns1__editDefectByRecordID(soap, tag, id, (const struct ns1__editDefectByRecordID *)ptr, "ns1:editDefectByRecordID");
	case SOAP_TYPE_ns1__editDefectByRecordIDResponse:
		return soap_out_ns1__editDefectByRecordIDResponse(soap, tag, id, (const struct ns1__editDefectByRecordIDResponse *)ptr, "ns1:editDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__editDefect:
		return soap_out_ns1__editDefect(soap, tag, id, (const struct ns1__editDefect *)ptr, "ns1:editDefect");
	case SOAP_TYPE_ns1__editDefectResponse:
		return soap_out_ns1__editDefectResponse(soap, tag, id, (const struct ns1__editDefectResponse *)ptr, "ns1:editDefectResponse");
	case SOAP_TYPE_ns1__deleteDefectByRecordID:
		return soap_out_ns1__deleteDefectByRecordID(soap, tag, id, (const struct ns1__deleteDefectByRecordID *)ptr, "ns1:deleteDefectByRecordID");
	case SOAP_TYPE_ns1__deleteDefectByRecordIDResponse:
		return soap_out_ns1__deleteDefectByRecordIDResponse(soap, tag, id, (const struct ns1__deleteDefectByRecordIDResponse *)ptr, "ns1:deleteDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteDefect:
		return soap_out_ns1__deleteDefect(soap, tag, id, (const struct ns1__deleteDefect *)ptr, "ns1:deleteDefect");
	case SOAP_TYPE_ns1__deleteDefectResponse:
		return soap_out_ns1__deleteDefectResponse(soap, tag, id, (const struct ns1__deleteDefectResponse *)ptr, "ns1:deleteDefectResponse");
	case SOAP_TYPE_ns1__addDefectWithLink:
		return soap_out_ns1__addDefectWithLink(soap, tag, id, (const struct ns1__addDefectWithLink *)ptr, "ns1:addDefectWithLink");
	case SOAP_TYPE_ns1__addDefectWithLinkResponse:
		return soap_out_ns1__addDefectWithLinkResponse(soap, tag, id, (const struct ns1__addDefectWithLinkResponse *)ptr, "ns1:addDefectWithLinkResponse");
	case SOAP_TYPE_ns1__addDefect:
		return soap_out_ns1__addDefect(soap, tag, id, (const struct ns1__addDefect *)ptr, "ns1:addDefect");
	case SOAP_TYPE_ns1__addDefectResponse:
		return soap_out_ns1__addDefectResponse(soap, tag, id, (const struct ns1__addDefectResponse *)ptr, "ns1:addDefectResponse");
	case SOAP_TYPE_ns1__getDefectByRecordID:
		return soap_out_ns1__getDefectByRecordID(soap, tag, id, (const struct ns1__getDefectByRecordID *)ptr, "ns1:getDefectByRecordID");
	case SOAP_TYPE_ns1__getDefectByRecordIDResponse:
		return soap_out_ns1__getDefectByRecordIDResponse(soap, tag, id, (const struct ns1__getDefectByRecordIDResponse *)ptr, "ns1:getDefectByRecordIDResponse");
	case SOAP_TYPE_ns1__getDefect:
		return soap_out_ns1__getDefect(soap, tag, id, (const struct ns1__getDefect *)ptr, "ns1:getDefect");
	case SOAP_TYPE_ns1__getDefectResponse:
		return soap_out_ns1__getDefectResponse(soap, tag, id, (const struct ns1__getDefectResponse *)ptr, "ns1:getDefectResponse");
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList:
		return soap_out_ns1__getDefectCustomFieldsDefinitionList(soap, tag, id, (const struct ns1__getDefectCustomFieldsDefinitionList *)ptr, "ns1:getDefectCustomFieldsDefinitionList");
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse:
		return soap_out_ns1__getDefectCustomFieldsDefinitionListResponse(soap, tag, id, (const struct ns1__getDefectCustomFieldsDefinitionListResponse *)ptr, "ns1:getDefectCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionList:
		return soap_out_ns1__getCustomFieldsDefinitionList(soap, tag, id, (const struct ns1__getCustomFieldsDefinitionList *)ptr, "ns1:getCustomFieldsDefinitionList");
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse:
		return soap_out_ns1__getCustomFieldsDefinitionListResponse(soap, tag, id, (const struct ns1__getCustomFieldsDefinitionListResponse *)ptr, "ns1:getCustomFieldsDefinitionListResponse");
	case SOAP_TYPE_ns1__getDefectEventDefinitionList:
		return soap_out_ns1__getDefectEventDefinitionList(soap, tag, id, (const struct ns1__getDefectEventDefinitionList *)ptr, "ns1:getDefectEventDefinitionList");
	case SOAP_TYPE_ns1__getDefectEventDefinitionListResponse:
		return soap_out_ns1__getDefectEventDefinitionListResponse(soap, tag, id, (const struct ns1__getDefectEventDefinitionListResponse *)ptr, "ns1:getDefectEventDefinitionListResponse");
	case SOAP_TYPE_ns1__getEventDefinitionList:
		return soap_out_ns1__getEventDefinitionList(soap, tag, id, (const struct ns1__getEventDefinitionList *)ptr, "ns1:getEventDefinitionList");
	case SOAP_TYPE_ns1__getEventDefinitionListResponse:
		return soap_out_ns1__getEventDefinitionListResponse(soap, tag, id, (const struct ns1__getEventDefinitionListResponse *)ptr, "ns1:getEventDefinitionListResponse");
	case SOAP_TYPE_ns1__getReportRunResultsByRecordID:
		return soap_out_ns1__getReportRunResultsByRecordID(soap, tag, id, (const struct ns1__getReportRunResultsByRecordID *)ptr, "ns1:getReportRunResultsByRecordID");
	case SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse:
		return soap_out_ns1__getReportRunResultsByRecordIDResponse(soap, tag, id, (const struct ns1__getReportRunResultsByRecordIDResponse *)ptr, "ns1:getReportRunResultsByRecordIDResponse");
	case SOAP_TYPE_ns1__getReportRunResultsByName:
		return soap_out_ns1__getReportRunResultsByName(soap, tag, id, (const struct ns1__getReportRunResultsByName *)ptr, "ns1:getReportRunResultsByName");
	case SOAP_TYPE_ns1__getReportRunResultsByNameResponse:
		return soap_out_ns1__getReportRunResultsByNameResponse(soap, tag, id, (const struct ns1__getReportRunResultsByNameResponse *)ptr, "ns1:getReportRunResultsByNameResponse");
	case SOAP_TYPE_ns1__getAttachmentTypes:
		return soap_out_ns1__getAttachmentTypes(soap, tag, id, (const struct ns1__getAttachmentTypes *)ptr, "ns1:getAttachmentTypes");
	case SOAP_TYPE_ns1__getAttachmentTypesResponse:
		return soap_out_ns1__getAttachmentTypesResponse(soap, tag, id, (const struct ns1__getAttachmentTypesResponse *)ptr, "ns1:getAttachmentTypesResponse");
	case SOAP_TYPE_ns1__cancelSaveTestConfig:
		return soap_out_ns1__cancelSaveTestConfig(soap, tag, id, (const struct ns1__cancelSaveTestConfig *)ptr, "ns1:cancelSaveTestConfig");
	case SOAP_TYPE_ns1__cancelSaveTestConfigResponse:
		return soap_out_ns1__cancelSaveTestConfigResponse(soap, tag, id, (const struct ns1__cancelSaveTestConfigResponse *)ptr, "ns1:cancelSaveTestConfigResponse");
	case SOAP_TYPE_ns1__deleteTestConfigByRecordID:
		return soap_out_ns1__deleteTestConfigByRecordID(soap, tag, id, (const struct ns1__deleteTestConfigByRecordID *)ptr, "ns1:deleteTestConfigByRecordID");
	case SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse:
		return soap_out_ns1__deleteTestConfigByRecordIDResponse(soap, tag, id, (const struct ns1__deleteTestConfigByRecordIDResponse *)ptr, "ns1:deleteTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__deleteTestConfig:
		return soap_out_ns1__deleteTestConfig(soap, tag, id, (const struct ns1__deleteTestConfig *)ptr, "ns1:deleteTestConfig");
	case SOAP_TYPE_ns1__deleteTestConfigResponse:
		return soap_out_ns1__deleteTestConfigResponse(soap, tag, id, (const struct ns1__deleteTestConfigResponse *)ptr, "ns1:deleteTestConfigResponse");
	case SOAP_TYPE_ns1__saveTestConfig:
		return soap_out_ns1__saveTestConfig(soap, tag, id, (const struct ns1__saveTestConfig *)ptr, "ns1:saveTestConfig");
	case SOAP_TYPE_ns1__saveTestConfigResponse:
		return soap_out_ns1__saveTestConfigResponse(soap, tag, id, (const struct ns1__saveTestConfigResponse *)ptr, "ns1:saveTestConfigResponse");
	case SOAP_TYPE_ns1__editTestConfigByRecordID:
		return soap_out_ns1__editTestConfigByRecordID(soap, tag, id, (const struct ns1__editTestConfigByRecordID *)ptr, "ns1:editTestConfigByRecordID");
	case SOAP_TYPE_ns1__editTestConfigByRecordIDResponse:
		return soap_out_ns1__editTestConfigByRecordIDResponse(soap, tag, id, (const struct ns1__editTestConfigByRecordIDResponse *)ptr, "ns1:editTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__editTestConfig:
		return soap_out_ns1__editTestConfig(soap, tag, id, (const struct ns1__editTestConfig *)ptr, "ns1:editTestConfig");
	case SOAP_TYPE_ns1__editTestConfigResponse:
		return soap_out_ns1__editTestConfigResponse(soap, tag, id, (const struct ns1__editTestConfigResponse *)ptr, "ns1:editTestConfigResponse");
	case SOAP_TYPE_ns1__addTestConfig:
		return soap_out_ns1__addTestConfig(soap, tag, id, (const struct ns1__addTestConfig *)ptr, "ns1:addTestConfig");
	case SOAP_TYPE_ns1__addTestConfigResponse:
		return soap_out_ns1__addTestConfigResponse(soap, tag, id, (const struct ns1__addTestConfigResponse *)ptr, "ns1:addTestConfigResponse");
	case SOAP_TYPE_ns1__getTestConfigByRecordID:
		return soap_out_ns1__getTestConfigByRecordID(soap, tag, id, (const struct ns1__getTestConfigByRecordID *)ptr, "ns1:getTestConfigByRecordID");
	case SOAP_TYPE_ns1__getTestConfigByRecordIDResponse:
		return soap_out_ns1__getTestConfigByRecordIDResponse(soap, tag, id, (const struct ns1__getTestConfigByRecordIDResponse *)ptr, "ns1:getTestConfigByRecordIDResponse");
	case SOAP_TYPE_ns1__getTestConfig:
		return soap_out_ns1__getTestConfig(soap, tag, id, (const struct ns1__getTestConfig *)ptr, "ns1:getTestConfig");
	case SOAP_TYPE_ns1__getTestConfigResponse:
		return soap_out_ns1__getTestConfigResponse(soap, tag, id, (const struct ns1__getTestConfigResponse *)ptr, "ns1:getTestConfigResponse");
	case SOAP_TYPE_ns1__getRecordListForTable:
		return soap_out_ns1__getRecordListForTable(soap, tag, id, (const struct ns1__getRecordListForTable *)ptr, "ns1:getRecordListForTable");
	case SOAP_TYPE_ns1__getRecordListForTableResponse:
		return soap_out_ns1__getRecordListForTableResponse(soap, tag, id, (const struct ns1__getRecordListForTableResponse *)ptr, "ns1:getRecordListForTableResponse");
	case SOAP_TYPE_ns1__getFilterListForTable:
		return soap_out_ns1__getFilterListForTable(soap, tag, id, (const struct ns1__getFilterListForTable *)ptr, "ns1:getFilterListForTable");
	case SOAP_TYPE_ns1__getFilterListForTableResponse:
		return soap_out_ns1__getFilterListForTableResponse(soap, tag, id, (const struct ns1__getFilterListForTableResponse *)ptr, "ns1:getFilterListForTableResponse");
	case SOAP_TYPE_ns1__getFilterList:
		return soap_out_ns1__getFilterList(soap, tag, id, (const struct ns1__getFilterList *)ptr, "ns1:getFilterList");
	case SOAP_TYPE_ns1__getFilterListResponse:
		return soap_out_ns1__getFilterListResponse(soap, tag, id, (const struct ns1__getFilterListResponse *)ptr, "ns1:getFilterListResponse");
	case SOAP_TYPE_ns1__getColumnsForTable:
		return soap_out_ns1__getColumnsForTable(soap, tag, id, (const struct ns1__getColumnsForTable *)ptr, "ns1:getColumnsForTable");
	case SOAP_TYPE_ns1__getColumnsForTableResponse:
		return soap_out_ns1__getColumnsForTableResponse(soap, tag, id, (const struct ns1__getColumnsForTableResponse *)ptr, "ns1:getColumnsForTableResponse");
	case SOAP_TYPE_ns1__GetLinkDefinitionValues:
		return soap_out_ns1__GetLinkDefinitionValues(soap, tag, id, (const struct ns1__GetLinkDefinitionValues *)ptr, "ns1:GetLinkDefinitionValues");
	case SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse:
		return soap_out_ns1__GetLinkDefinitionValuesResponse(soap, tag, id, (const struct ns1__GetLinkDefinitionValuesResponse *)ptr, "ns1:GetLinkDefinitionValuesResponse");
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTable:
		return soap_out_ns1__addDropdownFieldValuesForTable(soap, tag, id, (const struct ns1__addDropdownFieldValuesForTable *)ptr, "ns1:addDropdownFieldValuesForTable");
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse:
		return soap_out_ns1__addDropdownFieldValuesForTableResponse(soap, tag, id, (const struct ns1__addDropdownFieldValuesForTableResponse *)ptr, "ns1:addDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTable:
		return soap_out_ns1__getDropdownFieldValuesForTable(soap, tag, id, (const struct ns1__getDropdownFieldValuesForTable *)ptr, "ns1:getDropdownFieldValuesForTable");
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse:
		return soap_out_ns1__getDropdownFieldValuesForTableResponse(soap, tag, id, (const struct ns1__getDropdownFieldValuesForTableResponse *)ptr, "ns1:getDropdownFieldValuesForTableResponse");
	case SOAP_TYPE_ns1__getDropdownFieldForTable:
		return soap_out_ns1__getDropdownFieldForTable(soap, tag, id, (const struct ns1__getDropdownFieldForTable *)ptr, "ns1:getDropdownFieldForTable");
	case SOAP_TYPE_ns1__getDropdownFieldForTableResponse:
		return soap_out_ns1__getDropdownFieldForTableResponse(soap, tag, id, (const struct ns1__getDropdownFieldForTableResponse *)ptr, "ns1:getDropdownFieldForTableResponse");
	case SOAP_TYPE_ns1__getTableList:
		return soap_out_ns1__getTableList(soap, tag, id, (const struct ns1__getTableList *)ptr, "ns1:getTableList");
	case SOAP_TYPE_ns1__getTableListResponse:
		return soap_out_ns1__getTableListResponse(soap, tag, id, (const struct ns1__getTableListResponse *)ptr, "ns1:getTableListResponse");
	case SOAP_TYPE_ns1__formattedTextSupport:
		return soap_out_ns1__formattedTextSupport(soap, tag, id, (const struct ns1__formattedTextSupport *)ptr, "ns1:formattedTextSupport");
	case SOAP_TYPE_ns1__formattedTextSupportResponse:
		return soap_out_ns1__formattedTextSupportResponse(soap, tag, id, (const struct ns1__formattedTextSupportResponse *)ptr, "ns1:formattedTextSupportResponse");
	case SOAP_TYPE_ns1__DatabaseLogoff:
		return soap_out_ns1__DatabaseLogoff(soap, tag, id, (const struct ns1__DatabaseLogoff *)ptr, "ns1:DatabaseLogoff");
	case SOAP_TYPE_ns1__DatabaseLogoffResponse:
		return soap_out_ns1__DatabaseLogoffResponse(soap, tag, id, (const struct ns1__DatabaseLogoffResponse *)ptr, "ns1:DatabaseLogoffResponse");
	case SOAP_TYPE_ns1__ProjectLogon:
		return soap_out_ns1__ProjectLogon(soap, tag, id, (const struct ns1__ProjectLogon *)ptr, "ns1:ProjectLogon");
	case SOAP_TYPE_ns1__ProjectLogonResponse:
		return soap_out_ns1__ProjectLogonResponse(soap, tag, id, (const struct ns1__ProjectLogonResponse *)ptr, "ns1:ProjectLogonResponse");
	case SOAP_TYPE_ns1__DatabaseLogon:
		return soap_out_ns1__DatabaseLogon(soap, tag, id, (const struct ns1__DatabaseLogon *)ptr, "ns1:DatabaseLogon");
	case SOAP_TYPE_ns1__DatabaseLogonResponse:
		return soap_out_ns1__DatabaseLogonResponse(soap, tag, id, (const struct ns1__DatabaseLogonResponse *)ptr, "ns1:DatabaseLogonResponse");
	case SOAP_TYPE_ns1__getProjectDataOptionList:
		return soap_out_ns1__getProjectDataOptionList(soap, tag, id, (const struct ns1__getProjectDataOptionList *)ptr, "ns1:getProjectDataOptionList");
	case SOAP_TYPE_ns1__getProjectDataOptionListResponse:
		return soap_out_ns1__getProjectDataOptionListResponse(soap, tag, id, (const struct ns1__getProjectDataOptionListResponse *)ptr, "ns1:getProjectDataOptionListResponse");
	case SOAP_TYPE_ns1__getProjectList:
		return soap_out_ns1__getProjectList(soap, tag, id, (const struct ns1__getProjectList *)ptr, "ns1:getProjectList");
	case SOAP_TYPE_ns1__getProjectListResponse:
		return soap_out_ns1__getProjectListResponse(soap, tag, id, (const struct ns1__getProjectListResponse *)ptr, "ns1:getProjectListResponse");
	case SOAP_TYPE_ns1__getDatabaseList:
		return soap_out_ns1__getDatabaseList(soap, tag, id, (const struct ns1__getDatabaseList *)ptr, "ns1:getDatabaseList");
	case SOAP_TYPE_ns1__getDatabaseListResponse:
		return soap_out_ns1__getDatabaseListResponse(soap, tag, id, (const struct ns1__getDatabaseListResponse *)ptr, "ns1:getDatabaseListResponse");
	case SOAP_TYPE_PointerTons1__CItemHyperlinkContainer:
		return soap_out_PointerTons1__CItemHyperlinkContainer(soap, tag, id, (ns1__CItemHyperlinkContainer *const*)ptr, "ns1:CItemHyperlinkContainer");
	case SOAP_TYPE_PointerTons1__CRequirementDocument:
		return soap_out_PointerTons1__CRequirementDocument(soap, tag, id, (ns1__CRequirementDocument *const*)ptr, "ns1:CRequirementDocument");
	case SOAP_TYPE_PointerToArrayOflong:
		return soap_out_PointerToArrayOflong(soap, tag, id, (ArrayOflong *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons1__CRequirement:
		return soap_out_PointerTons1__CRequirement(soap, tag, id, (ns1__CRequirement *const*)ptr, "ns1:CRequirement");
	case SOAP_TYPE_PointerToArrayOfCFolder:
		return soap_out_PointerToArrayOfCFolder(soap, tag, id, (ArrayOfCFolder *const*)ptr, "ns1:CFolder");
	case SOAP_TYPE_PointerToArrayOfCFolderItem:
		return soap_out_PointerToArrayOfCFolderItem(soap, tag, id, (ArrayOfCFolderItem *const*)ptr, "ns1:CFolderItem");
	case SOAP_TYPE_PointerToArrayOfCFolderType:
		return soap_out_PointerToArrayOfCFolderType(soap, tag, id, (ArrayOfCFolderType *const*)ptr, "ns1:CFolderType");
	case SOAP_TYPE_PointerToArrayOfCTestRunVariantField:
		return soap_out_PointerToArrayOfCTestRunVariantField(soap, tag, id, (ArrayOfCTestRunVariantField *const*)ptr, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerToArrayOfCItemToTrack:
		return soap_out_PointerToArrayOfCItemToTrack(soap, tag, id, (ArrayOfCItemToTrack *const*)ptr, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerTons1__CTestRun:
		return soap_out_PointerTons1__CTestRun(soap, tag, id, (ns1__CTestRun *const*)ptr, "ns1:CTestRun");
	case SOAP_TYPE_PointerTons1__CTestCase:
		return soap_out_PointerTons1__CTestCase(soap, tag, id, (ns1__CTestCase *const*)ptr, "ns1:CTestCase");
	case SOAP_TYPE_PointerToArrayOfCLink:
		return soap_out_PointerToArrayOfCLink(soap, tag, id, (ArrayOfCLink *const*)ptr, "ns1:CLink");
	case SOAP_TYPE_PointerTons1__CUser:
		return soap_out_PointerTons1__CUser(soap, tag, id, (ns1__CUser *const*)ptr, "ns1:CUser");
	case SOAP_TYPE_PointerToArrayOfCUserLicense:
		return soap_out_PointerToArrayOfCUserLicense(soap, tag, id, (ArrayOfCUserLicense *const*)ptr, "ns1:CUserLicense");
	case SOAP_TYPE_PointerToArrayOfCGlobalUser:
		return soap_out_PointerToArrayOfCGlobalUser(soap, tag, id, (ArrayOfCGlobalUser *const*)ptr, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerTons1__CTask:
		return soap_out_PointerTons1__CTask(soap, tag, id, (ns1__CTask *const*)ptr, "ns1:CTask");
	case SOAP_TYPE_PointerTons1__CDefect:
		return soap_out_PointerTons1__CDefect(soap, tag, id, (ns1__CDefect *const*)ptr, "ns1:CDefect");
	case SOAP_TYPE_PointerToArrayOfCDefectEventDefinition:
		return soap_out_PointerToArrayOfCDefectEventDefinition(soap, tag, id, (ArrayOfCDefectEventDefinition *const*)ptr, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToArrayOfCEventDefinition:
		return soap_out_PointerToArrayOfCEventDefinition(soap, tag, id, (ArrayOfCEventDefinition *const*)ptr, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerTons1__CReportRunResults:
		return soap_out_PointerTons1__CReportRunResults(soap, tag, id, (ns1__CReportRunResults *const*)ptr, "ns1:CReportRunResults");
	case SOAP_TYPE_PointerTons1__CRecordListSoap:
		return soap_out_PointerTons1__CRecordListSoap(soap, tag, id, (ns1__CRecordListSoap *const*)ptr, "ns1:CRecordListSoap");
	case SOAP_TYPE_PointerToArrayOfCFilter:
		return soap_out_PointerToArrayOfCFilter(soap, tag, id, (ArrayOfCFilter *const*)ptr, "ns1:CFilter");
	case SOAP_TYPE_PointerToArrayOfCTableField:
		return soap_out_PointerToArrayOfCTableField(soap, tag, id, (ArrayOfCTableField *const*)ptr, "ns1:CTableField");
	case SOAP_TYPE_PointerToArrayOfCDatabaseTable:
		return soap_out_PointerToArrayOfCDatabaseTable(soap, tag, id, (ArrayOfCDatabaseTable *const*)ptr, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerToArrayOfCProject:
		return soap_out_PointerToArrayOfCProject(soap, tag, id, (ArrayOfCProject *const*)ptr, "ns1:CProject");
	case SOAP_TYPE_PointerToArrayOfCDatabase:
		return soap_out_PointerToArrayOfCDatabase(soap, tag, id, (ArrayOfCDatabase *const*)ptr, "ns1:CDatabase");
	case SOAP_TYPE_PointerToArrayOfCSnapshotInfo:
		return soap_out_PointerToArrayOfCSnapshotInfo(soap, tag, id, (ArrayOfCSnapshotInfo *const*)ptr, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerToArrayOfCVersionInfo:
		return soap_out_PointerToArrayOfCVersionInfo(soap, tag, id, (ArrayOfCVersionInfo *const*)ptr, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerTons1__CScheduleInfo:
		return soap_out_PointerTons1__CScheduleInfo(soap, tag, id, (ns1__CScheduleInfo *const*)ptr, "ns1:CScheduleInfo");
	case SOAP_TYPE_PointerToArrayOfCTestCaseVariantField:
		return soap_out_PointerToArrayOfCTestCaseVariantField(soap, tag, id, (ArrayOfCTestCaseVariantField *const*)ptr, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToArrayOfCLinkHistoryItem:
		return soap_out_PointerToArrayOfCLinkHistoryItem(soap, tag, id, (ArrayOfCLinkHistoryItem *const*)ptr, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToArrayOfCLinkedItem:
		return soap_out_PointerToArrayOfCLinkedItem(soap, tag, id, (ArrayOfCLinkedItem *const*)ptr, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		return soap_out_PointerTons1__PhoneNumber(soap, tag, id, (ns1__PhoneNumber *const*)ptr, "ns1:PhoneNumber");
	case SOAP_TYPE_PointerToArrayOfCSCCFileRecord:
		return soap_out_PointerToArrayOfCSCCFileRecord(soap, tag, id, (ArrayOfCSCCFileRecord *const*)ptr, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerToArrayOfCEvent:
		return soap_out_PointerToArrayOfCEvent(soap, tag, id, (ArrayOfCEvent *const*)ptr, "ns1:CEvent");
	case SOAP_TYPE_PointerToArrayOfCReportedByRecord:
		return soap_out_PointerToArrayOfCReportedByRecord(soap, tag, id, (ArrayOfCReportedByRecord *const*)ptr, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerToPointerTons1__CTreeNodeSoap:
		return soap_out_PointerToPointerTons1__CTreeNodeSoap(soap, tag, id, (ns1__CTreeNodeSoap **const*)ptr, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerTons1__CTreeNodeSoap:
		return soap_out_PointerTons1__CTreeNodeSoap(soap, tag, id, (ns1__CTreeNodeSoap *const*)ptr, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerToPointerTons1__CSnapshotInfo:
		return soap_out_PointerToPointerTons1__CSnapshotInfo(soap, tag, id, (ns1__CSnapshotInfo **const*)ptr, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerTons1__CSnapshotInfo:
		return soap_out_PointerTons1__CSnapshotInfo(soap, tag, id, (ns1__CSnapshotInfo *const*)ptr, "ns1:CSnapshotInfo");
	case SOAP_TYPE_PointerToPointerTons1__CVersionInfo:
		return soap_out_PointerToPointerTons1__CVersionInfo(soap, tag, id, (ns1__CVersionInfo **const*)ptr, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerTons1__CVersionInfo:
		return soap_out_PointerTons1__CVersionInfo(soap, tag, id, (ns1__CVersionInfo *const*)ptr, "ns1:CVersionInfo");
	case SOAP_TYPE_PointerToPointerTons1__CFolderItem:
		return soap_out_PointerToPointerTons1__CFolderItem(soap, tag, id, (ns1__CFolderItem **const*)ptr, "ns1:CFolderItem");
	case SOAP_TYPE_PointerTons1__CFolderItem:
		return soap_out_PointerTons1__CFolderItem(soap, tag, id, (ns1__CFolderItem *const*)ptr, "ns1:CFolderItem");
	case SOAP_TYPE_PointerToPointerTons1__CFolder:
		return soap_out_PointerToPointerTons1__CFolder(soap, tag, id, (ns1__CFolder **const*)ptr, "ns1:CFolder");
	case SOAP_TYPE_PointerTons1__CFolder:
		return soap_out_PointerTons1__CFolder(soap, tag, id, (ns1__CFolder *const*)ptr, "ns1:CFolder");
	case SOAP_TYPE_PointerToPointerTons1__CFolderType:
		return soap_out_PointerToPointerTons1__CFolderType(soap, tag, id, (ns1__CFolderType **const*)ptr, "ns1:CFolderType");
	case SOAP_TYPE_PointerTons1__CFolderType:
		return soap_out_PointerTons1__CFolderType(soap, tag, id, (ns1__CFolderType *const*)ptr, "ns1:CFolderType");
	case SOAP_TYPE_PointerToPointerTons1__CItemToTrack:
		return soap_out_PointerToPointerTons1__CItemToTrack(soap, tag, id, (ns1__CItemToTrack **const*)ptr, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerTons1__CItemToTrack:
		return soap_out_PointerTons1__CItemToTrack(soap, tag, id, (ns1__CItemToTrack *const*)ptr, "ns1:CItemToTrack");
	case SOAP_TYPE_PointerToPointerTons1__CLink:
		return soap_out_PointerToPointerTons1__CLink(soap, tag, id, (ns1__CLink **const*)ptr, "ns1:CLink");
	case SOAP_TYPE_PointerTons1__CLink:
		return soap_out_PointerTons1__CLink(soap, tag, id, (ns1__CLink *const*)ptr, "ns1:CLink");
	case SOAP_TYPE_PointerToPointerTons1__CLinkHistoryItem:
		return soap_out_PointerToPointerTons1__CLinkHistoryItem(soap, tag, id, (ns1__CLinkHistoryItem **const*)ptr, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerTons1__CLinkHistoryItem:
		return soap_out_PointerTons1__CLinkHistoryItem(soap, tag, id, (ns1__CLinkHistoryItem *const*)ptr, "ns1:CLinkHistoryItem");
	case SOAP_TYPE_PointerToPointerTons1__CLinkedItem:
		return soap_out_PointerToPointerTons1__CLinkedItem(soap, tag, id, (ns1__CLinkedItem **const*)ptr, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerTons1__CLinkedItem:
		return soap_out_PointerTons1__CLinkedItem(soap, tag, id, (ns1__CLinkedItem *const*)ptr, "ns1:CLinkedItem");
	case SOAP_TYPE_PointerToPointerTons1__CUserLicense:
		return soap_out_PointerToPointerTons1__CUserLicense(soap, tag, id, (ns1__CUserLicense **const*)ptr, "ns1:CUserLicense");
	case SOAP_TYPE_PointerTons1__CUserLicense:
		return soap_out_PointerTons1__CUserLicense(soap, tag, id, (ns1__CUserLicense *const*)ptr, "ns1:CUserLicense");
	case SOAP_TYPE_PointerToPointerTons1__CGlobalUser:
		return soap_out_PointerToPointerTons1__CGlobalUser(soap, tag, id, (ns1__CGlobalUser **const*)ptr, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerTons1__CGlobalUser:
		return soap_out_PointerTons1__CGlobalUser(soap, tag, id, (ns1__CGlobalUser *const*)ptr, "ns1:CGlobalUser");
	case SOAP_TYPE_PointerToPointerTons1__CDefectEventDefinition:
		return soap_out_PointerToPointerTons1__CDefectEventDefinition(soap, tag, id, (ns1__CDefectEventDefinition **const*)ptr, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerTons1__CDefectEventDefinition:
		return soap_out_PointerTons1__CDefectEventDefinition(soap, tag, id, (ns1__CDefectEventDefinition *const*)ptr, "ns1:CDefectEventDefinition");
	case SOAP_TYPE_PointerToPointerTons1__CEventDefinition:
		return soap_out_PointerToPointerTons1__CEventDefinition(soap, tag, id, (ns1__CEventDefinition **const*)ptr, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerTons1__CEventDefinition:
		return soap_out_PointerTons1__CEventDefinition(soap, tag, id, (ns1__CEventDefinition *const*)ptr, "ns1:CEventDefinition");
	case SOAP_TYPE_PointerToPointerTons1__CDefectEvent:
		return soap_out_PointerToPointerTons1__CDefectEvent(soap, tag, id, (ns1__CDefectEvent **const*)ptr, "ns1:CDefectEvent");
	case SOAP_TYPE_PointerTons1__CDefectEvent:
		return soap_out_PointerTons1__CDefectEvent(soap, tag, id, (ns1__CDefectEvent *const*)ptr, "ns1:CDefectEvent");
	case SOAP_TYPE_PointerToPointerTons1__CEvent:
		return soap_out_PointerToPointerTons1__CEvent(soap, tag, id, (ns1__CEvent **const*)ptr, "ns1:CEvent");
	case SOAP_TYPE_PointerTons1__CEvent:
		return soap_out_PointerTons1__CEvent(soap, tag, id, (ns1__CEvent *const*)ptr, "ns1:CEvent");
	case SOAP_TYPE_PointerToArrayOfstring:
		return soap_out_PointerToArrayOfstring(soap, tag, id, (ArrayOfstring *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__CTestCaseVariantField:
		return soap_out_PointerToPointerTons1__CTestCaseVariantField(soap, tag, id, (ns1__CTestCaseVariantField **const*)ptr, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerTons1__CTestCaseVariantField:
		return soap_out_PointerTons1__CTestCaseVariantField(soap, tag, id, (ns1__CTestCaseVariantField *const*)ptr, "ns1:CTestCaseVariantField");
	case SOAP_TYPE_PointerToPointerTons1__CTestRunVariantField:
		return soap_out_PointerToPointerTons1__CTestRunVariantField(soap, tag, id, (ns1__CTestRunVariantField **const*)ptr, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerTons1__CTestRunVariantField:
		return soap_out_PointerTons1__CTestRunVariantField(soap, tag, id, (ns1__CTestRunVariantField *const*)ptr, "ns1:CTestRunVariantField");
	case SOAP_TYPE_PointerToPointerTons1__CField:
		return soap_out_PointerToPointerTons1__CField(soap, tag, id, (ns1__CField **const*)ptr, "ns1:CField");
	case SOAP_TYPE_PointerTons1__CField:
		return soap_out_PointerTons1__CField(soap, tag, id, (ns1__CField *const*)ptr, "ns1:CField");
	case SOAP_TYPE_PointerToPointerTons1__CReportedByRecord:
		return soap_out_PointerToPointerTons1__CReportedByRecord(soap, tag, id, (ns1__CReportedByRecord **const*)ptr, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerTons1__CReportedByRecord:
		return soap_out_PointerTons1__CReportedByRecord(soap, tag, id, (ns1__CReportedByRecord *const*)ptr, "ns1:CReportedByRecord");
	case SOAP_TYPE_PointerToshort:
		return soap_out_PointerToshort(soap, tag, id, (short *const*)ptr, "xsd:short");
	case SOAP_TYPE_PointerTons1__CSystem:
		return soap_out_PointerTons1__CSystem(soap, tag, id, (ns1__CSystem *const*)ptr, "ns1:CSystem");
	case SOAP_TYPE_PointerToArrayOfCFileAttachment:
		return soap_out_PointerToArrayOfCFileAttachment(soap, tag, id, (ArrayOfCFileAttachment *const*)ptr, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerTons1__CFileAttachment:
		return soap_out_PointerToPointerTons1__CFileAttachment(soap, tag, id, (ns1__CFileAttachment **const*)ptr, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerTons1__CFileAttachment:
		return soap_out_PointerTons1__CFileAttachment(soap, tag, id, (ns1__CFileAttachment *const*)ptr, "ns1:CFileAttachment");
	case SOAP_TYPE_PointerToPointerTons1__CFile:
		return soap_out_PointerToPointerTons1__CFile(soap, tag, id, (ns1__CFile **const*)ptr, "ns1:CFile");
	case SOAP_TYPE_PointerTons1__CFile:
		return soap_out_PointerTons1__CFile(soap, tag, id, (ns1__CFile *const*)ptr, "ns1:CFile");
	case SOAP_TYPE_PointerToPointerTons1__CSCCFileRecord:
		return soap_out_PointerToPointerTons1__CSCCFileRecord(soap, tag, id, (ns1__CSCCFileRecord **const*)ptr, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerTons1__CSCCFileRecord:
		return soap_out_PointerTons1__CSCCFileRecord(soap, tag, id, (ns1__CSCCFileRecord *const*)ptr, "ns1:CSCCFileRecord");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons1__CRecordRowSoap:
		return soap_out_PointerToPointerTons1__CRecordRowSoap(soap, tag, id, (ns1__CRecordRowSoap **const*)ptr, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerTons1__CRecordRowSoap:
		return soap_out_PointerTons1__CRecordRowSoap(soap, tag, id, (ns1__CRecordRowSoap *const*)ptr, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerToPointerTons1__CRecordData:
		return soap_out_PointerToPointerTons1__CRecordData(soap, tag, id, (ns1__CRecordData **const*)ptr, "ns1:CRecordData");
	case SOAP_TYPE_PointerTons1__CRecordData:
		return soap_out_PointerTons1__CRecordData(soap, tag, id, (ns1__CRecordData *const*)ptr, "ns1:CRecordData");
	case SOAP_TYPE_PointerToPointerTons1__CFilter:
		return soap_out_PointerToPointerTons1__CFilter(soap, tag, id, (ns1__CFilter **const*)ptr, "ns1:CFilter");
	case SOAP_TYPE_PointerTons1__CFilter:
		return soap_out_PointerTons1__CFilter(soap, tag, id, (ns1__CFilter *const*)ptr, "ns1:CFilter");
	case SOAP_TYPE_PointerToPointerTons1__CTableColumn:
		return soap_out_PointerToPointerTons1__CTableColumn(soap, tag, id, (ns1__CTableColumn **const*)ptr, "ns1:CTableColumn");
	case SOAP_TYPE_PointerTons1__CTableColumn:
		return soap_out_PointerTons1__CTableColumn(soap, tag, id, (ns1__CTableColumn *const*)ptr, "ns1:CTableColumn");
	case SOAP_TYPE_PointerToPointerTons1__CFieldValue:
		return soap_out_PointerToPointerTons1__CFieldValue(soap, tag, id, (ns1__CFieldValue **const*)ptr, "ns1:CFieldValue");
	case SOAP_TYPE_PointerTons1__CFieldValue:
		return soap_out_PointerTons1__CFieldValue(soap, tag, id, (ns1__CFieldValue *const*)ptr, "ns1:CFieldValue");
	case SOAP_TYPE_PointerToPointerTons1__CTableField:
		return soap_out_PointerToPointerTons1__CTableField(soap, tag, id, (ns1__CTableField **const*)ptr, "ns1:CTableField");
	case SOAP_TYPE_PointerTons1__CTableField:
		return soap_out_PointerTons1__CTableField(soap, tag, id, (ns1__CTableField *const*)ptr, "ns1:CTableField");
	case SOAP_TYPE_PointerToPointerTons1__CDatabaseTable:
		return soap_out_PointerToPointerTons1__CDatabaseTable(soap, tag, id, (ns1__CDatabaseTable **const*)ptr, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerTons1__CDatabaseTable:
		return soap_out_PointerTons1__CDatabaseTable(soap, tag, id, (ns1__CDatabaseTable *const*)ptr, "ns1:CDatabaseTable");
	case SOAP_TYPE_PointerToPointerTons1__CProject:
		return soap_out_PointerToPointerTons1__CProject(soap, tag, id, (ns1__CProject **const*)ptr, "ns1:CProject");
	case SOAP_TYPE_PointerTons1__CProject:
		return soap_out_PointerTons1__CProject(soap, tag, id, (ns1__CProject *const*)ptr, "ns1:CProject");
	case SOAP_TYPE_PointerToPointerTons1__CProjectDataOption:
		return soap_out_PointerToPointerTons1__CProjectDataOption(soap, tag, id, (ns1__CProjectDataOption **const*)ptr, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerTons1__CProjectDataOption:
		return soap_out_PointerTons1__CProjectDataOption(soap, tag, id, (ns1__CProjectDataOption *const*)ptr, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerToPointerTons1__CDatabase:
		return soap_out_PointerToPointerTons1__CDatabase(soap, tag, id, (ns1__CDatabase **const*)ptr, "ns1:CDatabase");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToArrayOfCTreeNodeSoap:
		return soap_out_PointerToArrayOfCTreeNodeSoap(soap, tag, id, (ArrayOfCTreeNodeSoap *const*)ptr, "ns1:CTreeNodeSoap");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerToLONG64:
		return soap_out_PointerToLONG64(soap, tag, id, (LONG64 *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToArrayOfCField:
		return soap_out_PointerToArrayOfCField(soap, tag, id, (ArrayOfCField *const*)ptr, "ns1:CField");
	case SOAP_TYPE_PointerToArrayOfCFieldValue:
		return soap_out_PointerToArrayOfCFieldValue(soap, tag, id, (ArrayOfCFieldValue *const*)ptr, "ns1:CFieldValue");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerToArrayOfCFile:
		return soap_out_PointerToArrayOfCFile(soap, tag, id, (ArrayOfCFile *const*)ptr, "ns1:CFile");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerToArrayOfCRecordRowSoap:
		return soap_out_PointerToArrayOfCRecordRowSoap(soap, tag, id, (ArrayOfCRecordRowSoap *const*)ptr, "ns1:CRecordRowSoap");
	case SOAP_TYPE_PointerToArrayOfCTableColumn:
		return soap_out_PointerToArrayOfCTableColumn(soap, tag, id, (ArrayOfCTableColumn *const*)ptr, "ns1:CTableColumn");
	case SOAP_TYPE_PointerToArrayOfCRecordData:
		return soap_out_PointerToArrayOfCRecordData(soap, tag, id, (ArrayOfCRecordData *const*)ptr, "ns1:CRecordData");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToArrayOfCProjectDataOption:
		return soap_out_PointerToArrayOfCProjectDataOption(soap, tag, id, (ArrayOfCProjectDataOption *const*)ptr, "ns1:CProjectDataOption");
	case SOAP_TYPE_PointerTons1__CDatabase:
		return soap_out_PointerTons1__CDatabase(soap, tag, id, (ns1__CDatabase *const*)ptr, "ns1:CDatabase");
	case SOAP_TYPE_xsd__date:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:date");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__CItemHyperlinkContainer:
		((ns1__CItemHyperlinkContainer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDocumentTreeNode:
		((ns1__CDocumentTreeNode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTreeNodeSoap:
		((ArrayOfCTreeNodeSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTreeNodeSoap:
		((ns1__CTreeNodeSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CRequirementDocument:
		((ns1__CRequirementDocument *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CRequirement:
		((ns1__CRequirement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCSnapshotInfo:
		((ArrayOfCSnapshotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CSnapshotInfo:
		((ns1__CSnapshotInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCVersionInfo:
		((ArrayOfCVersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CVersionInfo:
		((ns1__CVersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFolderItem:
		((ArrayOfCFolderItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFolder:
		((ArrayOfCFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFolderItem:
		((ns1__CFolderItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFolder:
		((ns1__CFolder *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFolderType:
		((ArrayOfCFolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFolderType:
		((ns1__CFolderType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CScheduleInfo:
		((ns1__CScheduleInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCItemToTrack:
		((ArrayOfCItemToTrack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTestRun:
		((ns1__CTestRun *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTestCase:
		((ns1__CTestCase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCLink:
		((ArrayOfCLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CLink:
		((ns1__CLink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCLinkHistoryItem:
		((ArrayOfCLinkHistoryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CLinkHistoryItem:
		((ns1__CLinkHistoryItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCLinkedItem:
		((ArrayOfCLinkedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CLinkedItem:
		((ns1__CLinkedItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCUserLicense:
		((ArrayOfCUserLicense *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CUserLicense:
		((ns1__CUserLicense *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCGlobalUser:
		((ArrayOfCGlobalUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CGlobalUser:
		((ns1__CGlobalUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CUser:
		((ns1__CUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PhoneNumber:
		((ns1__PhoneNumber *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTask:
		((ns1__CTask *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDefect:
		((ns1__CDefect *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCDefectEventDefinition:
		((ArrayOfCDefectEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDefectEventDefinition:
		((ns1__CDefectEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCEventDefinition:
		((ArrayOfCEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CEventDefinition:
		((ns1__CEventDefinition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCDefectEvent:
		((ArrayOfCDefectEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDefectEvent:
		((ns1__CDefectEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCEvent:
		((ArrayOfCEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CEvent:
		((ns1__CEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTestCaseVariantField:
		((ArrayOfCTestCaseVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTestRunVariantField:
		((ArrayOfCTestRunVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCField:
		((ArrayOfCField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTimespanField:
		((ns1__CTimespanField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CVersionField:
		((ns1__CVersionField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTestCaseVariantField:
		((ns1__CTestCaseVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTestRunVariantField:
		((ns1__CTestRunVariantField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CMultiSelectDropdownField:
		((ns1__CMultiSelectDropdownField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDropdownField:
		((ns1__CDropdownField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDateTimeField:
		((ns1__CDateTimeField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDateField:
		((ns1__CDateField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CBooleanField:
		((ns1__CBooleanField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDecimalField:
		((ns1__CDecimalField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CIntegerField:
		((ns1__CIntegerField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CStringField:
		((ns1__CStringField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CField:
		((ns1__CField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCReportedByRecord:
		((ArrayOfCReportedByRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CReportedByRecord:
		((ns1__CReportedByRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFileAttachment:
		((ArrayOfCFileAttachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFileAttachment:
		((ns1__CFileAttachment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CReportRunResults:
		((ns1__CReportRunResults *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFile:
		((ArrayOfCFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFile:
		((ns1__CFile *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCSCCFileRecord:
		((ArrayOfCSCCFileRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CSCCFileRecord:
		((ns1__CSCCFileRecord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CSystem:
		((ns1__CSystem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CSystemBase:
		((ns1__CSystemBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__COrderedItemWithDBRecordId:
		((ns1__COrderedItemWithDBRecordId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CItemToTrack:
		((ns1__CItemToTrack *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CItemWithDBRecordId:
		((ns1__CItemWithDBRecordId *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CRecordListSoap:
		((ns1__CRecordListSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCRecordRowSoap:
		((ArrayOfCRecordRowSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CRecordRowSoap:
		((ns1__CRecordRowSoap *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCRecordData:
		((ArrayOfCRecordData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CRecordData:
		((ns1__CRecordData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFilter:
		((ArrayOfCFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFilter:
		((ns1__CFilter *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTableColumn:
		((ArrayOfCTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTableColumn:
		((ns1__CTableColumn *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCFieldValue:
		((ArrayOfCFieldValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CFieldValue:
		((ns1__CFieldValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTableField:
		((ArrayOfCTableField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTableField:
		((ns1__CTableField *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCDatabaseTable:
		((ArrayOfCDatabaseTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDatabaseTable:
		((ns1__CDatabaseTable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCProject:
		((ArrayOfCProject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CProject:
		((ns1__CProject *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCProjectDataOption:
		((ArrayOfCProjectDataOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CProjectDataOption:
		((ns1__CProjectDataOption *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCDatabase:
		((ArrayOfCDatabase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CDatabase:
		((ns1__CDatabase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOflong:
		((ArrayOflong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfstring:
		((ArrayOfstring *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getItemHyperlinks:
		soap_serialize_ns1__getItemHyperlinks(soap, (const struct ns1__getItemHyperlinks *)ptr);
		break;
	case SOAP_TYPE_ns1__getItemHyperlinksResponse:
		soap_serialize_ns1__getItemHyperlinksResponse(soap, (const struct ns1__getItemHyperlinksResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTree:
		soap_serialize_ns1__getFolderTree(soap, (const struct ns1__getFolderTree *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeResponse:
		soap_serialize_ns1__getFolderTreeResponse(soap, (const struct ns1__getFolderTreeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeByRecordID:
		soap_serialize_ns1__getFolderTreeByRecordID(soap, (const struct ns1__getFolderTreeByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse:
		soap_serialize_ns1__getFolderTreeByRecordIDResponse(soap, (const struct ns1__getFolderTreeByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentTree:
		soap_serialize_ns1__getDocumentTree(soap, (const struct ns1__getDocumentTree *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentTreeResponse:
		soap_serialize_ns1__getDocumentTreeResponse(soap, (const struct ns1__getDocumentTreeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementIDsForDocument:
		soap_serialize_ns1__getRequirementIDsForDocument(soap, (const struct ns1__getRequirementIDsForDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse:
		soap_serialize_ns1__getRequirementIDsForDocumentResponse(soap, (const struct ns1__getRequirementIDsForDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__createSnapshot:
		soap_serialize_ns1__createSnapshot(soap, (const struct ns1__createSnapshot *)ptr);
		break;
	case SOAP_TYPE_ns1__createSnapshotResponse:
		soap_serialize_ns1__createSnapshotResponse(soap, (const struct ns1__createSnapshotResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementDocument:
		soap_serialize_ns1__cancelSaveRequirementDocument(soap, (const struct ns1__cancelSaveRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse:
		soap_serialize_ns1__cancelSaveRequirementDocumentResponse(soap, (const struct ns1__cancelSaveRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementDocument:
		soap_serialize_ns1__saveRequirementDocument(soap, (const struct ns1__saveRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementDocumentResponse:
		soap_serialize_ns1__saveRequirementDocumentResponse(soap, (const struct ns1__saveRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordID:
		soap_serialize_ns1__editRequirementDocumentByRecordID(soap, (const struct ns1__editRequirementDocumentByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse:
		soap_serialize_ns1__editRequirementDocumentByRecordIDResponse(soap, (const struct ns1__editRequirementDocumentByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocument:
		soap_serialize_ns1__editRequirementDocument(soap, (const struct ns1__editRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentResponse:
		soap_serialize_ns1__editRequirementDocumentResponse(soap, (const struct ns1__editRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID:
		soap_serialize_ns1__deleteRequirementDocumentByRecordID(soap, (const struct ns1__deleteRequirementDocumentByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse:
		soap_serialize_ns1__deleteRequirementDocumentByRecordIDResponse(soap, (const struct ns1__deleteRequirementDocumentByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocument:
		soap_serialize_ns1__deleteRequirementDocument(soap, (const struct ns1__deleteRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentResponse:
		soap_serialize_ns1__deleteRequirementDocumentResponse(soap, (const struct ns1__deleteRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementDocument:
		soap_serialize_ns1__addRequirementDocument(soap, (const struct ns1__addRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementDocumentResponse:
		soap_serialize_ns1__addRequirementDocumentResponse(soap, (const struct ns1__addRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordID:
		soap_serialize_ns1__getRequirementDocumentByRecordID(soap, (const struct ns1__getRequirementDocumentByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse:
		soap_serialize_ns1__getRequirementDocumentByRecordIDResponse(soap, (const struct ns1__getRequirementDocumentByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocument:
		soap_serialize_ns1__getRequirementDocument(soap, (const struct ns1__getRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentResponse:
		soap_serialize_ns1__getRequirementDocumentResponse(soap, (const struct ns1__getRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__changeRequirementType:
		soap_serialize_ns1__changeRequirementType(soap, (const struct ns1__changeRequirementType *)ptr);
		break;
	case SOAP_TYPE_ns1__changeRequirementTypeResponse:
		soap_serialize_ns1__changeRequirementTypeResponse(soap, (const struct ns1__changeRequirementTypeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentIDsForRequirement:
		soap_serialize_ns1__getDocumentIDsForRequirement(soap, (const struct ns1__getDocumentIDsForRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse:
		soap_serialize_ns1__getDocumentIDsForRequirementResponse(soap, (const struct ns1__getDocumentIDsForRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__appendToRequirementDocument:
		soap_serialize_ns1__appendToRequirementDocument(soap, (const struct ns1__appendToRequirementDocument *)ptr);
		break;
	case SOAP_TYPE_ns1__appendToRequirementDocumentResponse:
		soap_serialize_ns1__appendToRequirementDocumentResponse(soap, (const struct ns1__appendToRequirementDocumentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirement:
		soap_serialize_ns1__cancelSaveRequirement(soap, (const struct ns1__cancelSaveRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementResponse:
		soap_serialize_ns1__cancelSaveRequirementResponse(soap, (const struct ns1__cancelSaveRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirement:
		soap_serialize_ns1__saveRequirement(soap, (const struct ns1__saveRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementResponse:
		soap_serialize_ns1__saveRequirementResponse(soap, (const struct ns1__saveRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementByRecordID:
		soap_serialize_ns1__editRequirementByRecordID(soap, (const struct ns1__editRequirementByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementByRecordIDResponse:
		soap_serialize_ns1__editRequirementByRecordIDResponse(soap, (const struct ns1__editRequirementByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirement:
		soap_serialize_ns1__editRequirement(soap, (const struct ns1__editRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementResponse:
		soap_serialize_ns1__editRequirementResponse(soap, (const struct ns1__editRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementByRecordID:
		soap_serialize_ns1__deleteRequirementByRecordID(soap, (const struct ns1__deleteRequirementByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse:
		soap_serialize_ns1__deleteRequirementByRecordIDResponse(soap, (const struct ns1__deleteRequirementByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirement:
		soap_serialize_ns1__deleteRequirement(soap, (const struct ns1__deleteRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementResponse:
		soap_serialize_ns1__deleteRequirementResponse(soap, (const struct ns1__deleteRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addRequirement:
		soap_serialize_ns1__addRequirement(soap, (const struct ns1__addRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementResponse:
		soap_serialize_ns1__addRequirementResponse(soap, (const struct ns1__addRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementByRecordID:
		soap_serialize_ns1__getRequirementByRecordID(soap, (const struct ns1__getRequirementByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementByRecordIDResponse:
		soap_serialize_ns1__getRequirementByRecordIDResponse(soap, (const struct ns1__getRequirementByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirement:
		soap_serialize_ns1__getRequirement(soap, (const struct ns1__getRequirement *)ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementResponse:
		soap_serialize_ns1__getRequirementResponse(soap, (const struct ns1__getRequirementResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderItemRank:
		soap_serialize_ns1__cancelSaveFolderItemRank(soap, (const struct ns1__cancelSaveFolderItemRank *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse:
		soap_serialize_ns1__cancelSaveFolderItemRankResponse(soap, (const struct ns1__cancelSaveFolderItemRankResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderItemRank:
		soap_serialize_ns1__saveFolderItemRank(soap, (const struct ns1__saveFolderItemRank *)ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderItemRankResponse:
		soap_serialize_ns1__saveFolderItemRankResponse(soap, (const struct ns1__saveFolderItemRankResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolderItemRank:
		soap_serialize_ns1__editFolderItemRank(soap, (const struct ns1__editFolderItemRank *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolderItemRankResponse:
		soap_serialize_ns1__editFolderItemRankResponse(soap, (const struct ns1__editFolderItemRankResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRootPrivateFolderPath:
		soap_serialize_ns1__getRootPrivateFolderPath(soap, (const struct ns1__getRootPrivateFolderPath *)ptr);
		break;
	case SOAP_TYPE_ns1__getRootPrivateFolderPathResponse:
		soap_serialize_ns1__getRootPrivateFolderPathResponse(soap, (const struct ns1__getRootPrivateFolderPathResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRootPublicFolderPath:
		soap_serialize_ns1__getRootPublicFolderPath(soap, (const struct ns1__getRootPublicFolderPath *)ptr);
		break;
	case SOAP_TYPE_ns1__getRootPublicFolderPathResponse:
		soap_serialize_ns1__getRootPublicFolderPathResponse(soap, (const struct ns1__getRootPublicFolderPathResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderPathSeparator:
		soap_serialize_ns1__getFolderPathSeparator(soap, (const struct ns1__getFolderPathSeparator *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderPathSeparatorResponse:
		soap_serialize_ns1__getFolderPathSeparatorResponse(soap, (const struct ns1__getFolderPathSeparatorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordID:
		soap_serialize_ns1__getFolderListForEntityByRecordID(soap, (const struct ns1__getFolderListForEntityByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse:
		soap_serialize_ns1__getFolderListForEntityByRecordIDResponse(soap, (const struct ns1__getFolderListForEntityByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordID:
		soap_serialize_ns1__getEntityListForFolderByRecordID(soap, (const struct ns1__getEntityListForFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse:
		soap_serialize_ns1__getEntityListForFolderByRecordIDResponse(soap, (const struct ns1__getEntityListForFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordID:
		soap_serialize_ns1__removeEntityFromFolderByRecordID(soap, (const struct ns1__removeEntityFromFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse:
		soap_serialize_ns1__removeEntityFromFolderByRecordIDResponse(soap, (const struct ns1__removeEntityFromFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addEntityToFolderByRecordID:
		soap_serialize_ns1__addEntityToFolderByRecordID(soap, (const struct ns1__addEntityToFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse:
		soap_serialize_ns1__addEntityToFolderByRecordIDResponse(soap, (const struct ns1__addEntityToFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderByRecordID:
		soap_serialize_ns1__deleteFolderByRecordID(soap, (const struct ns1__deleteFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderByRecordIDResponse:
		soap_serialize_ns1__deleteFolderByRecordIDResponse(soap, (const struct ns1__deleteFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolder:
		soap_serialize_ns1__deleteFolder(soap, (const struct ns1__deleteFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderResponse:
		soap_serialize_ns1__deleteFolderResponse(soap, (const struct ns1__deleteFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderByRecordID:
		soap_serialize_ns1__getFolderByRecordID(soap, (const struct ns1__getFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderByRecordIDResponse:
		soap_serialize_ns1__getFolderByRecordIDResponse(soap, (const struct ns1__getFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolder:
		soap_serialize_ns1__getFolder(soap, (const struct ns1__getFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderResponse:
		soap_serialize_ns1__getFolderResponse(soap, (const struct ns1__getFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolder:
		soap_serialize_ns1__cancelSaveFolder(soap, (const struct ns1__cancelSaveFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderResponse:
		soap_serialize_ns1__cancelSaveFolderResponse(soap, (const struct ns1__cancelSaveFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveFolder:
		soap_serialize_ns1__saveFolder(soap, (const struct ns1__saveFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderResponse:
		soap_serialize_ns1__saveFolderResponse(soap, (const struct ns1__saveFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolderByRecordID:
		soap_serialize_ns1__editFolderByRecordID(soap, (const struct ns1__editFolderByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolderByRecordIDResponse:
		soap_serialize_ns1__editFolderByRecordIDResponse(soap, (const struct ns1__editFolderByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolder:
		soap_serialize_ns1__editFolder(soap, (const struct ns1__editFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__editFolderResponse:
		soap_serialize_ns1__editFolderResponse(soap, (const struct ns1__editFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addFolder:
		soap_serialize_ns1__addFolder(soap, (const struct ns1__addFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__addFolderResponse:
		soap_serialize_ns1__addFolderResponse(soap, (const struct ns1__addFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeList:
		soap_serialize_ns1__getFolderTypeList(soap, (const struct ns1__getFolderTypeList *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeListResponse:
		soap_serialize_ns1__getFolderTypeListResponse(soap, (const struct ns1__getFolderTypeListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeByName:
		soap_serialize_ns1__getFolderTypeByName(soap, (const struct ns1__getFolderTypeByName *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeByNameResponse:
		soap_serialize_ns1__getFolderTypeByNameResponse(soap, (const struct ns1__getFolderTypeByNameResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__generateTestRuns:
		soap_serialize_ns1__generateTestRuns(soap, (const struct ns1__generateTestRuns *)ptr);
		break;
	case SOAP_TYPE_ns1__generateTestRunsResponse:
		soap_serialize_ns1__generateTestRunsResponse(soap, (const struct ns1__generateTestRunsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__createDefectForTestRun:
		soap_serialize_ns1__createDefectForTestRun(soap, (const struct ns1__createDefectForTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__createDefectForTestRunResponse:
		soap_serialize_ns1__createDefectForTestRunResponse(soap, (const struct ns1__createDefectForTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestRun:
		soap_serialize_ns1__cancelSaveTestRun(soap, (const struct ns1__cancelSaveTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestRunResponse:
		soap_serialize_ns1__cancelSaveTestRunResponse(soap, (const struct ns1__cancelSaveTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestRun:
		soap_serialize_ns1__saveTestRun(soap, (const struct ns1__saveTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestRunResponse:
		soap_serialize_ns1__saveTestRunResponse(soap, (const struct ns1__saveTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunByRecordID:
		soap_serialize_ns1__editTestRunByRecordID(soap, (const struct ns1__editTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunByRecordIDResponse:
		soap_serialize_ns1__editTestRunByRecordIDResponse(soap, (const struct ns1__editTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestRun:
		soap_serialize_ns1__editTestRun(soap, (const struct ns1__editTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunResponse:
		soap_serialize_ns1__editTestRunResponse(soap, (const struct ns1__editTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunByRecordID:
		soap_serialize_ns1__deleteTestRunByRecordID(soap, (const struct ns1__deleteTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse:
		soap_serialize_ns1__deleteTestRunByRecordIDResponse(soap, (const struct ns1__deleteTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRun:
		soap_serialize_ns1__deleteTestRun(soap, (const struct ns1__deleteTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunResponse:
		soap_serialize_ns1__deleteTestRunResponse(soap, (const struct ns1__deleteTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunByRecordID:
		soap_serialize_ns1__getTestRunByRecordID(soap, (const struct ns1__getTestRunByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunByRecordIDResponse:
		soap_serialize_ns1__getTestRunByRecordIDResponse(soap, (const struct ns1__getTestRunByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRun:
		soap_serialize_ns1__getTestRun(soap, (const struct ns1__getTestRun *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunResponse:
		soap_serialize_ns1__getTestRunResponse(soap, (const struct ns1__getTestRunResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestCase:
		soap_serialize_ns1__cancelSaveTestCase(soap, (const struct ns1__cancelSaveTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestCaseResponse:
		soap_serialize_ns1__cancelSaveTestCaseResponse(soap, (const struct ns1__cancelSaveTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestCase:
		soap_serialize_ns1__saveTestCase(soap, (const struct ns1__saveTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestCaseResponse:
		soap_serialize_ns1__saveTestCaseResponse(soap, (const struct ns1__saveTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseByRecordID:
		soap_serialize_ns1__editTestCaseByRecordID(soap, (const struct ns1__editTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseByRecordIDResponse:
		soap_serialize_ns1__editTestCaseByRecordIDResponse(soap, (const struct ns1__editTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestCase:
		soap_serialize_ns1__editTestCase(soap, (const struct ns1__editTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseResponse:
		soap_serialize_ns1__editTestCaseResponse(soap, (const struct ns1__editTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseByRecordID:
		soap_serialize_ns1__deleteTestCaseByRecordID(soap, (const struct ns1__deleteTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse:
		soap_serialize_ns1__deleteTestCaseByRecordIDResponse(soap, (const struct ns1__deleteTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCase:
		soap_serialize_ns1__deleteTestCase(soap, (const struct ns1__deleteTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseResponse:
		soap_serialize_ns1__deleteTestCaseResponse(soap, (const struct ns1__deleteTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addTestCase:
		soap_serialize_ns1__addTestCase(soap, (const struct ns1__addTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__addTestCaseResponse:
		soap_serialize_ns1__addTestCaseResponse(soap, (const struct ns1__addTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseByRecordID:
		soap_serialize_ns1__getTestCaseByRecordID(soap, (const struct ns1__getTestCaseByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseByRecordIDResponse:
		soap_serialize_ns1__getTestCaseByRecordIDResponse(soap, (const struct ns1__getTestCaseByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestCase:
		soap_serialize_ns1__getTestCase(soap, (const struct ns1__getTestCase *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseResponse:
		soap_serialize_ns1__getTestCaseResponse(soap, (const struct ns1__getTestCaseResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunStepsModes:
		soap_serialize_ns1__getTestRunStepsModes(soap, (const struct ns1__getTestRunStepsModes *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunStepsModesResponse:
		soap_serialize_ns1__getTestRunStepsModesResponse(soap, (const struct ns1__getTestRunStepsModesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestVariantTypes:
		soap_serialize_ns1__getTestVariantTypes(soap, (const struct ns1__getTestVariantTypes *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestVariantTypesResponse:
		soap_serialize_ns1__getTestVariantTypesResponse(soap, (const struct ns1__getTestVariantTypesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveLink:
		soap_serialize_ns1__cancelSaveLink(soap, (const struct ns1__cancelSaveLink *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveLinkResponse:
		soap_serialize_ns1__cancelSaveLinkResponse(soap, (const struct ns1__cancelSaveLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveLink:
		soap_serialize_ns1__saveLink(soap, (const struct ns1__saveLink *)ptr);
		break;
	case SOAP_TYPE_ns1__saveLinkResponse:
		soap_serialize_ns1__saveLinkResponse(soap, (const struct ns1__saveLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editLink:
		soap_serialize_ns1__editLink(soap, (const struct ns1__editLink *)ptr);
		break;
	case SOAP_TYPE_ns1__editLinkResponse:
		soap_serialize_ns1__editLinkResponse(soap, (const struct ns1__editLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteLink:
		soap_serialize_ns1__deleteLink(soap, (const struct ns1__deleteLink *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteLinkResponse:
		soap_serialize_ns1__deleteLinkResponse(soap, (const struct ns1__deleteLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addLink:
		soap_serialize_ns1__addLink(soap, (const struct ns1__addLink *)ptr);
		break;
	case SOAP_TYPE_ns1__addLinkResponse:
		soap_serialize_ns1__addLinkResponse(soap, (const struct ns1__addLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getLink:
		soap_serialize_ns1__getLink(soap, (const struct ns1__getLink *)ptr);
		break;
	case SOAP_TYPE_ns1__getLinkResponse:
		soap_serialize_ns1__getLinkResponse(soap, (const struct ns1__getLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForDefect:
		soap_serialize_ns1__getLinksForDefect(soap, (const struct ns1__getLinksForDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForDefectResponse:
		soap_serialize_ns1__getLinksForDefectResponse(soap, (const struct ns1__getLinksForDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForItem:
		soap_serialize_ns1__getLinksForItem(soap, (const struct ns1__getLinksForItem *)ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForItemResponse:
		soap_serialize_ns1__getLinksForItemResponse(soap, (const struct ns1__getLinksForItemResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalCustomer:
		soap_serialize_ns1__addGlobalCustomer(soap, (const struct ns1__addGlobalCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalCustomerResponse:
		soap_serialize_ns1__addGlobalCustomerResponse(soap, (const struct ns1__addGlobalCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__promoteCustomer:
		soap_serialize_ns1__promoteCustomer(soap, (const struct ns1__promoteCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__promoteCustomerResponse:
		soap_serialize_ns1__promoteCustomerResponse(soap, (const struct ns1__promoteCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveCustomer:
		soap_serialize_ns1__cancelSaveCustomer(soap, (const struct ns1__cancelSaveCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveCustomerResponse:
		soap_serialize_ns1__cancelSaveCustomerResponse(soap, (const struct ns1__cancelSaveCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerByRecordID:
		soap_serialize_ns1__deleteCustomerByRecordID(soap, (const struct ns1__deleteCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse:
		soap_serialize_ns1__deleteCustomerByRecordIDResponse(soap, (const struct ns1__deleteCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomer:
		soap_serialize_ns1__deleteCustomer(soap, (const struct ns1__deleteCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerResponse:
		soap_serialize_ns1__deleteCustomerResponse(soap, (const struct ns1__deleteCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveCustomer:
		soap_serialize_ns1__saveCustomer(soap, (const struct ns1__saveCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__saveCustomerResponse:
		soap_serialize_ns1__saveCustomerResponse(soap, (const struct ns1__saveCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerByRecordID:
		soap_serialize_ns1__editCustomerByRecordID(soap, (const struct ns1__editCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerByRecordIDResponse:
		soap_serialize_ns1__editCustomerByRecordIDResponse(soap, (const struct ns1__editCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editCustomer:
		soap_serialize_ns1__editCustomer(soap, (const struct ns1__editCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerResponse:
		soap_serialize_ns1__editCustomerResponse(soap, (const struct ns1__editCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addCustomer:
		soap_serialize_ns1__addCustomer(soap, (const struct ns1__addCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__addCustomerResponse:
		soap_serialize_ns1__addCustomerResponse(soap, (const struct ns1__addCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerByRecordID:
		soap_serialize_ns1__getCustomerByRecordID(soap, (const struct ns1__getCustomerByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerByRecordIDResponse:
		soap_serialize_ns1__getCustomerByRecordIDResponse(soap, (const struct ns1__getCustomerByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomer:
		soap_serialize_ns1__getCustomer(soap, (const struct ns1__getCustomer *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerResponse:
		soap_serialize_ns1__getCustomerResponse(soap, (const struct ns1__getCustomerResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalUser:
		soap_serialize_ns1__addGlobalUser(soap, (const struct ns1__addGlobalUser *)ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalUserResponse:
		soap_serialize_ns1__addGlobalUserResponse(soap, (const struct ns1__addGlobalUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__promoteUser:
		soap_serialize_ns1__promoteUser(soap, (const struct ns1__promoteUser *)ptr);
		break;
	case SOAP_TYPE_ns1__promoteUserResponse:
		soap_serialize_ns1__promoteUserResponse(soap, (const struct ns1__promoteUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveUser:
		soap_serialize_ns1__cancelSaveUser(soap, (const struct ns1__cancelSaveUser *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveUserResponse:
		soap_serialize_ns1__cancelSaveUserResponse(soap, (const struct ns1__cancelSaveUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserByRecordID:
		soap_serialize_ns1__deleteUserByRecordID(soap, (const struct ns1__deleteUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserByRecordIDResponse:
		soap_serialize_ns1__deleteUserByRecordIDResponse(soap, (const struct ns1__deleteUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteUser:
		soap_serialize_ns1__deleteUser(soap, (const struct ns1__deleteUser *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserResponse:
		soap_serialize_ns1__deleteUserResponse(soap, (const struct ns1__deleteUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUser:
		soap_serialize_ns1__saveUser(soap, (const struct ns1__saveUser *)ptr);
		break;
	case SOAP_TYPE_ns1__saveUserResponse:
		soap_serialize_ns1__saveUserResponse(soap, (const struct ns1__saveUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editUserByRecordID:
		soap_serialize_ns1__editUserByRecordID(soap, (const struct ns1__editUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editUserByRecordIDResponse:
		soap_serialize_ns1__editUserByRecordIDResponse(soap, (const struct ns1__editUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editUser:
		soap_serialize_ns1__editUser(soap, (const struct ns1__editUser *)ptr);
		break;
	case SOAP_TYPE_ns1__editUserResponse:
		soap_serialize_ns1__editUserResponse(soap, (const struct ns1__editUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addUser:
		soap_serialize_ns1__addUser(soap, (const struct ns1__addUser *)ptr);
		break;
	case SOAP_TYPE_ns1__addUserResponse:
		soap_serialize_ns1__addUserResponse(soap, (const struct ns1__addUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserForCurrentSession:
		soap_serialize_ns1__getUserForCurrentSession(soap, (const struct ns1__getUserForCurrentSession *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserForCurrentSessionResponse:
		soap_serialize_ns1__getUserForCurrentSessionResponse(soap, (const struct ns1__getUserForCurrentSessionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserByRecordID:
		soap_serialize_ns1__getUserByRecordID(soap, (const struct ns1__getUserByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserByRecordIDResponse:
		soap_serialize_ns1__getUserByRecordIDResponse(soap, (const struct ns1__getUserByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUser:
		soap_serialize_ns1__getUser(soap, (const struct ns1__getUser *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserResponse:
		soap_serialize_ns1__getUserResponse(soap, (const struct ns1__getUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserLicenseList:
		soap_serialize_ns1__getUserLicenseList(soap, (const struct ns1__getUserLicenseList *)ptr);
		break;
	case SOAP_TYPE_ns1__getUserLicenseListResponse:
		soap_serialize_ns1__getUserLicenseListResponse(soap, (const struct ns1__getUserLicenseListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalCustomerList:
		soap_serialize_ns1__getGlobalCustomerList(soap, (const struct ns1__getGlobalCustomerList *)ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalCustomerListResponse:
		soap_serialize_ns1__getGlobalCustomerListResponse(soap, (const struct ns1__getGlobalCustomerListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalUserList:
		soap_serialize_ns1__getGlobalUserList(soap, (const struct ns1__getGlobalUserList *)ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalUserListResponse:
		soap_serialize_ns1__getGlobalUserListResponse(soap, (const struct ns1__getGlobalUserListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTask:
		soap_serialize_ns1__cancelSaveTask(soap, (const struct ns1__cancelSaveTask *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTaskResponse:
		soap_serialize_ns1__cancelSaveTaskResponse(soap, (const struct ns1__cancelSaveTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTask:
		soap_serialize_ns1__saveTask(soap, (const struct ns1__saveTask *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTaskResponse:
		soap_serialize_ns1__saveTaskResponse(soap, (const struct ns1__saveTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTaskByRecordID:
		soap_serialize_ns1__editTaskByRecordID(soap, (const struct ns1__editTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editTaskByRecordIDResponse:
		soap_serialize_ns1__editTaskByRecordIDResponse(soap, (const struct ns1__editTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTask:
		soap_serialize_ns1__editTask(soap, (const struct ns1__editTask *)ptr);
		break;
	case SOAP_TYPE_ns1__editTaskResponse:
		soap_serialize_ns1__editTaskResponse(soap, (const struct ns1__editTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskByRecordID:
		soap_serialize_ns1__deleteTaskByRecordID(soap, (const struct ns1__deleteTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskByRecordIDResponse:
		soap_serialize_ns1__deleteTaskByRecordIDResponse(soap, (const struct ns1__deleteTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTask:
		soap_serialize_ns1__deleteTask(soap, (const struct ns1__deleteTask *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskResponse:
		soap_serialize_ns1__deleteTaskResponse(soap, (const struct ns1__deleteTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addTask:
		soap_serialize_ns1__addTask(soap, (const struct ns1__addTask *)ptr);
		break;
	case SOAP_TYPE_ns1__addTaskResponse:
		soap_serialize_ns1__addTaskResponse(soap, (const struct ns1__addTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTaskByRecordID:
		soap_serialize_ns1__getTaskByRecordID(soap, (const struct ns1__getTaskByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getTaskByRecordIDResponse:
		soap_serialize_ns1__getTaskByRecordIDResponse(soap, (const struct ns1__getTaskByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTask:
		soap_serialize_ns1__getTask(soap, (const struct ns1__getTask *)ptr);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		soap_serialize_ns1__getTaskResponse(soap, (const struct ns1__getTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectAttachment:
		soap_serialize_ns1__getDefectAttachment(soap, (const struct ns1__getDefectAttachment *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectAttachmentResponse:
		soap_serialize_ns1__getDefectAttachmentResponse(soap, (const struct ns1__getDefectAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAttachment:
		soap_serialize_ns1__getAttachment(soap, (const struct ns1__getAttachment *)ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentResponse:
		soap_serialize_ns1__getAttachmentResponse(soap, (const struct ns1__getAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveDefect:
		soap_serialize_ns1__cancelSaveDefect(soap, (const struct ns1__cancelSaveDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveDefectResponse:
		soap_serialize_ns1__cancelSaveDefectResponse(soap, (const struct ns1__cancelSaveDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveDefect:
		soap_serialize_ns1__saveDefect(soap, (const struct ns1__saveDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__saveDefectResponse:
		soap_serialize_ns1__saveDefectResponse(soap, (const struct ns1__saveDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editDefectByRecordID:
		soap_serialize_ns1__editDefectByRecordID(soap, (const struct ns1__editDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editDefectByRecordIDResponse:
		soap_serialize_ns1__editDefectByRecordIDResponse(soap, (const struct ns1__editDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editDefect:
		soap_serialize_ns1__editDefect(soap, (const struct ns1__editDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__editDefectResponse:
		soap_serialize_ns1__editDefectResponse(soap, (const struct ns1__editDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectByRecordID:
		soap_serialize_ns1__deleteDefectByRecordID(soap, (const struct ns1__deleteDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectByRecordIDResponse:
		soap_serialize_ns1__deleteDefectByRecordIDResponse(soap, (const struct ns1__deleteDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefect:
		soap_serialize_ns1__deleteDefect(soap, (const struct ns1__deleteDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectResponse:
		soap_serialize_ns1__deleteDefectResponse(soap, (const struct ns1__deleteDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addDefectWithLink:
		soap_serialize_ns1__addDefectWithLink(soap, (const struct ns1__addDefectWithLink *)ptr);
		break;
	case SOAP_TYPE_ns1__addDefectWithLinkResponse:
		soap_serialize_ns1__addDefectWithLinkResponse(soap, (const struct ns1__addDefectWithLinkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addDefect:
		soap_serialize_ns1__addDefect(soap, (const struct ns1__addDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__addDefectResponse:
		soap_serialize_ns1__addDefectResponse(soap, (const struct ns1__addDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectByRecordID:
		soap_serialize_ns1__getDefectByRecordID(soap, (const struct ns1__getDefectByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectByRecordIDResponse:
		soap_serialize_ns1__getDefectByRecordIDResponse(soap, (const struct ns1__getDefectByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefect:
		soap_serialize_ns1__getDefect(soap, (const struct ns1__getDefect *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectResponse:
		soap_serialize_ns1__getDefectResponse(soap, (const struct ns1__getDefectResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList:
		soap_serialize_ns1__getDefectCustomFieldsDefinitionList(soap, (const struct ns1__getDefectCustomFieldsDefinitionList *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse:
		soap_serialize_ns1__getDefectCustomFieldsDefinitionListResponse(soap, (const struct ns1__getDefectCustomFieldsDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionList:
		soap_serialize_ns1__getCustomFieldsDefinitionList(soap, (const struct ns1__getCustomFieldsDefinitionList *)ptr);
		break;
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse:
		soap_serialize_ns1__getCustomFieldsDefinitionListResponse(soap, (const struct ns1__getCustomFieldsDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectEventDefinitionList:
		soap_serialize_ns1__getDefectEventDefinitionList(soap, (const struct ns1__getDefectEventDefinitionList *)ptr);
		break;
	case SOAP_TYPE_ns1__getDefectEventDefinitionListResponse:
		soap_serialize_ns1__getDefectEventDefinitionListResponse(soap, (const struct ns1__getDefectEventDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getEventDefinitionList:
		soap_serialize_ns1__getEventDefinitionList(soap, (const struct ns1__getEventDefinitionList *)ptr);
		break;
	case SOAP_TYPE_ns1__getEventDefinitionListResponse:
		soap_serialize_ns1__getEventDefinitionListResponse(soap, (const struct ns1__getEventDefinitionListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByRecordID:
		soap_serialize_ns1__getReportRunResultsByRecordID(soap, (const struct ns1__getReportRunResultsByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse:
		soap_serialize_ns1__getReportRunResultsByRecordIDResponse(soap, (const struct ns1__getReportRunResultsByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByName:
		soap_serialize_ns1__getReportRunResultsByName(soap, (const struct ns1__getReportRunResultsByName *)ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByNameResponse:
		soap_serialize_ns1__getReportRunResultsByNameResponse(soap, (const struct ns1__getReportRunResultsByNameResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentTypes:
		soap_serialize_ns1__getAttachmentTypes(soap, (const struct ns1__getAttachmentTypes *)ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentTypesResponse:
		soap_serialize_ns1__getAttachmentTypesResponse(soap, (const struct ns1__getAttachmentTypesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestConfig:
		soap_serialize_ns1__cancelSaveTestConfig(soap, (const struct ns1__cancelSaveTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestConfigResponse:
		soap_serialize_ns1__cancelSaveTestConfigResponse(soap, (const struct ns1__cancelSaveTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigByRecordID:
		soap_serialize_ns1__deleteTestConfigByRecordID(soap, (const struct ns1__deleteTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse:
		soap_serialize_ns1__deleteTestConfigByRecordIDResponse(soap, (const struct ns1__deleteTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfig:
		soap_serialize_ns1__deleteTestConfig(soap, (const struct ns1__deleteTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigResponse:
		soap_serialize_ns1__deleteTestConfigResponse(soap, (const struct ns1__deleteTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestConfig:
		soap_serialize_ns1__saveTestConfig(soap, (const struct ns1__saveTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__saveTestConfigResponse:
		soap_serialize_ns1__saveTestConfigResponse(soap, (const struct ns1__saveTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigByRecordID:
		soap_serialize_ns1__editTestConfigByRecordID(soap, (const struct ns1__editTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigByRecordIDResponse:
		soap_serialize_ns1__editTestConfigByRecordIDResponse(soap, (const struct ns1__editTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfig:
		soap_serialize_ns1__editTestConfig(soap, (const struct ns1__editTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigResponse:
		soap_serialize_ns1__editTestConfigResponse(soap, (const struct ns1__editTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addTestConfig:
		soap_serialize_ns1__addTestConfig(soap, (const struct ns1__addTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__addTestConfigResponse:
		soap_serialize_ns1__addTestConfigResponse(soap, (const struct ns1__addTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigByRecordID:
		soap_serialize_ns1__getTestConfigByRecordID(soap, (const struct ns1__getTestConfigByRecordID *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigByRecordIDResponse:
		soap_serialize_ns1__getTestConfigByRecordIDResponse(soap, (const struct ns1__getTestConfigByRecordIDResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfig:
		soap_serialize_ns1__getTestConfig(soap, (const struct ns1__getTestConfig *)ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigResponse:
		soap_serialize_ns1__getTestConfigResponse(soap, (const struct ns1__getTestConfigResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getRecordListForTable:
		soap_serialize_ns1__getRecordListForTable(soap, (const struct ns1__getRecordListForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__getRecordListForTableResponse:
		soap_serialize_ns1__getRecordListForTableResponse(soap, (const struct ns1__getRecordListForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListForTable:
		soap_serialize_ns1__getFilterListForTable(soap, (const struct ns1__getFilterListForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListForTableResponse:
		soap_serialize_ns1__getFilterListForTableResponse(soap, (const struct ns1__getFilterListForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFilterList:
		soap_serialize_ns1__getFilterList(soap, (const struct ns1__getFilterList *)ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListResponse:
		soap_serialize_ns1__getFilterListResponse(soap, (const struct ns1__getFilterListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getColumnsForTable:
		soap_serialize_ns1__getColumnsForTable(soap, (const struct ns1__getColumnsForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__getColumnsForTableResponse:
		soap_serialize_ns1__getColumnsForTableResponse(soap, (const struct ns1__getColumnsForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetLinkDefinitionValues:
		soap_serialize_ns1__GetLinkDefinitionValues(soap, (const struct ns1__GetLinkDefinitionValues *)ptr);
		break;
	case SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse:
		soap_serialize_ns1__GetLinkDefinitionValuesResponse(soap, (const struct ns1__GetLinkDefinitionValuesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTable:
		soap_serialize_ns1__addDropdownFieldValuesForTable(soap, (const struct ns1__addDropdownFieldValuesForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse:
		soap_serialize_ns1__addDropdownFieldValuesForTableResponse(soap, (const struct ns1__addDropdownFieldValuesForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTable:
		soap_serialize_ns1__getDropdownFieldValuesForTable(soap, (const struct ns1__getDropdownFieldValuesForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse:
		soap_serialize_ns1__getDropdownFieldValuesForTableResponse(soap, (const struct ns1__getDropdownFieldValuesForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldForTable:
		soap_serialize_ns1__getDropdownFieldForTable(soap, (const struct ns1__getDropdownFieldForTable *)ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldForTableResponse:
		soap_serialize_ns1__getDropdownFieldForTableResponse(soap, (const struct ns1__getDropdownFieldForTableResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getTableList:
		soap_serialize_ns1__getTableList(soap, (const struct ns1__getTableList *)ptr);
		break;
	case SOAP_TYPE_ns1__getTableListResponse:
		soap_serialize_ns1__getTableListResponse(soap, (const struct ns1__getTableListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__formattedTextSupport:
		soap_serialize_ns1__formattedTextSupport(soap, (const struct ns1__formattedTextSupport *)ptr);
		break;
	case SOAP_TYPE_ns1__formattedTextSupportResponse:
		soap_serialize_ns1__formattedTextSupportResponse(soap, (const struct ns1__formattedTextSupportResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogoff:
		soap_serialize_ns1__DatabaseLogoff(soap, (const struct ns1__DatabaseLogoff *)ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogoffResponse:
		soap_serialize_ns1__DatabaseLogoffResponse(soap, (const struct ns1__DatabaseLogoffResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ProjectLogon:
		soap_serialize_ns1__ProjectLogon(soap, (const struct ns1__ProjectLogon *)ptr);
		break;
	case SOAP_TYPE_ns1__ProjectLogonResponse:
		soap_serialize_ns1__ProjectLogonResponse(soap, (const struct ns1__ProjectLogonResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogon:
		soap_serialize_ns1__DatabaseLogon(soap, (const struct ns1__DatabaseLogon *)ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogonResponse:
		soap_serialize_ns1__DatabaseLogonResponse(soap, (const struct ns1__DatabaseLogonResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getProjectDataOptionList:
		soap_serialize_ns1__getProjectDataOptionList(soap, (const struct ns1__getProjectDataOptionList *)ptr);
		break;
	case SOAP_TYPE_ns1__getProjectDataOptionListResponse:
		soap_serialize_ns1__getProjectDataOptionListResponse(soap, (const struct ns1__getProjectDataOptionListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getProjectList:
		soap_serialize_ns1__getProjectList(soap, (const struct ns1__getProjectList *)ptr);
		break;
	case SOAP_TYPE_ns1__getProjectListResponse:
		soap_serialize_ns1__getProjectListResponse(soap, (const struct ns1__getProjectListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDatabaseList:
		soap_serialize_ns1__getDatabaseList(soap, (const struct ns1__getDatabaseList *)ptr);
		break;
	case SOAP_TYPE_ns1__getDatabaseListResponse:
		soap_serialize_ns1__getDatabaseListResponse(soap, (const struct ns1__getDatabaseListResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CItemHyperlinkContainer:
		soap_serialize_PointerTons1__CItemHyperlinkContainer(soap, (ns1__CItemHyperlinkContainer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CRequirementDocument:
		soap_serialize_PointerTons1__CRequirementDocument(soap, (ns1__CRequirementDocument *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOflong:
		soap_serialize_PointerToArrayOflong(soap, (ArrayOflong *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CRequirement:
		soap_serialize_PointerTons1__CRequirement(soap, (ns1__CRequirement *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFolder:
		soap_serialize_PointerToArrayOfCFolder(soap, (ArrayOfCFolder *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFolderItem:
		soap_serialize_PointerToArrayOfCFolderItem(soap, (ArrayOfCFolderItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFolderType:
		soap_serialize_PointerToArrayOfCFolderType(soap, (ArrayOfCFolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTestRunVariantField:
		soap_serialize_PointerToArrayOfCTestRunVariantField(soap, (ArrayOfCTestRunVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCItemToTrack:
		soap_serialize_PointerToArrayOfCItemToTrack(soap, (ArrayOfCItemToTrack *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTestRun:
		soap_serialize_PointerTons1__CTestRun(soap, (ns1__CTestRun *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTestCase:
		soap_serialize_PointerTons1__CTestCase(soap, (ns1__CTestCase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCLink:
		soap_serialize_PointerToArrayOfCLink(soap, (ArrayOfCLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CUser:
		soap_serialize_PointerTons1__CUser(soap, (ns1__CUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCUserLicense:
		soap_serialize_PointerToArrayOfCUserLicense(soap, (ArrayOfCUserLicense *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCGlobalUser:
		soap_serialize_PointerToArrayOfCGlobalUser(soap, (ArrayOfCGlobalUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTask:
		soap_serialize_PointerTons1__CTask(soap, (ns1__CTask *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CDefect:
		soap_serialize_PointerTons1__CDefect(soap, (ns1__CDefect *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCDefectEventDefinition:
		soap_serialize_PointerToArrayOfCDefectEventDefinition(soap, (ArrayOfCDefectEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCEventDefinition:
		soap_serialize_PointerToArrayOfCEventDefinition(soap, (ArrayOfCEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CReportRunResults:
		soap_serialize_PointerTons1__CReportRunResults(soap, (ns1__CReportRunResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CRecordListSoap:
		soap_serialize_PointerTons1__CRecordListSoap(soap, (ns1__CRecordListSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFilter:
		soap_serialize_PointerToArrayOfCFilter(soap, (ArrayOfCFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTableField:
		soap_serialize_PointerToArrayOfCTableField(soap, (ArrayOfCTableField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCDatabaseTable:
		soap_serialize_PointerToArrayOfCDatabaseTable(soap, (ArrayOfCDatabaseTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCProject:
		soap_serialize_PointerToArrayOfCProject(soap, (ArrayOfCProject *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCDatabase:
		soap_serialize_PointerToArrayOfCDatabase(soap, (ArrayOfCDatabase *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCSnapshotInfo:
		soap_serialize_PointerToArrayOfCSnapshotInfo(soap, (ArrayOfCSnapshotInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCVersionInfo:
		soap_serialize_PointerToArrayOfCVersionInfo(soap, (ArrayOfCVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CScheduleInfo:
		soap_serialize_PointerTons1__CScheduleInfo(soap, (ns1__CScheduleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTestCaseVariantField:
		soap_serialize_PointerToArrayOfCTestCaseVariantField(soap, (ArrayOfCTestCaseVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCLinkHistoryItem:
		soap_serialize_PointerToArrayOfCLinkHistoryItem(soap, (ArrayOfCLinkHistoryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCLinkedItem:
		soap_serialize_PointerToArrayOfCLinkedItem(soap, (ArrayOfCLinkedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PhoneNumber:
		soap_serialize_PointerTons1__PhoneNumber(soap, (ns1__PhoneNumber *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCSCCFileRecord:
		soap_serialize_PointerToArrayOfCSCCFileRecord(soap, (ArrayOfCSCCFileRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCEvent:
		soap_serialize_PointerToArrayOfCEvent(soap, (ArrayOfCEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCReportedByRecord:
		soap_serialize_PointerToArrayOfCReportedByRecord(soap, (ArrayOfCReportedByRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTreeNodeSoap:
		soap_serialize_PointerToPointerTons1__CTreeNodeSoap(soap, (ns1__CTreeNodeSoap **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTreeNodeSoap:
		soap_serialize_PointerTons1__CTreeNodeSoap(soap, (ns1__CTreeNodeSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CSnapshotInfo:
		soap_serialize_PointerToPointerTons1__CSnapshotInfo(soap, (ns1__CSnapshotInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CSnapshotInfo:
		soap_serialize_PointerTons1__CSnapshotInfo(soap, (ns1__CSnapshotInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CVersionInfo:
		soap_serialize_PointerToPointerTons1__CVersionInfo(soap, (ns1__CVersionInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CVersionInfo:
		soap_serialize_PointerTons1__CVersionInfo(soap, (ns1__CVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFolderItem:
		soap_serialize_PointerToPointerTons1__CFolderItem(soap, (ns1__CFolderItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFolderItem:
		soap_serialize_PointerTons1__CFolderItem(soap, (ns1__CFolderItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFolder:
		soap_serialize_PointerToPointerTons1__CFolder(soap, (ns1__CFolder **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFolder:
		soap_serialize_PointerTons1__CFolder(soap, (ns1__CFolder *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFolderType:
		soap_serialize_PointerToPointerTons1__CFolderType(soap, (ns1__CFolderType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFolderType:
		soap_serialize_PointerTons1__CFolderType(soap, (ns1__CFolderType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CItemToTrack:
		soap_serialize_PointerToPointerTons1__CItemToTrack(soap, (ns1__CItemToTrack **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CItemToTrack:
		soap_serialize_PointerTons1__CItemToTrack(soap, (ns1__CItemToTrack *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CLink:
		soap_serialize_PointerToPointerTons1__CLink(soap, (ns1__CLink **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CLink:
		soap_serialize_PointerTons1__CLink(soap, (ns1__CLink *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CLinkHistoryItem:
		soap_serialize_PointerToPointerTons1__CLinkHistoryItem(soap, (ns1__CLinkHistoryItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CLinkHistoryItem:
		soap_serialize_PointerTons1__CLinkHistoryItem(soap, (ns1__CLinkHistoryItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CLinkedItem:
		soap_serialize_PointerToPointerTons1__CLinkedItem(soap, (ns1__CLinkedItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CLinkedItem:
		soap_serialize_PointerTons1__CLinkedItem(soap, (ns1__CLinkedItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CUserLicense:
		soap_serialize_PointerToPointerTons1__CUserLicense(soap, (ns1__CUserLicense **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CUserLicense:
		soap_serialize_PointerTons1__CUserLicense(soap, (ns1__CUserLicense *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CGlobalUser:
		soap_serialize_PointerToPointerTons1__CGlobalUser(soap, (ns1__CGlobalUser **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CGlobalUser:
		soap_serialize_PointerTons1__CGlobalUser(soap, (ns1__CGlobalUser *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CDefectEventDefinition:
		soap_serialize_PointerToPointerTons1__CDefectEventDefinition(soap, (ns1__CDefectEventDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CDefectEventDefinition:
		soap_serialize_PointerTons1__CDefectEventDefinition(soap, (ns1__CDefectEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CEventDefinition:
		soap_serialize_PointerToPointerTons1__CEventDefinition(soap, (ns1__CEventDefinition **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CEventDefinition:
		soap_serialize_PointerTons1__CEventDefinition(soap, (ns1__CEventDefinition *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CDefectEvent:
		soap_serialize_PointerToPointerTons1__CDefectEvent(soap, (ns1__CDefectEvent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CDefectEvent:
		soap_serialize_PointerTons1__CDefectEvent(soap, (ns1__CDefectEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CEvent:
		soap_serialize_PointerToPointerTons1__CEvent(soap, (ns1__CEvent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CEvent:
		soap_serialize_PointerTons1__CEvent(soap, (ns1__CEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfstring:
		soap_serialize_PointerToArrayOfstring(soap, (ArrayOfstring *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTestCaseVariantField:
		soap_serialize_PointerToPointerTons1__CTestCaseVariantField(soap, (ns1__CTestCaseVariantField **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTestCaseVariantField:
		soap_serialize_PointerTons1__CTestCaseVariantField(soap, (ns1__CTestCaseVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTestRunVariantField:
		soap_serialize_PointerToPointerTons1__CTestRunVariantField(soap, (ns1__CTestRunVariantField **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTestRunVariantField:
		soap_serialize_PointerTons1__CTestRunVariantField(soap, (ns1__CTestRunVariantField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CField:
		soap_serialize_PointerToPointerTons1__CField(soap, (ns1__CField **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CField:
		soap_serialize_PointerTons1__CField(soap, (ns1__CField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CReportedByRecord:
		soap_serialize_PointerToPointerTons1__CReportedByRecord(soap, (ns1__CReportedByRecord **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CReportedByRecord:
		soap_serialize_PointerTons1__CReportedByRecord(soap, (ns1__CReportedByRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerToshort:
		soap_serialize_PointerToshort(soap, (short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CSystem:
		soap_serialize_PointerTons1__CSystem(soap, (ns1__CSystem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFileAttachment:
		soap_serialize_PointerToArrayOfCFileAttachment(soap, (ArrayOfCFileAttachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFileAttachment:
		soap_serialize_PointerToPointerTons1__CFileAttachment(soap, (ns1__CFileAttachment **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFileAttachment:
		soap_serialize_PointerTons1__CFileAttachment(soap, (ns1__CFileAttachment *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFile:
		soap_serialize_PointerToPointerTons1__CFile(soap, (ns1__CFile **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFile:
		soap_serialize_PointerTons1__CFile(soap, (ns1__CFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CSCCFileRecord:
		soap_serialize_PointerToPointerTons1__CSCCFileRecord(soap, (ns1__CSCCFileRecord **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CSCCFileRecord:
		soap_serialize_PointerTons1__CSCCFileRecord(soap, (ns1__CSCCFileRecord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CRecordRowSoap:
		soap_serialize_PointerToPointerTons1__CRecordRowSoap(soap, (ns1__CRecordRowSoap **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CRecordRowSoap:
		soap_serialize_PointerTons1__CRecordRowSoap(soap, (ns1__CRecordRowSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CRecordData:
		soap_serialize_PointerToPointerTons1__CRecordData(soap, (ns1__CRecordData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CRecordData:
		soap_serialize_PointerTons1__CRecordData(soap, (ns1__CRecordData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFilter:
		soap_serialize_PointerToPointerTons1__CFilter(soap, (ns1__CFilter **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFilter:
		soap_serialize_PointerTons1__CFilter(soap, (ns1__CFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTableColumn:
		soap_serialize_PointerToPointerTons1__CTableColumn(soap, (ns1__CTableColumn **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTableColumn:
		soap_serialize_PointerTons1__CTableColumn(soap, (ns1__CTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CFieldValue:
		soap_serialize_PointerToPointerTons1__CFieldValue(soap, (ns1__CFieldValue **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CFieldValue:
		soap_serialize_PointerTons1__CFieldValue(soap, (ns1__CFieldValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTableField:
		soap_serialize_PointerToPointerTons1__CTableField(soap, (ns1__CTableField **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTableField:
		soap_serialize_PointerTons1__CTableField(soap, (ns1__CTableField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CDatabaseTable:
		soap_serialize_PointerToPointerTons1__CDatabaseTable(soap, (ns1__CDatabaseTable **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CDatabaseTable:
		soap_serialize_PointerTons1__CDatabaseTable(soap, (ns1__CDatabaseTable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CProject:
		soap_serialize_PointerToPointerTons1__CProject(soap, (ns1__CProject **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CProject:
		soap_serialize_PointerTons1__CProject(soap, (ns1__CProject *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CProjectDataOption:
		soap_serialize_PointerToPointerTons1__CProjectDataOption(soap, (ns1__CProjectDataOption **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CProjectDataOption:
		soap_serialize_PointerTons1__CProjectDataOption(soap, (ns1__CProjectDataOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CDatabase:
		soap_serialize_PointerToPointerTons1__CDatabase(soap, (ns1__CDatabase **const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTreeNodeSoap:
		soap_serialize_PointerToArrayOfCTreeNodeSoap(soap, (ArrayOfCTreeNodeSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerToLONG64:
		soap_serialize_PointerToLONG64(soap, (LONG64 *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCField:
		soap_serialize_PointerToArrayOfCField(soap, (ArrayOfCField *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFieldValue:
		soap_serialize_PointerToArrayOfCFieldValue(soap, (ArrayOfCFieldValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCFile:
		soap_serialize_PointerToArrayOfCFile(soap, (ArrayOfCFile *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCRecordRowSoap:
		soap_serialize_PointerToArrayOfCRecordRowSoap(soap, (ArrayOfCRecordRowSoap *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTableColumn:
		soap_serialize_PointerToArrayOfCTableColumn(soap, (ArrayOfCTableColumn *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCRecordData:
		soap_serialize_PointerToArrayOfCRecordData(soap, (ArrayOfCRecordData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCProjectDataOption:
		soap_serialize_PointerToArrayOfCProjectDataOption(soap, (ArrayOfCProjectDataOption *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CDatabase:
		soap_serialize_PointerTons1__CDatabase(soap, (ns1__CDatabase *const*)ptr);
		break;
	case SOAP_TYPE_xsd__date:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDatabase:
		return (void*)soap_instantiate_ns1__CDatabase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CProjectDataOption:
		return (void*)soap_instantiate_ns1__CProjectDataOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CProject:
		return (void*)soap_instantiate_ns1__CProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDatabaseTable:
		return (void*)soap_instantiate_ns1__CDatabaseTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTableField:
		return (void*)soap_instantiate_ns1__CTableField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFieldValue:
		return (void*)soap_instantiate_ns1__CFieldValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTableColumn:
		return (void*)soap_instantiate_ns1__CTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFilter:
		return (void*)soap_instantiate_ns1__CFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CRecordData:
		return (void*)soap_instantiate_ns1__CRecordData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CRecordRowSoap:
		return (void*)soap_instantiate_ns1__CRecordRowSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CRecordListSoap:
		return (void*)soap_instantiate_ns1__CRecordListSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CItemWithDBRecordId:
		return (void*)soap_instantiate_ns1__CItemWithDBRecordId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFile:
		return (void*)soap_instantiate_ns1__CFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CReportRunResults:
		return (void*)soap_instantiate_ns1__CReportRunResults(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CEventDefinition:
		return (void*)soap_instantiate_ns1__CEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PhoneNumber:
		return (void*)soap_instantiate_ns1__PhoneNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CGlobalUser:
		return (void*)soap_instantiate_ns1__CGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CUserLicense:
		return (void*)soap_instantiate_ns1__CUserLicense(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CScheduleInfo:
		return (void*)soap_instantiate_ns1__CScheduleInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CVersionInfo:
		return (void*)soap_instantiate_ns1__CVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTreeNodeSoap:
		return (void*)soap_instantiate_ns1__CTreeNodeSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CItemHyperlinkContainer:
		return (void*)soap_instantiate_ns1__CItemHyperlinkContainer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfstring:
		return (void*)soap_instantiate_ArrayOfstring(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOflong:
		return (void*)soap_instantiate_ArrayOflong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCDatabase:
		return (void*)soap_instantiate_ArrayOfCDatabase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCProjectDataOption:
		return (void*)soap_instantiate_ArrayOfCProjectDataOption(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCProject:
		return (void*)soap_instantiate_ArrayOfCProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCDatabaseTable:
		return (void*)soap_instantiate_ArrayOfCDatabaseTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTableField:
		return (void*)soap_instantiate_ArrayOfCTableField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFieldValue:
		return (void*)soap_instantiate_ArrayOfCFieldValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTableColumn:
		return (void*)soap_instantiate_ArrayOfCTableColumn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFilter:
		return (void*)soap_instantiate_ArrayOfCFilter(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCRecordData:
		return (void*)soap_instantiate_ArrayOfCRecordData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCRecordRowSoap:
		return (void*)soap_instantiate_ArrayOfCRecordRowSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CItemToTrack:
		return (void*)soap_instantiate_ns1__CItemToTrack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__COrderedItemWithDBRecordId:
		return (void*)soap_instantiate_ns1__COrderedItemWithDBRecordId(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CSCCFileRecord:
		return (void*)soap_instantiate_ns1__CSCCFileRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCSCCFileRecord:
		return (void*)soap_instantiate_ArrayOfCSCCFileRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFile:
		return (void*)soap_instantiate_ArrayOfCFile(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFileAttachment:
		return (void*)soap_instantiate_ns1__CFileAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFileAttachment:
		return (void*)soap_instantiate_ArrayOfCFileAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CReportedByRecord:
		return (void*)soap_instantiate_ns1__CReportedByRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCReportedByRecord:
		return (void*)soap_instantiate_ArrayOfCReportedByRecord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CField:
		return (void*)soap_instantiate_ns1__CField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCField:
		return (void*)soap_instantiate_ArrayOfCField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTestRunVariantField:
		return (void*)soap_instantiate_ArrayOfCTestRunVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTestCaseVariantField:
		return (void*)soap_instantiate_ArrayOfCTestCaseVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CEvent:
		return (void*)soap_instantiate_ns1__CEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCEvent:
		return (void*)soap_instantiate_ArrayOfCEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCDefectEvent:
		return (void*)soap_instantiate_ArrayOfCDefectEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCEventDefinition:
		return (void*)soap_instantiate_ArrayOfCEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDefectEventDefinition:
		return (void*)soap_instantiate_ns1__CDefectEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCDefectEventDefinition:
		return (void*)soap_instantiate_ArrayOfCDefectEventDefinition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCGlobalUser:
		return (void*)soap_instantiate_ArrayOfCGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCUserLicense:
		return (void*)soap_instantiate_ArrayOfCUserLicense(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCLinkedItem:
		return (void*)soap_instantiate_ArrayOfCLinkedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCLinkHistoryItem:
		return (void*)soap_instantiate_ArrayOfCLinkHistoryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCLink:
		return (void*)soap_instantiate_ArrayOfCLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCItemToTrack:
		return (void*)soap_instantiate_ArrayOfCItemToTrack(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFolderType:
		return (void*)soap_instantiate_ArrayOfCFolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFolderItem:
		return (void*)soap_instantiate_ns1__CFolderItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFolder:
		return (void*)soap_instantiate_ArrayOfCFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCFolderItem:
		return (void*)soap_instantiate_ArrayOfCFolderItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCVersionInfo:
		return (void*)soap_instantiate_ArrayOfCVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CSnapshotInfo:
		return (void*)soap_instantiate_ns1__CSnapshotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCSnapshotInfo:
		return (void*)soap_instantiate_ArrayOfCSnapshotInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTreeNodeSoap:
		return (void*)soap_instantiate_ArrayOfCTreeNodeSoap(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDocumentTreeNode:
		return (void*)soap_instantiate_ns1__CDocumentTreeNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CSystemBase:
		return (void*)soap_instantiate_ns1__CSystemBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CStringField:
		return (void*)soap_instantiate_ns1__CStringField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CIntegerField:
		return (void*)soap_instantiate_ns1__CIntegerField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDecimalField:
		return (void*)soap_instantiate_ns1__CDecimalField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CBooleanField:
		return (void*)soap_instantiate_ns1__CBooleanField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDateField:
		return (void*)soap_instantiate_ns1__CDateField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDateTimeField:
		return (void*)soap_instantiate_ns1__CDateTimeField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDropdownField:
		return (void*)soap_instantiate_ns1__CDropdownField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CMultiSelectDropdownField:
		return (void*)soap_instantiate_ns1__CMultiSelectDropdownField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CVersionField:
		return (void*)soap_instantiate_ns1__CVersionField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTimespanField:
		return (void*)soap_instantiate_ns1__CTimespanField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDefectEvent:
		return (void*)soap_instantiate_ns1__CDefectEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CDefect:
		return (void*)soap_instantiate_ns1__CDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTask:
		return (void*)soap_instantiate_ns1__CTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CUser:
		return (void*)soap_instantiate_ns1__CUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CLinkedItem:
		return (void*)soap_instantiate_ns1__CLinkedItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CLinkHistoryItem:
		return (void*)soap_instantiate_ns1__CLinkHistoryItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CLink:
		return (void*)soap_instantiate_ns1__CLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTestCase:
		return (void*)soap_instantiate_ns1__CTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTestRun:
		return (void*)soap_instantiate_ns1__CTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFolderType:
		return (void*)soap_instantiate_ns1__CFolderType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CFolder:
		return (void*)soap_instantiate_ns1__CFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CRequirement:
		return (void*)soap_instantiate_ns1__CRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CRequirementDocument:
		return (void*)soap_instantiate_ns1__CRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CSystem:
		return (void*)soap_instantiate_ns1__CSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTestRunVariantField:
		return (void*)soap_instantiate_ns1__CTestRunVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTestCaseVariantField:
		return (void*)soap_instantiate_ns1__CTestCaseVariantField(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatabaseListResponse:
		return (void*)soap_instantiate_ns1__getDatabaseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDatabaseList:
		return (void*)soap_instantiate_ns1__getDatabaseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProjectListResponse:
		return (void*)soap_instantiate_ns1__getProjectListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProjectList:
		return (void*)soap_instantiate_ns1__getProjectList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProjectDataOptionListResponse:
		return (void*)soap_instantiate_ns1__getProjectDataOptionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getProjectDataOptionList:
		return (void*)soap_instantiate_ns1__getProjectDataOptionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DatabaseLogonResponse:
		return (void*)soap_instantiate_ns1__DatabaseLogonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DatabaseLogon:
		return (void*)soap_instantiate_ns1__DatabaseLogon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProjectLogonResponse:
		return (void*)soap_instantiate_ns1__ProjectLogonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ProjectLogon:
		return (void*)soap_instantiate_ns1__ProjectLogon(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DatabaseLogoffResponse:
		return (void*)soap_instantiate_ns1__DatabaseLogoffResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DatabaseLogoff:
		return (void*)soap_instantiate_ns1__DatabaseLogoff(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__formattedTextSupportResponse:
		return (void*)soap_instantiate_ns1__formattedTextSupportResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__formattedTextSupport:
		return (void*)soap_instantiate_ns1__formattedTextSupport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTableListResponse:
		return (void*)soap_instantiate_ns1__getTableListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTableList:
		return (void*)soap_instantiate_ns1__getTableList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDropdownFieldForTableResponse:
		return (void*)soap_instantiate_ns1__getDropdownFieldForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDropdownFieldForTable:
		return (void*)soap_instantiate_ns1__getDropdownFieldForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse:
		return (void*)soap_instantiate_ns1__getDropdownFieldValuesForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTable:
		return (void*)soap_instantiate_ns1__getDropdownFieldValuesForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse:
		return (void*)soap_instantiate_ns1__addDropdownFieldValuesForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTable:
		return (void*)soap_instantiate_ns1__addDropdownFieldValuesForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse:
		return (void*)soap_instantiate_ns1__GetLinkDefinitionValuesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetLinkDefinitionValues:
		return (void*)soap_instantiate_ns1__GetLinkDefinitionValues(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getColumnsForTableResponse:
		return (void*)soap_instantiate_ns1__getColumnsForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getColumnsForTable:
		return (void*)soap_instantiate_ns1__getColumnsForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFilterListResponse:
		return (void*)soap_instantiate_ns1__getFilterListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFilterList:
		return (void*)soap_instantiate_ns1__getFilterList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFilterListForTableResponse:
		return (void*)soap_instantiate_ns1__getFilterListForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFilterListForTable:
		return (void*)soap_instantiate_ns1__getFilterListForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRecordListForTableResponse:
		return (void*)soap_instantiate_ns1__getRecordListForTableResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRecordListForTable:
		return (void*)soap_instantiate_ns1__getRecordListForTable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestConfigResponse:
		return (void*)soap_instantiate_ns1__getTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestConfig:
		return (void*)soap_instantiate_ns1__getTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestConfigByRecordID:
		return (void*)soap_instantiate_ns1__getTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTestConfigResponse:
		return (void*)soap_instantiate_ns1__addTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTestConfig:
		return (void*)soap_instantiate_ns1__addTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestConfigResponse:
		return (void*)soap_instantiate_ns1__editTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestConfig:
		return (void*)soap_instantiate_ns1__editTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestConfigByRecordID:
		return (void*)soap_instantiate_ns1__editTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestConfigResponse:
		return (void*)soap_instantiate_ns1__saveTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestConfig:
		return (void*)soap_instantiate_ns1__saveTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestConfigResponse:
		return (void*)soap_instantiate_ns1__deleteTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestConfig:
		return (void*)soap_instantiate_ns1__deleteTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteTestConfigByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestConfigByRecordID:
		return (void*)soap_instantiate_ns1__deleteTestConfigByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestConfigResponse:
		return (void*)soap_instantiate_ns1__cancelSaveTestConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestConfig:
		return (void*)soap_instantiate_ns1__cancelSaveTestConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAttachmentTypesResponse:
		return (void*)soap_instantiate_ns1__getAttachmentTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAttachmentTypes:
		return (void*)soap_instantiate_ns1__getAttachmentTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReportRunResultsByNameResponse:
		return (void*)soap_instantiate_ns1__getReportRunResultsByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReportRunResultsByName:
		return (void*)soap_instantiate_ns1__getReportRunResultsByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getReportRunResultsByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getReportRunResultsByRecordID:
		return (void*)soap_instantiate_ns1__getReportRunResultsByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventDefinitionListResponse:
		return (void*)soap_instantiate_ns1__getEventDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventDefinitionList:
		return (void*)soap_instantiate_ns1__getEventDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectEventDefinitionListResponse:
		return (void*)soap_instantiate_ns1__getDefectEventDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectEventDefinitionList:
		return (void*)soap_instantiate_ns1__getDefectEventDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse:
		return (void*)soap_instantiate_ns1__getCustomFieldsDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionList:
		return (void*)soap_instantiate_ns1__getCustomFieldsDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse:
		return (void*)soap_instantiate_ns1__getDefectCustomFieldsDefinitionListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList:
		return (void*)soap_instantiate_ns1__getDefectCustomFieldsDefinitionList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectResponse:
		return (void*)soap_instantiate_ns1__getDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefect:
		return (void*)soap_instantiate_ns1__getDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectByRecordID:
		return (void*)soap_instantiate_ns1__getDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDefectResponse:
		return (void*)soap_instantiate_ns1__addDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDefect:
		return (void*)soap_instantiate_ns1__addDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDefectWithLinkResponse:
		return (void*)soap_instantiate_ns1__addDefectWithLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addDefectWithLink:
		return (void*)soap_instantiate_ns1__addDefectWithLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDefectResponse:
		return (void*)soap_instantiate_ns1__deleteDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDefect:
		return (void*)soap_instantiate_ns1__deleteDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDefectByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteDefectByRecordID:
		return (void*)soap_instantiate_ns1__deleteDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editDefectResponse:
		return (void*)soap_instantiate_ns1__editDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editDefect:
		return (void*)soap_instantiate_ns1__editDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editDefectByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editDefectByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editDefectByRecordID:
		return (void*)soap_instantiate_ns1__editDefectByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveDefectResponse:
		return (void*)soap_instantiate_ns1__saveDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveDefect:
		return (void*)soap_instantiate_ns1__saveDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveDefectResponse:
		return (void*)soap_instantiate_ns1__cancelSaveDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveDefect:
		return (void*)soap_instantiate_ns1__cancelSaveDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAttachmentResponse:
		return (void*)soap_instantiate_ns1__getAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAttachment:
		return (void*)soap_instantiate_ns1__getAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectAttachmentResponse:
		return (void*)soap_instantiate_ns1__getDefectAttachmentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDefectAttachment:
		return (void*)soap_instantiate_ns1__getDefectAttachment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskResponse:
		return (void*)soap_instantiate_ns1__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTask:
		return (void*)soap_instantiate_ns1__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskByRecordID:
		return (void*)soap_instantiate_ns1__getTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTaskResponse:
		return (void*)soap_instantiate_ns1__addTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTask:
		return (void*)soap_instantiate_ns1__addTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTaskResponse:
		return (void*)soap_instantiate_ns1__deleteTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTask:
		return (void*)soap_instantiate_ns1__deleteTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTaskByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTaskByRecordID:
		return (void*)soap_instantiate_ns1__deleteTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTaskResponse:
		return (void*)soap_instantiate_ns1__editTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTask:
		return (void*)soap_instantiate_ns1__editTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTaskByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editTaskByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTaskByRecordID:
		return (void*)soap_instantiate_ns1__editTaskByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTaskResponse:
		return (void*)soap_instantiate_ns1__saveTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTask:
		return (void*)soap_instantiate_ns1__saveTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTaskResponse:
		return (void*)soap_instantiate_ns1__cancelSaveTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTask:
		return (void*)soap_instantiate_ns1__cancelSaveTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalUserListResponse:
		return (void*)soap_instantiate_ns1__getGlobalUserListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalUserList:
		return (void*)soap_instantiate_ns1__getGlobalUserList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalCustomerListResponse:
		return (void*)soap_instantiate_ns1__getGlobalCustomerListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalCustomerList:
		return (void*)soap_instantiate_ns1__getGlobalCustomerList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserLicenseListResponse:
		return (void*)soap_instantiate_ns1__getUserLicenseListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserLicenseList:
		return (void*)soap_instantiate_ns1__getUserLicenseList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserResponse:
		return (void*)soap_instantiate_ns1__getUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUser:
		return (void*)soap_instantiate_ns1__getUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserByRecordID:
		return (void*)soap_instantiate_ns1__getUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserForCurrentSessionResponse:
		return (void*)soap_instantiate_ns1__getUserForCurrentSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getUserForCurrentSession:
		return (void*)soap_instantiate_ns1__getUserForCurrentSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addUserResponse:
		return (void*)soap_instantiate_ns1__addUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addUser:
		return (void*)soap_instantiate_ns1__addUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editUserResponse:
		return (void*)soap_instantiate_ns1__editUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editUser:
		return (void*)soap_instantiate_ns1__editUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editUserByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editUserByRecordID:
		return (void*)soap_instantiate_ns1__editUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUserResponse:
		return (void*)soap_instantiate_ns1__saveUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveUser:
		return (void*)soap_instantiate_ns1__saveUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteUserResponse:
		return (void*)soap_instantiate_ns1__deleteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteUser:
		return (void*)soap_instantiate_ns1__deleteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteUserByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteUserByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteUserByRecordID:
		return (void*)soap_instantiate_ns1__deleteUserByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveUserResponse:
		return (void*)soap_instantiate_ns1__cancelSaveUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveUser:
		return (void*)soap_instantiate_ns1__cancelSaveUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__promoteUserResponse:
		return (void*)soap_instantiate_ns1__promoteUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__promoteUser:
		return (void*)soap_instantiate_ns1__promoteUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addGlobalUserResponse:
		return (void*)soap_instantiate_ns1__addGlobalUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addGlobalUser:
		return (void*)soap_instantiate_ns1__addGlobalUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomerResponse:
		return (void*)soap_instantiate_ns1__getCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomer:
		return (void*)soap_instantiate_ns1__getCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomerByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomerByRecordID:
		return (void*)soap_instantiate_ns1__getCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCustomerResponse:
		return (void*)soap_instantiate_ns1__addCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addCustomer:
		return (void*)soap_instantiate_ns1__addCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editCustomerResponse:
		return (void*)soap_instantiate_ns1__editCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editCustomer:
		return (void*)soap_instantiate_ns1__editCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editCustomerByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editCustomerByRecordID:
		return (void*)soap_instantiate_ns1__editCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveCustomerResponse:
		return (void*)soap_instantiate_ns1__saveCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveCustomer:
		return (void*)soap_instantiate_ns1__saveCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteCustomerResponse:
		return (void*)soap_instantiate_ns1__deleteCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteCustomer:
		return (void*)soap_instantiate_ns1__deleteCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteCustomerByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteCustomerByRecordID:
		return (void*)soap_instantiate_ns1__deleteCustomerByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveCustomerResponse:
		return (void*)soap_instantiate_ns1__cancelSaveCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveCustomer:
		return (void*)soap_instantiate_ns1__cancelSaveCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__promoteCustomerResponse:
		return (void*)soap_instantiate_ns1__promoteCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__promoteCustomer:
		return (void*)soap_instantiate_ns1__promoteCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addGlobalCustomerResponse:
		return (void*)soap_instantiate_ns1__addGlobalCustomerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addGlobalCustomer:
		return (void*)soap_instantiate_ns1__addGlobalCustomer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLinksForItemResponse:
		return (void*)soap_instantiate_ns1__getLinksForItemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLinksForItem:
		return (void*)soap_instantiate_ns1__getLinksForItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLinksForDefectResponse:
		return (void*)soap_instantiate_ns1__getLinksForDefectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLinksForDefect:
		return (void*)soap_instantiate_ns1__getLinksForDefect(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLinkResponse:
		return (void*)soap_instantiate_ns1__getLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLink:
		return (void*)soap_instantiate_ns1__getLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addLinkResponse:
		return (void*)soap_instantiate_ns1__addLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addLink:
		return (void*)soap_instantiate_ns1__addLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteLinkResponse:
		return (void*)soap_instantiate_ns1__deleteLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteLink:
		return (void*)soap_instantiate_ns1__deleteLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editLinkResponse:
		return (void*)soap_instantiate_ns1__editLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editLink:
		return (void*)soap_instantiate_ns1__editLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveLinkResponse:
		return (void*)soap_instantiate_ns1__saveLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveLink:
		return (void*)soap_instantiate_ns1__saveLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveLinkResponse:
		return (void*)soap_instantiate_ns1__cancelSaveLinkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveLink:
		return (void*)soap_instantiate_ns1__cancelSaveLink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestVariantTypesResponse:
		return (void*)soap_instantiate_ns1__getTestVariantTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestVariantTypes:
		return (void*)soap_instantiate_ns1__getTestVariantTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRunStepsModesResponse:
		return (void*)soap_instantiate_ns1__getTestRunStepsModesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRunStepsModes:
		return (void*)soap_instantiate_ns1__getTestRunStepsModes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestCaseResponse:
		return (void*)soap_instantiate_ns1__getTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestCase:
		return (void*)soap_instantiate_ns1__getTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestCaseByRecordID:
		return (void*)soap_instantiate_ns1__getTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTestCaseResponse:
		return (void*)soap_instantiate_ns1__addTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addTestCase:
		return (void*)soap_instantiate_ns1__addTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestCaseResponse:
		return (void*)soap_instantiate_ns1__deleteTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestCase:
		return (void*)soap_instantiate_ns1__deleteTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestCaseByRecordID:
		return (void*)soap_instantiate_ns1__deleteTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestCaseResponse:
		return (void*)soap_instantiate_ns1__editTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestCase:
		return (void*)soap_instantiate_ns1__editTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestCaseByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editTestCaseByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestCaseByRecordID:
		return (void*)soap_instantiate_ns1__editTestCaseByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestCaseResponse:
		return (void*)soap_instantiate_ns1__saveTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestCase:
		return (void*)soap_instantiate_ns1__saveTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestCaseResponse:
		return (void*)soap_instantiate_ns1__cancelSaveTestCaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestCase:
		return (void*)soap_instantiate_ns1__cancelSaveTestCase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRunResponse:
		return (void*)soap_instantiate_ns1__getTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRun:
		return (void*)soap_instantiate_ns1__getTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRunByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTestRunByRecordID:
		return (void*)soap_instantiate_ns1__getTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestRunResponse:
		return (void*)soap_instantiate_ns1__deleteTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestRun:
		return (void*)soap_instantiate_ns1__deleteTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteTestRunByRecordID:
		return (void*)soap_instantiate_ns1__deleteTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestRunResponse:
		return (void*)soap_instantiate_ns1__editTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestRun:
		return (void*)soap_instantiate_ns1__editTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestRunByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editTestRunByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editTestRunByRecordID:
		return (void*)soap_instantiate_ns1__editTestRunByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestRunResponse:
		return (void*)soap_instantiate_ns1__saveTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveTestRun:
		return (void*)soap_instantiate_ns1__saveTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestRunResponse:
		return (void*)soap_instantiate_ns1__cancelSaveTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveTestRun:
		return (void*)soap_instantiate_ns1__cancelSaveTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDefectForTestRunResponse:
		return (void*)soap_instantiate_ns1__createDefectForTestRunResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createDefectForTestRun:
		return (void*)soap_instantiate_ns1__createDefectForTestRun(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__generateTestRunsResponse:
		return (void*)soap_instantiate_ns1__generateTestRunsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__generateTestRuns:
		return (void*)soap_instantiate_ns1__generateTestRuns(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTypeByNameResponse:
		return (void*)soap_instantiate_ns1__getFolderTypeByNameResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTypeByName:
		return (void*)soap_instantiate_ns1__getFolderTypeByName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTypeListResponse:
		return (void*)soap_instantiate_ns1__getFolderTypeListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTypeList:
		return (void*)soap_instantiate_ns1__getFolderTypeList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addFolderResponse:
		return (void*)soap_instantiate_ns1__addFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addFolder:
		return (void*)soap_instantiate_ns1__addFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolderResponse:
		return (void*)soap_instantiate_ns1__editFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolder:
		return (void*)soap_instantiate_ns1__editFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolderByRecordID:
		return (void*)soap_instantiate_ns1__editFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveFolderResponse:
		return (void*)soap_instantiate_ns1__saveFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveFolder:
		return (void*)soap_instantiate_ns1__saveFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveFolderResponse:
		return (void*)soap_instantiate_ns1__cancelSaveFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveFolder:
		return (void*)soap_instantiate_ns1__cancelSaveFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderResponse:
		return (void*)soap_instantiate_ns1__getFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolder:
		return (void*)soap_instantiate_ns1__getFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderByRecordID:
		return (void*)soap_instantiate_ns1__getFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteFolderResponse:
		return (void*)soap_instantiate_ns1__deleteFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteFolder:
		return (void*)soap_instantiate_ns1__deleteFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteFolderByRecordID:
		return (void*)soap_instantiate_ns1__deleteFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__addEntityToFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addEntityToFolderByRecordID:
		return (void*)soap_instantiate_ns1__addEntityToFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__removeEntityFromFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordID:
		return (void*)soap_instantiate_ns1__removeEntityFromFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getEntityListForFolderByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordID:
		return (void*)soap_instantiate_ns1__getEntityListForFolderByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getFolderListForEntityByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordID:
		return (void*)soap_instantiate_ns1__getFolderListForEntityByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderPathSeparatorResponse:
		return (void*)soap_instantiate_ns1__getFolderPathSeparatorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderPathSeparator:
		return (void*)soap_instantiate_ns1__getFolderPathSeparator(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRootPublicFolderPathResponse:
		return (void*)soap_instantiate_ns1__getRootPublicFolderPathResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRootPublicFolderPath:
		return (void*)soap_instantiate_ns1__getRootPublicFolderPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRootPrivateFolderPathResponse:
		return (void*)soap_instantiate_ns1__getRootPrivateFolderPathResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRootPrivateFolderPath:
		return (void*)soap_instantiate_ns1__getRootPrivateFolderPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolderItemRankResponse:
		return (void*)soap_instantiate_ns1__editFolderItemRankResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editFolderItemRank:
		return (void*)soap_instantiate_ns1__editFolderItemRank(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveFolderItemRankResponse:
		return (void*)soap_instantiate_ns1__saveFolderItemRankResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveFolderItemRank:
		return (void*)soap_instantiate_ns1__saveFolderItemRank(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse:
		return (void*)soap_instantiate_ns1__cancelSaveFolderItemRankResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveFolderItemRank:
		return (void*)soap_instantiate_ns1__cancelSaveFolderItemRank(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementResponse:
		return (void*)soap_instantiate_ns1__getRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirement:
		return (void*)soap_instantiate_ns1__getRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getRequirementByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementByRecordID:
		return (void*)soap_instantiate_ns1__getRequirementByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addRequirementResponse:
		return (void*)soap_instantiate_ns1__addRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addRequirement:
		return (void*)soap_instantiate_ns1__addRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementResponse:
		return (void*)soap_instantiate_ns1__deleteRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirement:
		return (void*)soap_instantiate_ns1__deleteRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteRequirementByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementByRecordID:
		return (void*)soap_instantiate_ns1__deleteRequirementByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementResponse:
		return (void*)soap_instantiate_ns1__editRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirement:
		return (void*)soap_instantiate_ns1__editRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editRequirementByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementByRecordID:
		return (void*)soap_instantiate_ns1__editRequirementByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveRequirementResponse:
		return (void*)soap_instantiate_ns1__saveRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveRequirement:
		return (void*)soap_instantiate_ns1__saveRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveRequirementResponse:
		return (void*)soap_instantiate_ns1__cancelSaveRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveRequirement:
		return (void*)soap_instantiate_ns1__cancelSaveRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__appendToRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__appendToRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__appendToRequirementDocument:
		return (void*)soap_instantiate_ns1__appendToRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse:
		return (void*)soap_instantiate_ns1__getDocumentIDsForRequirementResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocumentIDsForRequirement:
		return (void*)soap_instantiate_ns1__getDocumentIDsForRequirement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__changeRequirementTypeResponse:
		return (void*)soap_instantiate_ns1__changeRequirementTypeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__changeRequirementType:
		return (void*)soap_instantiate_ns1__changeRequirementType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__getRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementDocument:
		return (void*)soap_instantiate_ns1__getRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getRequirementDocumentByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordID:
		return (void*)soap_instantiate_ns1__getRequirementDocumentByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__addRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addRequirementDocument:
		return (void*)soap_instantiate_ns1__addRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__deleteRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementDocument:
		return (void*)soap_instantiate_ns1__deleteRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse:
		return (void*)soap_instantiate_ns1__deleteRequirementDocumentByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID:
		return (void*)soap_instantiate_ns1__deleteRequirementDocumentByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__editRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementDocument:
		return (void*)soap_instantiate_ns1__editRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse:
		return (void*)soap_instantiate_ns1__editRequirementDocumentByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordID:
		return (void*)soap_instantiate_ns1__editRequirementDocumentByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__saveRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveRequirementDocument:
		return (void*)soap_instantiate_ns1__saveRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse:
		return (void*)soap_instantiate_ns1__cancelSaveRequirementDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cancelSaveRequirementDocument:
		return (void*)soap_instantiate_ns1__cancelSaveRequirementDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createSnapshotResponse:
		return (void*)soap_instantiate_ns1__createSnapshotResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__createSnapshot:
		return (void*)soap_instantiate_ns1__createSnapshot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse:
		return (void*)soap_instantiate_ns1__getRequirementIDsForDocumentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getRequirementIDsForDocument:
		return (void*)soap_instantiate_ns1__getRequirementIDsForDocument(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocumentTreeResponse:
		return (void*)soap_instantiate_ns1__getDocumentTreeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocumentTree:
		return (void*)soap_instantiate_ns1__getDocumentTree(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse:
		return (void*)soap_instantiate_ns1__getFolderTreeByRecordIDResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTreeByRecordID:
		return (void*)soap_instantiate_ns1__getFolderTreeByRecordID(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTreeResponse:
		return (void*)soap_instantiate_ns1__getFolderTreeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderTree:
		return (void*)soap_instantiate_ns1__getFolderTree(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getItemHyperlinksResponse:
		return (void*)soap_instantiate_ns1__getItemHyperlinksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getItemHyperlinks:
		return (void*)soap_instantiate_ns1__getItemHyperlinks(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE((xsd__base64Binary*)p->ptr);
		else
			SOAP_DELETE_ARRAY((xsd__base64Binary*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDatabase:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDatabase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDatabase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CProjectDataOption:
		if (p->size < 0)
			SOAP_DELETE((ns1__CProjectDataOption*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CProjectDataOption*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CProject:
		if (p->size < 0)
			SOAP_DELETE((ns1__CProject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CProject*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDatabaseTable:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDatabaseTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDatabaseTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTableField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTableField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTableField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFieldValue:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFieldValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFieldValue*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTableColumn:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTableColumn*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTableColumn*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFilter:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFilter*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CRecordData:
		if (p->size < 0)
			SOAP_DELETE((ns1__CRecordData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CRecordData*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CRecordRowSoap:
		if (p->size < 0)
			SOAP_DELETE((ns1__CRecordRowSoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CRecordRowSoap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CRecordListSoap:
		if (p->size < 0)
			SOAP_DELETE((ns1__CRecordListSoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CRecordListSoap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CItemWithDBRecordId:
		if (p->size < 0)
			SOAP_DELETE((ns1__CItemWithDBRecordId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CItemWithDBRecordId*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFile:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CReportRunResults:
		if (p->size < 0)
			SOAP_DELETE((ns1__CReportRunResults*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CReportRunResults*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CEventDefinition:
		if (p->size < 0)
			SOAP_DELETE((ns1__CEventDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CEventDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ns1__PhoneNumber:
		if (p->size < 0)
			SOAP_DELETE((ns1__PhoneNumber*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__PhoneNumber*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CGlobalUser:
		if (p->size < 0)
			SOAP_DELETE((ns1__CGlobalUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CGlobalUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CUserLicense:
		if (p->size < 0)
			SOAP_DELETE((ns1__CUserLicense*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CUserLicense*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CScheduleInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__CScheduleInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CScheduleInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CVersionInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__CVersionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CVersionInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTreeNodeSoap:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTreeNodeSoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTreeNodeSoap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CItemHyperlinkContainer:
		if (p->size < 0)
			SOAP_DELETE((ns1__CItemHyperlinkContainer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CItemHyperlinkContainer*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfstring:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfstring*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfstring*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOflong:
		if (p->size < 0)
			SOAP_DELETE((ArrayOflong*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOflong*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCDatabase:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCDatabase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCDatabase*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCProjectDataOption:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCProjectDataOption*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCProjectDataOption*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCProject:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCProject*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCProject*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCDatabaseTable:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCDatabaseTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCDatabaseTable*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCTableField:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCTableField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCTableField*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFieldValue:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFieldValue*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFieldValue*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCTableColumn:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCTableColumn*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCTableColumn*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFilter:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFilter*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFilter*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCRecordData:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCRecordData*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCRecordData*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCRecordRowSoap:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCRecordRowSoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCRecordRowSoap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CItemToTrack:
		if (p->size < 0)
			SOAP_DELETE((ns1__CItemToTrack*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CItemToTrack*)p->ptr);
		break;
	case SOAP_TYPE_ns1__COrderedItemWithDBRecordId:
		if (p->size < 0)
			SOAP_DELETE((ns1__COrderedItemWithDBRecordId*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__COrderedItemWithDBRecordId*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CSCCFileRecord:
		if (p->size < 0)
			SOAP_DELETE((ns1__CSCCFileRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CSCCFileRecord*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCSCCFileRecord:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCSCCFileRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCSCCFileRecord*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFile:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFile*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFile*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFileAttachment:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFileAttachment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFileAttachment*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFileAttachment:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFileAttachment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFileAttachment*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CReportedByRecord:
		if (p->size < 0)
			SOAP_DELETE((ns1__CReportedByRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CReportedByRecord*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCReportedByRecord:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCReportedByRecord*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCReportedByRecord*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CField*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCField:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCField*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCTestRunVariantField:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCTestRunVariantField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCTestRunVariantField*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCTestCaseVariantField:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCTestCaseVariantField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCTestCaseVariantField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CEvent:
		if (p->size < 0)
			SOAP_DELETE((ns1__CEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CEvent*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCEvent:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCEvent*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCDefectEvent:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCDefectEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCDefectEvent*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCEventDefinition:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCEventDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCEventDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDefectEventDefinition:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDefectEventDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDefectEventDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCDefectEventDefinition:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCDefectEventDefinition*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCDefectEventDefinition*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCGlobalUser:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCGlobalUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCGlobalUser*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCUserLicense:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCUserLicense*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCUserLicense*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCLinkedItem:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCLinkedItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCLinkedItem*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCLinkHistoryItem:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCLinkHistoryItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCLinkHistoryItem*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCLink:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCLink*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCItemToTrack:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCItemToTrack*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCItemToTrack*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFolderType:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFolderType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFolderType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFolderItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFolderItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFolderItem*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFolder:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFolder*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCFolderItem:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCFolderItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCFolderItem*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCVersionInfo:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCVersionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCVersionInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CSnapshotInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__CSnapshotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CSnapshotInfo*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCSnapshotInfo:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCSnapshotInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCSnapshotInfo*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfCTreeNodeSoap:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfCTreeNodeSoap*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfCTreeNodeSoap*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDocumentTreeNode:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDocumentTreeNode*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDocumentTreeNode*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CSystemBase:
		if (p->size < 0)
			SOAP_DELETE((ns1__CSystemBase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CSystemBase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CStringField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CStringField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CStringField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CIntegerField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CIntegerField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CIntegerField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDecimalField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDecimalField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDecimalField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CBooleanField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CBooleanField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CBooleanField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDateField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDateField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDateField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDateTimeField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDateTimeField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDateTimeField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDropdownField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDropdownField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDropdownField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CMultiSelectDropdownField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CMultiSelectDropdownField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CMultiSelectDropdownField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CVersionField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CVersionField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CVersionField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTimespanField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTimespanField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTimespanField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDefectEvent:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDefectEvent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDefectEvent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CDefect:
		if (p->size < 0)
			SOAP_DELETE((ns1__CDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTask:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CUser:
		if (p->size < 0)
			SOAP_DELETE((ns1__CUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CLinkedItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__CLinkedItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CLinkedItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CLinkHistoryItem:
		if (p->size < 0)
			SOAP_DELETE((ns1__CLinkHistoryItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CLinkHistoryItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CLink:
		if (p->size < 0)
			SOAP_DELETE((ns1__CLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTestCase:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTestRun:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFolderType:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFolderType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFolderType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CFolder:
		if (p->size < 0)
			SOAP_DELETE((ns1__CFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CRequirement:
		if (p->size < 0)
			SOAP_DELETE((ns1__CRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((ns1__CRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CSystem:
		if (p->size < 0)
			SOAP_DELETE((ns1__CSystem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CSystem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTestRunVariantField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTestRunVariantField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTestRunVariantField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__CTestCaseVariantField:
		if (p->size < 0)
			SOAP_DELETE((ns1__CTestCaseVariantField*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__CTestCaseVariantField*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatabaseListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDatabaseListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDatabaseListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDatabaseList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDatabaseList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDatabaseList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProjectListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProjectListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProjectListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProjectList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProjectList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProjectList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProjectDataOptionListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProjectDataOptionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProjectDataOptionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getProjectDataOptionList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getProjectDataOptionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getProjectDataOptionList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogonResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DatabaseLogonResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DatabaseLogonResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogon:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DatabaseLogon*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DatabaseLogon*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ProjectLogonResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__ProjectLogonResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__ProjectLogonResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__ProjectLogon:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__ProjectLogon*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__ProjectLogon*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogoffResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DatabaseLogoffResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DatabaseLogoffResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__DatabaseLogoff:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__DatabaseLogoff*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__DatabaseLogoff*)p->ptr);
		break;
	case SOAP_TYPE_ns1__formattedTextSupportResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__formattedTextSupportResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__formattedTextSupportResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__formattedTextSupport:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__formattedTextSupport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__formattedTextSupport*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTableListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTableListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTableListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTableList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTableList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTableList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDropdownFieldForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDropdownFieldForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDropdownFieldForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDropdownFieldForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDropdownFieldValuesForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDropdownFieldValuesForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDropdownFieldValuesForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDropdownFieldValuesForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDropdownFieldValuesForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDropdownFieldValuesForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDropdownFieldValuesForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDropdownFieldValuesForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDropdownFieldValuesForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDropdownFieldValuesForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetLinkDefinitionValuesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetLinkDefinitionValuesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__GetLinkDefinitionValues:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__GetLinkDefinitionValues*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__GetLinkDefinitionValues*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getColumnsForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getColumnsForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getColumnsForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getColumnsForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getColumnsForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getColumnsForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFilterListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFilterListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFilterList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFilterList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFilterList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFilterListForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFilterListForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFilterListForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFilterListForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFilterListForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRecordListForTableResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRecordListForTableResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRecordListForTableResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRecordListForTable:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRecordListForTable*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRecordListForTable*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestConfigByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestConfigByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestConfigByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestConfigByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestConfigByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestConfigByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestConfigByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestConfigByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestConfigByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestConfigByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestConfigByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestConfigByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestConfigByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestConfigByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestConfigByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestConfigResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestConfigResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestConfigResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestConfig:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestConfig*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestConfig*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentTypesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAttachmentTypesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAttachmentTypesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentTypes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAttachmentTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAttachmentTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByNameResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getReportRunResultsByNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getReportRunResultsByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByName:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getReportRunResultsByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getReportRunResultsByName*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getReportRunResultsByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getReportRunResultsByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getReportRunResultsByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getReportRunResultsByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getReportRunResultsByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getEventDefinitionListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getEventDefinitionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getEventDefinitionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getEventDefinitionList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getEventDefinitionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getEventDefinitionList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectEventDefinitionListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectEventDefinitionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectEventDefinitionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectEventDefinitionList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectEventDefinitionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectEventDefinitionList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomFieldsDefinitionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomFieldsDefinitionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomFieldsDefinitionList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomFieldsDefinitionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomFieldsDefinitionList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectCustomFieldsDefinitionListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectCustomFieldsDefinitionListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectCustomFieldsDefinitionList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectCustomFieldsDefinitionList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDefectWithLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDefectWithLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDefectWithLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addDefectWithLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addDefectWithLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addDefectWithLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteDefectByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteDefectByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteDefectByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteDefectByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteDefectByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editDefectByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editDefectByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editDefectByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editDefectByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editDefectByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editDefectByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAttachmentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAttachmentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAttachmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getAttachment:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getAttachment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getAttachment*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectAttachmentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectAttachmentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectAttachmentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDefectAttachment:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDefectAttachment*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDefectAttachment*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTaskByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTaskByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTaskByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTaskByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTaskByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTaskByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTaskByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTaskByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTaskByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTaskByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTaskByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTaskByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTaskByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTaskByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTaskByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTaskResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTaskResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTaskResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTask:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTask*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTask*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalUserListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getGlobalUserListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getGlobalUserListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalUserList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getGlobalUserList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getGlobalUserList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalCustomerListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getGlobalCustomerListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getGlobalCustomerListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getGlobalCustomerList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getGlobalCustomerList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getGlobalCustomerList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserLicenseListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserLicenseListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserLicenseListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserLicenseList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserLicenseList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserLicenseList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserForCurrentSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserForCurrentSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserForCurrentSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getUserForCurrentSession:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getUserForCurrentSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getUserForCurrentSession*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editUserByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editUserByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editUserByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editUserByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editUserByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editUserByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteUserByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteUserByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteUserByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteUserByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteUserByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__promoteUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__promoteUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__promoteUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__promoteUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__promoteUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__promoteUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalUserResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addGlobalUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addGlobalUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalUser:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addGlobalUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addGlobalUser*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomerByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomerByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getCustomerByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getCustomerByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getCustomerByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editCustomerByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editCustomerByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editCustomerByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editCustomerByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editCustomerByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteCustomerByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteCustomerByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteCustomerByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteCustomerByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteCustomerByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__promoteCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__promoteCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__promoteCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__promoteCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__promoteCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__promoteCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalCustomerResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addGlobalCustomerResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addGlobalCustomerResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addGlobalCustomer:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addGlobalCustomer*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addGlobalCustomer*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForItemResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLinksForItemResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLinksForItemResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForItem:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLinksForItem*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLinksForItem*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForDefectResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLinksForDefectResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLinksForDefectResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLinksForDefect:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLinksForDefect*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLinksForDefect*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveLinkResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveLinkResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveLinkResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveLink:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveLink*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveLink*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestVariantTypesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestVariantTypesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestVariantTypesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestVariantTypes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestVariantTypes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestVariantTypes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunStepsModesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRunStepsModesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRunStepsModesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunStepsModes:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRunStepsModes*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRunStepsModes*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestCaseByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestCaseByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestCaseByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestCaseByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestCaseByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestCaseByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestCaseByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestCaseByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestCaseByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestCaseByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestCaseByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestCaseByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestCaseByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestCaseByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestCaseByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestCaseResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestCaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestCaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestCase:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestCase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestCase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRunByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRunByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTestRunByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getTestRunByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getTestRunByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestRunByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestRunByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteTestRunByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteTestRunByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteTestRunByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestRunByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestRunByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editTestRunByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editTestRunByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editTestRunByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDefectForTestRunResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__createDefectForTestRunResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__createDefectForTestRunResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createDefectForTestRun:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__createDefectForTestRun*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__createDefectForTestRun*)p->ptr);
		break;
	case SOAP_TYPE_ns1__generateTestRunsResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__generateTestRunsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__generateTestRunsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__generateTestRuns:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__generateTestRuns*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__generateTestRuns*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeByNameResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTypeByNameResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTypeByNameResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeByName:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTypeByName*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTypeByName*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeListResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTypeListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTypeListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTypeList:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTypeList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTypeList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteFolderResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteFolderResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolder:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteFolder*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteFolder*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addEntityToFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addEntityToFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addEntityToFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addEntityToFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addEntityToFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeEntityFromFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeEntityFromFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__removeEntityFromFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__removeEntityFromFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__removeEntityFromFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getEntityListForFolderByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getEntityListForFolderByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getEntityListForFolderByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getEntityListForFolderByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getEntityListForFolderByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderListForEntityByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderListForEntityByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderListForEntityByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderListForEntityByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderListForEntityByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderPathSeparatorResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderPathSeparatorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderPathSeparatorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderPathSeparator:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderPathSeparator*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderPathSeparator*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRootPublicFolderPathResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRootPublicFolderPathResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRootPublicFolderPathResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRootPublicFolderPath:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRootPublicFolderPath*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRootPublicFolderPath*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRootPrivateFolderPathResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRootPrivateFolderPathResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRootPrivateFolderPathResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRootPrivateFolderPath:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRootPrivateFolderPath*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRootPrivateFolderPath*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolderItemRankResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolderItemRankResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolderItemRankResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editFolderItemRank:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editFolderItemRank*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editFolderItemRank*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderItemRankResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveFolderItemRankResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveFolderItemRankResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveFolderItemRank:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveFolderItemRank*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveFolderItemRank*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveFolderItemRankResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveFolderItemRankResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveFolderItemRank:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveFolderItemRank*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveFolderItemRank*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__appendToRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__appendToRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__appendToRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__appendToRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__appendToRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__appendToRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDocumentIDsForRequirementResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDocumentIDsForRequirementResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentIDsForRequirement:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDocumentIDsForRequirement*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDocumentIDsForRequirement*)p->ptr);
		break;
	case SOAP_TYPE_ns1__changeRequirementTypeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__changeRequirementTypeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__changeRequirementTypeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__changeRequirementType:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__changeRequirementType*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__changeRequirementType*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementDocumentByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementDocumentByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementDocumentByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementDocumentByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementDocumentByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__addRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__addRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__addRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementDocumentByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementDocumentByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__deleteRequirementDocumentByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__deleteRequirementDocumentByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementDocumentByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementDocumentByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__editRequirementDocumentByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__editRequirementDocumentByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__editRequirementDocumentByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__saveRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__saveRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__saveRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveRequirementDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveRequirementDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cancelSaveRequirementDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__cancelSaveRequirementDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__cancelSaveRequirementDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createSnapshotResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__createSnapshotResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__createSnapshotResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__createSnapshot:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__createSnapshot*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__createSnapshot*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementIDsForDocumentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementIDsForDocumentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getRequirementIDsForDocument:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getRequirementIDsForDocument*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getRequirementIDsForDocument*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentTreeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDocumentTreeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDocumentTreeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDocumentTree:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getDocumentTree*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getDocumentTree*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTreeByRecordIDResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTreeByRecordIDResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeByRecordID:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTreeByRecordID*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTreeByRecordID*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTreeResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTreeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTreeResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getFolderTree:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getFolderTree*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getFolderTree*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getItemHyperlinksResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getItemHyperlinksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getItemHyperlinksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getItemHyperlinks:
		if (p->size < 0)
			SOAP_DELETE((struct ns1__getItemHyperlinks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns1__getItemHyperlinks*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag?tag:"xsd:byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__CItemHyperlinkContainer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CItemHyperlinkContainer::ttstudioHyperlink);
	soap_default_string(soap, &this->ns1__CItemHyperlinkContainer::httpHyperlink);
	/* transient soap skipped */
}

void ns1__CItemHyperlinkContainer::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CItemHyperlinkContainer::ttstudioHyperlink);
	soap_serialize_string(soap, &this->ns1__CItemHyperlinkContainer::httpHyperlink);
	/* transient soap skipped */
#endif
}

int ns1__CItemHyperlinkContainer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CItemHyperlinkContainer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CItemHyperlinkContainer(struct soap *soap, const char *tag, int id, const ns1__CItemHyperlinkContainer *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CItemHyperlinkContainer), type))
		return soap->error;
	if (soap_out_string(soap, "ttstudioHyperlink", -1, &(a->ns1__CItemHyperlinkContainer::ttstudioHyperlink), ""))
		return soap->error;
	if (soap_out_string(soap, "httpHyperlink", -1, &(a->ns1__CItemHyperlinkContainer::httpHyperlink), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CItemHyperlinkContainer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CItemHyperlinkContainer(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CItemHyperlinkContainer * SOAP_FMAC4 soap_in_ns1__CItemHyperlinkContainer(struct soap *soap, const char *tag, ns1__CItemHyperlinkContainer *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CItemHyperlinkContainer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CItemHyperlinkContainer, sizeof(ns1__CItemHyperlinkContainer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CItemHyperlinkContainer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CItemHyperlinkContainer *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ttstudioHyperlink1 = 1;
	size_t soap_flag_httpHyperlink1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ttstudioHyperlink1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ttstudioHyperlink", &(a->ns1__CItemHyperlinkContainer::ttstudioHyperlink), "xsd:string"))
				{	soap_flag_ttstudioHyperlink1--;
					continue;
				}
			if (soap_flag_httpHyperlink1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "httpHyperlink", &(a->ns1__CItemHyperlinkContainer::httpHyperlink), "xsd:string"))
				{	soap_flag_httpHyperlink1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CItemHyperlinkContainer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CItemHyperlinkContainer, 0, sizeof(ns1__CItemHyperlinkContainer), 0, soap_copy_ns1__CItemHyperlinkContainer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CItemHyperlinkContainer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CItemHyperlinkContainer);
	if (this->soap_out(soap, tag?tag:"ns1:CItemHyperlinkContainer", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CItemHyperlinkContainer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CItemHyperlinkContainer(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CItemHyperlinkContainer * SOAP_FMAC4 soap_get_ns1__CItemHyperlinkContainer(struct soap *soap, ns1__CItemHyperlinkContainer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CItemHyperlinkContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CItemHyperlinkContainer * SOAP_FMAC2 soap_instantiate_ns1__CItemHyperlinkContainer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CItemHyperlinkContainer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CItemHyperlinkContainer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CItemHyperlinkContainer);
		if (size)
			*size = sizeof(ns1__CItemHyperlinkContainer);
		((ns1__CItemHyperlinkContainer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CItemHyperlinkContainer, n);
		if (size)
			*size = n * sizeof(ns1__CItemHyperlinkContainer);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CItemHyperlinkContainer*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CItemHyperlinkContainer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CItemHyperlinkContainer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CItemHyperlinkContainer %p -> %p\n", q, p));
	*(ns1__CItemHyperlinkContainer*)p = *(ns1__CItemHyperlinkContainer*)q;
}

void ns1__CDocumentTreeNode::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->ns1__CDocumentTreeNode::entityTableName);
	soap_default_LONG64(soap, &this->ns1__CDocumentTreeNode::entityRecordID);
	this->ns1__CDocumentTreeNode::childList = NULL;
	soap_default_string(soap, &this->ns1__CDocumentTreeNode::summary);
	soap_default_string(soap, &this->ns1__CDocumentTreeNode::outlineNumber);
	soap_default_string(soap, &this->ns1__CDocumentTreeNode::tag);
}

void ns1__CDocumentTreeNode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CDocumentTreeNode::entityTableName);
	soap_embedded(soap, &this->ns1__CDocumentTreeNode::entityRecordID, SOAP_TYPE_LONG64);
	soap_serialize_PointerToArrayOfCTreeNodeSoap(soap, &this->ns1__CDocumentTreeNode::childList);
	soap_serialize_string(soap, &this->ns1__CDocumentTreeNode::summary);
	soap_serialize_string(soap, &this->ns1__CDocumentTreeNode::outlineNumber);
	soap_serialize_string(soap, &this->ns1__CDocumentTreeNode::tag);
#endif
}

int ns1__CDocumentTreeNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDocumentTreeNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDocumentTreeNode(struct soap *soap, const char *tag, int id, const ns1__CDocumentTreeNode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDocumentTreeNode), type))
		return soap->error;
	if (soap_out_string(soap, "entityTableName", -1, &(a->ns1__CDocumentTreeNode::entityTableName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityRecordID", -1, &(a->ns1__CDocumentTreeNode::entityRecordID), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTreeNodeSoap(soap, "childList", -1, &(a->ns1__CDocumentTreeNode::childList), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CDocumentTreeNode::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "outlineNumber", -1, &(a->ns1__CDocumentTreeNode::outlineNumber), ""))
		return soap->error;
	if (soap_out_string(soap, "tag", -1, &(a->ns1__CDocumentTreeNode::tag), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDocumentTreeNode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDocumentTreeNode(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDocumentTreeNode * SOAP_FMAC4 soap_in_ns1__CDocumentTreeNode(struct soap *soap, const char *tag, ns1__CDocumentTreeNode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDocumentTreeNode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDocumentTreeNode, sizeof(ns1__CDocumentTreeNode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDocumentTreeNode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDocumentTreeNode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityTableName1 = 1;
	size_t soap_flag_entityRecordID1 = 1;
	size_t soap_flag_childList1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_outlineNumber1 = 1;
	size_t soap_flag_tag1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entityTableName", &(a->ns1__CDocumentTreeNode::entityTableName), "xsd:string"))
				{	soap_flag_entityTableName1--;
					continue;
				}
			if (soap_flag_entityRecordID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityRecordID", &(a->ns1__CDocumentTreeNode::entityRecordID), "xsd:long"))
				{	soap_flag_entityRecordID1--;
					continue;
				}
			if (soap_flag_childList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTreeNodeSoap(soap, "childList", &(a->ns1__CDocumentTreeNode::childList), "ns1:CTreeNodeSoap"))
				{	soap_flag_childList1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CDocumentTreeNode::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_outlineNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "outlineNumber", &(a->ns1__CDocumentTreeNode::outlineNumber), "xsd:string"))
				{	soap_flag_outlineNumber1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tag", &(a->ns1__CDocumentTreeNode::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDocumentTreeNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDocumentTreeNode, 0, sizeof(ns1__CDocumentTreeNode), 0, soap_copy_ns1__CDocumentTreeNode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityRecordID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDocumentTreeNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDocumentTreeNode);
	if (this->soap_out(soap, tag?tag:"ns1:CDocumentTreeNode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDocumentTreeNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDocumentTreeNode(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDocumentTreeNode * SOAP_FMAC4 soap_get_ns1__CDocumentTreeNode(struct soap *soap, ns1__CDocumentTreeNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDocumentTreeNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDocumentTreeNode * SOAP_FMAC2 soap_instantiate_ns1__CDocumentTreeNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDocumentTreeNode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDocumentTreeNode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDocumentTreeNode);
		if (size)
			*size = sizeof(ns1__CDocumentTreeNode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDocumentTreeNode, n);
		if (size)
			*size = n * sizeof(ns1__CDocumentTreeNode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDocumentTreeNode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDocumentTreeNode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDocumentTreeNode %p -> %p\n", q, p));
	*(ns1__CDocumentTreeNode*)p = *(ns1__CDocumentTreeNode*)q;
}

void ArrayOfCTreeNodeSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCTreeNodeSoap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCTreeNodeSoap))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTreeNodeSoap(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCTreeNodeSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTreeNodeSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTreeNodeSoap(struct soap *soap, const char *tag, int id, const ArrayOfCTreeNodeSoap *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CTreeNodeSoap", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTreeNodeSoap);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTreeNodeSoap(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCTreeNodeSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTreeNodeSoap(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTreeNodeSoap * SOAP_FMAC4 soap_in_ArrayOfCTreeNodeSoap(struct soap *soap, const char *tag, ArrayOfCTreeNodeSoap *a, const char *type)
{	int i, j;
	ns1__CTreeNodeSoap **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTreeNodeSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTreeNodeSoap, sizeof(ArrayOfCTreeNodeSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CTreeNodeSoap **)soap_malloc(soap, sizeof(ns1__CTreeNodeSoap *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTreeNodeSoap(soap, NULL, a->__ptritem + i, "ns1:CTreeNodeSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTreeNodeSoap **)soap_push_block(soap, NULL, sizeof(ns1__CTreeNodeSoap *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTreeNodeSoap(soap, NULL, p, "ns1:CTreeNodeSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CTreeNodeSoap **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTreeNodeSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTreeNodeSoap, 0, sizeof(ArrayOfCTreeNodeSoap), 0, soap_copy_ArrayOfCTreeNodeSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCTreeNodeSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCTreeNodeSoap);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCTreeNodeSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTreeNodeSoap(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTreeNodeSoap * SOAP_FMAC4 soap_get_ArrayOfCTreeNodeSoap(struct soap *soap, ArrayOfCTreeNodeSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTreeNodeSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCTreeNodeSoap * SOAP_FMAC2 soap_instantiate_ArrayOfCTreeNodeSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTreeNodeSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTreeNodeSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCTreeNodeSoap);
		if (size)
			*size = sizeof(ArrayOfCTreeNodeSoap);
		((ArrayOfCTreeNodeSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCTreeNodeSoap, n);
		if (size)
			*size = n * sizeof(ArrayOfCTreeNodeSoap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCTreeNodeSoap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCTreeNodeSoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTreeNodeSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTreeNodeSoap %p -> %p\n", q, p));
	*(ArrayOfCTreeNodeSoap*)p = *(ArrayOfCTreeNodeSoap*)q;
}

void ns1__CTreeNodeSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CTreeNodeSoap::entityTableName);
	soap_default_LONG64(soap, &this->ns1__CTreeNodeSoap::entityRecordID);
	this->ns1__CTreeNodeSoap::childList = NULL;
	/* transient soap skipped */
}

void ns1__CTreeNodeSoap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CTreeNodeSoap::entityTableName);
	soap_embedded(soap, &this->ns1__CTreeNodeSoap::entityRecordID, SOAP_TYPE_LONG64);
	soap_serialize_PointerToArrayOfCTreeNodeSoap(soap, &this->ns1__CTreeNodeSoap::childList);
	/* transient soap skipped */
#endif
}

int ns1__CTreeNodeSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTreeNodeSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTreeNodeSoap(struct soap *soap, const char *tag, int id, const ns1__CTreeNodeSoap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTreeNodeSoap), type))
		return soap->error;
	if (soap_out_string(soap, "entityTableName", -1, &(a->ns1__CTreeNodeSoap::entityTableName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityRecordID", -1, &(a->ns1__CTreeNodeSoap::entityRecordID), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTreeNodeSoap(soap, "childList", -1, &(a->ns1__CTreeNodeSoap::childList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CTreeNodeSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTreeNodeSoap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTreeNodeSoap * SOAP_FMAC4 soap_in_ns1__CTreeNodeSoap(struct soap *soap, const char *tag, ns1__CTreeNodeSoap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTreeNodeSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTreeNodeSoap, sizeof(ns1__CTreeNodeSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTreeNodeSoap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTreeNodeSoap *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityTableName1 = 1;
	size_t soap_flag_entityRecordID1 = 1;
	size_t soap_flag_childList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityTableName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entityTableName", &(a->ns1__CTreeNodeSoap::entityTableName), "xsd:string"))
				{	soap_flag_entityTableName1--;
					continue;
				}
			if (soap_flag_entityRecordID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityRecordID", &(a->ns1__CTreeNodeSoap::entityRecordID), "xsd:long"))
				{	soap_flag_entityRecordID1--;
					continue;
				}
			if (soap_flag_childList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTreeNodeSoap(soap, "childList", &(a->ns1__CTreeNodeSoap::childList), "ns1:CTreeNodeSoap"))
				{	soap_flag_childList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTreeNodeSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTreeNodeSoap, 0, sizeof(ns1__CTreeNodeSoap), 0, soap_copy_ns1__CTreeNodeSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityRecordID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTreeNodeSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTreeNodeSoap);
	if (this->soap_out(soap, tag?tag:"ns1:CTreeNodeSoap", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTreeNodeSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTreeNodeSoap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTreeNodeSoap * SOAP_FMAC4 soap_get_ns1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTreeNodeSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTreeNodeSoap * SOAP_FMAC2 soap_instantiate_ns1__CTreeNodeSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTreeNodeSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTreeNodeSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTreeNodeSoap);
		if (size)
			*size = sizeof(ns1__CTreeNodeSoap);
		((ns1__CTreeNodeSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTreeNodeSoap, n);
		if (size)
			*size = n * sizeof(ns1__CTreeNodeSoap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CTreeNodeSoap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTreeNodeSoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTreeNodeSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTreeNodeSoap %p -> %p\n", q, p));
	*(ns1__CTreeNodeSoap*)p = *(ns1__CTreeNodeSoap*)q;
}

void ns1__CRequirementDocument::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CRequirementDocument::recordid);
	this->ns1__CRequirementDocument::number = NULL;
	soap_default_string(soap, &this->ns1__CRequirementDocument::name);
	soap_default_string(soap, &this->ns1__CRequirementDocument::description);
	this->ns1__CRequirementDocument::descriptionInlineAttachList = NULL;
	soap_default_string(soap, &this->ns1__CRequirementDocument::state);
	this->ns1__CRequirementDocument::attachmentList = NULL;
	this->ns1__CRequirementDocument::sccFileList = NULL;
	this->ns1__CRequirementDocument::customFieldList = NULL;
	this->ns1__CRequirementDocument::eventList = NULL;
	this->ns1__CRequirementDocument::snapshotList = NULL;
	this->ns1__CRequirementDocument::dateTimeCreated = NULL;
	soap_default_string(soap, &this->ns1__CRequirementDocument::createdByUser);
	soap_default_string(soap, &this->ns1__CRequirementDocument::locationAddedFrom);
	soap_default_string(soap, &this->ns1__CRequirementDocument::modifiedByUser);
	this->ns1__CRequirementDocument::dateTimeModified = NULL;
	this->ns1__CRequirementDocument::actualHours = NULL;
	this->ns1__CRequirementDocument::estimatedHours = NULL;
	this->ns1__CRequirementDocument::remainingHours = NULL;
	this->ns1__CRequirementDocument::variance = NULL;
	this->ns1__CRequirementDocument::storyPoints = NULL;
	this->ns1__CRequirementDocument::percentDone = NULL;
}

void ns1__CRequirementDocument::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CRequirementDocument::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirementDocument::number);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::name);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::description);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CRequirementDocument::descriptionInlineAttachList);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::state);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CRequirementDocument::attachmentList);
	soap_serialize_PointerToArrayOfCSCCFileRecord(soap, &this->ns1__CRequirementDocument::sccFileList);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CRequirementDocument::customFieldList);
	soap_serialize_PointerToArrayOfCEvent(soap, &this->ns1__CRequirementDocument::eventList);
	soap_serialize_PointerToArrayOfCSnapshotInfo(soap, &this->ns1__CRequirementDocument::snapshotList);
	soap_serialize_PointerTotime(soap, &this->ns1__CRequirementDocument::dateTimeCreated);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::createdByUser);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::locationAddedFrom);
	soap_serialize_string(soap, &this->ns1__CRequirementDocument::modifiedByUser);
	soap_serialize_PointerTotime(soap, &this->ns1__CRequirementDocument::dateTimeModified);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirementDocument::actualHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirementDocument::estimatedHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirementDocument::remainingHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirementDocument::variance);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirementDocument::storyPoints);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirementDocument::percentDone);
#endif
}

int ns1__CRequirementDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CRequirementDocument(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CRequirementDocument(struct soap *soap, const char *tag, int id, const ns1__CRequirementDocument *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CRequirementDocument::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "number", -1, &(a->ns1__CRequirementDocument::number), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CRequirementDocument::name), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns1__CRequirementDocument::description), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "descriptionInlineAttachList", -1, &(a->ns1__CRequirementDocument::descriptionInlineAttachList), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CRequirementDocument::state), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentList", -1, &(a->ns1__CRequirementDocument::attachmentList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->ns1__CRequirementDocument::sccFileList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFieldList", -1, &(a->ns1__CRequirementDocument::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCEvent(soap, "eventList", -1, &(a->ns1__CRequirementDocument::eventList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSnapshotInfo(soap, "snapshotList", -1, &(a->ns1__CRequirementDocument::snapshotList), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateTimeCreated", -1, &(a->ns1__CRequirementDocument::dateTimeCreated), ""))
		return soap->error;
	if (soap_out_string(soap, "createdByUser", -1, &(a->ns1__CRequirementDocument::createdByUser), ""))
		return soap->error;
	if (soap_out_string(soap, "locationAddedFrom", -1, &(a->ns1__CRequirementDocument::locationAddedFrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedByUser", -1, &(a->ns1__CRequirementDocument::modifiedByUser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateTimeModified", -1, &(a->ns1__CRequirementDocument::dateTimeModified), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualHours", -1, &(a->ns1__CRequirementDocument::actualHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedHours", -1, &(a->ns1__CRequirementDocument::estimatedHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "remainingHours", -1, &(a->ns1__CRequirementDocument::remainingHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "variance", -1, &(a->ns1__CRequirementDocument::variance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storyPoints", -1, &(a->ns1__CRequirementDocument::storyPoints), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "percentDone", -1, &(a->ns1__CRequirementDocument::percentDone), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CRequirementDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CRequirementDocument(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CRequirementDocument * SOAP_FMAC4 soap_in_ns1__CRequirementDocument(struct soap *soap, const char *tag, ns1__CRequirementDocument *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CRequirementDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CRequirementDocument, sizeof(ns1__CRequirementDocument), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CRequirementDocument)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CRequirementDocument *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_descriptionInlineAttachList1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_attachmentList1 = 1;
	size_t soap_flag_sccFileList1 = 1;
	size_t soap_flag_customFieldList1 = 1;
	size_t soap_flag_eventList1 = 1;
	size_t soap_flag_snapshotList1 = 1;
	size_t soap_flag_dateTimeCreated1 = 1;
	size_t soap_flag_createdByUser1 = 1;
	size_t soap_flag_locationAddedFrom1 = 1;
	size_t soap_flag_modifiedByUser1 = 1;
	size_t soap_flag_dateTimeModified1 = 1;
	size_t soap_flag_actualHours1 = 1;
	size_t soap_flag_estimatedHours1 = 1;
	size_t soap_flag_remainingHours1 = 1;
	size_t soap_flag_variance1 = 1;
	size_t soap_flag_storyPoints1 = 1;
	size_t soap_flag_percentDone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CRequirementDocument::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "number", &(a->ns1__CRequirementDocument::number), "xsd:long"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CRequirementDocument::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns1__CRequirementDocument::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_descriptionInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "descriptionInlineAttachList", &(a->ns1__CRequirementDocument::descriptionInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_descriptionInlineAttachList1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CRequirementDocument::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_attachmentList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentList", &(a->ns1__CRequirementDocument::attachmentList), "ns1:CFileAttachment"))
				{	soap_flag_attachmentList1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", &(a->ns1__CRequirementDocument::sccFileList), "ns1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFieldList", &(a->ns1__CRequirementDocument::customFieldList), "ns1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEvent(soap, "eventList", &(a->ns1__CRequirementDocument::eventList), "ns1:CEvent"))
				{	soap_flag_eventList1--;
					continue;
				}
			if (soap_flag_snapshotList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSnapshotInfo(soap, "snapshotList", &(a->ns1__CRequirementDocument::snapshotList), "ns1:CSnapshotInfo"))
				{	soap_flag_snapshotList1--;
					continue;
				}
			if (soap_flag_dateTimeCreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateTimeCreated", &(a->ns1__CRequirementDocument::dateTimeCreated), "xsd:dateTime"))
				{	soap_flag_dateTimeCreated1--;
					continue;
				}
			if (soap_flag_createdByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdByUser", &(a->ns1__CRequirementDocument::createdByUser), "xsd:string"))
				{	soap_flag_createdByUser1--;
					continue;
				}
			if (soap_flag_locationAddedFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationAddedFrom", &(a->ns1__CRequirementDocument::locationAddedFrom), "xsd:string"))
				{	soap_flag_locationAddedFrom1--;
					continue;
				}
			if (soap_flag_modifiedByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedByUser", &(a->ns1__CRequirementDocument::modifiedByUser), "xsd:string"))
				{	soap_flag_modifiedByUser1--;
					continue;
				}
			if (soap_flag_dateTimeModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateTimeModified", &(a->ns1__CRequirementDocument::dateTimeModified), "xsd:dateTime"))
				{	soap_flag_dateTimeModified1--;
					continue;
				}
			if (soap_flag_actualHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualHours", &(a->ns1__CRequirementDocument::actualHours), "xsd:double"))
				{	soap_flag_actualHours1--;
					continue;
				}
			if (soap_flag_estimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedHours", &(a->ns1__CRequirementDocument::estimatedHours), "xsd:double"))
				{	soap_flag_estimatedHours1--;
					continue;
				}
			if (soap_flag_remainingHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "remainingHours", &(a->ns1__CRequirementDocument::remainingHours), "xsd:double"))
				{	soap_flag_remainingHours1--;
					continue;
				}
			if (soap_flag_variance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "variance", &(a->ns1__CRequirementDocument::variance), "xsd:double"))
				{	soap_flag_variance1--;
					continue;
				}
			if (soap_flag_storyPoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storyPoints", &(a->ns1__CRequirementDocument::storyPoints), "xsd:long"))
				{	soap_flag_storyPoints1--;
					continue;
				}
			if (soap_flag_percentDone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "percentDone", &(a->ns1__CRequirementDocument::percentDone), "xsd:long"))
				{	soap_flag_percentDone1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CRequirementDocument, 0, sizeof(ns1__CRequirementDocument), 0, soap_copy_ns1__CRequirementDocument);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CRequirementDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CRequirementDocument);
	if (this->soap_out(soap, tag?tag:"ns1:CRequirementDocument", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CRequirementDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CRequirementDocument(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CRequirementDocument * SOAP_FMAC4 soap_get_ns1__CRequirementDocument(struct soap *soap, ns1__CRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__CRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CRequirementDocument);
		if (size)
			*size = sizeof(ns1__CRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CRequirementDocument, n);
		if (size)
			*size = n * sizeof(ns1__CRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CRequirementDocument %p -> %p\n", q, p));
	*(ns1__CRequirementDocument*)p = *(ns1__CRequirementDocument*)q;
}

void ns1__CRequirement::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CRequirement::recordid);
	this->ns1__CRequirement::number = NULL;
	soap_default_string(soap, &this->ns1__CRequirement::type);
	soap_default_string(soap, &this->ns1__CRequirement::summary);
	soap_default_string(soap, &this->ns1__CRequirement::tag);
	soap_default_xsd__date(soap, &this->ns1__CRequirement::dateEntered);
	soap_default_string(soap, &this->ns1__CRequirement::enteredBy);
	soap_default_string(soap, &this->ns1__CRequirement::importance);
	soap_default_string(soap, &this->ns1__CRequirement::description);
	this->ns1__CRequirement::descriptionInlineAttachList = NULL;
	soap_default_string(soap, &this->ns1__CRequirement::state);
	this->ns1__CRequirement::attachmentList = NULL;
	this->ns1__CRequirement::sccFileList = NULL;
	this->ns1__CRequirement::customFieldList = NULL;
	this->ns1__CRequirement::eventList = NULL;
	this->ns1__CRequirement::versionList = NULL;
	this->ns1__CRequirement::dateTimeCreated = NULL;
	soap_default_string(soap, &this->ns1__CRequirement::createdByUser);
	soap_default_string(soap, &this->ns1__CRequirement::locationAddedFrom);
	soap_default_string(soap, &this->ns1__CRequirement::modifiedByUser);
	this->ns1__CRequirement::dateTimeModified = NULL;
	this->ns1__CRequirement::actualHours = NULL;
	this->ns1__CRequirement::estimatedHours = NULL;
	this->ns1__CRequirement::remainingHours = NULL;
	this->ns1__CRequirement::variance = NULL;
	this->ns1__CRequirement::storyPoints = NULL;
	this->ns1__CRequirement::percentDone = NULL;
}

void ns1__CRequirement::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CRequirement::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirement::number);
	soap_serialize_string(soap, &this->ns1__CRequirement::type);
	soap_serialize_string(soap, &this->ns1__CRequirement::summary);
	soap_serialize_string(soap, &this->ns1__CRequirement::tag);
	soap_serialize_xsd__date(soap, &this->ns1__CRequirement::dateEntered);
	soap_serialize_string(soap, &this->ns1__CRequirement::enteredBy);
	soap_serialize_string(soap, &this->ns1__CRequirement::importance);
	soap_serialize_string(soap, &this->ns1__CRequirement::description);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CRequirement::descriptionInlineAttachList);
	soap_serialize_string(soap, &this->ns1__CRequirement::state);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CRequirement::attachmentList);
	soap_serialize_PointerToArrayOfCSCCFileRecord(soap, &this->ns1__CRequirement::sccFileList);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CRequirement::customFieldList);
	soap_serialize_PointerToArrayOfCEvent(soap, &this->ns1__CRequirement::eventList);
	soap_serialize_PointerToArrayOfCVersionInfo(soap, &this->ns1__CRequirement::versionList);
	soap_serialize_PointerTotime(soap, &this->ns1__CRequirement::dateTimeCreated);
	soap_serialize_string(soap, &this->ns1__CRequirement::createdByUser);
	soap_serialize_string(soap, &this->ns1__CRequirement::locationAddedFrom);
	soap_serialize_string(soap, &this->ns1__CRequirement::modifiedByUser);
	soap_serialize_PointerTotime(soap, &this->ns1__CRequirement::dateTimeModified);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirement::actualHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirement::estimatedHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirement::remainingHours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CRequirement::variance);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirement::storyPoints);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CRequirement::percentDone);
#endif
}

int ns1__CRequirement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CRequirement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CRequirement(struct soap *soap, const char *tag, int id, const ns1__CRequirement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CRequirement::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "number", -1, &(a->ns1__CRequirement::number), ""))
		return soap->error;
	if (a->ns1__CRequirement::type)
	{	if (soap_out_string(soap, "type", -1, &a->ns1__CRequirement::type, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "type"))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CRequirement::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "tag", -1, &(a->ns1__CRequirement::tag), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "dateEntered", -1, &(a->ns1__CRequirement::dateEntered), ""))
		return soap->error;
	if (soap_out_string(soap, "enteredBy", -1, &(a->ns1__CRequirement::enteredBy), ""))
		return soap->error;
	if (soap_out_string(soap, "importance", -1, &(a->ns1__CRequirement::importance), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns1__CRequirement::description), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "descriptionInlineAttachList", -1, &(a->ns1__CRequirement::descriptionInlineAttachList), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CRequirement::state), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentList", -1, &(a->ns1__CRequirement::attachmentList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->ns1__CRequirement::sccFileList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFieldList", -1, &(a->ns1__CRequirement::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCEvent(soap, "eventList", -1, &(a->ns1__CRequirement::eventList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCVersionInfo(soap, "versionList", -1, &(a->ns1__CRequirement::versionList), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateTimeCreated", -1, &(a->ns1__CRequirement::dateTimeCreated), ""))
		return soap->error;
	if (soap_out_string(soap, "createdByUser", -1, &(a->ns1__CRequirement::createdByUser), ""))
		return soap->error;
	if (soap_out_string(soap, "locationAddedFrom", -1, &(a->ns1__CRequirement::locationAddedFrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedByUser", -1, &(a->ns1__CRequirement::modifiedByUser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "dateTimeModified", -1, &(a->ns1__CRequirement::dateTimeModified), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualHours", -1, &(a->ns1__CRequirement::actualHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedHours", -1, &(a->ns1__CRequirement::estimatedHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "remainingHours", -1, &(a->ns1__CRequirement::remainingHours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "variance", -1, &(a->ns1__CRequirement::variance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storyPoints", -1, &(a->ns1__CRequirement::storyPoints), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "percentDone", -1, &(a->ns1__CRequirement::percentDone), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CRequirement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CRequirement(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CRequirement * SOAP_FMAC4 soap_in_ns1__CRequirement(struct soap *soap, const char *tag, ns1__CRequirement *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CRequirement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CRequirement, sizeof(ns1__CRequirement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CRequirement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CRequirement *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_tag1 = 1;
	size_t soap_flag_dateEntered1 = 1;
	size_t soap_flag_enteredBy1 = 1;
	size_t soap_flag_importance1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_descriptionInlineAttachList1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_attachmentList1 = 1;
	size_t soap_flag_sccFileList1 = 1;
	size_t soap_flag_customFieldList1 = 1;
	size_t soap_flag_eventList1 = 1;
	size_t soap_flag_versionList1 = 1;
	size_t soap_flag_dateTimeCreated1 = 1;
	size_t soap_flag_createdByUser1 = 1;
	size_t soap_flag_locationAddedFrom1 = 1;
	size_t soap_flag_modifiedByUser1 = 1;
	size_t soap_flag_dateTimeModified1 = 1;
	size_t soap_flag_actualHours1 = 1;
	size_t soap_flag_estimatedHours1 = 1;
	size_t soap_flag_remainingHours1 = 1;
	size_t soap_flag_variance1 = 1;
	size_t soap_flag_storyPoints1 = 1;
	size_t soap_flag_percentDone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CRequirement::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_number1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "number", &(a->ns1__CRequirement::number), "xsd:long"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns1__CRequirement::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CRequirement::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_tag1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tag", &(a->ns1__CRequirement::tag), "xsd:string"))
				{	soap_flag_tag1--;
					continue;
				}
			if (soap_flag_dateEntered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "dateEntered", &(a->ns1__CRequirement::dateEntered), "xsd:date"))
				{	soap_flag_dateEntered1--;
					continue;
				}
			if (soap_flag_enteredBy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "enteredBy", &(a->ns1__CRequirement::enteredBy), "xsd:string"))
				{	soap_flag_enteredBy1--;
					continue;
				}
			if (soap_flag_importance1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "importance", &(a->ns1__CRequirement::importance), "xsd:string"))
				{	soap_flag_importance1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns1__CRequirement::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_descriptionInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "descriptionInlineAttachList", &(a->ns1__CRequirement::descriptionInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_descriptionInlineAttachList1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CRequirement::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_attachmentList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentList", &(a->ns1__CRequirement::attachmentList), "ns1:CFileAttachment"))
				{	soap_flag_attachmentList1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", &(a->ns1__CRequirement::sccFileList), "ns1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFieldList", &(a->ns1__CRequirement::customFieldList), "ns1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEvent(soap, "eventList", &(a->ns1__CRequirement::eventList), "ns1:CEvent"))
				{	soap_flag_eventList1--;
					continue;
				}
			if (soap_flag_versionList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCVersionInfo(soap, "versionList", &(a->ns1__CRequirement::versionList), "ns1:CVersionInfo"))
				{	soap_flag_versionList1--;
					continue;
				}
			if (soap_flag_dateTimeCreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateTimeCreated", &(a->ns1__CRequirement::dateTimeCreated), "xsd:dateTime"))
				{	soap_flag_dateTimeCreated1--;
					continue;
				}
			if (soap_flag_createdByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdByUser", &(a->ns1__CRequirement::createdByUser), "xsd:string"))
				{	soap_flag_createdByUser1--;
					continue;
				}
			if (soap_flag_locationAddedFrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationAddedFrom", &(a->ns1__CRequirement::locationAddedFrom), "xsd:string"))
				{	soap_flag_locationAddedFrom1--;
					continue;
				}
			if (soap_flag_modifiedByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedByUser", &(a->ns1__CRequirement::modifiedByUser), "xsd:string"))
				{	soap_flag_modifiedByUser1--;
					continue;
				}
			if (soap_flag_dateTimeModified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "dateTimeModified", &(a->ns1__CRequirement::dateTimeModified), "xsd:dateTime"))
				{	soap_flag_dateTimeModified1--;
					continue;
				}
			if (soap_flag_actualHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualHours", &(a->ns1__CRequirement::actualHours), "xsd:double"))
				{	soap_flag_actualHours1--;
					continue;
				}
			if (soap_flag_estimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedHours", &(a->ns1__CRequirement::estimatedHours), "xsd:double"))
				{	soap_flag_estimatedHours1--;
					continue;
				}
			if (soap_flag_remainingHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "remainingHours", &(a->ns1__CRequirement::remainingHours), "xsd:double"))
				{	soap_flag_remainingHours1--;
					continue;
				}
			if (soap_flag_variance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "variance", &(a->ns1__CRequirement::variance), "xsd:double"))
				{	soap_flag_variance1--;
					continue;
				}
			if (soap_flag_storyPoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storyPoints", &(a->ns1__CRequirement::storyPoints), "xsd:long"))
				{	soap_flag_storyPoints1--;
					continue;
				}
			if (soap_flag_percentDone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "percentDone", &(a->ns1__CRequirement::percentDone), "xsd:long"))
				{	soap_flag_percentDone1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CRequirement, 0, sizeof(ns1__CRequirement), 0, soap_copy_ns1__CRequirement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CRequirement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CRequirement);
	if (this->soap_out(soap, tag?tag:"ns1:CRequirement", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CRequirement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CRequirement(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CRequirement * SOAP_FMAC4 soap_get_ns1__CRequirement(struct soap *soap, ns1__CRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CRequirement * SOAP_FMAC2 soap_instantiate_ns1__CRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CRequirement);
		if (size)
			*size = sizeof(ns1__CRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CRequirement, n);
		if (size)
			*size = n * sizeof(ns1__CRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CRequirement %p -> %p\n", q, p));
	*(ns1__CRequirement*)p = *(ns1__CRequirement*)q;
}

void ArrayOfCSnapshotInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCSnapshotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCSnapshotInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CSnapshotInfo(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCSnapshotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCSnapshotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCSnapshotInfo(struct soap *soap, const char *tag, int id, const ArrayOfCSnapshotInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CSnapshotInfo", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCSnapshotInfo);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CSnapshotInfo(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCSnapshotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCSnapshotInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCSnapshotInfo * SOAP_FMAC4 soap_in_ArrayOfCSnapshotInfo(struct soap *soap, const char *tag, ArrayOfCSnapshotInfo *a, const char *type)
{	int i, j;
	ns1__CSnapshotInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCSnapshotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCSnapshotInfo, sizeof(ArrayOfCSnapshotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CSnapshotInfo **)soap_malloc(soap, sizeof(ns1__CSnapshotInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CSnapshotInfo(soap, NULL, a->__ptritem + i, "ns1:CSnapshotInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CSnapshotInfo **)soap_push_block(soap, NULL, sizeof(ns1__CSnapshotInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CSnapshotInfo(soap, NULL, p, "ns1:CSnapshotInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CSnapshotInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCSnapshotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCSnapshotInfo, 0, sizeof(ArrayOfCSnapshotInfo), 0, soap_copy_ArrayOfCSnapshotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCSnapshotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCSnapshotInfo);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCSnapshotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCSnapshotInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCSnapshotInfo * SOAP_FMAC4 soap_get_ArrayOfCSnapshotInfo(struct soap *soap, ArrayOfCSnapshotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCSnapshotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCSnapshotInfo * SOAP_FMAC2 soap_instantiate_ArrayOfCSnapshotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCSnapshotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCSnapshotInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCSnapshotInfo);
		if (size)
			*size = sizeof(ArrayOfCSnapshotInfo);
		((ArrayOfCSnapshotInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCSnapshotInfo, n);
		if (size)
			*size = n * sizeof(ArrayOfCSnapshotInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCSnapshotInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCSnapshotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCSnapshotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCSnapshotInfo %p -> %p\n", q, p));
	*(ArrayOfCSnapshotInfo*)p = *(ArrayOfCSnapshotInfo*)q;
}

void ns1__CSnapshotInfo::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns1__CSnapshotInfo::versionNumber = NULL;
	soap_default_string(soap, &this->ns1__CSnapshotInfo::createdByUser);
	soap_default_string(soap, &this->ns1__CSnapshotInfo::dateTimeCreated);
	soap_default_string(soap, &this->ns1__CSnapshotInfo::label);
	soap_default_string(soap, &this->ns1__CSnapshotInfo::comment);
}

void ns1__CSnapshotInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__CSnapshotInfo::versionNumber);
	soap_serialize_string(soap, &this->ns1__CSnapshotInfo::createdByUser);
	soap_serialize_string(soap, &this->ns1__CSnapshotInfo::dateTimeCreated);
	soap_serialize_string(soap, &this->ns1__CSnapshotInfo::label);
	soap_serialize_string(soap, &this->ns1__CSnapshotInfo::comment);
#endif
}

int ns1__CSnapshotInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CSnapshotInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CSnapshotInfo(struct soap *soap, const char *tag, int id, const ns1__CSnapshotInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CSnapshotInfo), type))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "versionNumber", -1, &(a->ns1__CSnapshotInfo::versionNumber), ""))
		return soap->error;
	if (soap_out_string(soap, "createdByUser", -1, &(a->ns1__CSnapshotInfo::createdByUser), ""))
		return soap->error;
	if (soap_out_string(soap, "dateTimeCreated", -1, &(a->ns1__CSnapshotInfo::dateTimeCreated), ""))
		return soap->error;
	if (soap_out_string(soap, "label", -1, &(a->ns1__CSnapshotInfo::label), ""))
		return soap->error;
	if (soap_out_string(soap, "comment", -1, &(a->ns1__CSnapshotInfo::comment), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CSnapshotInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CSnapshotInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CSnapshotInfo * SOAP_FMAC4 soap_in_ns1__CSnapshotInfo(struct soap *soap, const char *tag, ns1__CSnapshotInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CSnapshotInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CSnapshotInfo, sizeof(ns1__CSnapshotInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CSnapshotInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CSnapshotInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_versionNumber1 = 1;
	size_t soap_flag_createdByUser1 = 1;
	size_t soap_flag_dateTimeCreated1 = 1;
	size_t soap_flag_label1 = 1;
	size_t soap_flag_comment1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "versionNumber", &(a->ns1__CSnapshotInfo::versionNumber), "xsd:long"))
				{	soap_flag_versionNumber1--;
					continue;
				}
			if (soap_flag_createdByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdByUser", &(a->ns1__CSnapshotInfo::createdByUser), "xsd:string"))
				{	soap_flag_createdByUser1--;
					continue;
				}
			if (soap_flag_dateTimeCreated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dateTimeCreated", &(a->ns1__CSnapshotInfo::dateTimeCreated), "xsd:string"))
				{	soap_flag_dateTimeCreated1--;
					continue;
				}
			if (soap_flag_label1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "label", &(a->ns1__CSnapshotInfo::label), "xsd:string"))
				{	soap_flag_label1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comment", &(a->ns1__CSnapshotInfo::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CSnapshotInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CSnapshotInfo, 0, sizeof(ns1__CSnapshotInfo), 0, soap_copy_ns1__CSnapshotInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CSnapshotInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CSnapshotInfo);
	if (this->soap_out(soap, tag?tag:"ns1:CSnapshotInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CSnapshotInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CSnapshotInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CSnapshotInfo * SOAP_FMAC4 soap_get_ns1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CSnapshotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CSnapshotInfo * SOAP_FMAC2 soap_instantiate_ns1__CSnapshotInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CSnapshotInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CSnapshotInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CSnapshotInfo);
		if (size)
			*size = sizeof(ns1__CSnapshotInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CSnapshotInfo, n);
		if (size)
			*size = n * sizeof(ns1__CSnapshotInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CSnapshotInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CSnapshotInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CSnapshotInfo %p -> %p\n", q, p));
	*(ns1__CSnapshotInfo*)p = *(ns1__CSnapshotInfo*)q;
}

void ArrayOfCVersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCVersionInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCVersionInfo))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CVersionInfo(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCVersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCVersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCVersionInfo(struct soap *soap, const char *tag, int id, const ArrayOfCVersionInfo *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CVersionInfo", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCVersionInfo);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CVersionInfo(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCVersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCVersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCVersionInfo * SOAP_FMAC4 soap_in_ArrayOfCVersionInfo(struct soap *soap, const char *tag, ArrayOfCVersionInfo *a, const char *type)
{	int i, j;
	ns1__CVersionInfo **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCVersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCVersionInfo, sizeof(ArrayOfCVersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CVersionInfo **)soap_malloc(soap, sizeof(ns1__CVersionInfo *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CVersionInfo(soap, NULL, a->__ptritem + i, "ns1:CVersionInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CVersionInfo **)soap_push_block(soap, NULL, sizeof(ns1__CVersionInfo *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CVersionInfo(soap, NULL, p, "ns1:CVersionInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CVersionInfo **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCVersionInfo, 0, sizeof(ArrayOfCVersionInfo), 0, soap_copy_ArrayOfCVersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCVersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCVersionInfo);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCVersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCVersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCVersionInfo * SOAP_FMAC4 soap_get_ArrayOfCVersionInfo(struct soap *soap, ArrayOfCVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCVersionInfo * SOAP_FMAC2 soap_instantiate_ArrayOfCVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCVersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCVersionInfo);
		if (size)
			*size = sizeof(ArrayOfCVersionInfo);
		((ArrayOfCVersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCVersionInfo, n);
		if (size)
			*size = n * sizeof(ArrayOfCVersionInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCVersionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCVersionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCVersionInfo %p -> %p\n", q, p));
	*(ArrayOfCVersionInfo*)p = *(ArrayOfCVersionInfo*)q;
}

void ns1__CVersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CVersionInfo::versionNumber = NULL;
	soap_default_string(soap, &this->ns1__CVersionInfo::createdByUser);
	soap_default_string(soap, &this->ns1__CVersionInfo::dateTimeCreated);
	/* transient soap skipped */
}

void ns1__CVersionInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToLONG64(soap, &this->ns1__CVersionInfo::versionNumber);
	soap_serialize_string(soap, &this->ns1__CVersionInfo::createdByUser);
	soap_serialize_string(soap, &this->ns1__CVersionInfo::dateTimeCreated);
	/* transient soap skipped */
#endif
}

int ns1__CVersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CVersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CVersionInfo(struct soap *soap, const char *tag, int id, const ns1__CVersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CVersionInfo), type))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "versionNumber", -1, &(a->ns1__CVersionInfo::versionNumber), ""))
		return soap->error;
	if (soap_out_string(soap, "createdByUser", -1, &(a->ns1__CVersionInfo::createdByUser), ""))
		return soap->error;
	if (soap_out_string(soap, "dateTimeCreated", -1, &(a->ns1__CVersionInfo::dateTimeCreated), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CVersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CVersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CVersionInfo * SOAP_FMAC4 soap_in_ns1__CVersionInfo(struct soap *soap, const char *tag, ns1__CVersionInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CVersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CVersionInfo, sizeof(ns1__CVersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CVersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CVersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_versionNumber1 = 1;
	size_t soap_flag_createdByUser1 = 1;
	size_t soap_flag_dateTimeCreated1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionNumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "versionNumber", &(a->ns1__CVersionInfo::versionNumber), "xsd:long"))
				{	soap_flag_versionNumber1--;
					continue;
				}
			if (soap_flag_createdByUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdByUser", &(a->ns1__CVersionInfo::createdByUser), "xsd:string"))
				{	soap_flag_createdByUser1--;
					continue;
				}
			if (soap_flag_dateTimeCreated1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dateTimeCreated", &(a->ns1__CVersionInfo::dateTimeCreated), "xsd:string"))
				{	soap_flag_dateTimeCreated1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CVersionInfo, 0, sizeof(ns1__CVersionInfo), 0, soap_copy_ns1__CVersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CVersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CVersionInfo);
	if (this->soap_out(soap, tag?tag:"ns1:CVersionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CVersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CVersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CVersionInfo * SOAP_FMAC4 soap_get_ns1__CVersionInfo(struct soap *soap, ns1__CVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CVersionInfo * SOAP_FMAC2 soap_instantiate_ns1__CVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CVersionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CVersionInfo);
		if (size)
			*size = sizeof(ns1__CVersionInfo);
		((ns1__CVersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CVersionInfo, n);
		if (size)
			*size = n * sizeof(ns1__CVersionInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CVersionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CVersionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CVersionInfo %p -> %p\n", q, p));
	*(ns1__CVersionInfo*)p = *(ns1__CVersionInfo*)q;
}

void ArrayOfCFolderItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFolderItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFolderItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFolderItem(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFolderItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFolderItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFolderItem(struct soap *soap, const char *tag, int id, const ArrayOfCFolderItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFolderItem", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolderItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFolderItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFolderItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFolderItem(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFolderItem * SOAP_FMAC4 soap_in_ArrayOfCFolderItem(struct soap *soap, const char *tag, ArrayOfCFolderItem *a, const char *type)
{	int i, j;
	ns1__CFolderItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFolderItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFolderItem, sizeof(ArrayOfCFolderItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFolderItem **)soap_malloc(soap, sizeof(ns1__CFolderItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFolderItem(soap, NULL, a->__ptritem + i, "ns1:CFolderItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFolderItem **)soap_push_block(soap, NULL, sizeof(ns1__CFolderItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFolderItem(soap, NULL, p, "ns1:CFolderItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFolderItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFolderItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFolderItem, 0, sizeof(ArrayOfCFolderItem), 0, soap_copy_ArrayOfCFolderItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFolderItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFolderItem);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFolderItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFolderItem(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFolderItem * SOAP_FMAC4 soap_get_ArrayOfCFolderItem(struct soap *soap, ArrayOfCFolderItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFolderItem * SOAP_FMAC2 soap_instantiate_ArrayOfCFolderItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFolderItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFolderItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFolderItem);
		if (size)
			*size = sizeof(ArrayOfCFolderItem);
		((ArrayOfCFolderItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFolderItem, n);
		if (size)
			*size = n * sizeof(ArrayOfCFolderItem);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFolderItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFolderItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFolderItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFolderItem %p -> %p\n", q, p));
	*(ArrayOfCFolderItem*)p = *(ArrayOfCFolderItem*)q;
}

void ArrayOfCFolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFolder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFolder))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFolder(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFolder(struct soap *soap, const char *tag, int id, const ArrayOfCFolder *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFolder", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolder);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFolder(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFolder(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFolder * SOAP_FMAC4 soap_in_ArrayOfCFolder(struct soap *soap, const char *tag, ArrayOfCFolder *a, const char *type)
{	int i, j;
	ns1__CFolder **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFolder, sizeof(ArrayOfCFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFolder **)soap_malloc(soap, sizeof(ns1__CFolder *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFolder(soap, NULL, a->__ptritem + i, "ns1:CFolder"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFolder **)soap_push_block(soap, NULL, sizeof(ns1__CFolder *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFolder(soap, NULL, p, "ns1:CFolder"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFolder **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFolder, 0, sizeof(ArrayOfCFolder), 0, soap_copy_ArrayOfCFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFolder);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFolder(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFolder * SOAP_FMAC4 soap_get_ArrayOfCFolder(struct soap *soap, ArrayOfCFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFolder * SOAP_FMAC2 soap_instantiate_ArrayOfCFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFolder);
		if (size)
			*size = sizeof(ArrayOfCFolder);
		((ArrayOfCFolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFolder, n);
		if (size)
			*size = n * sizeof(ArrayOfCFolder);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFolder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFolder %p -> %p\n", q, p));
	*(ArrayOfCFolder*)p = *(ArrayOfCFolder*)q;
}

void ns1__CFolderItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CFolderItem::recordid);
	soap_default_string(soap, &this->ns1__CFolderItem::entitytablename);
	soap_default_LONG64(soap, &this->ns1__CFolderItem::entityrecordid);
	this->ns1__CFolderItem::rank = NULL;
}

void ns1__CFolderItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CFolderItem::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CFolderItem::entitytablename);
	soap_embedded(soap, &this->ns1__CFolderItem::entityrecordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFolderItem::rank);
#endif
}

int ns1__CFolderItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFolderItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFolderItem(struct soap *soap, const char *tag, int id, const ns1__CFolderItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFolderItem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CFolderItem::recordid), ""))
		return soap->error;
	if (a->ns1__CFolderItem::entitytablename)
	{	if (soap_out_string(soap, "entitytablename", -1, &a->ns1__CFolderItem::entitytablename, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "entitytablename"))
		return soap->error;
	if (soap_out_LONG64(soap, "entityrecordid", -1, &(a->ns1__CFolderItem::entityrecordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "rank", -1, &(a->ns1__CFolderItem::rank), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CFolderItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFolderItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFolderItem * SOAP_FMAC4 soap_in_ns1__CFolderItem(struct soap *soap, const char *tag, ns1__CFolderItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFolderItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFolderItem, sizeof(ns1__CFolderItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFolderItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFolderItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_entitytablename1 = 1;
	size_t soap_flag_entityrecordid1 = 1;
	size_t soap_flag_rank1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CFolderItem::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_entitytablename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entitytablename", &(a->ns1__CFolderItem::entitytablename), "xsd:string"))
				{	soap_flag_entitytablename1--;
					continue;
				}
			if (soap_flag_entityrecordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityrecordid", &(a->ns1__CFolderItem::entityrecordid), "xsd:long"))
				{	soap_flag_entityrecordid1--;
					continue;
				}
			if (soap_flag_rank1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "rank", &(a->ns1__CFolderItem::rank), "xsd:long"))
				{	soap_flag_rank1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFolderItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFolderItem, 0, sizeof(ns1__CFolderItem), 0, soap_copy_ns1__CFolderItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_entitytablename1 > 0 || soap_flag_entityrecordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFolderItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFolderItem);
	if (this->soap_out(soap, tag?tag:"ns1:CFolderItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFolderItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFolderItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFolderItem * SOAP_FMAC4 soap_get_ns1__CFolderItem(struct soap *soap, ns1__CFolderItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFolderItem * SOAP_FMAC2 soap_instantiate_ns1__CFolderItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFolderItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFolderItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFolderItem);
		if (size)
			*size = sizeof(ns1__CFolderItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFolderItem, n);
		if (size)
			*size = n * sizeof(ns1__CFolderItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFolderItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFolderItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFolderItem %p -> %p\n", q, p));
	*(ns1__CFolderItem*)p = *(ns1__CFolderItem*)q;
}

void ns1__CFolder::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CFolder::recordid);
	this->ns1__CFolder::createdbyuser = NULL;
	this->ns1__CFolder::ispublic = NULL;
	this->ns1__CFolder::modifiedbyuser = NULL;
	soap_default_string(soap, &this->ns1__CFolder::locationaddedfrom);
	this->ns1__CFolder::datetimecreated = NULL;
	this->ns1__CFolder::datetimemodified = NULL;
	soap_default_string(soap, &this->ns1__CFolder::name);
	soap_default_string(soap, &this->ns1__CFolder::description);
	soap_default_string(soap, &this->ns1__CFolder::path);
	this->ns1__CFolder::order = NULL;
	this->ns1__CFolder::parentid = NULL;
	soap_default_string(soap, &this->ns1__CFolder::foldertypename);
	soap_default_string(soap, &this->ns1__CFolder::webview);
	soap_default_string(soap, &this->ns1__CFolder::notes);
	this->ns1__CFolder::notesInlineAttachList = NULL;
	this->ns1__CFolder::noteseditable = NULL;
	this->ns1__CFolder::scheduleinfo = NULL;
}

void ns1__CFolder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CFolder::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFolder::createdbyuser);
	soap_serialize_PointerTobool(soap, &this->ns1__CFolder::ispublic);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFolder::modifiedbyuser);
	soap_serialize_string(soap, &this->ns1__CFolder::locationaddedfrom);
	soap_serialize_PointerTotime(soap, &this->ns1__CFolder::datetimecreated);
	soap_serialize_PointerTotime(soap, &this->ns1__CFolder::datetimemodified);
	soap_serialize_string(soap, &this->ns1__CFolder::name);
	soap_serialize_string(soap, &this->ns1__CFolder::description);
	soap_serialize_string(soap, &this->ns1__CFolder::path);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFolder::order);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFolder::parentid);
	soap_serialize_string(soap, &this->ns1__CFolder::foldertypename);
	soap_serialize_string(soap, &this->ns1__CFolder::webview);
	soap_serialize_string(soap, &this->ns1__CFolder::notes);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CFolder::notesInlineAttachList);
	soap_serialize_PointerTobool(soap, &this->ns1__CFolder::noteseditable);
	soap_serialize_PointerTons1__CScheduleInfo(soap, &this->ns1__CFolder::scheduleinfo);
#endif
}

int ns1__CFolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFolder(struct soap *soap, const char *tag, int id, const ns1__CFolder *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CFolder::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "createdbyuser", -1, &(a->ns1__CFolder::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "ispublic", -1, &(a->ns1__CFolder::ispublic), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "modifiedbyuser", -1, &(a->ns1__CFolder::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->ns1__CFolder::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->ns1__CFolder::datetimecreated), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->ns1__CFolder::datetimemodified), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CFolder::name), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns1__CFolder::description), ""))
		return soap->error;
	if (soap_out_string(soap, "path", -1, &(a->ns1__CFolder::path), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "order", -1, &(a->ns1__CFolder::order), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parentid", -1, &(a->ns1__CFolder::parentid), ""))
		return soap->error;
	if (soap_out_string(soap, "foldertypename", -1, &(a->ns1__CFolder::foldertypename), ""))
		return soap->error;
	if (soap_out_string(soap, "webview", -1, &(a->ns1__CFolder::webview), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->ns1__CFolder::notes), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "notesInlineAttachList", -1, &(a->ns1__CFolder::notesInlineAttachList), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "noteseditable", -1, &(a->ns1__CFolder::noteseditable), ""))
		return soap->error;
	if (soap_out_PointerTons1__CScheduleInfo(soap, "scheduleinfo", -1, &(a->ns1__CFolder::scheduleinfo), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CFolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFolder(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFolder * SOAP_FMAC4 soap_in_ns1__CFolder(struct soap *soap, const char *tag, ns1__CFolder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFolder, sizeof(ns1__CFolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFolder *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_createdbyuser1 = 1;
	size_t soap_flag_ispublic1 = 1;
	size_t soap_flag_modifiedbyuser1 = 1;
	size_t soap_flag_locationaddedfrom1 = 1;
	size_t soap_flag_datetimecreated1 = 1;
	size_t soap_flag_datetimemodified1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_path1 = 1;
	size_t soap_flag_order1 = 1;
	size_t soap_flag_parentid1 = 1;
	size_t soap_flag_foldertypename1 = 1;
	size_t soap_flag_webview1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_notesInlineAttachList1 = 1;
	size_t soap_flag_noteseditable1 = 1;
	size_t soap_flag_scheduleinfo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CFolder::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "createdbyuser", &(a->ns1__CFolder::createdbyuser), "xsd:long"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_ispublic1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "ispublic", &(a->ns1__CFolder::ispublic), "xsd:boolean"))
				{	soap_flag_ispublic1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "modifiedbyuser", &(a->ns1__CFolder::modifiedbyuser), "xsd:long"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->ns1__CFolder::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->ns1__CFolder::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->ns1__CFolder::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CFolder::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns1__CFolder::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &(a->ns1__CFolder::path), "xsd:string"))
				{	soap_flag_path1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "order", &(a->ns1__CFolder::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap_flag_parentid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parentid", &(a->ns1__CFolder::parentid), "xsd:long"))
				{	soap_flag_parentid1--;
					continue;
				}
			if (soap_flag_foldertypename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "foldertypename", &(a->ns1__CFolder::foldertypename), "xsd:string"))
				{	soap_flag_foldertypename1--;
					continue;
				}
			if (soap_flag_webview1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "webview", &(a->ns1__CFolder::webview), "xsd:string"))
				{	soap_flag_webview1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->ns1__CFolder::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_notesInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "notesInlineAttachList", &(a->ns1__CFolder::notesInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_notesInlineAttachList1--;
					continue;
				}
			if (soap_flag_noteseditable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "noteseditable", &(a->ns1__CFolder::noteseditable), "xsd:boolean"))
				{	soap_flag_noteseditable1--;
					continue;
				}
			if (soap_flag_scheduleinfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CScheduleInfo(soap, "scheduleinfo", &(a->ns1__CFolder::scheduleinfo), "ns1:CScheduleInfo"))
				{	soap_flag_scheduleinfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFolder, 0, sizeof(ns1__CFolder), 0, soap_copy_ns1__CFolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFolder);
	if (this->soap_out(soap, tag?tag:"ns1:CFolder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFolder(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFolder * SOAP_FMAC4 soap_get_ns1__CFolder(struct soap *soap, ns1__CFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFolder * SOAP_FMAC2 soap_instantiate_ns1__CFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFolder);
		if (size)
			*size = sizeof(ns1__CFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFolder, n);
		if (size)
			*size = n * sizeof(ns1__CFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFolder %p -> %p\n", q, p));
	*(ns1__CFolder*)p = *(ns1__CFolder*)q;
}

void ArrayOfCFolderType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFolderType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFolderType))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFolderType(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFolderType(struct soap *soap, const char *tag, int id, const ArrayOfCFolderType *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFolderType", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolderType);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFolderType(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFolderType(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFolderType * SOAP_FMAC4 soap_in_ArrayOfCFolderType(struct soap *soap, const char *tag, ArrayOfCFolderType *a, const char *type)
{	int i, j;
	ns1__CFolderType **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFolderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFolderType, sizeof(ArrayOfCFolderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFolderType **)soap_malloc(soap, sizeof(ns1__CFolderType *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFolderType(soap, NULL, a->__ptritem + i, "ns1:CFolderType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFolderType **)soap_push_block(soap, NULL, sizeof(ns1__CFolderType *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFolderType(soap, NULL, p, "ns1:CFolderType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFolderType **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFolderType, 0, sizeof(ArrayOfCFolderType), 0, soap_copy_ArrayOfCFolderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFolderType);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFolderType(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFolderType * SOAP_FMAC4 soap_get_ArrayOfCFolderType(struct soap *soap, ArrayOfCFolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFolderType * SOAP_FMAC2 soap_instantiate_ArrayOfCFolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFolderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFolderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFolderType);
		if (size)
			*size = sizeof(ArrayOfCFolderType);
		((ArrayOfCFolderType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFolderType, n);
		if (size)
			*size = n * sizeof(ArrayOfCFolderType);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFolderType*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFolderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFolderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFolderType %p -> %p\n", q, p));
	*(ArrayOfCFolderType*)p = *(ArrayOfCFolderType*)q;
}

void ns1__CFolderType::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CFolderType::recordid);
	soap_default_string(soap, &this->ns1__CFolderType::name);
	soap_default_string(soap, &this->ns1__CFolderType::description);
	this->ns1__CFolderType::allowweb = NULL;
	this->ns1__CFolderType::allowdetails = NULL;
	this->ns1__CFolderType::releaseplanning = NULL;
}

void ns1__CFolderType::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CFolderType::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CFolderType::name);
	soap_serialize_string(soap, &this->ns1__CFolderType::description);
	soap_serialize_PointerTobool(soap, &this->ns1__CFolderType::allowweb);
	soap_serialize_PointerTobool(soap, &this->ns1__CFolderType::allowdetails);
	soap_serialize_PointerTobool(soap, &this->ns1__CFolderType::releaseplanning);
#endif
}

int ns1__CFolderType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFolderType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFolderType(struct soap *soap, const char *tag, int id, const ns1__CFolderType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFolderType), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CFolderType::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CFolderType::name), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns1__CFolderType::description), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "allowweb", -1, &(a->ns1__CFolderType::allowweb), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "allowdetails", -1, &(a->ns1__CFolderType::allowdetails), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "releaseplanning", -1, &(a->ns1__CFolderType::releaseplanning), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CFolderType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFolderType(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFolderType * SOAP_FMAC4 soap_in_ns1__CFolderType(struct soap *soap, const char *tag, ns1__CFolderType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFolderType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFolderType, sizeof(ns1__CFolderType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFolderType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFolderType *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_allowweb1 = 1;
	size_t soap_flag_allowdetails1 = 1;
	size_t soap_flag_releaseplanning1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CFolderType::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CFolderType::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns1__CFolderType::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_allowweb1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "allowweb", &(a->ns1__CFolderType::allowweb), "xsd:boolean"))
				{	soap_flag_allowweb1--;
					continue;
				}
			if (soap_flag_allowdetails1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "allowdetails", &(a->ns1__CFolderType::allowdetails), "xsd:boolean"))
				{	soap_flag_allowdetails1--;
					continue;
				}
			if (soap_flag_releaseplanning1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "releaseplanning", &(a->ns1__CFolderType::releaseplanning), "xsd:boolean"))
				{	soap_flag_releaseplanning1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFolderType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFolderType, 0, sizeof(ns1__CFolderType), 0, soap_copy_ns1__CFolderType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFolderType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFolderType);
	if (this->soap_out(soap, tag?tag:"ns1:CFolderType", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFolderType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFolderType(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFolderType * SOAP_FMAC4 soap_get_ns1__CFolderType(struct soap *soap, ns1__CFolderType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFolderType * SOAP_FMAC2 soap_instantiate_ns1__CFolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFolderType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFolderType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFolderType);
		if (size)
			*size = sizeof(ns1__CFolderType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFolderType, n);
		if (size)
			*size = n * sizeof(ns1__CFolderType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFolderType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFolderType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFolderType %p -> %p\n", q, p));
	*(ns1__CFolderType*)p = *(ns1__CFolderType*)q;
}

void ns1__CScheduleInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__date(soap, &this->ns1__CScheduleInfo::startdate);
	soap_default_xsd__date(soap, &this->ns1__CScheduleInfo::enddate);
	this->ns1__CScheduleInfo::includeweekends = NULL;
	this->ns1__CScheduleInfo::nonworkingdays = NULL;
	this->ns1__CScheduleInfo::hoursperday = NULL;
	this->ns1__CScheduleInfo::ptohours = NULL;
	this->ns1__CScheduleInfo::usersavailable = NULL;
	this->ns1__CScheduleInfo::storypoints = NULL;
	/* transient soap skipped */
}

void ns1__CScheduleInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__date(soap, &this->ns1__CScheduleInfo::startdate);
	soap_serialize_xsd__date(soap, &this->ns1__CScheduleInfo::enddate);
	soap_serialize_PointerTobool(soap, &this->ns1__CScheduleInfo::includeweekends);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CScheduleInfo::nonworkingdays);
	soap_serialize_PointerTodouble(soap, &this->ns1__CScheduleInfo::hoursperday);
	soap_serialize_PointerTodouble(soap, &this->ns1__CScheduleInfo::ptohours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CScheduleInfo::usersavailable);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CScheduleInfo::storypoints);
	/* transient soap skipped */
#endif
}

int ns1__CScheduleInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CScheduleInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CScheduleInfo(struct soap *soap, const char *tag, int id, const ns1__CScheduleInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CScheduleInfo), type))
		return soap->error;
	if (soap_out_xsd__date(soap, "startdate", -1, &(a->ns1__CScheduleInfo::startdate), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "enddate", -1, &(a->ns1__CScheduleInfo::enddate), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "includeweekends", -1, &(a->ns1__CScheduleInfo::includeweekends), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "nonworkingdays", -1, &(a->ns1__CScheduleInfo::nonworkingdays), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "hoursperday", -1, &(a->ns1__CScheduleInfo::hoursperday), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "ptohours", -1, &(a->ns1__CScheduleInfo::ptohours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "usersavailable", -1, &(a->ns1__CScheduleInfo::usersavailable), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storypoints", -1, &(a->ns1__CScheduleInfo::storypoints), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CScheduleInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CScheduleInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CScheduleInfo * SOAP_FMAC4 soap_in_ns1__CScheduleInfo(struct soap *soap, const char *tag, ns1__CScheduleInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CScheduleInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CScheduleInfo, sizeof(ns1__CScheduleInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CScheduleInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CScheduleInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_startdate1 = 1;
	size_t soap_flag_enddate1 = 1;
	size_t soap_flag_includeweekends1 = 1;
	size_t soap_flag_nonworkingdays1 = 1;
	size_t soap_flag_hoursperday1 = 1;
	size_t soap_flag_ptohours1 = 1;
	size_t soap_flag_usersavailable1 = 1;
	size_t soap_flag_storypoints1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startdate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "startdate", &(a->ns1__CScheduleInfo::startdate), "xsd:date"))
				{	soap_flag_startdate1--;
					continue;
				}
			if (soap_flag_enddate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "enddate", &(a->ns1__CScheduleInfo::enddate), "xsd:date"))
				{	soap_flag_enddate1--;
					continue;
				}
			if (soap_flag_includeweekends1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "includeweekends", &(a->ns1__CScheduleInfo::includeweekends), "xsd:boolean"))
				{	soap_flag_includeweekends1--;
					continue;
				}
			if (soap_flag_nonworkingdays1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "nonworkingdays", &(a->ns1__CScheduleInfo::nonworkingdays), "xsd:long"))
				{	soap_flag_nonworkingdays1--;
					continue;
				}
			if (soap_flag_hoursperday1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "hoursperday", &(a->ns1__CScheduleInfo::hoursperday), "xsd:double"))
				{	soap_flag_hoursperday1--;
					continue;
				}
			if (soap_flag_ptohours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "ptohours", &(a->ns1__CScheduleInfo::ptohours), "xsd:double"))
				{	soap_flag_ptohours1--;
					continue;
				}
			if (soap_flag_usersavailable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "usersavailable", &(a->ns1__CScheduleInfo::usersavailable), "xsd:double"))
				{	soap_flag_usersavailable1--;
					continue;
				}
			if (soap_flag_storypoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storypoints", &(a->ns1__CScheduleInfo::storypoints), "xsd:long"))
				{	soap_flag_storypoints1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CScheduleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CScheduleInfo, 0, sizeof(ns1__CScheduleInfo), 0, soap_copy_ns1__CScheduleInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CScheduleInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CScheduleInfo);
	if (this->soap_out(soap, tag?tag:"ns1:CScheduleInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CScheduleInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CScheduleInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CScheduleInfo * SOAP_FMAC4 soap_get_ns1__CScheduleInfo(struct soap *soap, ns1__CScheduleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CScheduleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CScheduleInfo * SOAP_FMAC2 soap_instantiate_ns1__CScheduleInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CScheduleInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CScheduleInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CScheduleInfo);
		if (size)
			*size = sizeof(ns1__CScheduleInfo);
		((ns1__CScheduleInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CScheduleInfo, n);
		if (size)
			*size = n * sizeof(ns1__CScheduleInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CScheduleInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CScheduleInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CScheduleInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CScheduleInfo %p -> %p\n", q, p));
	*(ns1__CScheduleInfo*)p = *(ns1__CScheduleInfo*)q;
}

void ArrayOfCItemToTrack::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCItemToTrack::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCItemToTrack))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CItemToTrack(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCItemToTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCItemToTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCItemToTrack(struct soap *soap, const char *tag, int id, const ArrayOfCItemToTrack *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CItemToTrack", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCItemToTrack);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CItemToTrack(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCItemToTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCItemToTrack(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCItemToTrack * SOAP_FMAC4 soap_in_ArrayOfCItemToTrack(struct soap *soap, const char *tag, ArrayOfCItemToTrack *a, const char *type)
{	int i, j;
	ns1__CItemToTrack **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCItemToTrack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCItemToTrack, sizeof(ArrayOfCItemToTrack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CItemToTrack **)soap_malloc(soap, sizeof(ns1__CItemToTrack *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CItemToTrack(soap, NULL, a->__ptritem + i, "ns1:CItemToTrack"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CItemToTrack **)soap_push_block(soap, NULL, sizeof(ns1__CItemToTrack *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CItemToTrack(soap, NULL, p, "ns1:CItemToTrack"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CItemToTrack **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCItemToTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCItemToTrack, 0, sizeof(ArrayOfCItemToTrack), 0, soap_copy_ArrayOfCItemToTrack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCItemToTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCItemToTrack);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCItemToTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCItemToTrack(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCItemToTrack * SOAP_FMAC4 soap_get_ArrayOfCItemToTrack(struct soap *soap, ArrayOfCItemToTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCItemToTrack * SOAP_FMAC2 soap_instantiate_ArrayOfCItemToTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCItemToTrack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCItemToTrack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCItemToTrack);
		if (size)
			*size = sizeof(ArrayOfCItemToTrack);
		((ArrayOfCItemToTrack*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCItemToTrack, n);
		if (size)
			*size = n * sizeof(ArrayOfCItemToTrack);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCItemToTrack*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCItemToTrack*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCItemToTrack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCItemToTrack %p -> %p\n", q, p));
	*(ArrayOfCItemToTrack*)p = *(ArrayOfCItemToTrack*)q;
}

void ns1__CTestRun::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTestRun::recordid);
	this->ns1__CTestRun::testrunnumber = NULL;
	soap_default_string(soap, &this->ns1__CTestRun::summary);
	soap_default_string(soap, &this->ns1__CTestRun::state);
	soap_default_string(soap, &this->ns1__CTestRun::createdbyuser);
	this->ns1__CTestRun::datetimecreated = NULL;
	soap_default_string(soap, &this->ns1__CTestRun::locationaddedfrom);
	soap_default_string(soap, &this->ns1__CTestRun::modifiedbyuser);
	this->ns1__CTestRun::datetimemodified = NULL;
	this->ns1__CTestRun::customFieldList = NULL;
	this->ns1__CTestRun::eventlist = NULL;
	this->ns1__CTestRun::actualhours = NULL;
	this->ns1__CTestRun::estimatedhours = NULL;
	this->ns1__CTestRun::remaininghours = NULL;
	this->ns1__CTestRun::variance = NULL;
	this->ns1__CTestRun::storypoints = NULL;
	this->ns1__CTestRun::percentdone = NULL;
	this->ns1__CTestRun::testcasenumber = NULL;
	this->ns1__CTestRun::testcaserecordid = NULL;
	soap_default_string(soap, &this->ns1__CTestRun::type);
	soap_default_string(soap, &this->ns1__CTestRun::testrunset);
	this->ns1__CTestRun::isautomated = NULL;
	soap_default_string(soap, &this->ns1__CTestRun::estimatedtime);
	soap_default_string(soap, &this->ns1__CTestRun::steps);
	soap_default_string(soap, &this->ns1__CTestRun::problemstatement);
	this->ns1__CTestRun::testVariants = NULL;
	this->ns1__CTestRun::attachmentlist = NULL;
	this->ns1__CTestRun::sccFileList = NULL;
	soap_default_string(soap, &this->ns1__CTestRun::stepsmode);
}

void ns1__CTestRun::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTestRun::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestRun::testrunnumber);
	soap_serialize_string(soap, &this->ns1__CTestRun::summary);
	soap_serialize_string(soap, &this->ns1__CTestRun::state);
	soap_serialize_string(soap, &this->ns1__CTestRun::createdbyuser);
	soap_serialize_PointerTotime(soap, &this->ns1__CTestRun::datetimecreated);
	soap_serialize_string(soap, &this->ns1__CTestRun::locationaddedfrom);
	soap_serialize_string(soap, &this->ns1__CTestRun::modifiedbyuser);
	soap_serialize_PointerTotime(soap, &this->ns1__CTestRun::datetimemodified);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CTestRun::customFieldList);
	soap_serialize_PointerToArrayOfCEvent(soap, &this->ns1__CTestRun::eventlist);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestRun::actualhours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestRun::estimatedhours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestRun::remaininghours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestRun::variance);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestRun::storypoints);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestRun::percentdone);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestRun::testcasenumber);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestRun::testcaserecordid);
	soap_serialize_string(soap, &this->ns1__CTestRun::type);
	soap_serialize_string(soap, &this->ns1__CTestRun::testrunset);
	soap_serialize_PointerTobool(soap, &this->ns1__CTestRun::isautomated);
	soap_serialize_string(soap, &this->ns1__CTestRun::estimatedtime);
	soap_serialize_string(soap, &this->ns1__CTestRun::steps);
	soap_serialize_string(soap, &this->ns1__CTestRun::problemstatement);
	soap_serialize_PointerToArrayOfCTestCaseVariantField(soap, &this->ns1__CTestRun::testVariants);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CTestRun::attachmentlist);
	soap_serialize_PointerToArrayOfCSCCFileRecord(soap, &this->ns1__CTestRun::sccFileList);
	soap_serialize_string(soap, &this->ns1__CTestRun::stepsmode);
#endif
}

int ns1__CTestRun::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTestRun(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTestRun(struct soap *soap, const char *tag, int id, const ns1__CTestRun *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTestRun::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testrunnumber", -1, &(a->ns1__CTestRun::testrunnumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CTestRun::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CTestRun::state), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->ns1__CTestRun::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->ns1__CTestRun::datetimecreated), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->ns1__CTestRun::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->ns1__CTestRun::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->ns1__CTestRun::datetimemodified), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFieldList", -1, &(a->ns1__CTestRun::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCEvent(soap, "eventlist", -1, &(a->ns1__CTestRun::eventlist), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhours", -1, &(a->ns1__CTestRun::actualhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->ns1__CTestRun::estimatedhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "remaininghours", -1, &(a->ns1__CTestRun::remaininghours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "variance", -1, &(a->ns1__CTestRun::variance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storypoints", -1, &(a->ns1__CTestRun::storypoints), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "percentdone", -1, &(a->ns1__CTestRun::percentdone), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testcasenumber", -1, &(a->ns1__CTestRun::testcasenumber), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testcaserecordid", -1, &(a->ns1__CTestRun::testcaserecordid), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->ns1__CTestRun::type), ""))
		return soap->error;
	if (soap_out_string(soap, "testrunset", -1, &(a->ns1__CTestRun::testrunset), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isautomated", -1, &(a->ns1__CTestRun::isautomated), ""))
		return soap->error;
	if (soap_out_string(soap, "estimatedtime", -1, &(a->ns1__CTestRun::estimatedtime), ""))
		return soap->error;
	if (soap_out_string(soap, "steps", -1, &(a->ns1__CTestRun::steps), ""))
		return soap->error;
	if (soap_out_string(soap, "problemstatement", -1, &(a->ns1__CTestRun::problemstatement), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTestCaseVariantField(soap, "testVariants", -1, &(a->ns1__CTestRun::testVariants), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->ns1__CTestRun::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->ns1__CTestRun::sccFileList), ""))
		return soap->error;
	if (soap_out_string(soap, "stepsmode", -1, &(a->ns1__CTestRun::stepsmode), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTestRun::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTestRun(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTestRun * SOAP_FMAC4 soap_in_ns1__CTestRun(struct soap *soap, const char *tag, ns1__CTestRun *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTestRun *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTestRun, sizeof(ns1__CTestRun), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTestRun)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTestRun *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_testrunnumber1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_createdbyuser1 = 1;
	size_t soap_flag_datetimecreated1 = 1;
	size_t soap_flag_locationaddedfrom1 = 1;
	size_t soap_flag_modifiedbyuser1 = 1;
	size_t soap_flag_datetimemodified1 = 1;
	size_t soap_flag_customFieldList1 = 1;
	size_t soap_flag_eventlist1 = 1;
	size_t soap_flag_actualhours1 = 1;
	size_t soap_flag_estimatedhours1 = 1;
	size_t soap_flag_remaininghours1 = 1;
	size_t soap_flag_variance1 = 1;
	size_t soap_flag_storypoints1 = 1;
	size_t soap_flag_percentdone1 = 1;
	size_t soap_flag_testcasenumber1 = 1;
	size_t soap_flag_testcaserecordid1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_testrunset1 = 1;
	size_t soap_flag_isautomated1 = 1;
	size_t soap_flag_estimatedtime1 = 1;
	size_t soap_flag_steps1 = 1;
	size_t soap_flag_problemstatement1 = 1;
	size_t soap_flag_testVariants1 = 1;
	size_t soap_flag_attachmentlist1 = 1;
	size_t soap_flag_sccFileList1 = 1;
	size_t soap_flag_stepsmode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTestRun::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_testrunnumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testrunnumber", &(a->ns1__CTestRun::testrunnumber), "xsd:long"))
				{	soap_flag_testrunnumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CTestRun::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CTestRun::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->ns1__CTestRun::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->ns1__CTestRun::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->ns1__CTestRun::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->ns1__CTestRun::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->ns1__CTestRun::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFieldList", &(a->ns1__CTestRun::customFieldList), "ns1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEvent(soap, "eventlist", &(a->ns1__CTestRun::eventlist), "ns1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_actualhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhours", &(a->ns1__CTestRun::actualhours), "xsd:double"))
				{	soap_flag_actualhours1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->ns1__CTestRun::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_remaininghours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "remaininghours", &(a->ns1__CTestRun::remaininghours), "xsd:double"))
				{	soap_flag_remaininghours1--;
					continue;
				}
			if (soap_flag_variance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "variance", &(a->ns1__CTestRun::variance), "xsd:double"))
				{	soap_flag_variance1--;
					continue;
				}
			if (soap_flag_storypoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storypoints", &(a->ns1__CTestRun::storypoints), "xsd:long"))
				{	soap_flag_storypoints1--;
					continue;
				}
			if (soap_flag_percentdone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "percentdone", &(a->ns1__CTestRun::percentdone), "xsd:long"))
				{	soap_flag_percentdone1--;
					continue;
				}
			if (soap_flag_testcasenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcasenumber", &(a->ns1__CTestRun::testcasenumber), "xsd:long"))
				{	soap_flag_testcasenumber1--;
					continue;
				}
			if (soap_flag_testcaserecordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcaserecordid", &(a->ns1__CTestRun::testcaserecordid), "xsd:long"))
				{	soap_flag_testcaserecordid1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns1__CTestRun::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_testrunset1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testrunset", &(a->ns1__CTestRun::testrunset), "xsd:string"))
				{	soap_flag_testrunset1--;
					continue;
				}
			if (soap_flag_isautomated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isautomated", &(a->ns1__CTestRun::isautomated), "xsd:boolean"))
				{	soap_flag_isautomated1--;
					continue;
				}
			if (soap_flag_estimatedtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "estimatedtime", &(a->ns1__CTestRun::estimatedtime), "xsd:string"))
				{	soap_flag_estimatedtime1--;
					continue;
				}
			if (soap_flag_steps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "steps", &(a->ns1__CTestRun::steps), "xsd:string"))
				{	soap_flag_steps1--;
					continue;
				}
			if (soap_flag_problemstatement1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "problemstatement", &(a->ns1__CTestRun::problemstatement), "xsd:string"))
				{	soap_flag_problemstatement1--;
					continue;
				}
			if (soap_flag_testVariants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTestCaseVariantField(soap, "testVariants", &(a->ns1__CTestRun::testVariants), "ns1:CTestCaseVariantField"))
				{	soap_flag_testVariants1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentlist", &(a->ns1__CTestRun::attachmentlist), "ns1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", &(a->ns1__CTestRun::sccFileList), "ns1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap_flag_stepsmode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "stepsmode", &(a->ns1__CTestRun::stepsmode), "xsd:string"))
				{	soap_flag_stepsmode1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTestRun, 0, sizeof(ns1__CTestRun), 0, soap_copy_ns1__CTestRun);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTestRun::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTestRun);
	if (this->soap_out(soap, tag?tag:"ns1:CTestRun", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTestRun::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTestRun(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTestRun * SOAP_FMAC4 soap_get_ns1__CTestRun(struct soap *soap, ns1__CTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTestRun * SOAP_FMAC2 soap_instantiate_ns1__CTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTestRun);
		if (size)
			*size = sizeof(ns1__CTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTestRun, n);
		if (size)
			*size = n * sizeof(ns1__CTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTestRun %p -> %p\n", q, p));
	*(ns1__CTestRun*)p = *(ns1__CTestRun*)q;
}

void ns1__CTestCase::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTestCase::recordid);
	this->ns1__CTestCase::testcasenumber = NULL;
	soap_default_string(soap, &this->ns1__CTestCase::summary);
	soap_default_string(soap, &this->ns1__CTestCase::state);
	soap_default_string(soap, &this->ns1__CTestCase::createdbyuser);
	this->ns1__CTestCase::datetimecreated = NULL;
	soap_default_string(soap, &this->ns1__CTestCase::locationaddedfrom);
	soap_default_string(soap, &this->ns1__CTestCase::modifiedbyuser);
	this->ns1__CTestCase::datetimemodified = NULL;
	this->ns1__CTestCase::customFieldList = NULL;
	this->ns1__CTestCase::eventlist = NULL;
	this->ns1__CTestCase::actualhours = NULL;
	this->ns1__CTestCase::estimatedhours = NULL;
	this->ns1__CTestCase::remaininghours = NULL;
	this->ns1__CTestCase::variance = NULL;
	this->ns1__CTestCase::storypoints = NULL;
	this->ns1__CTestCase::percentdone = NULL;
	soap_default_string(soap, &this->ns1__CTestCase::type);
	soap_default_string(soap, &this->ns1__CTestCase::testrunstepsmode);
	this->ns1__CTestCase::isautomated = NULL;
	soap_default_string(soap, &this->ns1__CTestCase::estimatedtime);
	soap_default_string(soap, &this->ns1__CTestCase::steps);
	this->ns1__CTestCase::testVariants = NULL;
	this->ns1__CTestCase::attachmentlist = NULL;
	this->ns1__CTestCase::sccFileList = NULL;
}

void ns1__CTestCase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTestCase::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestCase::testcasenumber);
	soap_serialize_string(soap, &this->ns1__CTestCase::summary);
	soap_serialize_string(soap, &this->ns1__CTestCase::state);
	soap_serialize_string(soap, &this->ns1__CTestCase::createdbyuser);
	soap_serialize_PointerTotime(soap, &this->ns1__CTestCase::datetimecreated);
	soap_serialize_string(soap, &this->ns1__CTestCase::locationaddedfrom);
	soap_serialize_string(soap, &this->ns1__CTestCase::modifiedbyuser);
	soap_serialize_PointerTotime(soap, &this->ns1__CTestCase::datetimemodified);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CTestCase::customFieldList);
	soap_serialize_PointerToArrayOfCEvent(soap, &this->ns1__CTestCase::eventlist);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestCase::actualhours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestCase::estimatedhours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestCase::remaininghours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CTestCase::variance);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestCase::storypoints);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTestCase::percentdone);
	soap_serialize_string(soap, &this->ns1__CTestCase::type);
	soap_serialize_string(soap, &this->ns1__CTestCase::testrunstepsmode);
	soap_serialize_PointerTobool(soap, &this->ns1__CTestCase::isautomated);
	soap_serialize_string(soap, &this->ns1__CTestCase::estimatedtime);
	soap_serialize_string(soap, &this->ns1__CTestCase::steps);
	soap_serialize_PointerToArrayOfCTestCaseVariantField(soap, &this->ns1__CTestCase::testVariants);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CTestCase::attachmentlist);
	soap_serialize_PointerToArrayOfCSCCFileRecord(soap, &this->ns1__CTestCase::sccFileList);
#endif
}

int ns1__CTestCase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTestCase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTestCase(struct soap *soap, const char *tag, int id, const ns1__CTestCase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTestCase::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "testcasenumber", -1, &(a->ns1__CTestCase::testcasenumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CTestCase::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CTestCase::state), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->ns1__CTestCase::createdbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->ns1__CTestCase::datetimecreated), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->ns1__CTestCase::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->ns1__CTestCase::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->ns1__CTestCase::datetimemodified), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFieldList", -1, &(a->ns1__CTestCase::customFieldList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCEvent(soap, "eventlist", -1, &(a->ns1__CTestCase::eventlist), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhours", -1, &(a->ns1__CTestCase::actualhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->ns1__CTestCase::estimatedhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "remaininghours", -1, &(a->ns1__CTestCase::remaininghours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "variance", -1, &(a->ns1__CTestCase::variance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storypoints", -1, &(a->ns1__CTestCase::storypoints), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "percentdone", -1, &(a->ns1__CTestCase::percentdone), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->ns1__CTestCase::type), ""))
		return soap->error;
	if (soap_out_string(soap, "testrunstepsmode", -1, &(a->ns1__CTestCase::testrunstepsmode), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isautomated", -1, &(a->ns1__CTestCase::isautomated), ""))
		return soap->error;
	if (soap_out_string(soap, "estimatedtime", -1, &(a->ns1__CTestCase::estimatedtime), ""))
		return soap->error;
	if (soap_out_string(soap, "steps", -1, &(a->ns1__CTestCase::steps), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTestCaseVariantField(soap, "testVariants", -1, &(a->ns1__CTestCase::testVariants), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->ns1__CTestCase::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", -1, &(a->ns1__CTestCase::sccFileList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTestCase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTestCase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTestCase * SOAP_FMAC4 soap_in_ns1__CTestCase(struct soap *soap, const char *tag, ns1__CTestCase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTestCase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTestCase, sizeof(ns1__CTestCase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTestCase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTestCase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_testcasenumber1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_createdbyuser1 = 1;
	size_t soap_flag_datetimecreated1 = 1;
	size_t soap_flag_locationaddedfrom1 = 1;
	size_t soap_flag_modifiedbyuser1 = 1;
	size_t soap_flag_datetimemodified1 = 1;
	size_t soap_flag_customFieldList1 = 1;
	size_t soap_flag_eventlist1 = 1;
	size_t soap_flag_actualhours1 = 1;
	size_t soap_flag_estimatedhours1 = 1;
	size_t soap_flag_remaininghours1 = 1;
	size_t soap_flag_variance1 = 1;
	size_t soap_flag_storypoints1 = 1;
	size_t soap_flag_percentdone1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_testrunstepsmode1 = 1;
	size_t soap_flag_isautomated1 = 1;
	size_t soap_flag_estimatedtime1 = 1;
	size_t soap_flag_steps1 = 1;
	size_t soap_flag_testVariants1 = 1;
	size_t soap_flag_attachmentlist1 = 1;
	size_t soap_flag_sccFileList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTestCase::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_testcasenumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "testcasenumber", &(a->ns1__CTestCase::testcasenumber), "xsd:long"))
				{	soap_flag_testcasenumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CTestCase::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CTestCase::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->ns1__CTestCase::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->ns1__CTestCase::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->ns1__CTestCase::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->ns1__CTestCase::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->ns1__CTestCase::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFieldList", &(a->ns1__CTestCase::customFieldList), "ns1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEvent(soap, "eventlist", &(a->ns1__CTestCase::eventlist), "ns1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_actualhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhours", &(a->ns1__CTestCase::actualhours), "xsd:double"))
				{	soap_flag_actualhours1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->ns1__CTestCase::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_remaininghours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "remaininghours", &(a->ns1__CTestCase::remaininghours), "xsd:double"))
				{	soap_flag_remaininghours1--;
					continue;
				}
			if (soap_flag_variance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "variance", &(a->ns1__CTestCase::variance), "xsd:double"))
				{	soap_flag_variance1--;
					continue;
				}
			if (soap_flag_storypoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storypoints", &(a->ns1__CTestCase::storypoints), "xsd:long"))
				{	soap_flag_storypoints1--;
					continue;
				}
			if (soap_flag_percentdone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "percentdone", &(a->ns1__CTestCase::percentdone), "xsd:long"))
				{	soap_flag_percentdone1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns1__CTestCase::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_testrunstepsmode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testrunstepsmode", &(a->ns1__CTestCase::testrunstepsmode), "xsd:string"))
				{	soap_flag_testrunstepsmode1--;
					continue;
				}
			if (soap_flag_isautomated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isautomated", &(a->ns1__CTestCase::isautomated), "xsd:boolean"))
				{	soap_flag_isautomated1--;
					continue;
				}
			if (soap_flag_estimatedtime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "estimatedtime", &(a->ns1__CTestCase::estimatedtime), "xsd:string"))
				{	soap_flag_estimatedtime1--;
					continue;
				}
			if (soap_flag_steps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "steps", &(a->ns1__CTestCase::steps), "xsd:string"))
				{	soap_flag_steps1--;
					continue;
				}
			if (soap_flag_testVariants1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTestCaseVariantField(soap, "testVariants", &(a->ns1__CTestCase::testVariants), "ns1:CTestCaseVariantField"))
				{	soap_flag_testVariants1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentlist", &(a->ns1__CTestCase::attachmentlist), "ns1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_sccFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSCCFileRecord(soap, "sccFileList", &(a->ns1__CTestCase::sccFileList), "ns1:CSCCFileRecord"))
				{	soap_flag_sccFileList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTestCase, 0, sizeof(ns1__CTestCase), 0, soap_copy_ns1__CTestCase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTestCase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTestCase);
	if (this->soap_out(soap, tag?tag:"ns1:CTestCase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTestCase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTestCase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTestCase * SOAP_FMAC4 soap_get_ns1__CTestCase(struct soap *soap, ns1__CTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTestCase * SOAP_FMAC2 soap_instantiate_ns1__CTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTestCase);
		if (size)
			*size = sizeof(ns1__CTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTestCase, n);
		if (size)
			*size = n * sizeof(ns1__CTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTestCase %p -> %p\n", q, p));
	*(ns1__CTestCase*)p = *(ns1__CTestCase*)q;
}

void ArrayOfCLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCLink::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCLink))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CLink(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCLink(struct soap *soap, const char *tag, int id, const ArrayOfCLink *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CLink", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLink);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CLink(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCLink(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCLink * SOAP_FMAC4 soap_in_ArrayOfCLink(struct soap *soap, const char *tag, ArrayOfCLink *a, const char *type)
{	int i, j;
	ns1__CLink **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCLink, sizeof(ArrayOfCLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CLink **)soap_malloc(soap, sizeof(ns1__CLink *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CLink(soap, NULL, a->__ptritem + i, "ns1:CLink"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CLink **)soap_push_block(soap, NULL, sizeof(ns1__CLink *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CLink(soap, NULL, p, "ns1:CLink"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CLink **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCLink, 0, sizeof(ArrayOfCLink), 0, soap_copy_ArrayOfCLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCLink);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCLink(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCLink * SOAP_FMAC4 soap_get_ArrayOfCLink(struct soap *soap, ArrayOfCLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCLink * SOAP_FMAC2 soap_instantiate_ArrayOfCLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCLink);
		if (size)
			*size = sizeof(ArrayOfCLink);
		((ArrayOfCLink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCLink, n);
		if (size)
			*size = n * sizeof(ArrayOfCLink);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCLink*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCLink %p -> %p\n", q, p));
	*(ArrayOfCLink*)p = *(ArrayOfCLink*)q;
}

void ns1__CLink::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CLink::recordid);
	soap_default_string(soap, &this->ns1__CLink::linkDefinitionName);
	soap_default_string(soap, &this->ns1__CLink::comment);
	this->ns1__CLink::linkbroken = NULL;
	this->ns1__CLink::linkparent = NULL;
	this->ns1__CLink::childList = NULL;
	this->ns1__CLink::historyList = NULL;
}

void ns1__CLink::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CLink::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CLink::linkDefinitionName);
	soap_serialize_string(soap, &this->ns1__CLink::comment);
	soap_serialize_PointerTobool(soap, &this->ns1__CLink::linkbroken);
	soap_serialize_PointerTons1__CLinkedItem(soap, &this->ns1__CLink::linkparent);
	soap_serialize_PointerToArrayOfCLinkedItem(soap, &this->ns1__CLink::childList);
	soap_serialize_PointerToArrayOfCLinkHistoryItem(soap, &this->ns1__CLink::historyList);
#endif
}

int ns1__CLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CLink(struct soap *soap, const char *tag, int id, const ns1__CLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CLink::recordid), ""))
		return soap->error;
	if (a->ns1__CLink::linkDefinitionName)
	{	if (soap_out_string(soap, "linkDefinitionName", -1, &a->ns1__CLink::linkDefinitionName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "linkDefinitionName"))
		return soap->error;
	if (soap_out_string(soap, "comment", -1, &(a->ns1__CLink::comment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "linkbroken", -1, &(a->ns1__CLink::linkbroken), ""))
		return soap->error;
	if (soap_out_PointerTons1__CLinkedItem(soap, "linkparent", -1, &(a->ns1__CLink::linkparent), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCLinkedItem(soap, "childList", -1, &(a->ns1__CLink::childList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCLinkHistoryItem(soap, "historyList", -1, &(a->ns1__CLink::historyList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CLink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CLink(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CLink * SOAP_FMAC4 soap_in_ns1__CLink(struct soap *soap, const char *tag, ns1__CLink *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CLink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CLink, sizeof(ns1__CLink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CLink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CLink *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_linkDefinitionName1 = 1;
	size_t soap_flag_comment1 = 1;
	size_t soap_flag_linkbroken1 = 1;
	size_t soap_flag_linkparent1 = 1;
	size_t soap_flag_childList1 = 1;
	size_t soap_flag_historyList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CLink::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_linkDefinitionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "linkDefinitionName", &(a->ns1__CLink::linkDefinitionName), "xsd:string"))
				{	soap_flag_linkDefinitionName1--;
					continue;
				}
			if (soap_flag_comment1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comment", &(a->ns1__CLink::comment), "xsd:string"))
				{	soap_flag_comment1--;
					continue;
				}
			if (soap_flag_linkbroken1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "linkbroken", &(a->ns1__CLink::linkbroken), "xsd:boolean"))
				{	soap_flag_linkbroken1--;
					continue;
				}
			if (soap_flag_linkparent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CLinkedItem(soap, "linkparent", &(a->ns1__CLink::linkparent), "ns1:CLinkedItem"))
				{	soap_flag_linkparent1--;
					continue;
				}
			if (soap_flag_childList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCLinkedItem(soap, "childList", &(a->ns1__CLink::childList), "ns1:CLinkedItem"))
				{	soap_flag_childList1--;
					continue;
				}
			if (soap_flag_historyList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCLinkHistoryItem(soap, "historyList", &(a->ns1__CLink::historyList), "ns1:CLinkHistoryItem"))
				{	soap_flag_historyList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CLink, 0, sizeof(ns1__CLink), 0, soap_copy_ns1__CLink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_linkDefinitionName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CLink);
	if (this->soap_out(soap, tag?tag:"ns1:CLink", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CLink(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CLink * SOAP_FMAC4 soap_get_ns1__CLink(struct soap *soap, ns1__CLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CLink * SOAP_FMAC2 soap_instantiate_ns1__CLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CLink);
		if (size)
			*size = sizeof(ns1__CLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CLink, n);
		if (size)
			*size = n * sizeof(ns1__CLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CLink %p -> %p\n", q, p));
	*(ns1__CLink*)p = *(ns1__CLink*)q;
}

void ArrayOfCLinkHistoryItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCLinkHistoryItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCLinkHistoryItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CLinkHistoryItem(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCLinkHistoryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCLinkHistoryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, int id, const ArrayOfCLinkHistoryItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CLinkHistoryItem", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLinkHistoryItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CLinkHistoryItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCLinkHistoryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCLinkHistoryItem(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCLinkHistoryItem * SOAP_FMAC4 soap_in_ArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, ArrayOfCLinkHistoryItem *a, const char *type)
{	int i, j;
	ns1__CLinkHistoryItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCLinkHistoryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCLinkHistoryItem, sizeof(ArrayOfCLinkHistoryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CLinkHistoryItem **)soap_malloc(soap, sizeof(ns1__CLinkHistoryItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CLinkHistoryItem(soap, NULL, a->__ptritem + i, "ns1:CLinkHistoryItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CLinkHistoryItem **)soap_push_block(soap, NULL, sizeof(ns1__CLinkHistoryItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CLinkHistoryItem(soap, NULL, p, "ns1:CLinkHistoryItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CLinkHistoryItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCLinkHistoryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCLinkHistoryItem, 0, sizeof(ArrayOfCLinkHistoryItem), 0, soap_copy_ArrayOfCLinkHistoryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCLinkHistoryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCLinkHistoryItem);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCLinkHistoryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCLinkHistoryItem(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCLinkHistoryItem * SOAP_FMAC4 soap_get_ArrayOfCLinkHistoryItem(struct soap *soap, ArrayOfCLinkHistoryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCLinkHistoryItem * SOAP_FMAC2 soap_instantiate_ArrayOfCLinkHistoryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCLinkHistoryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCLinkHistoryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCLinkHistoryItem);
		if (size)
			*size = sizeof(ArrayOfCLinkHistoryItem);
		((ArrayOfCLinkHistoryItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCLinkHistoryItem, n);
		if (size)
			*size = n * sizeof(ArrayOfCLinkHistoryItem);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCLinkHistoryItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCLinkHistoryItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCLinkHistoryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCLinkHistoryItem %p -> %p\n", q, p));
	*(ArrayOfCLinkHistoryItem*)p = *(ArrayOfCLinkHistoryItem*)q;
}

void ns1__CLinkHistoryItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CLinkHistoryItem::recordid);
	soap_default_LONG64(soap, &this->ns1__CLinkHistoryItem::order);
	this->ns1__CLinkHistoryItem::date = NULL;
	soap_default_string(soap, &this->ns1__CLinkHistoryItem::firstname);
	soap_default_string(soap, &this->ns1__CLinkHistoryItem::lastname);
	soap_default_string(soap, &this->ns1__CLinkHistoryItem::history);
}

void ns1__CLinkHistoryItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CLinkHistoryItem::recordid, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->ns1__CLinkHistoryItem::order, SOAP_TYPE_LONG64);
	soap_serialize_PointerTotime(soap, &this->ns1__CLinkHistoryItem::date);
	soap_serialize_string(soap, &this->ns1__CLinkHistoryItem::firstname);
	soap_serialize_string(soap, &this->ns1__CLinkHistoryItem::lastname);
	soap_serialize_string(soap, &this->ns1__CLinkHistoryItem::history);
#endif
}

int ns1__CLinkHistoryItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CLinkHistoryItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, const ns1__CLinkHistoryItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CLinkHistoryItem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CLinkHistoryItem::recordid), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "order", -1, &(a->ns1__CLinkHistoryItem::order), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "date", -1, &(a->ns1__CLinkHistoryItem::date), ""))
		return soap->error;
	if (soap_out_string(soap, "firstname", -1, &(a->ns1__CLinkHistoryItem::firstname), ""))
		return soap->error;
	if (soap_out_string(soap, "lastname", -1, &(a->ns1__CLinkHistoryItem::lastname), ""))
		return soap->error;
	if (soap_out_string(soap, "history", -1, &(a->ns1__CLinkHistoryItem::history), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CLinkHistoryItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CLinkHistoryItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CLinkHistoryItem * SOAP_FMAC4 soap_in_ns1__CLinkHistoryItem(struct soap *soap, const char *tag, ns1__CLinkHistoryItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CLinkHistoryItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CLinkHistoryItem, sizeof(ns1__CLinkHistoryItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CLinkHistoryItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CLinkHistoryItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_order1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_firstname1 = 1;
	size_t soap_flag_lastname1 = 1;
	size_t soap_flag_history1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CLinkHistoryItem::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->ns1__CLinkHistoryItem::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "date", &(a->ns1__CLinkHistoryItem::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_firstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstname", &(a->ns1__CLinkHistoryItem::firstname), "xsd:string"))
				{	soap_flag_firstname1--;
					continue;
				}
			if (soap_flag_lastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastname", &(a->ns1__CLinkHistoryItem::lastname), "xsd:string"))
				{	soap_flag_lastname1--;
					continue;
				}
			if (soap_flag_history1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "history", &(a->ns1__CLinkHistoryItem::history), "xsd:string"))
				{	soap_flag_history1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CLinkHistoryItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CLinkHistoryItem, 0, sizeof(ns1__CLinkHistoryItem), 0, soap_copy_ns1__CLinkHistoryItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_order1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CLinkHistoryItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CLinkHistoryItem);
	if (this->soap_out(soap, tag?tag:"ns1:CLinkHistoryItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CLinkHistoryItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CLinkHistoryItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CLinkHistoryItem * SOAP_FMAC4 soap_get_ns1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CLinkHistoryItem * SOAP_FMAC2 soap_instantiate_ns1__CLinkHistoryItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CLinkHistoryItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CLinkHistoryItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CLinkHistoryItem);
		if (size)
			*size = sizeof(ns1__CLinkHistoryItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CLinkHistoryItem, n);
		if (size)
			*size = n * sizeof(ns1__CLinkHistoryItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CLinkHistoryItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CLinkHistoryItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CLinkHistoryItem %p -> %p\n", q, p));
	*(ns1__CLinkHistoryItem*)p = *(ns1__CLinkHistoryItem*)q;
}

void ArrayOfCLinkedItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCLinkedItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCLinkedItem))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CLinkedItem(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCLinkedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCLinkedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCLinkedItem(struct soap *soap, const char *tag, int id, const ArrayOfCLinkedItem *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CLinkedItem", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLinkedItem);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CLinkedItem(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCLinkedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCLinkedItem(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCLinkedItem * SOAP_FMAC4 soap_in_ArrayOfCLinkedItem(struct soap *soap, const char *tag, ArrayOfCLinkedItem *a, const char *type)
{	int i, j;
	ns1__CLinkedItem **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCLinkedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCLinkedItem, sizeof(ArrayOfCLinkedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CLinkedItem **)soap_malloc(soap, sizeof(ns1__CLinkedItem *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CLinkedItem(soap, NULL, a->__ptritem + i, "ns1:CLinkedItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CLinkedItem **)soap_push_block(soap, NULL, sizeof(ns1__CLinkedItem *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CLinkedItem(soap, NULL, p, "ns1:CLinkedItem"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CLinkedItem **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCLinkedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCLinkedItem, 0, sizeof(ArrayOfCLinkedItem), 0, soap_copy_ArrayOfCLinkedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCLinkedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCLinkedItem);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCLinkedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCLinkedItem(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCLinkedItem * SOAP_FMAC4 soap_get_ArrayOfCLinkedItem(struct soap *soap, ArrayOfCLinkedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCLinkedItem * SOAP_FMAC2 soap_instantiate_ArrayOfCLinkedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCLinkedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCLinkedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCLinkedItem);
		if (size)
			*size = sizeof(ArrayOfCLinkedItem);
		((ArrayOfCLinkedItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCLinkedItem, n);
		if (size)
			*size = n * sizeof(ArrayOfCLinkedItem);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCLinkedItem*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCLinkedItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCLinkedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCLinkedItem %p -> %p\n", q, p));
	*(ArrayOfCLinkedItem*)p = *(ArrayOfCLinkedItem*)q;
}

void ns1__CLinkedItem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CLinkedItem::recordid);
	soap_default_LONG64(soap, &this->ns1__CLinkedItem::order);
	this->ns1__CLinkedItem::entityType = NULL;
	soap_default_string(soap, &this->ns1__CLinkedItem::tablename);
	soap_default_LONG64(soap, &this->ns1__CLinkedItem::entityID);
	soap_default_string(soap, &this->ns1__CLinkedItem::number);
	soap_default_string(soap, &this->ns1__CLinkedItem::summary);
	soap_default_string(soap, &this->ns1__CLinkedItem::status);
	soap_default_string(soap, &this->ns1__CLinkedItem::state);
	this->ns1__CLinkedItem::issuspect = NULL;
}

void ns1__CLinkedItem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CLinkedItem::recordid, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->ns1__CLinkedItem::order, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CLinkedItem::entityType);
	soap_serialize_string(soap, &this->ns1__CLinkedItem::tablename);
	soap_embedded(soap, &this->ns1__CLinkedItem::entityID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CLinkedItem::number);
	soap_serialize_string(soap, &this->ns1__CLinkedItem::summary);
	soap_serialize_string(soap, &this->ns1__CLinkedItem::status);
	soap_serialize_string(soap, &this->ns1__CLinkedItem::state);
	soap_serialize_PointerTobool(soap, &this->ns1__CLinkedItem::issuspect);
#endif
}

int ns1__CLinkedItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CLinkedItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CLinkedItem(struct soap *soap, const char *tag, int id, const ns1__CLinkedItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CLinkedItem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CLinkedItem::recordid), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "order", -1, &(a->ns1__CLinkedItem::order), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "entityType", -1, &(a->ns1__CLinkedItem::entityType), ""))
		return soap->error;
	if (a->ns1__CLinkedItem::tablename)
	{	if (soap_out_string(soap, "tablename", -1, &a->ns1__CLinkedItem::tablename, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tablename"))
		return soap->error;
	if (soap_out_LONG64(soap, "entityID", -1, &(a->ns1__CLinkedItem::entityID), ""))
		return soap->error;
	if (soap_out_string(soap, "number", -1, &(a->ns1__CLinkedItem::number), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CLinkedItem::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "status", -1, &(a->ns1__CLinkedItem::status), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CLinkedItem::state), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "issuspect", -1, &(a->ns1__CLinkedItem::issuspect), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CLinkedItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CLinkedItem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CLinkedItem * SOAP_FMAC4 soap_in_ns1__CLinkedItem(struct soap *soap, const char *tag, ns1__CLinkedItem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CLinkedItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CLinkedItem, sizeof(ns1__CLinkedItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CLinkedItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CLinkedItem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_order1 = 1;
	size_t soap_flag_entityType1 = 1;
	size_t soap_flag_tablename1 = 1;
	size_t soap_flag_entityID1 = 1;
	size_t soap_flag_number1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_issuspect1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CLinkedItem::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->ns1__CLinkedItem::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap_flag_entityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "entityType", &(a->ns1__CLinkedItem::entityType), "xsd:long"))
				{	soap_flag_entityType1--;
					continue;
				}
			if (soap_flag_tablename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &(a->ns1__CLinkedItem::tablename), "xsd:string"))
				{	soap_flag_tablename1--;
					continue;
				}
			if (soap_flag_entityID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityID", &(a->ns1__CLinkedItem::entityID), "xsd:long"))
				{	soap_flag_entityID1--;
					continue;
				}
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "number", &(a->ns1__CLinkedItem::number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CLinkedItem::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status", &(a->ns1__CLinkedItem::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CLinkedItem::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_issuspect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "issuspect", &(a->ns1__CLinkedItem::issuspect), "xsd:boolean"))
				{	soap_flag_issuspect1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CLinkedItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CLinkedItem, 0, sizeof(ns1__CLinkedItem), 0, soap_copy_ns1__CLinkedItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_order1 > 0 || soap_flag_tablename1 > 0 || soap_flag_entityID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CLinkedItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CLinkedItem);
	if (this->soap_out(soap, tag?tag:"ns1:CLinkedItem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CLinkedItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CLinkedItem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CLinkedItem * SOAP_FMAC4 soap_get_ns1__CLinkedItem(struct soap *soap, ns1__CLinkedItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CLinkedItem * SOAP_FMAC2 soap_instantiate_ns1__CLinkedItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CLinkedItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CLinkedItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CLinkedItem);
		if (size)
			*size = sizeof(ns1__CLinkedItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CLinkedItem, n);
		if (size)
			*size = n * sizeof(ns1__CLinkedItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CLinkedItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CLinkedItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CLinkedItem %p -> %p\n", q, p));
	*(ns1__CLinkedItem*)p = *(ns1__CLinkedItem*)q;
}

void ArrayOfCUserLicense::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCUserLicense::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCUserLicense))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CUserLicense(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCUserLicense::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCUserLicense(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCUserLicense(struct soap *soap, const char *tag, int id, const ArrayOfCUserLicense *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CUserLicense", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCUserLicense);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CUserLicense(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCUserLicense::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCUserLicense(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCUserLicense * SOAP_FMAC4 soap_in_ArrayOfCUserLicense(struct soap *soap, const char *tag, ArrayOfCUserLicense *a, const char *type)
{	int i, j;
	ns1__CUserLicense **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCUserLicense *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCUserLicense, sizeof(ArrayOfCUserLicense), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CUserLicense **)soap_malloc(soap, sizeof(ns1__CUserLicense *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CUserLicense(soap, NULL, a->__ptritem + i, "ns1:CUserLicense"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CUserLicense **)soap_push_block(soap, NULL, sizeof(ns1__CUserLicense *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CUserLicense(soap, NULL, p, "ns1:CUserLicense"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CUserLicense **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCUserLicense *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCUserLicense, 0, sizeof(ArrayOfCUserLicense), 0, soap_copy_ArrayOfCUserLicense);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCUserLicense::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCUserLicense);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCUserLicense::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCUserLicense(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCUserLicense * SOAP_FMAC4 soap_get_ArrayOfCUserLicense(struct soap *soap, ArrayOfCUserLicense *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCUserLicense * SOAP_FMAC2 soap_instantiate_ArrayOfCUserLicense(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCUserLicense(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCUserLicense, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCUserLicense);
		if (size)
			*size = sizeof(ArrayOfCUserLicense);
		((ArrayOfCUserLicense*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCUserLicense, n);
		if (size)
			*size = n * sizeof(ArrayOfCUserLicense);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCUserLicense*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCUserLicense*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCUserLicense(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCUserLicense %p -> %p\n", q, p));
	*(ArrayOfCUserLicense*)p = *(ArrayOfCUserLicense*)q;
}

void ns1__CUserLicense::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CUserLicense::name);
	this->ns1__CUserLicense::numberUsed = NULL;
	this->ns1__CUserLicense::numberTotal = NULL;
	/* transient soap skipped */
}

void ns1__CUserLicense::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CUserLicense::name);
	soap_serialize_PointerToint(soap, &this->ns1__CUserLicense::numberUsed);
	soap_serialize_PointerToint(soap, &this->ns1__CUserLicense::numberTotal);
	/* transient soap skipped */
#endif
}

int ns1__CUserLicense::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CUserLicense(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CUserLicense(struct soap *soap, const char *tag, int id, const ns1__CUserLicense *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CUserLicense), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CUserLicense::name), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numberUsed", -1, &(a->ns1__CUserLicense::numberUsed), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "numberTotal", -1, &(a->ns1__CUserLicense::numberTotal), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CUserLicense::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CUserLicense(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CUserLicense * SOAP_FMAC4 soap_in_ns1__CUserLicense(struct soap *soap, const char *tag, ns1__CUserLicense *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CUserLicense *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CUserLicense, sizeof(ns1__CUserLicense), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CUserLicense)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CUserLicense *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_numberUsed1 = 1;
	size_t soap_flag_numberTotal1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CUserLicense::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_numberUsed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberUsed", &(a->ns1__CUserLicense::numberUsed), "xsd:int"))
				{	soap_flag_numberUsed1--;
					continue;
				}
			if (soap_flag_numberTotal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberTotal", &(a->ns1__CUserLicense::numberTotal), "xsd:int"))
				{	soap_flag_numberTotal1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CUserLicense *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CUserLicense, 0, sizeof(ns1__CUserLicense), 0, soap_copy_ns1__CUserLicense);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CUserLicense::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CUserLicense);
	if (this->soap_out(soap, tag?tag:"ns1:CUserLicense", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CUserLicense::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CUserLicense(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CUserLicense * SOAP_FMAC4 soap_get_ns1__CUserLicense(struct soap *soap, ns1__CUserLicense *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CUserLicense * SOAP_FMAC2 soap_instantiate_ns1__CUserLicense(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CUserLicense(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CUserLicense, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CUserLicense);
		if (size)
			*size = sizeof(ns1__CUserLicense);
		((ns1__CUserLicense*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CUserLicense, n);
		if (size)
			*size = n * sizeof(ns1__CUserLicense);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CUserLicense*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CUserLicense*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CUserLicense(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CUserLicense %p -> %p\n", q, p));
	*(ns1__CUserLicense*)p = *(ns1__CUserLicense*)q;
}

void ArrayOfCGlobalUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCGlobalUser::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCGlobalUser))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CGlobalUser(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCGlobalUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCGlobalUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCGlobalUser(struct soap *soap, const char *tag, int id, const ArrayOfCGlobalUser *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CGlobalUser", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCGlobalUser);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CGlobalUser(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCGlobalUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCGlobalUser(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCGlobalUser * SOAP_FMAC4 soap_in_ArrayOfCGlobalUser(struct soap *soap, const char *tag, ArrayOfCGlobalUser *a, const char *type)
{	int i, j;
	ns1__CGlobalUser **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCGlobalUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCGlobalUser, sizeof(ArrayOfCGlobalUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CGlobalUser **)soap_malloc(soap, sizeof(ns1__CGlobalUser *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CGlobalUser(soap, NULL, a->__ptritem + i, "ns1:CGlobalUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CGlobalUser **)soap_push_block(soap, NULL, sizeof(ns1__CGlobalUser *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CGlobalUser(soap, NULL, p, "ns1:CGlobalUser"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CGlobalUser **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCGlobalUser, 0, sizeof(ArrayOfCGlobalUser), 0, soap_copy_ArrayOfCGlobalUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCGlobalUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCGlobalUser);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCGlobalUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCGlobalUser(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCGlobalUser * SOAP_FMAC4 soap_get_ArrayOfCGlobalUser(struct soap *soap, ArrayOfCGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCGlobalUser * SOAP_FMAC2 soap_instantiate_ArrayOfCGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCGlobalUser);
		if (size)
			*size = sizeof(ArrayOfCGlobalUser);
		((ArrayOfCGlobalUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCGlobalUser, n);
		if (size)
			*size = n * sizeof(ArrayOfCGlobalUser);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCGlobalUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCGlobalUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCGlobalUser %p -> %p\n", q, p));
	*(ArrayOfCGlobalUser*)p = *(ArrayOfCGlobalUser*)q;
}

void ns1__CGlobalUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CGlobalUser::loginname);
	soap_default_string(soap, &this->ns1__CGlobalUser::name);
	/* transient soap skipped */
}

void ns1__CGlobalUser::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CGlobalUser::loginname);
	soap_serialize_string(soap, &this->ns1__CGlobalUser::name);
	/* transient soap skipped */
#endif
}

int ns1__CGlobalUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CGlobalUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CGlobalUser(struct soap *soap, const char *tag, int id, const ns1__CGlobalUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CGlobalUser), type))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &(a->ns1__CGlobalUser::loginname), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CGlobalUser::name), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CGlobalUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CGlobalUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CGlobalUser * SOAP_FMAC4 soap_in_ns1__CGlobalUser(struct soap *soap, const char *tag, ns1__CGlobalUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CGlobalUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CGlobalUser, sizeof(ns1__CGlobalUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CGlobalUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CGlobalUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_loginname1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &(a->ns1__CGlobalUser::loginname), "xsd:string"))
				{	soap_flag_loginname1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CGlobalUser::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CGlobalUser, 0, sizeof(ns1__CGlobalUser), 0, soap_copy_ns1__CGlobalUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CGlobalUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CGlobalUser);
	if (this->soap_out(soap, tag?tag:"ns1:CGlobalUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CGlobalUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CGlobalUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CGlobalUser * SOAP_FMAC4 soap_get_ns1__CGlobalUser(struct soap *soap, ns1__CGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CGlobalUser * SOAP_FMAC2 soap_instantiate_ns1__CGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CGlobalUser);
		if (size)
			*size = sizeof(ns1__CGlobalUser);
		((ns1__CGlobalUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CGlobalUser, n);
		if (size)
			*size = n * sizeof(ns1__CGlobalUser);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CGlobalUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CGlobalUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CGlobalUser %p -> %p\n", q, p));
	*(ns1__CGlobalUser*)p = *(ns1__CGlobalUser*)q;
}

void ns1__CUser::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CUser::recordid);
	soap_default_string(soap, &this->ns1__CUser::firstname);
	soap_default_string(soap, &this->ns1__CUser::middleinitials);
	soap_default_string(soap, &this->ns1__CUser::lastname);
	soap_default_string(soap, &this->ns1__CUser::usergroupname);
	soap_default_string(soap, &this->ns1__CUser::company);
	soap_default_string(soap, &this->ns1__CUser::division);
	soap_default_string(soap, &this->ns1__CUser::department);
	soap_default_string(soap, &this->ns1__CUser::emailtype);
	soap_default_string(soap, &this->ns1__CUser::emailaddress);
	this->ns1__CUser::isactive = NULL;
	this->ns1__CUser::iscustomer = NULL;
	this->ns1__CUser::isglobal = NULL;
	this->ns1__CUser::isactiveglobal = NULL;
	soap_default_string(soap, &this->ns1__CUser::userLicense);
	soap_default_string(soap, &this->ns1__CUser::userLicenseTCM);
	soap_default_string(soap, &this->ns1__CUser::userLicenseRM);
	soap_default_string(soap, &this->ns1__CUser::password);
	soap_default_string(soap, &this->ns1__CUser::loginname);
	this->ns1__CUser::phoneone = NULL;
	this->ns1__CUser::phonetwo = NULL;
	soap_default_string(soap, &this->ns1__CUser::notes);
	this->ns1__CUser::betasite = NULL;
	soap_default_string(soap, &this->ns1__CUser::address);
	this->ns1__CUser::testconfig = NULL;
}

void ns1__CUser::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CUser::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CUser::firstname);
	soap_serialize_string(soap, &this->ns1__CUser::middleinitials);
	soap_serialize_string(soap, &this->ns1__CUser::lastname);
	soap_serialize_string(soap, &this->ns1__CUser::usergroupname);
	soap_serialize_string(soap, &this->ns1__CUser::company);
	soap_serialize_string(soap, &this->ns1__CUser::division);
	soap_serialize_string(soap, &this->ns1__CUser::department);
	soap_serialize_string(soap, &this->ns1__CUser::emailtype);
	soap_serialize_string(soap, &this->ns1__CUser::emailaddress);
	soap_serialize_PointerTobool(soap, &this->ns1__CUser::isactive);
	soap_serialize_PointerTobool(soap, &this->ns1__CUser::iscustomer);
	soap_serialize_PointerTobool(soap, &this->ns1__CUser::isglobal);
	soap_serialize_PointerTobool(soap, &this->ns1__CUser::isactiveglobal);
	soap_serialize_string(soap, &this->ns1__CUser::userLicense);
	soap_serialize_string(soap, &this->ns1__CUser::userLicenseTCM);
	soap_serialize_string(soap, &this->ns1__CUser::userLicenseRM);
	soap_serialize_string(soap, &this->ns1__CUser::password);
	soap_serialize_string(soap, &this->ns1__CUser::loginname);
	soap_serialize_PointerTons1__PhoneNumber(soap, &this->ns1__CUser::phoneone);
	soap_serialize_PointerTons1__PhoneNumber(soap, &this->ns1__CUser::phonetwo);
	soap_serialize_string(soap, &this->ns1__CUser::notes);
	soap_serialize_PointerTobool(soap, &this->ns1__CUser::betasite);
	soap_serialize_string(soap, &this->ns1__CUser::address);
	soap_serialize_PointerTons1__CSystem(soap, &this->ns1__CUser::testconfig);
#endif
}

int ns1__CUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CUser(struct soap *soap, const char *tag, int id, const ns1__CUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CUser::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "firstname", -1, &(a->ns1__CUser::firstname), ""))
		return soap->error;
	if (soap_out_string(soap, "middleinitials", -1, &(a->ns1__CUser::middleinitials), ""))
		return soap->error;
	if (soap_out_string(soap, "lastname", -1, &(a->ns1__CUser::lastname), ""))
		return soap->error;
	if (soap_out_string(soap, "usergroupname", -1, &(a->ns1__CUser::usergroupname), ""))
		return soap->error;
	if (soap_out_string(soap, "company", -1, &(a->ns1__CUser::company), ""))
		return soap->error;
	if (soap_out_string(soap, "division", -1, &(a->ns1__CUser::division), ""))
		return soap->error;
	if (soap_out_string(soap, "department", -1, &(a->ns1__CUser::department), ""))
		return soap->error;
	if (soap_out_string(soap, "emailtype", -1, &(a->ns1__CUser::emailtype), ""))
		return soap->error;
	if (soap_out_string(soap, "emailaddress", -1, &(a->ns1__CUser::emailaddress), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isactive", -1, &(a->ns1__CUser::isactive), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "iscustomer", -1, &(a->ns1__CUser::iscustomer), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isglobal", -1, &(a->ns1__CUser::isglobal), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isactiveglobal", -1, &(a->ns1__CUser::isactiveglobal), ""))
		return soap->error;
	if (soap_out_string(soap, "userLicense", -1, &(a->ns1__CUser::userLicense), ""))
		return soap->error;
	if (soap_out_string(soap, "userLicenseTCM", -1, &(a->ns1__CUser::userLicenseTCM), ""))
		return soap->error;
	if (soap_out_string(soap, "userLicenseRM", -1, &(a->ns1__CUser::userLicenseRM), ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &(a->ns1__CUser::password), ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &(a->ns1__CUser::loginname), ""))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumber(soap, "phoneone", -1, &(a->ns1__CUser::phoneone), ""))
		return soap->error;
	if (soap_out_PointerTons1__PhoneNumber(soap, "phonetwo", -1, &(a->ns1__CUser::phonetwo), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->ns1__CUser::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "betasite", -1, &(a->ns1__CUser::betasite), ""))
		return soap->error;
	if (soap_out_string(soap, "address", -1, &(a->ns1__CUser::address), ""))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "testconfig", -1, &(a->ns1__CUser::testconfig), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CUser(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CUser * SOAP_FMAC4 soap_in_ns1__CUser(struct soap *soap, const char *tag, ns1__CUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CUser, sizeof(ns1__CUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_firstname1 = 1;
	size_t soap_flag_middleinitials1 = 1;
	size_t soap_flag_lastname1 = 1;
	size_t soap_flag_usergroupname1 = 1;
	size_t soap_flag_company1 = 1;
	size_t soap_flag_division1 = 1;
	size_t soap_flag_department1 = 1;
	size_t soap_flag_emailtype1 = 1;
	size_t soap_flag_emailaddress1 = 1;
	size_t soap_flag_isactive1 = 1;
	size_t soap_flag_iscustomer1 = 1;
	size_t soap_flag_isglobal1 = 1;
	size_t soap_flag_isactiveglobal1 = 1;
	size_t soap_flag_userLicense1 = 1;
	size_t soap_flag_userLicenseTCM1 = 1;
	size_t soap_flag_userLicenseRM1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_loginname1 = 1;
	size_t soap_flag_phoneone1 = 1;
	size_t soap_flag_phonetwo1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_betasite1 = 1;
	size_t soap_flag_address1 = 1;
	size_t soap_flag_testconfig1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CUser::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_firstname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstname", &(a->ns1__CUser::firstname), "xsd:string"))
				{	soap_flag_firstname1--;
					continue;
				}
			if (soap_flag_middleinitials1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleinitials", &(a->ns1__CUser::middleinitials), "xsd:string"))
				{	soap_flag_middleinitials1--;
					continue;
				}
			if (soap_flag_lastname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastname", &(a->ns1__CUser::lastname), "xsd:string"))
				{	soap_flag_lastname1--;
					continue;
				}
			if (soap_flag_usergroupname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "usergroupname", &(a->ns1__CUser::usergroupname), "xsd:string"))
				{	soap_flag_usergroupname1--;
					continue;
				}
			if (soap_flag_company1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "company", &(a->ns1__CUser::company), "xsd:string"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_division1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "division", &(a->ns1__CUser::division), "xsd:string"))
				{	soap_flag_division1--;
					continue;
				}
			if (soap_flag_department1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "department", &(a->ns1__CUser::department), "xsd:string"))
				{	soap_flag_department1--;
					continue;
				}
			if (soap_flag_emailtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailtype", &(a->ns1__CUser::emailtype), "xsd:string"))
				{	soap_flag_emailtype1--;
					continue;
				}
			if (soap_flag_emailaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "emailaddress", &(a->ns1__CUser::emailaddress), "xsd:string"))
				{	soap_flag_emailaddress1--;
					continue;
				}
			if (soap_flag_isactive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isactive", &(a->ns1__CUser::isactive), "xsd:boolean"))
				{	soap_flag_isactive1--;
					continue;
				}
			if (soap_flag_iscustomer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "iscustomer", &(a->ns1__CUser::iscustomer), "xsd:boolean"))
				{	soap_flag_iscustomer1--;
					continue;
				}
			if (soap_flag_isglobal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isglobal", &(a->ns1__CUser::isglobal), "xsd:boolean"))
				{	soap_flag_isglobal1--;
					continue;
				}
			if (soap_flag_isactiveglobal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isactiveglobal", &(a->ns1__CUser::isactiveglobal), "xsd:boolean"))
				{	soap_flag_isactiveglobal1--;
					continue;
				}
			if (soap_flag_userLicense1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userLicense", &(a->ns1__CUser::userLicense), "xsd:string"))
				{	soap_flag_userLicense1--;
					continue;
				}
			if (soap_flag_userLicenseTCM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userLicenseTCM", &(a->ns1__CUser::userLicenseTCM), "xsd:string"))
				{	soap_flag_userLicenseTCM1--;
					continue;
				}
			if (soap_flag_userLicenseRM1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userLicenseRM", &(a->ns1__CUser::userLicenseRM), "xsd:string"))
				{	soap_flag_userLicenseRM1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &(a->ns1__CUser::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_loginname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &(a->ns1__CUser::loginname), "xsd:string"))
				{	soap_flag_loginname1--;
					continue;
				}
			if (soap_flag_phoneone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneNumber(soap, "phoneone", &(a->ns1__CUser::phoneone), "ns1:PhoneNumber"))
				{	soap_flag_phoneone1--;
					continue;
				}
			if (soap_flag_phonetwo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PhoneNumber(soap, "phonetwo", &(a->ns1__CUser::phonetwo), "ns1:PhoneNumber"))
				{	soap_flag_phonetwo1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->ns1__CUser::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_betasite1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "betasite", &(a->ns1__CUser::betasite), "xsd:boolean"))
				{	soap_flag_betasite1--;
					continue;
				}
			if (soap_flag_address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "address", &(a->ns1__CUser::address), "xsd:string"))
				{	soap_flag_address1--;
					continue;
				}
			if (soap_flag_testconfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "testconfig", &(a->ns1__CUser::testconfig), "ns1:CSystem"))
				{	soap_flag_testconfig1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CUser, 0, sizeof(ns1__CUser), 0, soap_copy_ns1__CUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CUser);
	if (this->soap_out(soap, tag?tag:"ns1:CUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CUser(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CUser * SOAP_FMAC4 soap_get_ns1__CUser(struct soap *soap, ns1__CUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CUser * SOAP_FMAC2 soap_instantiate_ns1__CUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CUser);
		if (size)
			*size = sizeof(ns1__CUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CUser, n);
		if (size)
			*size = n * sizeof(ns1__CUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CUser %p -> %p\n", q, p));
	*(ns1__CUser*)p = *(ns1__CUser*)q;
}

void ns1__PhoneNumber::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__PhoneNumber::numbertype);
	soap_default_string(soap, &this->ns1__PhoneNumber::phonenumber);
	/* transient soap skipped */
}

void ns1__PhoneNumber::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__PhoneNumber::numbertype);
	soap_serialize_string(soap, &this->ns1__PhoneNumber::phonenumber);
	/* transient soap skipped */
#endif
}

int ns1__PhoneNumber::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PhoneNumber(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PhoneNumber(struct soap *soap, const char *tag, int id, const ns1__PhoneNumber *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PhoneNumber), type))
		return soap->error;
	if (soap_out_string(soap, "numbertype", -1, &(a->ns1__PhoneNumber::numbertype), ""))
		return soap->error;
	if (soap_out_string(soap, "phonenumber", -1, &(a->ns1__PhoneNumber::phonenumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__PhoneNumber::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PhoneNumber(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PhoneNumber * SOAP_FMAC4 soap_in_ns1__PhoneNumber(struct soap *soap, const char *tag, ns1__PhoneNumber *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PhoneNumber *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PhoneNumber, sizeof(ns1__PhoneNumber), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PhoneNumber)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PhoneNumber *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_numbertype1 = 1;
	size_t soap_flag_phonenumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_numbertype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "numbertype", &(a->ns1__PhoneNumber::numbertype), "xsd:string"))
				{	soap_flag_numbertype1--;
					continue;
				}
			if (soap_flag_phonenumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phonenumber", &(a->ns1__PhoneNumber::phonenumber), "xsd:string"))
				{	soap_flag_phonenumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PhoneNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PhoneNumber, 0, sizeof(ns1__PhoneNumber), 0, soap_copy_ns1__PhoneNumber);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__PhoneNumber::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PhoneNumber);
	if (this->soap_out(soap, tag?tag:"ns1:PhoneNumber", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__PhoneNumber::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PhoneNumber(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PhoneNumber * SOAP_FMAC4 soap_get_ns1__PhoneNumber(struct soap *soap, ns1__PhoneNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__PhoneNumber * SOAP_FMAC2 soap_instantiate_ns1__PhoneNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PhoneNumber(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PhoneNumber, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__PhoneNumber);
		if (size)
			*size = sizeof(ns1__PhoneNumber);
		((ns1__PhoneNumber*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__PhoneNumber, n);
		if (size)
			*size = n * sizeof(ns1__PhoneNumber);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__PhoneNumber*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__PhoneNumber*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PhoneNumber(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PhoneNumber %p -> %p\n", q, p));
	*(ns1__PhoneNumber*)p = *(ns1__PhoneNumber*)q;
}

void ns1__CTask::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTask::recordid);
	soap_default_string(soap, &this->ns1__CTask::status);
	soap_default_string(soap, &this->ns1__CTask::priority);
	soap_default_string(soap, &this->ns1__CTask::summary);
	soap_default_string(soap, &this->ns1__CTask::description);
	soap_default_xsd__date(soap, &this->ns1__CTask::datedue);
	soap_default_xsd__date(soap, &this->ns1__CTask::dateassigned);
	soap_default_string(soap, &this->ns1__CTask::versiondue);
	soap_default_string(soap, &this->ns1__CTask::assignedto);
	soap_default_string(soap, &this->ns1__CTask::assignedby);
	this->ns1__CTask::assigneddefect = NULL;
}

void ns1__CTask::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTask::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CTask::status);
	soap_serialize_string(soap, &this->ns1__CTask::priority);
	soap_serialize_string(soap, &this->ns1__CTask::summary);
	soap_serialize_string(soap, &this->ns1__CTask::description);
	soap_serialize_xsd__date(soap, &this->ns1__CTask::datedue);
	soap_serialize_xsd__date(soap, &this->ns1__CTask::dateassigned);
	soap_serialize_string(soap, &this->ns1__CTask::versiondue);
	soap_serialize_string(soap, &this->ns1__CTask::assignedto);
	soap_serialize_string(soap, &this->ns1__CTask::assignedby);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CTask::assigneddefect);
#endif
}

int ns1__CTask::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTask(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTask(struct soap *soap, const char *tag, int id, const ns1__CTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTask::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "status", -1, &(a->ns1__CTask::status), ""))
		return soap->error;
	if (soap_out_string(soap, "priority", -1, &(a->ns1__CTask::priority), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CTask::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns1__CTask::description), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "datedue", -1, &(a->ns1__CTask::datedue), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "dateassigned", -1, &(a->ns1__CTask::dateassigned), ""))
		return soap->error;
	if (soap_out_string(soap, "versiondue", -1, &(a->ns1__CTask::versiondue), ""))
		return soap->error;
	if (soap_out_string(soap, "assignedto", -1, &(a->ns1__CTask::assignedto), ""))
		return soap->error;
	if (soap_out_string(soap, "assignedby", -1, &(a->ns1__CTask::assignedby), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "assigneddefect", -1, &(a->ns1__CTask::assigneddefect), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTask::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTask(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTask * SOAP_FMAC4 soap_in_ns1__CTask(struct soap *soap, const char *tag, ns1__CTask *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTask *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTask, sizeof(ns1__CTask), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTask)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTask *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_description1 = 1;
	size_t soap_flag_datedue1 = 1;
	size_t soap_flag_dateassigned1 = 1;
	size_t soap_flag_versiondue1 = 1;
	size_t soap_flag_assignedto1 = 1;
	size_t soap_flag_assignedby1 = 1;
	size_t soap_flag_assigneddefect1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTask::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "status", &(a->ns1__CTask::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "priority", &(a->ns1__CTask::priority), "xsd:string"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CTask::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns1__CTask::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_datedue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "datedue", &(a->ns1__CTask::datedue), "xsd:date"))
				{	soap_flag_datedue1--;
					continue;
				}
			if (soap_flag_dateassigned1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "dateassigned", &(a->ns1__CTask::dateassigned), "xsd:date"))
				{	soap_flag_dateassigned1--;
					continue;
				}
			if (soap_flag_versiondue1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "versiondue", &(a->ns1__CTask::versiondue), "xsd:string"))
				{	soap_flag_versiondue1--;
					continue;
				}
			if (soap_flag_assignedto1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "assignedto", &(a->ns1__CTask::assignedto), "xsd:string"))
				{	soap_flag_assignedto1--;
					continue;
				}
			if (soap_flag_assignedby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "assignedby", &(a->ns1__CTask::assignedby), "xsd:string"))
				{	soap_flag_assignedby1--;
					continue;
				}
			if (soap_flag_assigneddefect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "assigneddefect", &(a->ns1__CTask::assigneddefect), "xsd:long"))
				{	soap_flag_assigneddefect1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTask, 0, sizeof(ns1__CTask), 0, soap_copy_ns1__CTask);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTask::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTask);
	if (this->soap_out(soap, tag?tag:"ns1:CTask", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTask::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTask(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTask * SOAP_FMAC4 soap_get_ns1__CTask(struct soap *soap, ns1__CTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTask * SOAP_FMAC2 soap_instantiate_ns1__CTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTask);
		if (size)
			*size = sizeof(ns1__CTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTask, n);
		if (size)
			*size = n * sizeof(ns1__CTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTask %p -> %p\n", q, p));
	*(ns1__CTask*)p = *(ns1__CTask*)q;
}

void ns1__CDefect::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDefect::recordid);
	this->ns1__CDefect::defectnumber = NULL;
	soap_default_string(soap, &this->ns1__CDefect::summary);
	soap_default_string(soap, &this->ns1__CDefect::state);
	soap_default_string(soap, &this->ns1__CDefect::disposition);
	soap_default_string(soap, &this->ns1__CDefect::type);
	soap_default_string(soap, &this->ns1__CDefect::priority);
	soap_default_string(soap, &this->ns1__CDefect::product);
	soap_default_string(soap, &this->ns1__CDefect::component);
	soap_default_string(soap, &this->ns1__CDefect::reference);
	soap_default_string(soap, &this->ns1__CDefect::severity);
	soap_default_string(soap, &this->ns1__CDefect::enteredby);
	soap_default_string(soap, &this->ns1__CDefect::workaround);
	this->ns1__CDefect::workaroundInlineAttachList = NULL;
	soap_default_xsd__date(soap, &this->ns1__CDefect::dateentered);
	soap_default_string(soap, &this->ns1__CDefect::locationaddedfrom);
	this->ns1__CDefect::datetimecreated = NULL;
	this->ns1__CDefect::datetimemodified = NULL;
	soap_default_string(soap, &this->ns1__CDefect::createdbyuser);
	soap_default_string(soap, &this->ns1__CDefect::modifiedbyuser);
	this->ns1__CDefect::actualhourstofix = NULL;
	this->ns1__CDefect::estimatedhours = NULL;
	this->ns1__CDefect::remaininghours = NULL;
	this->ns1__CDefect::variance = NULL;
	this->ns1__CDefect::storypoints = NULL;
	this->ns1__CDefect::percentdone = NULL;
	this->ns1__CDefect::reportedbylist = NULL;
	this->ns1__CDefect::eventlist = NULL;
	this->ns1__CDefect::pSCCFileList = NULL;
	this->ns1__CDefect::customFieldList = NULL;
}

void ns1__CDefect::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDefect::recordid, SOAP_TYPE_LONG64);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CDefect::defectnumber);
	soap_serialize_string(soap, &this->ns1__CDefect::summary);
	soap_serialize_string(soap, &this->ns1__CDefect::state);
	soap_serialize_string(soap, &this->ns1__CDefect::disposition);
	soap_serialize_string(soap, &this->ns1__CDefect::type);
	soap_serialize_string(soap, &this->ns1__CDefect::priority);
	soap_serialize_string(soap, &this->ns1__CDefect::product);
	soap_serialize_string(soap, &this->ns1__CDefect::component);
	soap_serialize_string(soap, &this->ns1__CDefect::reference);
	soap_serialize_string(soap, &this->ns1__CDefect::severity);
	soap_serialize_string(soap, &this->ns1__CDefect::enteredby);
	soap_serialize_string(soap, &this->ns1__CDefect::workaround);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CDefect::workaroundInlineAttachList);
	soap_serialize_xsd__date(soap, &this->ns1__CDefect::dateentered);
	soap_serialize_string(soap, &this->ns1__CDefect::locationaddedfrom);
	soap_serialize_PointerTotime(soap, &this->ns1__CDefect::datetimecreated);
	soap_serialize_PointerTotime(soap, &this->ns1__CDefect::datetimemodified);
	soap_serialize_string(soap, &this->ns1__CDefect::createdbyuser);
	soap_serialize_string(soap, &this->ns1__CDefect::modifiedbyuser);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefect::actualhourstofix);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefect::estimatedhours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefect::remaininghours);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefect::variance);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CDefect::storypoints);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CDefect::percentdone);
	soap_serialize_PointerToArrayOfCReportedByRecord(soap, &this->ns1__CDefect::reportedbylist);
	soap_serialize_PointerToArrayOfCEvent(soap, &this->ns1__CDefect::eventlist);
	soap_serialize_PointerToArrayOfCSCCFileRecord(soap, &this->ns1__CDefect::pSCCFileList);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CDefect::customFieldList);
#endif
}

int ns1__CDefect::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDefect(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDefect(struct soap *soap, const char *tag, int id, const ns1__CDefect *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDefect::recordid), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "defectnumber", -1, &(a->ns1__CDefect::defectnumber), ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &(a->ns1__CDefect::summary), ""))
		return soap->error;
	if (soap_out_string(soap, "state", -1, &(a->ns1__CDefect::state), ""))
		return soap->error;
	if (soap_out_string(soap, "disposition", -1, &(a->ns1__CDefect::disposition), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->ns1__CDefect::type), ""))
		return soap->error;
	if (soap_out_string(soap, "priority", -1, &(a->ns1__CDefect::priority), ""))
		return soap->error;
	if (soap_out_string(soap, "product", -1, &(a->ns1__CDefect::product), ""))
		return soap->error;
	if (soap_out_string(soap, "component", -1, &(a->ns1__CDefect::component), ""))
		return soap->error;
	if (soap_out_string(soap, "reference", -1, &(a->ns1__CDefect::reference), ""))
		return soap->error;
	if (soap_out_string(soap, "severity", -1, &(a->ns1__CDefect::severity), ""))
		return soap->error;
	if (soap_out_string(soap, "enteredby", -1, &(a->ns1__CDefect::enteredby), ""))
		return soap->error;
	if (soap_out_string(soap, "workaround", -1, &(a->ns1__CDefect::workaround), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "workaroundInlineAttachList", -1, &(a->ns1__CDefect::workaroundInlineAttachList), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "dateentered", -1, &(a->ns1__CDefect::dateentered), ""))
		return soap->error;
	if (soap_out_string(soap, "locationaddedfrom", -1, &(a->ns1__CDefect::locationaddedfrom), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimecreated", -1, &(a->ns1__CDefect::datetimecreated), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "datetimemodified", -1, &(a->ns1__CDefect::datetimemodified), ""))
		return soap->error;
	if (soap_out_string(soap, "createdbyuser", -1, &(a->ns1__CDefect::createdbyuser), ""))
		return soap->error;
	if (soap_out_string(soap, "modifiedbyuser", -1, &(a->ns1__CDefect::modifiedbyuser), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "actualhourstofix", -1, &(a->ns1__CDefect::actualhourstofix), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "estimatedhours", -1, &(a->ns1__CDefect::estimatedhours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "remaininghours", -1, &(a->ns1__CDefect::remaininghours), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "variance", -1, &(a->ns1__CDefect::variance), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "storypoints", -1, &(a->ns1__CDefect::storypoints), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "percentdone", -1, &(a->ns1__CDefect::percentdone), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCReportedByRecord(soap, "reportedbylist", -1, &(a->ns1__CDefect::reportedbylist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCEvent(soap, "eventlist", -1, &(a->ns1__CDefect::eventlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, "pSCCFileList", -1, &(a->ns1__CDefect::pSCCFileList), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFieldList", -1, &(a->ns1__CDefect::customFieldList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDefect::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDefect(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDefect * SOAP_FMAC4 soap_in_ns1__CDefect(struct soap *soap, const char *tag, ns1__CDefect *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDefect *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDefect, sizeof(ns1__CDefect), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDefect)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDefect *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_defectnumber1 = 1;
	size_t soap_flag_summary1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_disposition1 = 1;
	size_t soap_flag_type1 = 1;
	size_t soap_flag_priority1 = 1;
	size_t soap_flag_product1 = 1;
	size_t soap_flag_component1 = 1;
	size_t soap_flag_reference1 = 1;
	size_t soap_flag_severity1 = 1;
	size_t soap_flag_enteredby1 = 1;
	size_t soap_flag_workaround1 = 1;
	size_t soap_flag_workaroundInlineAttachList1 = 1;
	size_t soap_flag_dateentered1 = 1;
	size_t soap_flag_locationaddedfrom1 = 1;
	size_t soap_flag_datetimecreated1 = 1;
	size_t soap_flag_datetimemodified1 = 1;
	size_t soap_flag_createdbyuser1 = 1;
	size_t soap_flag_modifiedbyuser1 = 1;
	size_t soap_flag_actualhourstofix1 = 1;
	size_t soap_flag_estimatedhours1 = 1;
	size_t soap_flag_remaininghours1 = 1;
	size_t soap_flag_variance1 = 1;
	size_t soap_flag_storypoints1 = 1;
	size_t soap_flag_percentdone1 = 1;
	size_t soap_flag_reportedbylist1 = 1;
	size_t soap_flag_eventlist1 = 1;
	size_t soap_flag_pSCCFileList1 = 1;
	size_t soap_flag_customFieldList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDefect::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_defectnumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "defectnumber", &(a->ns1__CDefect::defectnumber), "xsd:long"))
				{	soap_flag_defectnumber1--;
					continue;
				}
			if (soap_flag_summary1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &(a->ns1__CDefect::summary), "xsd:string"))
				{	soap_flag_summary1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "state", &(a->ns1__CDefect::state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_disposition1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "disposition", &(a->ns1__CDefect::disposition), "xsd:string"))
				{	soap_flag_disposition1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns1__CDefect::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "priority", &(a->ns1__CDefect::priority), "xsd:string"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_product1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "product", &(a->ns1__CDefect::product), "xsd:string"))
				{	soap_flag_product1--;
					continue;
				}
			if (soap_flag_component1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "component", &(a->ns1__CDefect::component), "xsd:string"))
				{	soap_flag_component1--;
					continue;
				}
			if (soap_flag_reference1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reference", &(a->ns1__CDefect::reference), "xsd:string"))
				{	soap_flag_reference1--;
					continue;
				}
			if (soap_flag_severity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "severity", &(a->ns1__CDefect::severity), "xsd:string"))
				{	soap_flag_severity1--;
					continue;
				}
			if (soap_flag_enteredby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "enteredby", &(a->ns1__CDefect::enteredby), "xsd:string"))
				{	soap_flag_enteredby1--;
					continue;
				}
			if (soap_flag_workaround1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "workaround", &(a->ns1__CDefect::workaround), "xsd:string"))
				{	soap_flag_workaround1--;
					continue;
				}
			if (soap_flag_workaroundInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "workaroundInlineAttachList", &(a->ns1__CDefect::workaroundInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_workaroundInlineAttachList1--;
					continue;
				}
			if (soap_flag_dateentered1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "dateentered", &(a->ns1__CDefect::dateentered), "xsd:date"))
				{	soap_flag_dateentered1--;
					continue;
				}
			if (soap_flag_locationaddedfrom1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "locationaddedfrom", &(a->ns1__CDefect::locationaddedfrom), "xsd:string"))
				{	soap_flag_locationaddedfrom1--;
					continue;
				}
			if (soap_flag_datetimecreated1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimecreated", &(a->ns1__CDefect::datetimecreated), "xsd:dateTime"))
				{	soap_flag_datetimecreated1--;
					continue;
				}
			if (soap_flag_datetimemodified1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "datetimemodified", &(a->ns1__CDefect::datetimemodified), "xsd:dateTime"))
				{	soap_flag_datetimemodified1--;
					continue;
				}
			if (soap_flag_createdbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "createdbyuser", &(a->ns1__CDefect::createdbyuser), "xsd:string"))
				{	soap_flag_createdbyuser1--;
					continue;
				}
			if (soap_flag_modifiedbyuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modifiedbyuser", &(a->ns1__CDefect::modifiedbyuser), "xsd:string"))
				{	soap_flag_modifiedbyuser1--;
					continue;
				}
			if (soap_flag_actualhourstofix1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "actualhourstofix", &(a->ns1__CDefect::actualhourstofix), "xsd:double"))
				{	soap_flag_actualhourstofix1--;
					continue;
				}
			if (soap_flag_estimatedhours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "estimatedhours", &(a->ns1__CDefect::estimatedhours), "xsd:double"))
				{	soap_flag_estimatedhours1--;
					continue;
				}
			if (soap_flag_remaininghours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "remaininghours", &(a->ns1__CDefect::remaininghours), "xsd:double"))
				{	soap_flag_remaininghours1--;
					continue;
				}
			if (soap_flag_variance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "variance", &(a->ns1__CDefect::variance), "xsd:double"))
				{	soap_flag_variance1--;
					continue;
				}
			if (soap_flag_storypoints1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "storypoints", &(a->ns1__CDefect::storypoints), "xsd:long"))
				{	soap_flag_storypoints1--;
					continue;
				}
			if (soap_flag_percentdone1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "percentdone", &(a->ns1__CDefect::percentdone), "xsd:long"))
				{	soap_flag_percentdone1--;
					continue;
				}
			if (soap_flag_reportedbylist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCReportedByRecord(soap, "reportedbylist", &(a->ns1__CDefect::reportedbylist), "ns1:CReportedByRecord"))
				{	soap_flag_reportedbylist1--;
					continue;
				}
			if (soap_flag_eventlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEvent(soap, "eventlist", &(a->ns1__CDefect::eventlist), "ns1:CEvent"))
				{	soap_flag_eventlist1--;
					continue;
				}
			if (soap_flag_pSCCFileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCSCCFileRecord(soap, "pSCCFileList", &(a->ns1__CDefect::pSCCFileList), "ns1:CSCCFileRecord"))
				{	soap_flag_pSCCFileList1--;
					continue;
				}
			if (soap_flag_customFieldList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFieldList", &(a->ns1__CDefect::customFieldList), "ns1:CField"))
				{	soap_flag_customFieldList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDefect, 0, sizeof(ns1__CDefect), 0, soap_copy_ns1__CDefect);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDefect::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDefect);
	if (this->soap_out(soap, tag?tag:"ns1:CDefect", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDefect::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDefect(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDefect * SOAP_FMAC4 soap_get_ns1__CDefect(struct soap *soap, ns1__CDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDefect * SOAP_FMAC2 soap_instantiate_ns1__CDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDefect);
		if (size)
			*size = sizeof(ns1__CDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDefect, n);
		if (size)
			*size = n * sizeof(ns1__CDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDefect %p -> %p\n", q, p));
	*(ns1__CDefect*)p = *(ns1__CDefect*)q;
}

void ArrayOfCDefectEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCDefectEventDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCDefectEventDefinition))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CDefectEventDefinition(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCDefectEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCDefectEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, int id, const ArrayOfCDefectEventDefinition *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CDefectEventDefinition", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDefectEventDefinition);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CDefectEventDefinition(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCDefectEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCDefectEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCDefectEventDefinition * SOAP_FMAC4 soap_in_ArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, ArrayOfCDefectEventDefinition *a, const char *type)
{	int i, j;
	ns1__CDefectEventDefinition **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCDefectEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCDefectEventDefinition, sizeof(ArrayOfCDefectEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CDefectEventDefinition **)soap_malloc(soap, sizeof(ns1__CDefectEventDefinition *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CDefectEventDefinition(soap, NULL, a->__ptritem + i, "ns1:CDefectEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CDefectEventDefinition **)soap_push_block(soap, NULL, sizeof(ns1__CDefectEventDefinition *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CDefectEventDefinition(soap, NULL, p, "ns1:CDefectEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CDefectEventDefinition **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCDefectEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCDefectEventDefinition, 0, sizeof(ArrayOfCDefectEventDefinition), 0, soap_copy_ArrayOfCDefectEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCDefectEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCDefectEventDefinition);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCDefectEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCDefectEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCDefectEventDefinition * SOAP_FMAC4 soap_get_ArrayOfCDefectEventDefinition(struct soap *soap, ArrayOfCDefectEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCDefectEventDefinition * SOAP_FMAC2 soap_instantiate_ArrayOfCDefectEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCDefectEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCDefectEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCDefectEventDefinition);
		if (size)
			*size = sizeof(ArrayOfCDefectEventDefinition);
		((ArrayOfCDefectEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCDefectEventDefinition, n);
		if (size)
			*size = n * sizeof(ArrayOfCDefectEventDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCDefectEventDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCDefectEventDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCDefectEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCDefectEventDefinition %p -> %p\n", q, p));
	*(ArrayOfCDefectEventDefinition*)p = *(ArrayOfCDefectEventDefinition*)q;
}

void ns1__CDefectEventDefinition::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_string(soap, &this->ns1__CDefectEventDefinition::name);
	this->ns1__CDefectEventDefinition::user = NULL;
	this->ns1__CDefectEventDefinition::datetime = NULL;
	this->ns1__CDefectEventDefinition::notes = NULL;
	this->ns1__CDefectEventDefinition::resultingState = NULL;
	this->ns1__CDefectEventDefinition::resultingStateValues = NULL;
	this->ns1__CDefectEventDefinition::fileattachments = NULL;
	this->ns1__CDefectEventDefinition::timeTracking = NULL;
	this->ns1__CDefectEventDefinition::timeSumOfAll = NULL;
	this->ns1__CDefectEventDefinition::timeHoursSinceLast = NULL;
	this->ns1__CDefectEventDefinition::newAssignment = NULL;
	this->ns1__CDefectEventDefinition::releaseNotes = NULL;
	this->ns1__CDefectEventDefinition::marksuspect = NULL;
	this->ns1__CDefectEventDefinition::reviewnote = NULL;
	this->ns1__CDefectEventDefinition::customFields = NULL;
}

void ns1__CDefectEventDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CDefectEventDefinition::name);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::user);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::datetime);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::notes);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::resultingState);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CDefectEventDefinition::resultingStateValues);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::fileattachments);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::timeTracking);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::timeSumOfAll);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::timeHoursSinceLast);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::newAssignment);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::releaseNotes);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::marksuspect);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEventDefinition::reviewnote);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CDefectEventDefinition::customFields);
#endif
}

int ns1__CDefectEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDefectEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, const ns1__CDefectEventDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDefectEventDefinition), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CDefectEventDefinition::name), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "user", -1, &(a->ns1__CDefectEventDefinition::user), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "datetime", -1, &(a->ns1__CDefectEventDefinition::datetime), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "notes", -1, &(a->ns1__CDefectEventDefinition::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "resultingState", -1, &(a->ns1__CDefectEventDefinition::resultingState), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "resultingStateValues", -1, &(a->ns1__CDefectEventDefinition::resultingStateValues), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fileattachments", -1, &(a->ns1__CDefectEventDefinition::fileattachments), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeTracking", -1, &(a->ns1__CDefectEventDefinition::timeTracking), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeSumOfAll", -1, &(a->ns1__CDefectEventDefinition::timeSumOfAll), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeHoursSinceLast", -1, &(a->ns1__CDefectEventDefinition::timeHoursSinceLast), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "newAssignment", -1, &(a->ns1__CDefectEventDefinition::newAssignment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "releaseNotes", -1, &(a->ns1__CDefectEventDefinition::releaseNotes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "marksuspect", -1, &(a->ns1__CDefectEventDefinition::marksuspect), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "reviewnote", -1, &(a->ns1__CDefectEventDefinition::reviewnote), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFields", -1, &(a->ns1__CDefectEventDefinition::customFields), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDefectEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDefectEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDefectEventDefinition * SOAP_FMAC4 soap_in_ns1__CDefectEventDefinition(struct soap *soap, const char *tag, ns1__CDefectEventDefinition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDefectEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDefectEventDefinition, sizeof(ns1__CDefectEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDefectEventDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDefectEventDefinition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_datetime1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_resultingState1 = 1;
	size_t soap_flag_resultingStateValues1 = 1;
	size_t soap_flag_fileattachments1 = 1;
	size_t soap_flag_timeTracking1 = 1;
	size_t soap_flag_timeSumOfAll1 = 1;
	size_t soap_flag_timeHoursSinceLast1 = 1;
	size_t soap_flag_newAssignment1 = 1;
	size_t soap_flag_releaseNotes1 = 1;
	size_t soap_flag_marksuspect1 = 1;
	size_t soap_flag_reviewnote1 = 1;
	size_t soap_flag_customFields1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDefectEventDefinition::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "user", &(a->ns1__CDefectEventDefinition::user), "xsd:boolean"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "datetime", &(a->ns1__CDefectEventDefinition::datetime), "xsd:boolean"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_notes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "notes", &(a->ns1__CDefectEventDefinition::notes), "xsd:boolean"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_resultingState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "resultingState", &(a->ns1__CDefectEventDefinition::resultingState), "xsd:boolean"))
				{	soap_flag_resultingState1--;
					continue;
				}
			if (soap_flag_resultingStateValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "resultingStateValues", &(a->ns1__CDefectEventDefinition::resultingStateValues), "ns1:CFieldValue"))
				{	soap_flag_resultingStateValues1--;
					continue;
				}
			if (soap_flag_fileattachments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fileattachments", &(a->ns1__CDefectEventDefinition::fileattachments), "xsd:boolean"))
				{	soap_flag_fileattachments1--;
					continue;
				}
			if (soap_flag_timeTracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeTracking", &(a->ns1__CDefectEventDefinition::timeTracking), "xsd:boolean"))
				{	soap_flag_timeTracking1--;
					continue;
				}
			if (soap_flag_timeSumOfAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeSumOfAll", &(a->ns1__CDefectEventDefinition::timeSumOfAll), "xsd:boolean"))
				{	soap_flag_timeSumOfAll1--;
					continue;
				}
			if (soap_flag_timeHoursSinceLast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeHoursSinceLast", &(a->ns1__CDefectEventDefinition::timeHoursSinceLast), "xsd:boolean"))
				{	soap_flag_timeHoursSinceLast1--;
					continue;
				}
			if (soap_flag_newAssignment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "newAssignment", &(a->ns1__CDefectEventDefinition::newAssignment), "xsd:boolean"))
				{	soap_flag_newAssignment1--;
					continue;
				}
			if (soap_flag_releaseNotes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "releaseNotes", &(a->ns1__CDefectEventDefinition::releaseNotes), "xsd:boolean"))
				{	soap_flag_releaseNotes1--;
					continue;
				}
			if (soap_flag_marksuspect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "marksuspect", &(a->ns1__CDefectEventDefinition::marksuspect), "xsd:boolean"))
				{	soap_flag_marksuspect1--;
					continue;
				}
			if (soap_flag_reviewnote1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "reviewnote", &(a->ns1__CDefectEventDefinition::reviewnote), "xsd:boolean"))
				{	soap_flag_reviewnote1--;
					continue;
				}
			if (soap_flag_customFields1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFields", &(a->ns1__CDefectEventDefinition::customFields), "ns1:CField"))
				{	soap_flag_customFields1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDefectEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDefectEventDefinition, 0, sizeof(ns1__CDefectEventDefinition), 0, soap_copy_ns1__CDefectEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CDefectEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDefectEventDefinition);
	if (this->soap_out(soap, tag?tag:"ns1:CDefectEventDefinition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDefectEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDefectEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDefectEventDefinition * SOAP_FMAC4 soap_get_ns1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDefectEventDefinition * SOAP_FMAC2 soap_instantiate_ns1__CDefectEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDefectEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDefectEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDefectEventDefinition);
		if (size)
			*size = sizeof(ns1__CDefectEventDefinition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDefectEventDefinition, n);
		if (size)
			*size = n * sizeof(ns1__CDefectEventDefinition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDefectEventDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDefectEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDefectEventDefinition %p -> %p\n", q, p));
	*(ns1__CDefectEventDefinition*)p = *(ns1__CDefectEventDefinition*)q;
}

void ArrayOfCEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCEventDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCEventDefinition))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CEventDefinition(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCEventDefinition(struct soap *soap, const char *tag, int id, const ArrayOfCEventDefinition *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CEventDefinition", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCEventDefinition);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CEventDefinition(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCEventDefinition * SOAP_FMAC4 soap_in_ArrayOfCEventDefinition(struct soap *soap, const char *tag, ArrayOfCEventDefinition *a, const char *type)
{	int i, j;
	ns1__CEventDefinition **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCEventDefinition, sizeof(ArrayOfCEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CEventDefinition **)soap_malloc(soap, sizeof(ns1__CEventDefinition *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CEventDefinition(soap, NULL, a->__ptritem + i, "ns1:CEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CEventDefinition **)soap_push_block(soap, NULL, sizeof(ns1__CEventDefinition *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CEventDefinition(soap, NULL, p, "ns1:CEventDefinition"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CEventDefinition **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCEventDefinition, 0, sizeof(ArrayOfCEventDefinition), 0, soap_copy_ArrayOfCEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCEventDefinition);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCEventDefinition * SOAP_FMAC4 soap_get_ArrayOfCEventDefinition(struct soap *soap, ArrayOfCEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCEventDefinition * SOAP_FMAC2 soap_instantiate_ArrayOfCEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCEventDefinition);
		if (size)
			*size = sizeof(ArrayOfCEventDefinition);
		((ArrayOfCEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCEventDefinition, n);
		if (size)
			*size = n * sizeof(ArrayOfCEventDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCEventDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCEventDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCEventDefinition %p -> %p\n", q, p));
	*(ArrayOfCEventDefinition*)p = *(ArrayOfCEventDefinition*)q;
}

void ns1__CEventDefinition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CEventDefinition::name);
	this->ns1__CEventDefinition::user = NULL;
	this->ns1__CEventDefinition::datetime = NULL;
	this->ns1__CEventDefinition::notes = NULL;
	this->ns1__CEventDefinition::resultingState = NULL;
	this->ns1__CEventDefinition::resultingStateValues = NULL;
	this->ns1__CEventDefinition::fileattachments = NULL;
	this->ns1__CEventDefinition::timeTracking = NULL;
	this->ns1__CEventDefinition::timeSumOfAll = NULL;
	this->ns1__CEventDefinition::timeHoursSinceLast = NULL;
	this->ns1__CEventDefinition::newAssignment = NULL;
	this->ns1__CEventDefinition::releaseNotes = NULL;
	this->ns1__CEventDefinition::marksuspect = NULL;
	this->ns1__CEventDefinition::reviewnote = NULL;
	this->ns1__CEventDefinition::customFields = NULL;
	/* transient soap skipped */
}

void ns1__CEventDefinition::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CEventDefinition::name);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::user);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::datetime);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::notes);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::resultingState);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CEventDefinition::resultingStateValues);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::fileattachments);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::timeTracking);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::timeSumOfAll);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::timeHoursSinceLast);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::newAssignment);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::releaseNotes);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::marksuspect);
	soap_serialize_PointerTobool(soap, &this->ns1__CEventDefinition::reviewnote);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CEventDefinition::customFields);
	/* transient soap skipped */
#endif
}

int ns1__CEventDefinition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CEventDefinition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CEventDefinition(struct soap *soap, const char *tag, int id, const ns1__CEventDefinition *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CEventDefinition), type))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CEventDefinition::name), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "user", -1, &(a->ns1__CEventDefinition::user), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "datetime", -1, &(a->ns1__CEventDefinition::datetime), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "notes", -1, &(a->ns1__CEventDefinition::notes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "resultingState", -1, &(a->ns1__CEventDefinition::resultingState), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "resultingStateValues", -1, &(a->ns1__CEventDefinition::resultingStateValues), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "fileattachments", -1, &(a->ns1__CEventDefinition::fileattachments), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeTracking", -1, &(a->ns1__CEventDefinition::timeTracking), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeSumOfAll", -1, &(a->ns1__CEventDefinition::timeSumOfAll), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "timeHoursSinceLast", -1, &(a->ns1__CEventDefinition::timeHoursSinceLast), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "newAssignment", -1, &(a->ns1__CEventDefinition::newAssignment), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "releaseNotes", -1, &(a->ns1__CEventDefinition::releaseNotes), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "marksuspect", -1, &(a->ns1__CEventDefinition::marksuspect), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "reviewnote", -1, &(a->ns1__CEventDefinition::reviewnote), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFields", -1, &(a->ns1__CEventDefinition::customFields), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CEventDefinition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CEventDefinition(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CEventDefinition * SOAP_FMAC4 soap_in_ns1__CEventDefinition(struct soap *soap, const char *tag, ns1__CEventDefinition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CEventDefinition *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CEventDefinition, sizeof(ns1__CEventDefinition), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CEventDefinition)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CEventDefinition *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_datetime1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_resultingState1 = 1;
	size_t soap_flag_resultingStateValues1 = 1;
	size_t soap_flag_fileattachments1 = 1;
	size_t soap_flag_timeTracking1 = 1;
	size_t soap_flag_timeSumOfAll1 = 1;
	size_t soap_flag_timeHoursSinceLast1 = 1;
	size_t soap_flag_newAssignment1 = 1;
	size_t soap_flag_releaseNotes1 = 1;
	size_t soap_flag_marksuspect1 = 1;
	size_t soap_flag_reviewnote1 = 1;
	size_t soap_flag_customFields1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CEventDefinition::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_user1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "user", &(a->ns1__CEventDefinition::user), "xsd:boolean"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_datetime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "datetime", &(a->ns1__CEventDefinition::datetime), "xsd:boolean"))
				{	soap_flag_datetime1--;
					continue;
				}
			if (soap_flag_notes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "notes", &(a->ns1__CEventDefinition::notes), "xsd:boolean"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_resultingState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "resultingState", &(a->ns1__CEventDefinition::resultingState), "xsd:boolean"))
				{	soap_flag_resultingState1--;
					continue;
				}
			if (soap_flag_resultingStateValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "resultingStateValues", &(a->ns1__CEventDefinition::resultingStateValues), "ns1:CFieldValue"))
				{	soap_flag_resultingStateValues1--;
					continue;
				}
			if (soap_flag_fileattachments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "fileattachments", &(a->ns1__CEventDefinition::fileattachments), "xsd:boolean"))
				{	soap_flag_fileattachments1--;
					continue;
				}
			if (soap_flag_timeTracking1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeTracking", &(a->ns1__CEventDefinition::timeTracking), "xsd:boolean"))
				{	soap_flag_timeTracking1--;
					continue;
				}
			if (soap_flag_timeSumOfAll1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeSumOfAll", &(a->ns1__CEventDefinition::timeSumOfAll), "xsd:boolean"))
				{	soap_flag_timeSumOfAll1--;
					continue;
				}
			if (soap_flag_timeHoursSinceLast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "timeHoursSinceLast", &(a->ns1__CEventDefinition::timeHoursSinceLast), "xsd:boolean"))
				{	soap_flag_timeHoursSinceLast1--;
					continue;
				}
			if (soap_flag_newAssignment1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "newAssignment", &(a->ns1__CEventDefinition::newAssignment), "xsd:boolean"))
				{	soap_flag_newAssignment1--;
					continue;
				}
			if (soap_flag_releaseNotes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "releaseNotes", &(a->ns1__CEventDefinition::releaseNotes), "xsd:boolean"))
				{	soap_flag_releaseNotes1--;
					continue;
				}
			if (soap_flag_marksuspect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "marksuspect", &(a->ns1__CEventDefinition::marksuspect), "xsd:boolean"))
				{	soap_flag_marksuspect1--;
					continue;
				}
			if (soap_flag_reviewnote1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "reviewnote", &(a->ns1__CEventDefinition::reviewnote), "xsd:boolean"))
				{	soap_flag_reviewnote1--;
					continue;
				}
			if (soap_flag_customFields1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFields", &(a->ns1__CEventDefinition::customFields), "ns1:CField"))
				{	soap_flag_customFields1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CEventDefinition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CEventDefinition, 0, sizeof(ns1__CEventDefinition), 0, soap_copy_ns1__CEventDefinition);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CEventDefinition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CEventDefinition);
	if (this->soap_out(soap, tag?tag:"ns1:CEventDefinition", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CEventDefinition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CEventDefinition(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CEventDefinition * SOAP_FMAC4 soap_get_ns1__CEventDefinition(struct soap *soap, ns1__CEventDefinition *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CEventDefinition * SOAP_FMAC2 soap_instantiate_ns1__CEventDefinition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CEventDefinition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CEventDefinition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CEventDefinition);
		if (size)
			*size = sizeof(ns1__CEventDefinition);
		((ns1__CEventDefinition*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CEventDefinition, n);
		if (size)
			*size = n * sizeof(ns1__CEventDefinition);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CEventDefinition*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CEventDefinition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CEventDefinition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CEventDefinition %p -> %p\n", q, p));
	*(ns1__CEventDefinition*)p = *(ns1__CEventDefinition*)q;
}

void ArrayOfCDefectEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCDefectEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCDefectEvent))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CDefectEvent(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCDefectEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCDefectEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCDefectEvent(struct soap *soap, const char *tag, int id, const ArrayOfCDefectEvent *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CDefectEvent", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDefectEvent);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CDefectEvent(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCDefectEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCDefectEvent(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCDefectEvent * SOAP_FMAC4 soap_in_ArrayOfCDefectEvent(struct soap *soap, const char *tag, ArrayOfCDefectEvent *a, const char *type)
{	int i, j;
	ns1__CDefectEvent **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCDefectEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCDefectEvent, sizeof(ArrayOfCDefectEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CDefectEvent **)soap_malloc(soap, sizeof(ns1__CDefectEvent *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CDefectEvent(soap, NULL, a->__ptritem + i, "ns1:CDefectEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CDefectEvent **)soap_push_block(soap, NULL, sizeof(ns1__CDefectEvent *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CDefectEvent(soap, NULL, p, "ns1:CDefectEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CDefectEvent **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCDefectEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCDefectEvent, 0, sizeof(ArrayOfCDefectEvent), 0, soap_copy_ArrayOfCDefectEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCDefectEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCDefectEvent);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCDefectEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCDefectEvent(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCDefectEvent * SOAP_FMAC4 soap_get_ArrayOfCDefectEvent(struct soap *soap, ArrayOfCDefectEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCDefectEvent * SOAP_FMAC2 soap_instantiate_ArrayOfCDefectEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCDefectEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCDefectEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCDefectEvent);
		if (size)
			*size = sizeof(ArrayOfCDefectEvent);
		((ArrayOfCDefectEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCDefectEvent, n);
		if (size)
			*size = n * sizeof(ArrayOfCDefectEvent);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCDefectEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCDefectEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCDefectEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCDefectEvent %p -> %p\n", q, p));
	*(ArrayOfCDefectEvent*)p = *(ArrayOfCDefectEvent*)q;
}

void ns1__CDefectEvent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDefectEvent::recordid);
	soap_default_string(soap, &this->ns1__CDefectEvent::user);
	soap_default_time(soap, &this->ns1__CDefectEvent::date);
	soap_default_string(soap, &this->ns1__CDefectEvent::notes);
	soap_default_short(soap, &this->ns1__CDefectEvent::eventaddorder);
	soap_default_string(soap, &this->ns1__CDefectEvent::name);
	this->ns1__CDefectEvent::parenteventid = NULL;
	this->ns1__CDefectEvent::attachmentlist = NULL;
	this->ns1__CDefectEvent::fieldlist = NULL;
	soap_default_string(soap, &this->ns1__CDefectEvent::resultingstate);
	this->ns1__CDefectEvent::hours = NULL;
	this->ns1__CDefectEvent::assigntolist = NULL;
	soap_default_string(soap, &this->ns1__CDefectEvent::releasenotesversion);
	soap_default_string(soap, &this->ns1__CDefectEvent::generatedeventtype);
	soap_default_string(soap, &this->ns1__CDefectEvent::generatedbyname);
	this->ns1__CDefectEvent::totaltimespent = NULL;
	soap_default_string(soap, &this->ns1__CDefectEvent::overrideuser);
	this->ns1__CDefectEvent::marksuspect = NULL;
}

void ns1__CDefectEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDefectEvent::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::user);
	soap_embedded(soap, &this->ns1__CDefectEvent::date, SOAP_TYPE_time);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::notes);
	soap_embedded(soap, &this->ns1__CDefectEvent::eventaddorder, SOAP_TYPE_short);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::name);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CDefectEvent::parenteventid);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CDefectEvent::attachmentlist);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CDefectEvent::fieldlist);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::resultingstate);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefectEvent::hours);
	soap_serialize_PointerToArrayOfstring(soap, &this->ns1__CDefectEvent::assigntolist);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::releasenotesversion);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::generatedeventtype);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::generatedbyname);
	soap_serialize_PointerTodouble(soap, &this->ns1__CDefectEvent::totaltimespent);
	soap_serialize_string(soap, &this->ns1__CDefectEvent::overrideuser);
	soap_serialize_PointerTobool(soap, &this->ns1__CDefectEvent::marksuspect);
#endif
}

int ns1__CDefectEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDefectEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDefectEvent(struct soap *soap, const char *tag, int id, const ns1__CDefectEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDefectEvent), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDefectEvent::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &(a->ns1__CDefectEvent::user), ""))
		return soap->error;
	if (soap_out_time(soap, "date", -1, &(a->ns1__CDefectEvent::date), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->ns1__CDefectEvent::notes), ""))
		return soap->error;
	if (soap_out_short(soap, "eventaddorder", -1, &(a->ns1__CDefectEvent::eventaddorder), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CDefectEvent::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parenteventid", -1, &(a->ns1__CDefectEvent::parenteventid), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->ns1__CDefectEvent::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "fieldlist", -1, &(a->ns1__CDefectEvent::fieldlist), ""))
		return soap->error;
	if (soap_out_string(soap, "resultingstate", -1, &(a->ns1__CDefectEvent::resultingstate), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "hours", -1, &(a->ns1__CDefectEvent::hours), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfstring(soap, "assigntolist", -1, &(a->ns1__CDefectEvent::assigntolist), ""))
		return soap->error;
	if (soap_out_string(soap, "releasenotesversion", -1, &(a->ns1__CDefectEvent::releasenotesversion), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedeventtype", -1, &(a->ns1__CDefectEvent::generatedeventtype), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedbyname", -1, &(a->ns1__CDefectEvent::generatedbyname), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "totaltimespent", -1, &(a->ns1__CDefectEvent::totaltimespent), ""))
		return soap->error;
	if (soap_out_string(soap, "overrideuser", -1, &(a->ns1__CDefectEvent::overrideuser), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "marksuspect", -1, &(a->ns1__CDefectEvent::marksuspect), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDefectEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDefectEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDefectEvent * SOAP_FMAC4 soap_in_ns1__CDefectEvent(struct soap *soap, const char *tag, ns1__CDefectEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDefectEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDefectEvent, sizeof(ns1__CDefectEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDefectEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDefectEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_eventaddorder1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_parenteventid1 = 1;
	size_t soap_flag_attachmentlist1 = 1;
	size_t soap_flag_fieldlist1 = 1;
	size_t soap_flag_resultingstate1 = 1;
	size_t soap_flag_hours1 = 1;
	size_t soap_flag_assigntolist1 = 1;
	size_t soap_flag_releasenotesversion1 = 1;
	size_t soap_flag_generatedeventtype1 = 1;
	size_t soap_flag_generatedbyname1 = 1;
	size_t soap_flag_totaltimespent1 = 1;
	size_t soap_flag_overrideuser1 = 1;
	size_t soap_flag_marksuspect1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDefectEvent::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &(a->ns1__CDefectEvent::user), "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "date", &(a->ns1__CDefectEvent::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->ns1__CDefectEvent::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_eventaddorder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "eventaddorder", &(a->ns1__CDefectEvent::eventaddorder), "xsd:short"))
				{	soap_flag_eventaddorder1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDefectEvent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_parenteventid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parenteventid", &(a->ns1__CDefectEvent::parenteventid), "xsd:long"))
				{	soap_flag_parenteventid1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentlist", &(a->ns1__CDefectEvent::attachmentlist), "ns1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_fieldlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "fieldlist", &(a->ns1__CDefectEvent::fieldlist), "ns1:CField"))
				{	soap_flag_fieldlist1--;
					continue;
				}
			if (soap_flag_resultingstate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "resultingstate", &(a->ns1__CDefectEvent::resultingstate), "xsd:string"))
				{	soap_flag_resultingstate1--;
					continue;
				}
			if (soap_flag_hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "hours", &(a->ns1__CDefectEvent::hours), "xsd:double"))
				{	soap_flag_hours1--;
					continue;
				}
			if (soap_flag_assigntolist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "assigntolist", &(a->ns1__CDefectEvent::assigntolist), "xsd:string"))
				{	soap_flag_assigntolist1--;
					continue;
				}
			if (soap_flag_releasenotesversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "releasenotesversion", &(a->ns1__CDefectEvent::releasenotesversion), "xsd:string"))
				{	soap_flag_releasenotesversion1--;
					continue;
				}
			if (soap_flag_generatedeventtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedeventtype", &(a->ns1__CDefectEvent::generatedeventtype), "xsd:string"))
				{	soap_flag_generatedeventtype1--;
					continue;
				}
			if (soap_flag_generatedbyname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedbyname", &(a->ns1__CDefectEvent::generatedbyname), "xsd:string"))
				{	soap_flag_generatedbyname1--;
					continue;
				}
			if (soap_flag_totaltimespent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "totaltimespent", &(a->ns1__CDefectEvent::totaltimespent), "xsd:double"))
				{	soap_flag_totaltimespent1--;
					continue;
				}
			if (soap_flag_overrideuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "overrideuser", &(a->ns1__CDefectEvent::overrideuser), "xsd:string"))
				{	soap_flag_overrideuser1--;
					continue;
				}
			if (soap_flag_marksuspect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "marksuspect", &(a->ns1__CDefectEvent::marksuspect), "xsd:boolean"))
				{	soap_flag_marksuspect1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDefectEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDefectEvent, 0, sizeof(ns1__CDefectEvent), 0, soap_copy_ns1__CDefectEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_date1 > 0 || soap_flag_eventaddorder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDefectEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDefectEvent);
	if (this->soap_out(soap, tag?tag:"ns1:CDefectEvent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDefectEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDefectEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDefectEvent * SOAP_FMAC4 soap_get_ns1__CDefectEvent(struct soap *soap, ns1__CDefectEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDefectEvent * SOAP_FMAC2 soap_instantiate_ns1__CDefectEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDefectEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDefectEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDefectEvent);
		if (size)
			*size = sizeof(ns1__CDefectEvent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDefectEvent, n);
		if (size)
			*size = n * sizeof(ns1__CDefectEvent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDefectEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDefectEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDefectEvent %p -> %p\n", q, p));
	*(ns1__CDefectEvent*)p = *(ns1__CDefectEvent*)q;
}

void ArrayOfCEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCEvent))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CEvent(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCEvent(struct soap *soap, const char *tag, int id, const ArrayOfCEvent *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CEvent", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCEvent);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CEvent(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCEvent(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCEvent * SOAP_FMAC4 soap_in_ArrayOfCEvent(struct soap *soap, const char *tag, ArrayOfCEvent *a, const char *type)
{	int i, j;
	ns1__CEvent **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCEvent, sizeof(ArrayOfCEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CEvent **)soap_malloc(soap, sizeof(ns1__CEvent *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CEvent(soap, NULL, a->__ptritem + i, "ns1:CEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CEvent **)soap_push_block(soap, NULL, sizeof(ns1__CEvent *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CEvent(soap, NULL, p, "ns1:CEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CEvent **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCEvent, 0, sizeof(ArrayOfCEvent), 0, soap_copy_ArrayOfCEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCEvent);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCEvent(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCEvent * SOAP_FMAC4 soap_get_ArrayOfCEvent(struct soap *soap, ArrayOfCEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCEvent * SOAP_FMAC2 soap_instantiate_ArrayOfCEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCEvent);
		if (size)
			*size = sizeof(ArrayOfCEvent);
		((ArrayOfCEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCEvent, n);
		if (size)
			*size = n * sizeof(ArrayOfCEvent);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCEvent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCEvent %p -> %p\n", q, p));
	*(ArrayOfCEvent*)p = *(ArrayOfCEvent*)q;
}

void ns1__CEvent::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CEvent::recordid);
	soap_default_string(soap, &this->ns1__CEvent::user);
	soap_default_time(soap, &this->ns1__CEvent::date);
	soap_default_string(soap, &this->ns1__CEvent::notes);
	soap_default_short(soap, &this->ns1__CEvent::eventaddorder);
	soap_default_string(soap, &this->ns1__CEvent::name);
	this->ns1__CEvent::parenteventid = NULL;
	this->ns1__CEvent::attachmentlist = NULL;
	this->ns1__CEvent::fieldlist = NULL;
	soap_default_string(soap, &this->ns1__CEvent::resultingstate);
	this->ns1__CEvent::hours = NULL;
	this->ns1__CEvent::assigntolist = NULL;
	soap_default_string(soap, &this->ns1__CEvent::releasenotesversion);
	soap_default_string(soap, &this->ns1__CEvent::generatedeventtype);
	soap_default_string(soap, &this->ns1__CEvent::generatedbyname);
	this->ns1__CEvent::totaltimespent = NULL;
	soap_default_string(soap, &this->ns1__CEvent::overrideuser);
	this->ns1__CEvent::marksuspect = NULL;
}

void ns1__CEvent::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CEvent::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CEvent::user);
	soap_embedded(soap, &this->ns1__CEvent::date, SOAP_TYPE_time);
	soap_serialize_string(soap, &this->ns1__CEvent::notes);
	soap_embedded(soap, &this->ns1__CEvent::eventaddorder, SOAP_TYPE_short);
	soap_serialize_string(soap, &this->ns1__CEvent::name);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CEvent::parenteventid);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CEvent::attachmentlist);
	soap_serialize_PointerToArrayOfCField(soap, &this->ns1__CEvent::fieldlist);
	soap_serialize_string(soap, &this->ns1__CEvent::resultingstate);
	soap_serialize_PointerTodouble(soap, &this->ns1__CEvent::hours);
	soap_serialize_PointerToArrayOfstring(soap, &this->ns1__CEvent::assigntolist);
	soap_serialize_string(soap, &this->ns1__CEvent::releasenotesversion);
	soap_serialize_string(soap, &this->ns1__CEvent::generatedeventtype);
	soap_serialize_string(soap, &this->ns1__CEvent::generatedbyname);
	soap_serialize_PointerTodouble(soap, &this->ns1__CEvent::totaltimespent);
	soap_serialize_string(soap, &this->ns1__CEvent::overrideuser);
	soap_serialize_PointerTobool(soap, &this->ns1__CEvent::marksuspect);
#endif
}

int ns1__CEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CEvent(struct soap *soap, const char *tag, int id, const ns1__CEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CEvent), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CEvent::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "user", -1, &(a->ns1__CEvent::user), ""))
		return soap->error;
	if (soap_out_time(soap, "date", -1, &(a->ns1__CEvent::date), ""))
		return soap->error;
	if (soap_out_string(soap, "notes", -1, &(a->ns1__CEvent::notes), ""))
		return soap->error;
	if (soap_out_short(soap, "eventaddorder", -1, &(a->ns1__CEvent::eventaddorder), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns1__CEvent::name), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "parenteventid", -1, &(a->ns1__CEvent::parenteventid), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->ns1__CEvent::attachmentlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "fieldlist", -1, &(a->ns1__CEvent::fieldlist), ""))
		return soap->error;
	if (soap_out_string(soap, "resultingstate", -1, &(a->ns1__CEvent::resultingstate), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "hours", -1, &(a->ns1__CEvent::hours), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfstring(soap, "assigntolist", -1, &(a->ns1__CEvent::assigntolist), ""))
		return soap->error;
	if (soap_out_string(soap, "releasenotesversion", -1, &(a->ns1__CEvent::releasenotesversion), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedeventtype", -1, &(a->ns1__CEvent::generatedeventtype), ""))
		return soap->error;
	if (soap_out_string(soap, "generatedbyname", -1, &(a->ns1__CEvent::generatedbyname), ""))
		return soap->error;
	if (soap_out_PointerTodouble(soap, "totaltimespent", -1, &(a->ns1__CEvent::totaltimespent), ""))
		return soap->error;
	if (soap_out_string(soap, "overrideuser", -1, &(a->ns1__CEvent::overrideuser), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "marksuspect", -1, &(a->ns1__CEvent::marksuspect), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CEvent * SOAP_FMAC4 soap_in_ns1__CEvent(struct soap *soap, const char *tag, ns1__CEvent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CEvent, sizeof(ns1__CEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_user1 = 1;
	size_t soap_flag_date1 = 1;
	size_t soap_flag_notes1 = 1;
	size_t soap_flag_eventaddorder1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_parenteventid1 = 1;
	size_t soap_flag_attachmentlist1 = 1;
	size_t soap_flag_fieldlist1 = 1;
	size_t soap_flag_resultingstate1 = 1;
	size_t soap_flag_hours1 = 1;
	size_t soap_flag_assigntolist1 = 1;
	size_t soap_flag_releasenotesversion1 = 1;
	size_t soap_flag_generatedeventtype1 = 1;
	size_t soap_flag_generatedbyname1 = 1;
	size_t soap_flag_totaltimespent1 = 1;
	size_t soap_flag_overrideuser1 = 1;
	size_t soap_flag_marksuspect1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CEvent::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_user1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "user", &(a->ns1__CEvent::user), "xsd:string"))
				{	soap_flag_user1--;
					continue;
				}
			if (soap_flag_date1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "date", &(a->ns1__CEvent::date), "xsd:dateTime"))
				{	soap_flag_date1--;
					continue;
				}
			if (soap_flag_notes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "notes", &(a->ns1__CEvent::notes), "xsd:string"))
				{	soap_flag_notes1--;
					continue;
				}
			if (soap_flag_eventaddorder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "eventaddorder", &(a->ns1__CEvent::eventaddorder), "xsd:short"))
				{	soap_flag_eventaddorder1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CEvent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_parenteventid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "parenteventid", &(a->ns1__CEvent::parenteventid), "xsd:long"))
				{	soap_flag_parenteventid1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentlist", &(a->ns1__CEvent::attachmentlist), "ns1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_fieldlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "fieldlist", &(a->ns1__CEvent::fieldlist), "ns1:CField"))
				{	soap_flag_fieldlist1--;
					continue;
				}
			if (soap_flag_resultingstate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "resultingstate", &(a->ns1__CEvent::resultingstate), "xsd:string"))
				{	soap_flag_resultingstate1--;
					continue;
				}
			if (soap_flag_hours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "hours", &(a->ns1__CEvent::hours), "xsd:double"))
				{	soap_flag_hours1--;
					continue;
				}
			if (soap_flag_assigntolist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "assigntolist", &(a->ns1__CEvent::assigntolist), "xsd:string"))
				{	soap_flag_assigntolist1--;
					continue;
				}
			if (soap_flag_releasenotesversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "releasenotesversion", &(a->ns1__CEvent::releasenotesversion), "xsd:string"))
				{	soap_flag_releasenotesversion1--;
					continue;
				}
			if (soap_flag_generatedeventtype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedeventtype", &(a->ns1__CEvent::generatedeventtype), "xsd:string"))
				{	soap_flag_generatedeventtype1--;
					continue;
				}
			if (soap_flag_generatedbyname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "generatedbyname", &(a->ns1__CEvent::generatedbyname), "xsd:string"))
				{	soap_flag_generatedbyname1--;
					continue;
				}
			if (soap_flag_totaltimespent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "totaltimespent", &(a->ns1__CEvent::totaltimespent), "xsd:double"))
				{	soap_flag_totaltimespent1--;
					continue;
				}
			if (soap_flag_overrideuser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "overrideuser", &(a->ns1__CEvent::overrideuser), "xsd:string"))
				{	soap_flag_overrideuser1--;
					continue;
				}
			if (soap_flag_marksuspect1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "marksuspect", &(a->ns1__CEvent::marksuspect), "xsd:boolean"))
				{	soap_flag_marksuspect1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CEvent, 0, sizeof(ns1__CEvent), 0, soap_copy_ns1__CEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_date1 > 0 || soap_flag_eventaddorder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CEvent);
	if (this->soap_out(soap, tag?tag:"ns1:CEvent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CEvent * SOAP_FMAC4 soap_get_ns1__CEvent(struct soap *soap, ns1__CEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CEvent * SOAP_FMAC2 soap_instantiate_ns1__CEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CEvent);
		if (size)
			*size = sizeof(ns1__CEvent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CEvent, n);
		if (size)
			*size = n * sizeof(ns1__CEvent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CEvent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CEvent %p -> %p\n", q, p));
	*(ns1__CEvent*)p = *(ns1__CEvent*)q;
}

void ArrayOfCTestCaseVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCTestCaseVariantField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCTestCaseVariantField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTestCaseVariantField(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCTestCaseVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTestCaseVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, int id, const ArrayOfCTestCaseVariantField *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CTestCaseVariantField", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTestCaseVariantField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTestCaseVariantField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCTestCaseVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTestCaseVariantField(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTestCaseVariantField * SOAP_FMAC4 soap_in_ArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, ArrayOfCTestCaseVariantField *a, const char *type)
{	int i, j;
	ns1__CTestCaseVariantField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTestCaseVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTestCaseVariantField, sizeof(ArrayOfCTestCaseVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CTestCaseVariantField **)soap_malloc(soap, sizeof(ns1__CTestCaseVariantField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTestCaseVariantField(soap, NULL, a->__ptritem + i, "ns1:CTestCaseVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTestCaseVariantField **)soap_push_block(soap, NULL, sizeof(ns1__CTestCaseVariantField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTestCaseVariantField(soap, NULL, p, "ns1:CTestCaseVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CTestCaseVariantField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTestCaseVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTestCaseVariantField, 0, sizeof(ArrayOfCTestCaseVariantField), 0, soap_copy_ArrayOfCTestCaseVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCTestCaseVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCTestCaseVariantField);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCTestCaseVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTestCaseVariantField(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTestCaseVariantField * SOAP_FMAC4 soap_get_ArrayOfCTestCaseVariantField(struct soap *soap, ArrayOfCTestCaseVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCTestCaseVariantField * SOAP_FMAC2 soap_instantiate_ArrayOfCTestCaseVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTestCaseVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTestCaseVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCTestCaseVariantField);
		if (size)
			*size = sizeof(ArrayOfCTestCaseVariantField);
		((ArrayOfCTestCaseVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCTestCaseVariantField, n);
		if (size)
			*size = n * sizeof(ArrayOfCTestCaseVariantField);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCTestCaseVariantField*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCTestCaseVariantField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTestCaseVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTestCaseVariantField %p -> %p\n", q, p));
	*(ArrayOfCTestCaseVariantField*)p = *(ArrayOfCTestCaseVariantField*)q;
}

void ArrayOfCTestRunVariantField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCTestRunVariantField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCTestRunVariantField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTestRunVariantField(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCTestRunVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTestRunVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, int id, const ArrayOfCTestRunVariantField *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CTestRunVariantField", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTestRunVariantField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTestRunVariantField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCTestRunVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTestRunVariantField(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTestRunVariantField * SOAP_FMAC4 soap_in_ArrayOfCTestRunVariantField(struct soap *soap, const char *tag, ArrayOfCTestRunVariantField *a, const char *type)
{	int i, j;
	ns1__CTestRunVariantField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTestRunVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTestRunVariantField, sizeof(ArrayOfCTestRunVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CTestRunVariantField **)soap_malloc(soap, sizeof(ns1__CTestRunVariantField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTestRunVariantField(soap, NULL, a->__ptritem + i, "ns1:CTestRunVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTestRunVariantField **)soap_push_block(soap, NULL, sizeof(ns1__CTestRunVariantField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTestRunVariantField(soap, NULL, p, "ns1:CTestRunVariantField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CTestRunVariantField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTestRunVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTestRunVariantField, 0, sizeof(ArrayOfCTestRunVariantField), 0, soap_copy_ArrayOfCTestRunVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCTestRunVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCTestRunVariantField);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCTestRunVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTestRunVariantField(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTestRunVariantField * SOAP_FMAC4 soap_get_ArrayOfCTestRunVariantField(struct soap *soap, ArrayOfCTestRunVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCTestRunVariantField * SOAP_FMAC2 soap_instantiate_ArrayOfCTestRunVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTestRunVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTestRunVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCTestRunVariantField);
		if (size)
			*size = sizeof(ArrayOfCTestRunVariantField);
		((ArrayOfCTestRunVariantField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCTestRunVariantField, n);
		if (size)
			*size = n * sizeof(ArrayOfCTestRunVariantField);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCTestRunVariantField*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCTestRunVariantField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTestRunVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTestRunVariantField %p -> %p\n", q, p));
	*(ArrayOfCTestRunVariantField*)p = *(ArrayOfCTestRunVariantField*)q;
}

void ArrayOfCField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CField(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCField(struct soap *soap, const char *tag, int id, const ArrayOfCField *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CField", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCField(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCField * SOAP_FMAC4 soap_in_ArrayOfCField(struct soap *soap, const char *tag, ArrayOfCField *a, const char *type)
{	int i, j;
	ns1__CField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCField, sizeof(ArrayOfCField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CField **)soap_malloc(soap, sizeof(ns1__CField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CField(soap, NULL, a->__ptritem + i, "ns1:CField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CField **)soap_push_block(soap, NULL, sizeof(ns1__CField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CField(soap, NULL, p, "ns1:CField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCField, 0, sizeof(ArrayOfCField), 0, soap_copy_ArrayOfCField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCField);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCField(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCField * SOAP_FMAC4 soap_get_ArrayOfCField(struct soap *soap, ArrayOfCField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCField * SOAP_FMAC2 soap_instantiate_ArrayOfCField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCField);
		if (size)
			*size = sizeof(ArrayOfCField);
		((ArrayOfCField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCField, n);
		if (size)
			*size = n * sizeof(ArrayOfCField);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCField*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCField %p -> %p\n", q, p));
	*(ArrayOfCField*)p = *(ArrayOfCField*)q;
}

void ns1__CTimespanField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTimespanField::recordid);
	soap_default_string(soap, &this->ns1__CTimespanField::name);
	soap_default_double(soap, &this->ns1__CTimespanField::value);
	soap_default_string(soap, &this->ns1__CTimespanField::unit);
}

void ns1__CTimespanField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTimespanField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CTimespanField::name);
	soap_embedded(soap, &this->ns1__CTimespanField::value, SOAP_TYPE_double);
	soap_serialize_string(soap, &this->ns1__CTimespanField::unit);
#endif
}

int ns1__CTimespanField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTimespanField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTimespanField(struct soap *soap, const char *tag, int id, const ns1__CTimespanField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTimespanField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTimespanField::recordid), ""))
		return soap->error;
	if (a->ns1__CTimespanField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CTimespanField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &(a->ns1__CTimespanField::value), ""))
		return soap->error;
	if (a->ns1__CTimespanField::unit)
	{	if (soap_out_string(soap, "unit", -1, &a->ns1__CTimespanField::unit, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "unit"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTimespanField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTimespanField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTimespanField * SOAP_FMAC4 soap_in_ns1__CTimespanField(struct soap *soap, const char *tag, ns1__CTimespanField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTimespanField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTimespanField, sizeof(ns1__CTimespanField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTimespanField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTimespanField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_unit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTimespanField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CTimespanField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &(a->ns1__CTimespanField::value), "xsd:double"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_unit1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "unit", &(a->ns1__CTimespanField::unit), "xsd:string"))
				{	soap_flag_unit1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTimespanField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTimespanField, 0, sizeof(ns1__CTimespanField), 0, soap_copy_ns1__CTimespanField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0 || soap_flag_value1 > 0 || soap_flag_unit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTimespanField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTimespanField);
	if (this->soap_out(soap, tag?tag:"ns1:CTimespanField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTimespanField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTimespanField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTimespanField * SOAP_FMAC4 soap_get_ns1__CTimespanField(struct soap *soap, ns1__CTimespanField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTimespanField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTimespanField * SOAP_FMAC2 soap_instantiate_ns1__CTimespanField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTimespanField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTimespanField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTimespanField);
		if (size)
			*size = sizeof(ns1__CTimespanField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTimespanField, n);
		if (size)
			*size = n * sizeof(ns1__CTimespanField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTimespanField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTimespanField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTimespanField %p -> %p\n", q, p));
	*(ns1__CTimespanField*)p = *(ns1__CTimespanField*)q;
}

void ns1__CVersionField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CVersionField::recordid);
	soap_default_string(soap, &this->ns1__CVersionField::name);
	soap_default_string(soap, &this->ns1__CVersionField::value);
}

void ns1__CVersionField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CVersionField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CVersionField::name);
	soap_serialize_string(soap, &this->ns1__CVersionField::value);
#endif
}

int ns1__CVersionField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CVersionField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CVersionField(struct soap *soap, const char *tag, int id, const ns1__CVersionField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CVersionField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CVersionField::recordid), ""))
		return soap->error;
	if (a->ns1__CVersionField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CVersionField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->ns1__CVersionField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CVersionField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CVersionField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CVersionField * SOAP_FMAC4 soap_in_ns1__CVersionField(struct soap *soap, const char *tag, ns1__CVersionField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CVersionField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CVersionField, sizeof(ns1__CVersionField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CVersionField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CVersionField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CVersionField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CVersionField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->ns1__CVersionField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CVersionField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CVersionField, 0, sizeof(ns1__CVersionField), 0, soap_copy_ns1__CVersionField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CVersionField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CVersionField);
	if (this->soap_out(soap, tag?tag:"ns1:CVersionField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CVersionField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CVersionField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CVersionField * SOAP_FMAC4 soap_get_ns1__CVersionField(struct soap *soap, ns1__CVersionField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CVersionField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CVersionField * SOAP_FMAC2 soap_instantiate_ns1__CVersionField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CVersionField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CVersionField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CVersionField);
		if (size)
			*size = sizeof(ns1__CVersionField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CVersionField, n);
		if (size)
			*size = n * sizeof(ns1__CVersionField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CVersionField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CVersionField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CVersionField %p -> %p\n", q, p));
	*(ns1__CVersionField*)p = *(ns1__CVersionField*)q;
}

void ns1__CTestCaseVariantField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTestCaseVariantField::recordid);
	soap_default_string(soap, &this->ns1__CTestCaseVariantField::name);
	this->ns1__CTestCaseVariantField::values = NULL;
	this->ns1__CTestCaseVariantField::dropdownValues = NULL;
	soap_default_string(soap, &this->ns1__CTestCaseVariantField::type);
}

void ns1__CTestCaseVariantField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTestCaseVariantField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CTestCaseVariantField::name);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CTestCaseVariantField::values);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CTestCaseVariantField::dropdownValues);
	soap_serialize_string(soap, &this->ns1__CTestCaseVariantField::type);
#endif
}

int ns1__CTestCaseVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTestCaseVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, const ns1__CTestCaseVariantField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTestCaseVariantField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTestCaseVariantField::recordid), ""))
		return soap->error;
	if (a->ns1__CTestCaseVariantField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CTestCaseVariantField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "values", -1, &(a->ns1__CTestCaseVariantField::values), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->ns1__CTestCaseVariantField::dropdownValues), ""))
		return soap->error;
	if (a->ns1__CTestCaseVariantField::type)
	{	if (soap_out_string(soap, "type", -1, &a->ns1__CTestCaseVariantField::type, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "type"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTestCaseVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTestCaseVariantField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTestCaseVariantField * SOAP_FMAC4 soap_in_ns1__CTestCaseVariantField(struct soap *soap, const char *tag, ns1__CTestCaseVariantField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTestCaseVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTestCaseVariantField, sizeof(ns1__CTestCaseVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTestCaseVariantField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTestCaseVariantField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_values1 = 1;
	size_t soap_flag_dropdownValues1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTestCaseVariantField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CTestCaseVariantField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "values", &(a->ns1__CTestCaseVariantField::values), "ns1:CFieldValue"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "dropdownValues", &(a->ns1__CTestCaseVariantField::dropdownValues), "ns1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns1__CTestCaseVariantField::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTestCaseVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTestCaseVariantField, 0, sizeof(ns1__CTestCaseVariantField), 0, soap_copy_ns1__CTestCaseVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTestCaseVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTestCaseVariantField);
	if (this->soap_out(soap, tag?tag:"ns1:CTestCaseVariantField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTestCaseVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTestCaseVariantField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTestCaseVariantField * SOAP_FMAC4 soap_get_ns1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTestCaseVariantField * SOAP_FMAC2 soap_instantiate_ns1__CTestCaseVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTestCaseVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTestCaseVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTestCaseVariantField);
		if (size)
			*size = sizeof(ns1__CTestCaseVariantField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTestCaseVariantField, n);
		if (size)
			*size = n * sizeof(ns1__CTestCaseVariantField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTestCaseVariantField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTestCaseVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTestCaseVariantField %p -> %p\n", q, p));
	*(ns1__CTestCaseVariantField*)p = *(ns1__CTestCaseVariantField*)q;
}

void ns1__CTestRunVariantField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CTestRunVariantField::recordid);
	soap_default_string(soap, &this->ns1__CTestRunVariantField::name);
	this->ns1__CTestRunVariantField::values = NULL;
	this->ns1__CTestRunVariantField::dropdownValues = NULL;
}

void ns1__CTestRunVariantField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CTestRunVariantField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CTestRunVariantField::name);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CTestRunVariantField::values);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CTestRunVariantField::dropdownValues);
#endif
}

int ns1__CTestRunVariantField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTestRunVariantField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTestRunVariantField(struct soap *soap, const char *tag, int id, const ns1__CTestRunVariantField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTestRunVariantField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CTestRunVariantField::recordid), ""))
		return soap->error;
	if (a->ns1__CTestRunVariantField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CTestRunVariantField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "values", -1, &(a->ns1__CTestRunVariantField::values), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->ns1__CTestRunVariantField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CTestRunVariantField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTestRunVariantField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTestRunVariantField * SOAP_FMAC4 soap_in_ns1__CTestRunVariantField(struct soap *soap, const char *tag, ns1__CTestRunVariantField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTestRunVariantField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTestRunVariantField, sizeof(ns1__CTestRunVariantField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTestRunVariantField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTestRunVariantField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_values1 = 1;
	size_t soap_flag_dropdownValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CTestRunVariantField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CTestRunVariantField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "values", &(a->ns1__CTestRunVariantField::values), "ns1:CFieldValue"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "dropdownValues", &(a->ns1__CTestRunVariantField::dropdownValues), "ns1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTestRunVariantField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTestRunVariantField, 0, sizeof(ns1__CTestRunVariantField), 0, soap_copy_ns1__CTestRunVariantField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTestRunVariantField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTestRunVariantField);
	if (this->soap_out(soap, tag?tag:"ns1:CTestRunVariantField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTestRunVariantField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTestRunVariantField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTestRunVariantField * SOAP_FMAC4 soap_get_ns1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTestRunVariantField * SOAP_FMAC2 soap_instantiate_ns1__CTestRunVariantField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTestRunVariantField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTestRunVariantField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTestRunVariantField);
		if (size)
			*size = sizeof(ns1__CTestRunVariantField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTestRunVariantField, n);
		if (size)
			*size = n * sizeof(ns1__CTestRunVariantField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTestRunVariantField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTestRunVariantField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTestRunVariantField %p -> %p\n", q, p));
	*(ns1__CTestRunVariantField*)p = *(ns1__CTestRunVariantField*)q;
}

void ns1__CMultiSelectDropdownField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CMultiSelectDropdownField::recordid);
	soap_default_string(soap, &this->ns1__CMultiSelectDropdownField::name);
	this->ns1__CMultiSelectDropdownField::values = NULL;
	this->ns1__CMultiSelectDropdownField::dropdownValues = NULL;
}

void ns1__CMultiSelectDropdownField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CMultiSelectDropdownField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CMultiSelectDropdownField::name);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CMultiSelectDropdownField::values);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CMultiSelectDropdownField::dropdownValues);
#endif
}

int ns1__CMultiSelectDropdownField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CMultiSelectDropdownField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CMultiSelectDropdownField(struct soap *soap, const char *tag, int id, const ns1__CMultiSelectDropdownField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CMultiSelectDropdownField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CMultiSelectDropdownField::recordid), ""))
		return soap->error;
	if (a->ns1__CMultiSelectDropdownField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CMultiSelectDropdownField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "values", -1, &(a->ns1__CMultiSelectDropdownField::values), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->ns1__CMultiSelectDropdownField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CMultiSelectDropdownField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CMultiSelectDropdownField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CMultiSelectDropdownField * SOAP_FMAC4 soap_in_ns1__CMultiSelectDropdownField(struct soap *soap, const char *tag, ns1__CMultiSelectDropdownField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CMultiSelectDropdownField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CMultiSelectDropdownField, sizeof(ns1__CMultiSelectDropdownField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CMultiSelectDropdownField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CMultiSelectDropdownField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_values1 = 1;
	size_t soap_flag_dropdownValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CMultiSelectDropdownField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CMultiSelectDropdownField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_values1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "values", &(a->ns1__CMultiSelectDropdownField::values), "ns1:CFieldValue"))
				{	soap_flag_values1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "dropdownValues", &(a->ns1__CMultiSelectDropdownField::dropdownValues), "ns1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CMultiSelectDropdownField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CMultiSelectDropdownField, 0, sizeof(ns1__CMultiSelectDropdownField), 0, soap_copy_ns1__CMultiSelectDropdownField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CMultiSelectDropdownField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CMultiSelectDropdownField);
	if (this->soap_out(soap, tag?tag:"ns1:CMultiSelectDropdownField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CMultiSelectDropdownField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CMultiSelectDropdownField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CMultiSelectDropdownField * SOAP_FMAC4 soap_get_ns1__CMultiSelectDropdownField(struct soap *soap, ns1__CMultiSelectDropdownField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CMultiSelectDropdownField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CMultiSelectDropdownField * SOAP_FMAC2 soap_instantiate_ns1__CMultiSelectDropdownField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CMultiSelectDropdownField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CMultiSelectDropdownField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CMultiSelectDropdownField);
		if (size)
			*size = sizeof(ns1__CMultiSelectDropdownField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CMultiSelectDropdownField, n);
		if (size)
			*size = n * sizeof(ns1__CMultiSelectDropdownField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CMultiSelectDropdownField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CMultiSelectDropdownField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CMultiSelectDropdownField %p -> %p\n", q, p));
	*(ns1__CMultiSelectDropdownField*)p = *(ns1__CMultiSelectDropdownField*)q;
}

void ns1__CDropdownField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDropdownField::recordid);
	soap_default_string(soap, &this->ns1__CDropdownField::name);
	soap_default_string(soap, &this->ns1__CDropdownField::value);
	this->ns1__CDropdownField::dropdownValues = NULL;
}

void ns1__CDropdownField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDropdownField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CDropdownField::name);
	soap_serialize_string(soap, &this->ns1__CDropdownField::value);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &this->ns1__CDropdownField::dropdownValues);
#endif
}

int ns1__CDropdownField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDropdownField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDropdownField(struct soap *soap, const char *tag, int id, const ns1__CDropdownField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDropdownField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDropdownField::recordid), ""))
		return soap->error;
	if (a->ns1__CDropdownField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDropdownField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->ns1__CDropdownField::value), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "dropdownValues", -1, &(a->ns1__CDropdownField::dropdownValues), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDropdownField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDropdownField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDropdownField * SOAP_FMAC4 soap_in_ns1__CDropdownField(struct soap *soap, const char *tag, ns1__CDropdownField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDropdownField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDropdownField, sizeof(ns1__CDropdownField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDropdownField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDropdownField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_dropdownValues1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDropdownField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDropdownField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->ns1__CDropdownField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_dropdownValues1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "dropdownValues", &(a->ns1__CDropdownField::dropdownValues), "ns1:CFieldValue"))
				{	soap_flag_dropdownValues1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDropdownField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDropdownField, 0, sizeof(ns1__CDropdownField), 0, soap_copy_ns1__CDropdownField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDropdownField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDropdownField);
	if (this->soap_out(soap, tag?tag:"ns1:CDropdownField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDropdownField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDropdownField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDropdownField * SOAP_FMAC4 soap_get_ns1__CDropdownField(struct soap *soap, ns1__CDropdownField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDropdownField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDropdownField * SOAP_FMAC2 soap_instantiate_ns1__CDropdownField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDropdownField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDropdownField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDropdownField);
		if (size)
			*size = sizeof(ns1__CDropdownField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDropdownField, n);
		if (size)
			*size = n * sizeof(ns1__CDropdownField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDropdownField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDropdownField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDropdownField %p -> %p\n", q, p));
	*(ns1__CDropdownField*)p = *(ns1__CDropdownField*)q;
}

void ns1__CDateTimeField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDateTimeField::recordid);
	soap_default_string(soap, &this->ns1__CDateTimeField::name);
	this->ns1__CDateTimeField::value = NULL;
}

void ns1__CDateTimeField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDateTimeField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CDateTimeField::name);
	soap_serialize_PointerTotime(soap, &this->ns1__CDateTimeField::value);
#endif
}

int ns1__CDateTimeField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDateTimeField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDateTimeField(struct soap *soap, const char *tag, int id, const ns1__CDateTimeField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDateTimeField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDateTimeField::recordid), ""))
		return soap->error;
	if (a->ns1__CDateTimeField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDateTimeField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_PointerTotime(soap, "value", -1, &(a->ns1__CDateTimeField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDateTimeField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDateTimeField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDateTimeField * SOAP_FMAC4 soap_in_ns1__CDateTimeField(struct soap *soap, const char *tag, ns1__CDateTimeField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDateTimeField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDateTimeField, sizeof(ns1__CDateTimeField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDateTimeField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDateTimeField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDateTimeField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDateTimeField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "value", &(a->ns1__CDateTimeField::value), "xsd:dateTime"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDateTimeField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDateTimeField, 0, sizeof(ns1__CDateTimeField), 0, soap_copy_ns1__CDateTimeField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDateTimeField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDateTimeField);
	if (this->soap_out(soap, tag?tag:"ns1:CDateTimeField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDateTimeField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDateTimeField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDateTimeField * SOAP_FMAC4 soap_get_ns1__CDateTimeField(struct soap *soap, ns1__CDateTimeField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDateTimeField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDateTimeField * SOAP_FMAC2 soap_instantiate_ns1__CDateTimeField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDateTimeField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDateTimeField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDateTimeField);
		if (size)
			*size = sizeof(ns1__CDateTimeField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDateTimeField, n);
		if (size)
			*size = n * sizeof(ns1__CDateTimeField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDateTimeField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDateTimeField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDateTimeField %p -> %p\n", q, p));
	*(ns1__CDateTimeField*)p = *(ns1__CDateTimeField*)q;
}

void ns1__CDateField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDateField::recordid);
	soap_default_string(soap, &this->ns1__CDateField::name);
	soap_default_xsd__date(soap, &this->ns1__CDateField::value);
}

void ns1__CDateField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDateField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CDateField::name);
	soap_serialize_xsd__date(soap, &this->ns1__CDateField::value);
#endif
}

int ns1__CDateField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDateField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDateField(struct soap *soap, const char *tag, int id, const ns1__CDateField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDateField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDateField::recordid), ""))
		return soap->error;
	if (a->ns1__CDateField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDateField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_xsd__date(soap, "value", -1, &(a->ns1__CDateField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDateField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDateField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDateField * SOAP_FMAC4 soap_in_ns1__CDateField(struct soap *soap, const char *tag, ns1__CDateField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDateField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDateField, sizeof(ns1__CDateField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDateField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDateField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDateField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDateField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "value", &(a->ns1__CDateField::value), "xsd:date"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDateField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDateField, 0, sizeof(ns1__CDateField), 0, soap_copy_ns1__CDateField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDateField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDateField);
	if (this->soap_out(soap, tag?tag:"ns1:CDateField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDateField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDateField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDateField * SOAP_FMAC4 soap_get_ns1__CDateField(struct soap *soap, ns1__CDateField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDateField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDateField * SOAP_FMAC2 soap_instantiate_ns1__CDateField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDateField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDateField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDateField);
		if (size)
			*size = sizeof(ns1__CDateField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDateField, n);
		if (size)
			*size = n * sizeof(ns1__CDateField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDateField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDateField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDateField %p -> %p\n", q, p));
	*(ns1__CDateField*)p = *(ns1__CDateField*)q;
}

void ns1__CBooleanField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CBooleanField::recordid);
	soap_default_string(soap, &this->ns1__CBooleanField::name);
	soap_default_bool(soap, &this->ns1__CBooleanField::value);
}

void ns1__CBooleanField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CBooleanField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CBooleanField::name);
	soap_embedded(soap, &this->ns1__CBooleanField::value, SOAP_TYPE_bool);
#endif
}

int ns1__CBooleanField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CBooleanField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CBooleanField(struct soap *soap, const char *tag, int id, const ns1__CBooleanField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CBooleanField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CBooleanField::recordid), ""))
		return soap->error;
	if (a->ns1__CBooleanField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CBooleanField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_bool(soap, "value", -1, &(a->ns1__CBooleanField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CBooleanField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CBooleanField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CBooleanField * SOAP_FMAC4 soap_in_ns1__CBooleanField(struct soap *soap, const char *tag, ns1__CBooleanField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CBooleanField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CBooleanField, sizeof(ns1__CBooleanField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CBooleanField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CBooleanField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CBooleanField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CBooleanField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "value", &(a->ns1__CBooleanField::value), "xsd:boolean"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CBooleanField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CBooleanField, 0, sizeof(ns1__CBooleanField), 0, soap_copy_ns1__CBooleanField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CBooleanField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CBooleanField);
	if (this->soap_out(soap, tag?tag:"ns1:CBooleanField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CBooleanField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CBooleanField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CBooleanField * SOAP_FMAC4 soap_get_ns1__CBooleanField(struct soap *soap, ns1__CBooleanField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CBooleanField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CBooleanField * SOAP_FMAC2 soap_instantiate_ns1__CBooleanField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CBooleanField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CBooleanField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CBooleanField);
		if (size)
			*size = sizeof(ns1__CBooleanField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CBooleanField, n);
		if (size)
			*size = n * sizeof(ns1__CBooleanField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CBooleanField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CBooleanField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CBooleanField %p -> %p\n", q, p));
	*(ns1__CBooleanField*)p = *(ns1__CBooleanField*)q;
}

void ns1__CDecimalField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CDecimalField::recordid);
	soap_default_string(soap, &this->ns1__CDecimalField::name);
	soap_default_double(soap, &this->ns1__CDecimalField::value);
}

void ns1__CDecimalField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CDecimalField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CDecimalField::name);
	soap_embedded(soap, &this->ns1__CDecimalField::value, SOAP_TYPE_double);
#endif
}

int ns1__CDecimalField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDecimalField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDecimalField(struct soap *soap, const char *tag, int id, const ns1__CDecimalField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDecimalField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CDecimalField::recordid), ""))
		return soap->error;
	if (a->ns1__CDecimalField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDecimalField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_double(soap, "value", -1, &(a->ns1__CDecimalField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CDecimalField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDecimalField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDecimalField * SOAP_FMAC4 soap_in_ns1__CDecimalField(struct soap *soap, const char *tag, ns1__CDecimalField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDecimalField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDecimalField, sizeof(ns1__CDecimalField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDecimalField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDecimalField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CDecimalField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDecimalField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "value", &(a->ns1__CDecimalField::value), "xsd:double"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDecimalField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDecimalField, 0, sizeof(ns1__CDecimalField), 0, soap_copy_ns1__CDecimalField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDecimalField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDecimalField);
	if (this->soap_out(soap, tag?tag:"ns1:CDecimalField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDecimalField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDecimalField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDecimalField * SOAP_FMAC4 soap_get_ns1__CDecimalField(struct soap *soap, ns1__CDecimalField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDecimalField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDecimalField * SOAP_FMAC2 soap_instantiate_ns1__CDecimalField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDecimalField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDecimalField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDecimalField);
		if (size)
			*size = sizeof(ns1__CDecimalField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDecimalField, n);
		if (size)
			*size = n * sizeof(ns1__CDecimalField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDecimalField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDecimalField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDecimalField %p -> %p\n", q, p));
	*(ns1__CDecimalField*)p = *(ns1__CDecimalField*)q;
}

void ns1__CIntegerField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CIntegerField::recordid);
	soap_default_string(soap, &this->ns1__CIntegerField::name);
	soap_default_int(soap, &this->ns1__CIntegerField::value);
}

void ns1__CIntegerField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CIntegerField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CIntegerField::name);
	soap_embedded(soap, &this->ns1__CIntegerField::value, SOAP_TYPE_int);
#endif
}

int ns1__CIntegerField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CIntegerField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CIntegerField(struct soap *soap, const char *tag, int id, const ns1__CIntegerField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CIntegerField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CIntegerField::recordid), ""))
		return soap->error;
	if (a->ns1__CIntegerField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CIntegerField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &(a->ns1__CIntegerField::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CIntegerField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CIntegerField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CIntegerField * SOAP_FMAC4 soap_in_ns1__CIntegerField(struct soap *soap, const char *tag, ns1__CIntegerField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CIntegerField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CIntegerField, sizeof(ns1__CIntegerField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CIntegerField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CIntegerField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CIntegerField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CIntegerField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &(a->ns1__CIntegerField::value), "xsd:int"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CIntegerField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CIntegerField, 0, sizeof(ns1__CIntegerField), 0, soap_copy_ns1__CIntegerField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CIntegerField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CIntegerField);
	if (this->soap_out(soap, tag?tag:"ns1:CIntegerField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CIntegerField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CIntegerField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CIntegerField * SOAP_FMAC4 soap_get_ns1__CIntegerField(struct soap *soap, ns1__CIntegerField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CIntegerField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CIntegerField * SOAP_FMAC2 soap_instantiate_ns1__CIntegerField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CIntegerField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CIntegerField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CIntegerField);
		if (size)
			*size = sizeof(ns1__CIntegerField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CIntegerField, n);
		if (size)
			*size = n * sizeof(ns1__CIntegerField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CIntegerField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CIntegerField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CIntegerField %p -> %p\n", q, p));
	*(ns1__CIntegerField*)p = *(ns1__CIntegerField*)q;
}

void ns1__CStringField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CStringField::recordid);
	soap_default_string(soap, &this->ns1__CStringField::name);
	soap_default_string(soap, &this->ns1__CStringField::value);
	this->ns1__CStringField::isMultilineString = NULL;
	this->ns1__CStringField::containsFormatting = NULL;
	this->ns1__CStringField::inlineAttachmentList = NULL;
}

void ns1__CStringField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CStringField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CStringField::name);
	soap_serialize_string(soap, &this->ns1__CStringField::value);
	soap_serialize_PointerTobool(soap, &this->ns1__CStringField::isMultilineString);
	soap_serialize_PointerTobool(soap, &this->ns1__CStringField::containsFormatting);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CStringField::inlineAttachmentList);
#endif
}

int ns1__CStringField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CStringField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CStringField(struct soap *soap, const char *tag, int id, const ns1__CStringField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CStringField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CStringField::recordid), ""))
		return soap->error;
	if (a->ns1__CStringField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CStringField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &(a->ns1__CStringField::value), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "isMultilineString", -1, &(a->ns1__CStringField::isMultilineString), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "containsFormatting", -1, &(a->ns1__CStringField::containsFormatting), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "inlineAttachmentList", -1, &(a->ns1__CStringField::inlineAttachmentList), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CStringField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CStringField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CStringField * SOAP_FMAC4 soap_in_ns1__CStringField(struct soap *soap, const char *tag, ns1__CStringField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CStringField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CStringField, sizeof(ns1__CStringField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CStringField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CStringField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_isMultilineString1 = 1;
	size_t soap_flag_containsFormatting1 = 1;
	size_t soap_flag_inlineAttachmentList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CStringField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CStringField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->ns1__CStringField::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_isMultilineString1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "isMultilineString", &(a->ns1__CStringField::isMultilineString), "xsd:boolean"))
				{	soap_flag_isMultilineString1--;
					continue;
				}
			if (soap_flag_containsFormatting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "containsFormatting", &(a->ns1__CStringField::containsFormatting), "xsd:boolean"))
				{	soap_flag_containsFormatting1--;
					continue;
				}
			if (soap_flag_inlineAttachmentList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "inlineAttachmentList", &(a->ns1__CStringField::inlineAttachmentList), "ns1:CFileAttachment"))
				{	soap_flag_inlineAttachmentList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CStringField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CStringField, 0, sizeof(ns1__CStringField), 0, soap_copy_ns1__CStringField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CStringField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CStringField);
	if (this->soap_out(soap, tag?tag:"ns1:CStringField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CStringField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CStringField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CStringField * SOAP_FMAC4 soap_get_ns1__CStringField(struct soap *soap, ns1__CStringField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CStringField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CStringField * SOAP_FMAC2 soap_instantiate_ns1__CStringField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CStringField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CStringField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CStringField);
		if (size)
			*size = sizeof(ns1__CStringField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CStringField, n);
		if (size)
			*size = n * sizeof(ns1__CStringField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CStringField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CStringField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CStringField %p -> %p\n", q, p));
	*(ns1__CStringField*)p = *(ns1__CStringField*)q;
}

void ns1__CField::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CField::recordid);
	soap_default_string(soap, &this->ns1__CField::name);
}

void ns1__CField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CField::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CField::name);
#endif
}

int ns1__CField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CField(struct soap *soap, const char *tag, int id, const ns1__CField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CField), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CField::recordid), ""))
		return soap->error;
	if (a->ns1__CField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CField * SOAP_FMAC4 soap_in_ns1__CField(struct soap *soap, const char *tag, ns1__CField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CField, sizeof(ns1__CField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CField::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CField, 0, sizeof(ns1__CField), 0, soap_copy_ns1__CField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CField);
	if (this->soap_out(soap, tag?tag:"ns1:CField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CField * SOAP_FMAC4 soap_get_ns1__CField(struct soap *soap, ns1__CField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CField * SOAP_FMAC2 soap_instantiate_ns1__CField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CField);
		if (size)
			*size = sizeof(ns1__CField);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CField, n);
		if (size)
			*size = n * sizeof(ns1__CField);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CField %p -> %p\n", q, p));
	*(ns1__CField*)p = *(ns1__CField*)q;
}

void ArrayOfCReportedByRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCReportedByRecord::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCReportedByRecord))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CReportedByRecord(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCReportedByRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCReportedByRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCReportedByRecord(struct soap *soap, const char *tag, int id, const ArrayOfCReportedByRecord *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CReportedByRecord", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCReportedByRecord);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CReportedByRecord(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCReportedByRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCReportedByRecord(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCReportedByRecord * SOAP_FMAC4 soap_in_ArrayOfCReportedByRecord(struct soap *soap, const char *tag, ArrayOfCReportedByRecord *a, const char *type)
{	int i, j;
	ns1__CReportedByRecord **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCReportedByRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCReportedByRecord, sizeof(ArrayOfCReportedByRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CReportedByRecord **)soap_malloc(soap, sizeof(ns1__CReportedByRecord *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CReportedByRecord(soap, NULL, a->__ptritem + i, "ns1:CReportedByRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CReportedByRecord **)soap_push_block(soap, NULL, sizeof(ns1__CReportedByRecord *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CReportedByRecord(soap, NULL, p, "ns1:CReportedByRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CReportedByRecord **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCReportedByRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCReportedByRecord, 0, sizeof(ArrayOfCReportedByRecord), 0, soap_copy_ArrayOfCReportedByRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCReportedByRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCReportedByRecord);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCReportedByRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCReportedByRecord(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCReportedByRecord * SOAP_FMAC4 soap_get_ArrayOfCReportedByRecord(struct soap *soap, ArrayOfCReportedByRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCReportedByRecord * SOAP_FMAC2 soap_instantiate_ArrayOfCReportedByRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCReportedByRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCReportedByRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCReportedByRecord);
		if (size)
			*size = sizeof(ArrayOfCReportedByRecord);
		((ArrayOfCReportedByRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCReportedByRecord, n);
		if (size)
			*size = n * sizeof(ArrayOfCReportedByRecord);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCReportedByRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCReportedByRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCReportedByRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCReportedByRecord %p -> %p\n", q, p));
	*(ArrayOfCReportedByRecord*)p = *(ArrayOfCReportedByRecord*)q;
}

void ns1__CReportedByRecord::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CReportedByRecord::recordid);
	soap_default_string(soap, &this->ns1__CReportedByRecord::foundby);
	soap_default_xsd__date(soap, &this->ns1__CReportedByRecord::datefound);
	soap_default_string(soap, &this->ns1__CReportedByRecord::contactinfo);
	soap_default_string(soap, &this->ns1__CReportedByRecord::foundinversion);
	soap_default_string(soap, &this->ns1__CReportedByRecord::comments);
	this->ns1__CReportedByRecord::commentsInlineAttachList = NULL;
	soap_default_string(soap, &this->ns1__CReportedByRecord::reproduced);
	soap_default_string(soap, &this->ns1__CReportedByRecord::reproducedsteps);
	this->ns1__CReportedByRecord::reproStepsInlineAttachList = NULL;
	this->ns1__CReportedByRecord::standardtestconfig = NULL;
	soap_default_string(soap, &this->ns1__CReportedByRecord::otherhardwaresoftware);
	this->ns1__CReportedByRecord::otherHWSWInlineAttachList = NULL;
	this->ns1__CReportedByRecord::testconfigtype = NULL;
	this->ns1__CReportedByRecord::attachmentlist = NULL;
	soap_default_short(soap, &this->ns1__CReportedByRecord::showorder);
}

void ns1__CReportedByRecord::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CReportedByRecord::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::foundby);
	soap_serialize_xsd__date(soap, &this->ns1__CReportedByRecord::datefound);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::contactinfo);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::foundinversion);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::comments);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CReportedByRecord::commentsInlineAttachList);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::reproduced);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::reproducedsteps);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CReportedByRecord::reproStepsInlineAttachList);
	soap_serialize_PointerTons1__CSystem(soap, &this->ns1__CReportedByRecord::standardtestconfig);
	soap_serialize_string(soap, &this->ns1__CReportedByRecord::otherhardwaresoftware);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CReportedByRecord::otherHWSWInlineAttachList);
	soap_serialize_PointerToshort(soap, &this->ns1__CReportedByRecord::testconfigtype);
	soap_serialize_PointerToArrayOfCFileAttachment(soap, &this->ns1__CReportedByRecord::attachmentlist);
	soap_embedded(soap, &this->ns1__CReportedByRecord::showorder, SOAP_TYPE_short);
#endif
}

int ns1__CReportedByRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CReportedByRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CReportedByRecord(struct soap *soap, const char *tag, int id, const ns1__CReportedByRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CReportedByRecord), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CReportedByRecord::recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "foundby", -1, &(a->ns1__CReportedByRecord::foundby), ""))
		return soap->error;
	if (soap_out_xsd__date(soap, "datefound", -1, &(a->ns1__CReportedByRecord::datefound), ""))
		return soap->error;
	if (soap_out_string(soap, "contactinfo", -1, &(a->ns1__CReportedByRecord::contactinfo), ""))
		return soap->error;
	if (soap_out_string(soap, "foundinversion", -1, &(a->ns1__CReportedByRecord::foundinversion), ""))
		return soap->error;
	if (soap_out_string(soap, "comments", -1, &(a->ns1__CReportedByRecord::comments), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "commentsInlineAttachList", -1, &(a->ns1__CReportedByRecord::commentsInlineAttachList), ""))
		return soap->error;
	if (soap_out_string(soap, "reproduced", -1, &(a->ns1__CReportedByRecord::reproduced), ""))
		return soap->error;
	if (soap_out_string(soap, "reproducedsteps", -1, &(a->ns1__CReportedByRecord::reproducedsteps), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "reproStepsInlineAttachList", -1, &(a->ns1__CReportedByRecord::reproStepsInlineAttachList), ""))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "standardtestconfig", -1, &(a->ns1__CReportedByRecord::standardtestconfig), ""))
		return soap->error;
	if (soap_out_string(soap, "otherhardwaresoftware", -1, &(a->ns1__CReportedByRecord::otherhardwaresoftware), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "otherHWSWInlineAttachList", -1, &(a->ns1__CReportedByRecord::otherHWSWInlineAttachList), ""))
		return soap->error;
	if (soap_out_PointerToshort(soap, "testconfigtype", -1, &(a->ns1__CReportedByRecord::testconfigtype), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFileAttachment(soap, "attachmentlist", -1, &(a->ns1__CReportedByRecord::attachmentlist), ""))
		return soap->error;
	if (soap_out_short(soap, "showorder", -1, &(a->ns1__CReportedByRecord::showorder), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CReportedByRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CReportedByRecord(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CReportedByRecord * SOAP_FMAC4 soap_in_ns1__CReportedByRecord(struct soap *soap, const char *tag, ns1__CReportedByRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CReportedByRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CReportedByRecord, sizeof(ns1__CReportedByRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CReportedByRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CReportedByRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_foundby1 = 1;
	size_t soap_flag_datefound1 = 1;
	size_t soap_flag_contactinfo1 = 1;
	size_t soap_flag_foundinversion1 = 1;
	size_t soap_flag_comments1 = 1;
	size_t soap_flag_commentsInlineAttachList1 = 1;
	size_t soap_flag_reproduced1 = 1;
	size_t soap_flag_reproducedsteps1 = 1;
	size_t soap_flag_reproStepsInlineAttachList1 = 1;
	size_t soap_flag_standardtestconfig1 = 1;
	size_t soap_flag_otherhardwaresoftware1 = 1;
	size_t soap_flag_otherHWSWInlineAttachList1 = 1;
	size_t soap_flag_testconfigtype1 = 1;
	size_t soap_flag_attachmentlist1 = 1;
	size_t soap_flag_showorder1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CReportedByRecord::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_foundby1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "foundby", &(a->ns1__CReportedByRecord::foundby), "xsd:string"))
				{	soap_flag_foundby1--;
					continue;
				}
			if (soap_flag_datefound1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__date(soap, "datefound", &(a->ns1__CReportedByRecord::datefound), "xsd:date"))
				{	soap_flag_datefound1--;
					continue;
				}
			if (soap_flag_contactinfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "contactinfo", &(a->ns1__CReportedByRecord::contactinfo), "xsd:string"))
				{	soap_flag_contactinfo1--;
					continue;
				}
			if (soap_flag_foundinversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "foundinversion", &(a->ns1__CReportedByRecord::foundinversion), "xsd:string"))
				{	soap_flag_foundinversion1--;
					continue;
				}
			if (soap_flag_comments1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "comments", &(a->ns1__CReportedByRecord::comments), "xsd:string"))
				{	soap_flag_comments1--;
					continue;
				}
			if (soap_flag_commentsInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "commentsInlineAttachList", &(a->ns1__CReportedByRecord::commentsInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_commentsInlineAttachList1--;
					continue;
				}
			if (soap_flag_reproduced1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reproduced", &(a->ns1__CReportedByRecord::reproduced), "xsd:string"))
				{	soap_flag_reproduced1--;
					continue;
				}
			if (soap_flag_reproducedsteps1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "reproducedsteps", &(a->ns1__CReportedByRecord::reproducedsteps), "xsd:string"))
				{	soap_flag_reproducedsteps1--;
					continue;
				}
			if (soap_flag_reproStepsInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "reproStepsInlineAttachList", &(a->ns1__CReportedByRecord::reproStepsInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_reproStepsInlineAttachList1--;
					continue;
				}
			if (soap_flag_standardtestconfig1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "standardtestconfig", &(a->ns1__CReportedByRecord::standardtestconfig), "ns1:CSystem"))
				{	soap_flag_standardtestconfig1--;
					continue;
				}
			if (soap_flag_otherhardwaresoftware1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "otherhardwaresoftware", &(a->ns1__CReportedByRecord::otherhardwaresoftware), "xsd:string"))
				{	soap_flag_otherhardwaresoftware1--;
					continue;
				}
			if (soap_flag_otherHWSWInlineAttachList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "otherHWSWInlineAttachList", &(a->ns1__CReportedByRecord::otherHWSWInlineAttachList), "ns1:CFileAttachment"))
				{	soap_flag_otherHWSWInlineAttachList1--;
					continue;
				}
			if (soap_flag_testconfigtype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "testconfigtype", &(a->ns1__CReportedByRecord::testconfigtype), "xsd:short"))
				{	soap_flag_testconfigtype1--;
					continue;
				}
			if (soap_flag_attachmentlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFileAttachment(soap, "attachmentlist", &(a->ns1__CReportedByRecord::attachmentlist), "ns1:CFileAttachment"))
				{	soap_flag_attachmentlist1--;
					continue;
				}
			if (soap_flag_showorder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "showorder", &(a->ns1__CReportedByRecord::showorder), "xsd:short"))
				{	soap_flag_showorder1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CReportedByRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CReportedByRecord, 0, sizeof(ns1__CReportedByRecord), 0, soap_copy_ns1__CReportedByRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_showorder1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CReportedByRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CReportedByRecord);
	if (this->soap_out(soap, tag?tag:"ns1:CReportedByRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CReportedByRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CReportedByRecord(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CReportedByRecord * SOAP_FMAC4 soap_get_ns1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CReportedByRecord * SOAP_FMAC2 soap_instantiate_ns1__CReportedByRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CReportedByRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CReportedByRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CReportedByRecord);
		if (size)
			*size = sizeof(ns1__CReportedByRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CReportedByRecord, n);
		if (size)
			*size = n * sizeof(ns1__CReportedByRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CReportedByRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CReportedByRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CReportedByRecord %p -> %p\n", q, p));
	*(ns1__CReportedByRecord*)p = *(ns1__CReportedByRecord*)q;
}

void ArrayOfCFileAttachment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFileAttachment::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFileAttachment))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFileAttachment(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFileAttachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFileAttachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFileAttachment(struct soap *soap, const char *tag, int id, const ArrayOfCFileAttachment *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFileAttachment", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFileAttachment);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFileAttachment(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFileAttachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFileAttachment(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFileAttachment * SOAP_FMAC4 soap_in_ArrayOfCFileAttachment(struct soap *soap, const char *tag, ArrayOfCFileAttachment *a, const char *type)
{	int i, j;
	ns1__CFileAttachment **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFileAttachment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFileAttachment, sizeof(ArrayOfCFileAttachment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFileAttachment **)soap_malloc(soap, sizeof(ns1__CFileAttachment *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFileAttachment(soap, NULL, a->__ptritem + i, "ns1:CFileAttachment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFileAttachment **)soap_push_block(soap, NULL, sizeof(ns1__CFileAttachment *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFileAttachment(soap, NULL, p, "ns1:CFileAttachment"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFileAttachment **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFileAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFileAttachment, 0, sizeof(ArrayOfCFileAttachment), 0, soap_copy_ArrayOfCFileAttachment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFileAttachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFileAttachment);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFileAttachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFileAttachment(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFileAttachment * SOAP_FMAC4 soap_get_ArrayOfCFileAttachment(struct soap *soap, ArrayOfCFileAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFileAttachment * SOAP_FMAC2 soap_instantiate_ArrayOfCFileAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFileAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFileAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFileAttachment);
		if (size)
			*size = sizeof(ArrayOfCFileAttachment);
		((ArrayOfCFileAttachment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFileAttachment, n);
		if (size)
			*size = n * sizeof(ArrayOfCFileAttachment);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFileAttachment*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFileAttachment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFileAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFileAttachment %p -> %p\n", q, p));
	*(ArrayOfCFileAttachment*)p = *(ArrayOfCFileAttachment*)q;
}

void ns1__CFileAttachment::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->ns1__CFileAttachment::m_pFileData = NULL;
	soap_default_string(soap, &this->ns1__CFileAttachment::m_strFileName);
	soap_default_LONG64(soap, &this->ns1__CFileAttachment::m_recordid);
	soap_default_string(soap, &this->ns1__CFileAttachment::m_strArchiveName);
	soap_default_string(soap, &this->ns1__CFileAttachment::m_strType);
	this->ns1__CFileAttachment::m_scriptOrder = NULL;
	soap_default_string(soap, &this->ns1__CFileAttachment::m_strScriptState);
}

void ns1__CFileAttachment::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__CFileAttachment::m_pFileData);
	soap_serialize_string(soap, &this->ns1__CFileAttachment::m_strFileName);
	soap_embedded(soap, &this->ns1__CFileAttachment::m_recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CFileAttachment::m_strArchiveName);
	soap_serialize_string(soap, &this->ns1__CFileAttachment::m_strType);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CFileAttachment::m_scriptOrder);
	soap_serialize_string(soap, &this->ns1__CFileAttachment::m_strScriptState);
#endif
}

int ns1__CFileAttachment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFileAttachment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFileAttachment(struct soap *soap, const char *tag, int id, const ns1__CFileAttachment *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFileAttachment), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "m-pFileData", -1, &(a->ns1__CFileAttachment::m_pFileData), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strFileName", -1, &(a->ns1__CFileAttachment::m_strFileName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "m-recordid", -1, &(a->ns1__CFileAttachment::m_recordid), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strArchiveName", -1, &(a->ns1__CFileAttachment::m_strArchiveName), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strType", -1, &(a->ns1__CFileAttachment::m_strType), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "m-scriptOrder", -1, &(a->ns1__CFileAttachment::m_scriptOrder), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strScriptState", -1, &(a->ns1__CFileAttachment::m_strScriptState), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CFileAttachment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFileAttachment(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFileAttachment * SOAP_FMAC4 soap_in_ns1__CFileAttachment(struct soap *soap, const char *tag, ns1__CFileAttachment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFileAttachment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFileAttachment, sizeof(ns1__CFileAttachment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFileAttachment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFileAttachment *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_m_pFileData1 = 1;
	size_t soap_flag_m_strFileName1 = 1;
	size_t soap_flag_m_recordid1 = 1;
	size_t soap_flag_m_strArchiveName1 = 1;
	size_t soap_flag_m_strType1 = 1;
	size_t soap_flag_m_scriptOrder1 = 1;
	size_t soap_flag_m_strScriptState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_pFileData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "m-pFileData", &(a->ns1__CFileAttachment::m_pFileData), "xsd:base64Binary"))
				{	soap_flag_m_pFileData1--;
					continue;
				}
			if (soap_flag_m_strFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFileName", &(a->ns1__CFileAttachment::m_strFileName), "xsd:string"))
				{	soap_flag_m_strFileName1--;
					continue;
				}
			if (soap_flag_m_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "m-recordid", &(a->ns1__CFileAttachment::m_recordid), "xsd:long"))
				{	soap_flag_m_recordid1--;
					continue;
				}
			if (soap_flag_m_strArchiveName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strArchiveName", &(a->ns1__CFileAttachment::m_strArchiveName), "xsd:string"))
				{	soap_flag_m_strArchiveName1--;
					continue;
				}
			if (soap_flag_m_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strType", &(a->ns1__CFileAttachment::m_strType), "xsd:string"))
				{	soap_flag_m_strType1--;
					continue;
				}
			if (soap_flag_m_scriptOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "m-scriptOrder", &(a->ns1__CFileAttachment::m_scriptOrder), "xsd:long"))
				{	soap_flag_m_scriptOrder1--;
					continue;
				}
			if (soap_flag_m_strScriptState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strScriptState", &(a->ns1__CFileAttachment::m_strScriptState), "xsd:string"))
				{	soap_flag_m_strScriptState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFileAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFileAttachment, 0, sizeof(ns1__CFileAttachment), 0, soap_copy_ns1__CFileAttachment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_m_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFileAttachment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFileAttachment);
	if (this->soap_out(soap, tag?tag:"ns1:CFileAttachment", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFileAttachment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFileAttachment(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFileAttachment * SOAP_FMAC4 soap_get_ns1__CFileAttachment(struct soap *soap, ns1__CFileAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFileAttachment * SOAP_FMAC2 soap_instantiate_ns1__CFileAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFileAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFileAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFileAttachment);
		if (size)
			*size = sizeof(ns1__CFileAttachment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFileAttachment, n);
		if (size)
			*size = n * sizeof(ns1__CFileAttachment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFileAttachment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFileAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFileAttachment %p -> %p\n", q, p));
	*(ns1__CFileAttachment*)p = *(ns1__CFileAttachment*)q;
}

void ns1__CReportRunResults::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CReportRunResults::m_FileList = NULL;
	/* transient soap skipped */
}

void ns1__CReportRunResults::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFile(soap, &this->ns1__CReportRunResults::m_FileList);
	/* transient soap skipped */
#endif
}

int ns1__CReportRunResults::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CReportRunResults(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CReportRunResults(struct soap *soap, const char *tag, int id, const ns1__CReportRunResults *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CReportRunResults), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFile(soap, "m-FileList", -1, &(a->ns1__CReportRunResults::m_FileList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CReportRunResults::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CReportRunResults(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CReportRunResults * SOAP_FMAC4 soap_in_ns1__CReportRunResults(struct soap *soap, const char *tag, ns1__CReportRunResults *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CReportRunResults *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CReportRunResults, sizeof(ns1__CReportRunResults), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CReportRunResults)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CReportRunResults *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_m_FileList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_FileList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFile(soap, "m-FileList", &(a->ns1__CReportRunResults::m_FileList), "ns1:CFile"))
				{	soap_flag_m_FileList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CReportRunResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CReportRunResults, 0, sizeof(ns1__CReportRunResults), 0, soap_copy_ns1__CReportRunResults);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CReportRunResults::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CReportRunResults);
	if (this->soap_out(soap, tag?tag:"ns1:CReportRunResults", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CReportRunResults::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CReportRunResults(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CReportRunResults * SOAP_FMAC4 soap_get_ns1__CReportRunResults(struct soap *soap, ns1__CReportRunResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CReportRunResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CReportRunResults * SOAP_FMAC2 soap_instantiate_ns1__CReportRunResults(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CReportRunResults(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CReportRunResults, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CReportRunResults);
		if (size)
			*size = sizeof(ns1__CReportRunResults);
		((ns1__CReportRunResults*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CReportRunResults, n);
		if (size)
			*size = n * sizeof(ns1__CReportRunResults);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CReportRunResults*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CReportRunResults*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CReportRunResults(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CReportRunResults %p -> %p\n", q, p));
	*(ns1__CReportRunResults*)p = *(ns1__CReportRunResults*)q;
}

void ArrayOfCFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFile::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFile))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFile(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFile(struct soap *soap, const char *tag, int id, const ArrayOfCFile *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFile", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFile);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFile(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFile(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFile * SOAP_FMAC4 soap_in_ArrayOfCFile(struct soap *soap, const char *tag, ArrayOfCFile *a, const char *type)
{	int i, j;
	ns1__CFile **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFile, sizeof(ArrayOfCFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFile **)soap_malloc(soap, sizeof(ns1__CFile *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFile(soap, NULL, a->__ptritem + i, "ns1:CFile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFile **)soap_push_block(soap, NULL, sizeof(ns1__CFile *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFile(soap, NULL, p, "ns1:CFile"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFile **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFile, 0, sizeof(ArrayOfCFile), 0, soap_copy_ArrayOfCFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFile);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFile(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFile * SOAP_FMAC4 soap_get_ArrayOfCFile(struct soap *soap, ArrayOfCFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFile * SOAP_FMAC2 soap_instantiate_ArrayOfCFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFile);
		if (size)
			*size = sizeof(ArrayOfCFile);
		((ArrayOfCFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFile, n);
		if (size)
			*size = n * sizeof(ArrayOfCFile);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFile*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFile %p -> %p\n", q, p));
	*(ArrayOfCFile*)p = *(ArrayOfCFile*)q;
}

void ns1__CFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CFile::m_pFileData = NULL;
	soap_default_string(soap, &this->ns1__CFile::m_strFileName);
	/* transient soap skipped */
}

void ns1__CFile::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &this->ns1__CFile::m_pFileData);
	soap_serialize_string(soap, &this->ns1__CFile::m_strFileName);
	/* transient soap skipped */
#endif
}

int ns1__CFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFile(struct soap *soap, const char *tag, int id, const ns1__CFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFile), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "m-pFileData", -1, &(a->ns1__CFile::m_pFileData), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strFileName", -1, &(a->ns1__CFile::m_strFileName), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CFile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFile(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFile * SOAP_FMAC4 soap_in_ns1__CFile(struct soap *soap, const char *tag, ns1__CFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFile, sizeof(ns1__CFile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFile *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_m_pFileData1 = 1;
	size_t soap_flag_m_strFileName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_m_pFileData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "m-pFileData", &(a->ns1__CFile::m_pFileData), "xsd:base64Binary"))
				{	soap_flag_m_pFileData1--;
					continue;
				}
			if (soap_flag_m_strFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFileName", &(a->ns1__CFile::m_strFileName), "xsd:string"))
				{	soap_flag_m_strFileName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFile, 0, sizeof(ns1__CFile), 0, soap_copy_ns1__CFile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFile);
	if (this->soap_out(soap, tag?tag:"ns1:CFile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFile(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFile * SOAP_FMAC4 soap_get_ns1__CFile(struct soap *soap, ns1__CFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFile * SOAP_FMAC2 soap_instantiate_ns1__CFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFile);
		if (size)
			*size = sizeof(ns1__CFile);
		((ns1__CFile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFile, n);
		if (size)
			*size = n * sizeof(ns1__CFile);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CFile*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFile %p -> %p\n", q, p));
	*(ns1__CFile*)p = *(ns1__CFile*)q;
}

void ArrayOfCSCCFileRecord::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCSCCFileRecord::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCSCCFileRecord))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CSCCFileRecord(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCSCCFileRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCSCCFileRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, int id, const ArrayOfCSCCFileRecord *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CSCCFileRecord", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCSCCFileRecord);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CSCCFileRecord(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCSCCFileRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCSCCFileRecord(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCSCCFileRecord * SOAP_FMAC4 soap_in_ArrayOfCSCCFileRecord(struct soap *soap, const char *tag, ArrayOfCSCCFileRecord *a, const char *type)
{	int i, j;
	ns1__CSCCFileRecord **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCSCCFileRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCSCCFileRecord, sizeof(ArrayOfCSCCFileRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CSCCFileRecord **)soap_malloc(soap, sizeof(ns1__CSCCFileRecord *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CSCCFileRecord(soap, NULL, a->__ptritem + i, "ns1:CSCCFileRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CSCCFileRecord **)soap_push_block(soap, NULL, sizeof(ns1__CSCCFileRecord *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CSCCFileRecord(soap, NULL, p, "ns1:CSCCFileRecord"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CSCCFileRecord **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCSCCFileRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCSCCFileRecord, 0, sizeof(ArrayOfCSCCFileRecord), 0, soap_copy_ArrayOfCSCCFileRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCSCCFileRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCSCCFileRecord);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCSCCFileRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCSCCFileRecord(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCSCCFileRecord * SOAP_FMAC4 soap_get_ArrayOfCSCCFileRecord(struct soap *soap, ArrayOfCSCCFileRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCSCCFileRecord * SOAP_FMAC2 soap_instantiate_ArrayOfCSCCFileRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCSCCFileRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCSCCFileRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCSCCFileRecord);
		if (size)
			*size = sizeof(ArrayOfCSCCFileRecord);
		((ArrayOfCSCCFileRecord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCSCCFileRecord, n);
		if (size)
			*size = n * sizeof(ArrayOfCSCCFileRecord);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCSCCFileRecord*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCSCCFileRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCSCCFileRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCSCCFileRecord %p -> %p\n", q, p));
	*(ArrayOfCSCCFileRecord*)p = *(ArrayOfCSCCFileRecord*)q;
}

void ns1__CSCCFileRecord::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CSCCFileRecord::recordid);
	soap_default_string(soap, &this->ns1__CSCCFileRecord::m_strFileName);
	soap_default_string(soap, &this->ns1__CSCCFileRecord::m_strFixedRevision);
	this->ns1__CSCCFileRecord::m_dateFixedTimestamp = NULL;
	soap_default_string(soap, &this->ns1__CSCCFileRecord::m_strType);
	this->ns1__CSCCFileRecord::m_scriptOrder = NULL;
	soap_default_string(soap, &this->ns1__CSCCFileRecord::m_strScriptState);
}

void ns1__CSCCFileRecord::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CSCCFileRecord::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CSCCFileRecord::m_strFileName);
	soap_serialize_string(soap, &this->ns1__CSCCFileRecord::m_strFixedRevision);
	soap_serialize_PointerTotime(soap, &this->ns1__CSCCFileRecord::m_dateFixedTimestamp);
	soap_serialize_string(soap, &this->ns1__CSCCFileRecord::m_strType);
	soap_serialize_PointerToLONG64(soap, &this->ns1__CSCCFileRecord::m_scriptOrder);
	soap_serialize_string(soap, &this->ns1__CSCCFileRecord::m_strScriptState);
#endif
}

int ns1__CSCCFileRecord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CSCCFileRecord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CSCCFileRecord(struct soap *soap, const char *tag, int id, const ns1__CSCCFileRecord *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CSCCFileRecord), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CSCCFileRecord::recordid), ""))
		return soap->error;
	if (a->ns1__CSCCFileRecord::m_strFileName)
	{	if (soap_out_string(soap, "m-strFileName", -1, &a->ns1__CSCCFileRecord::m_strFileName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "m-strFileName"))
		return soap->error;
	if (soap_out_string(soap, "m-strFixedRevision", -1, &(a->ns1__CSCCFileRecord::m_strFixedRevision), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "m-dateFixedTimestamp", -1, &(a->ns1__CSCCFileRecord::m_dateFixedTimestamp), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strType", -1, &(a->ns1__CSCCFileRecord::m_strType), ""))
		return soap->error;
	if (soap_out_PointerToLONG64(soap, "m-scriptOrder", -1, &(a->ns1__CSCCFileRecord::m_scriptOrder), ""))
		return soap->error;
	if (soap_out_string(soap, "m-strScriptState", -1, &(a->ns1__CSCCFileRecord::m_strScriptState), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CSCCFileRecord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CSCCFileRecord(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CSCCFileRecord * SOAP_FMAC4 soap_in_ns1__CSCCFileRecord(struct soap *soap, const char *tag, ns1__CSCCFileRecord *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CSCCFileRecord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CSCCFileRecord, sizeof(ns1__CSCCFileRecord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CSCCFileRecord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CSCCFileRecord *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_m_strFileName1 = 1;
	size_t soap_flag_m_strFixedRevision1 = 1;
	size_t soap_flag_m_dateFixedTimestamp1 = 1;
	size_t soap_flag_m_strType1 = 1;
	size_t soap_flag_m_scriptOrder1 = 1;
	size_t soap_flag_m_strScriptState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CSCCFileRecord::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_m_strFileName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFileName", &(a->ns1__CSCCFileRecord::m_strFileName), "xsd:string"))
				{	soap_flag_m_strFileName1--;
					continue;
				}
			if (soap_flag_m_strFixedRevision1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strFixedRevision", &(a->ns1__CSCCFileRecord::m_strFixedRevision), "xsd:string"))
				{	soap_flag_m_strFixedRevision1--;
					continue;
				}
			if (soap_flag_m_dateFixedTimestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "m-dateFixedTimestamp", &(a->ns1__CSCCFileRecord::m_dateFixedTimestamp), "xsd:dateTime"))
				{	soap_flag_m_dateFixedTimestamp1--;
					continue;
				}
			if (soap_flag_m_strType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strType", &(a->ns1__CSCCFileRecord::m_strType), "xsd:string"))
				{	soap_flag_m_strType1--;
					continue;
				}
			if (soap_flag_m_scriptOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToLONG64(soap, "m-scriptOrder", &(a->ns1__CSCCFileRecord::m_scriptOrder), "xsd:long"))
				{	soap_flag_m_scriptOrder1--;
					continue;
				}
			if (soap_flag_m_strScriptState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "m-strScriptState", &(a->ns1__CSCCFileRecord::m_strScriptState), "xsd:string"))
				{	soap_flag_m_strScriptState1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CSCCFileRecord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CSCCFileRecord, 0, sizeof(ns1__CSCCFileRecord), 0, soap_copy_ns1__CSCCFileRecord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_m_strFileName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CSCCFileRecord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CSCCFileRecord);
	if (this->soap_out(soap, tag?tag:"ns1:CSCCFileRecord", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CSCCFileRecord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CSCCFileRecord(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CSCCFileRecord * SOAP_FMAC4 soap_get_ns1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CSCCFileRecord * SOAP_FMAC2 soap_instantiate_ns1__CSCCFileRecord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CSCCFileRecord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CSCCFileRecord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CSCCFileRecord);
		if (size)
			*size = sizeof(ns1__CSCCFileRecord);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CSCCFileRecord, n);
		if (size)
			*size = n * sizeof(ns1__CSCCFileRecord);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CSCCFileRecord*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CSCCFileRecord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CSCCFileRecord %p -> %p\n", q, p));
	*(ns1__CSCCFileRecord*)p = *(ns1__CSCCFileRecord*)q;
}

void ns1__CSystem::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CSystem::recordid);
	soap_default_string(soap, &this->ns1__CSystem::systemname);
	soap_default_string(soap, &this->ns1__CSystem::computermodel);
	soap_default_string(soap, &this->ns1__CSystem::computerbrand);
	soap_default_string(soap, &this->ns1__CSystem::cputype);
	soap_default_string(soap, &this->ns1__CSystem::cpuspeed);
	soap_default_string(soap, &this->ns1__CSystem::harddisktype);
	soap_default_string(soap, &this->ns1__CSystem::harddisksize);
	soap_default_string(soap, &this->ns1__CSystem::ramsize);
	soap_default_string(soap, &this->ns1__CSystem::romsize);
	soap_default_string(soap, &this->ns1__CSystem::osname);
	soap_default_string(soap, &this->ns1__CSystem::osversion);
	soap_default_string(soap, &this->ns1__CSystem::videoname);
	this->ns1__CSystem::hascdrom = NULL;
	soap_default_string(soap, &this->ns1__CSystem::cdrommodel);
	this->ns1__CSystem::hasscanner = NULL;
	soap_default_string(soap, &this->ns1__CSystem::scannermodel);
	this->ns1__CSystem::hasmodem = NULL;
	soap_default_string(soap, &this->ns1__CSystem::modemmodel);
	this->ns1__CSystem::hasprinter = NULL;
	soap_default_string(soap, &this->ns1__CSystem::printermodel);
	soap_default_string(soap, &this->ns1__CSystem::otherhardware);
	this->ns1__CSystem::hasmultiplemonitors = NULL;
}

void ns1__CSystem::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CSystem::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CSystem::systemname);
	soap_serialize_string(soap, &this->ns1__CSystem::computermodel);
	soap_serialize_string(soap, &this->ns1__CSystem::computerbrand);
	soap_serialize_string(soap, &this->ns1__CSystem::cputype);
	soap_serialize_string(soap, &this->ns1__CSystem::cpuspeed);
	soap_serialize_string(soap, &this->ns1__CSystem::harddisktype);
	soap_serialize_string(soap, &this->ns1__CSystem::harddisksize);
	soap_serialize_string(soap, &this->ns1__CSystem::ramsize);
	soap_serialize_string(soap, &this->ns1__CSystem::romsize);
	soap_serialize_string(soap, &this->ns1__CSystem::osname);
	soap_serialize_string(soap, &this->ns1__CSystem::osversion);
	soap_serialize_string(soap, &this->ns1__CSystem::videoname);
	soap_serialize_PointerTobool(soap, &this->ns1__CSystem::hascdrom);
	soap_serialize_string(soap, &this->ns1__CSystem::cdrommodel);
	soap_serialize_PointerTobool(soap, &this->ns1__CSystem::hasscanner);
	soap_serialize_string(soap, &this->ns1__CSystem::scannermodel);
	soap_serialize_PointerTobool(soap, &this->ns1__CSystem::hasmodem);
	soap_serialize_string(soap, &this->ns1__CSystem::modemmodel);
	soap_serialize_PointerTobool(soap, &this->ns1__CSystem::hasprinter);
	soap_serialize_string(soap, &this->ns1__CSystem::printermodel);
	soap_serialize_string(soap, &this->ns1__CSystem::otherhardware);
	soap_serialize_PointerTobool(soap, &this->ns1__CSystem::hasmultiplemonitors);
#endif
}

int ns1__CSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CSystem(struct soap *soap, const char *tag, int id, const ns1__CSystem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CSystem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CSystem::recordid), ""))
		return soap->error;
	if (a->ns1__CSystem::systemname)
	{	if (soap_out_string(soap, "systemname", -1, &a->ns1__CSystem::systemname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "systemname"))
		return soap->error;
	if (soap_out_string(soap, "computermodel", -1, &(a->ns1__CSystem::computermodel), ""))
		return soap->error;
	if (soap_out_string(soap, "computerbrand", -1, &(a->ns1__CSystem::computerbrand), ""))
		return soap->error;
	if (soap_out_string(soap, "cputype", -1, &(a->ns1__CSystem::cputype), ""))
		return soap->error;
	if (soap_out_string(soap, "cpuspeed", -1, &(a->ns1__CSystem::cpuspeed), ""))
		return soap->error;
	if (soap_out_string(soap, "harddisktype", -1, &(a->ns1__CSystem::harddisktype), ""))
		return soap->error;
	if (soap_out_string(soap, "harddisksize", -1, &(a->ns1__CSystem::harddisksize), ""))
		return soap->error;
	if (soap_out_string(soap, "ramsize", -1, &(a->ns1__CSystem::ramsize), ""))
		return soap->error;
	if (soap_out_string(soap, "romsize", -1, &(a->ns1__CSystem::romsize), ""))
		return soap->error;
	if (soap_out_string(soap, "osname", -1, &(a->ns1__CSystem::osname), ""))
		return soap->error;
	if (soap_out_string(soap, "osversion", -1, &(a->ns1__CSystem::osversion), ""))
		return soap->error;
	if (soap_out_string(soap, "videoname", -1, &(a->ns1__CSystem::videoname), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hascdrom", -1, &(a->ns1__CSystem::hascdrom), ""))
		return soap->error;
	if (soap_out_string(soap, "cdrommodel", -1, &(a->ns1__CSystem::cdrommodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasscanner", -1, &(a->ns1__CSystem::hasscanner), ""))
		return soap->error;
	if (soap_out_string(soap, "scannermodel", -1, &(a->ns1__CSystem::scannermodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasmodem", -1, &(a->ns1__CSystem::hasmodem), ""))
		return soap->error;
	if (soap_out_string(soap, "modemmodel", -1, &(a->ns1__CSystem::modemmodel), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasprinter", -1, &(a->ns1__CSystem::hasprinter), ""))
		return soap->error;
	if (soap_out_string(soap, "printermodel", -1, &(a->ns1__CSystem::printermodel), ""))
		return soap->error;
	if (soap_out_string(soap, "otherhardware", -1, &(a->ns1__CSystem::otherhardware), ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "hasmultiplemonitors", -1, &(a->ns1__CSystem::hasmultiplemonitors), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CSystem(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CSystem * SOAP_FMAC4 soap_in_ns1__CSystem(struct soap *soap, const char *tag, ns1__CSystem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CSystem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CSystem, sizeof(ns1__CSystem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CSystem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CSystem *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_systemname1 = 1;
	size_t soap_flag_computermodel1 = 1;
	size_t soap_flag_computerbrand1 = 1;
	size_t soap_flag_cputype1 = 1;
	size_t soap_flag_cpuspeed1 = 1;
	size_t soap_flag_harddisktype1 = 1;
	size_t soap_flag_harddisksize1 = 1;
	size_t soap_flag_ramsize1 = 1;
	size_t soap_flag_romsize1 = 1;
	size_t soap_flag_osname1 = 1;
	size_t soap_flag_osversion1 = 1;
	size_t soap_flag_videoname1 = 1;
	size_t soap_flag_hascdrom1 = 1;
	size_t soap_flag_cdrommodel1 = 1;
	size_t soap_flag_hasscanner1 = 1;
	size_t soap_flag_scannermodel1 = 1;
	size_t soap_flag_hasmodem1 = 1;
	size_t soap_flag_modemmodel1 = 1;
	size_t soap_flag_hasprinter1 = 1;
	size_t soap_flag_printermodel1 = 1;
	size_t soap_flag_otherhardware1 = 1;
	size_t soap_flag_hasmultiplemonitors1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CSystem::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_systemname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "systemname", &(a->ns1__CSystem::systemname), "xsd:string"))
				{	soap_flag_systemname1--;
					continue;
				}
			if (soap_flag_computermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "computermodel", &(a->ns1__CSystem::computermodel), "xsd:string"))
				{	soap_flag_computermodel1--;
					continue;
				}
			if (soap_flag_computerbrand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "computerbrand", &(a->ns1__CSystem::computerbrand), "xsd:string"))
				{	soap_flag_computerbrand1--;
					continue;
				}
			if (soap_flag_cputype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cputype", &(a->ns1__CSystem::cputype), "xsd:string"))
				{	soap_flag_cputype1--;
					continue;
				}
			if (soap_flag_cpuspeed1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cpuspeed", &(a->ns1__CSystem::cpuspeed), "xsd:string"))
				{	soap_flag_cpuspeed1--;
					continue;
				}
			if (soap_flag_harddisktype1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "harddisktype", &(a->ns1__CSystem::harddisktype), "xsd:string"))
				{	soap_flag_harddisktype1--;
					continue;
				}
			if (soap_flag_harddisksize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "harddisksize", &(a->ns1__CSystem::harddisksize), "xsd:string"))
				{	soap_flag_harddisksize1--;
					continue;
				}
			if (soap_flag_ramsize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ramsize", &(a->ns1__CSystem::ramsize), "xsd:string"))
				{	soap_flag_ramsize1--;
					continue;
				}
			if (soap_flag_romsize1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "romsize", &(a->ns1__CSystem::romsize), "xsd:string"))
				{	soap_flag_romsize1--;
					continue;
				}
			if (soap_flag_osname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "osname", &(a->ns1__CSystem::osname), "xsd:string"))
				{	soap_flag_osname1--;
					continue;
				}
			if (soap_flag_osversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "osversion", &(a->ns1__CSystem::osversion), "xsd:string"))
				{	soap_flag_osversion1--;
					continue;
				}
			if (soap_flag_videoname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "videoname", &(a->ns1__CSystem::videoname), "xsd:string"))
				{	soap_flag_videoname1--;
					continue;
				}
			if (soap_flag_hascdrom1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hascdrom", &(a->ns1__CSystem::hascdrom), "xsd:boolean"))
				{	soap_flag_hascdrom1--;
					continue;
				}
			if (soap_flag_cdrommodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cdrommodel", &(a->ns1__CSystem::cdrommodel), "xsd:string"))
				{	soap_flag_cdrommodel1--;
					continue;
				}
			if (soap_flag_hasscanner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasscanner", &(a->ns1__CSystem::hasscanner), "xsd:boolean"))
				{	soap_flag_hasscanner1--;
					continue;
				}
			if (soap_flag_scannermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "scannermodel", &(a->ns1__CSystem::scannermodel), "xsd:string"))
				{	soap_flag_scannermodel1--;
					continue;
				}
			if (soap_flag_hasmodem1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasmodem", &(a->ns1__CSystem::hasmodem), "xsd:boolean"))
				{	soap_flag_hasmodem1--;
					continue;
				}
			if (soap_flag_modemmodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "modemmodel", &(a->ns1__CSystem::modemmodel), "xsd:string"))
				{	soap_flag_modemmodel1--;
					continue;
				}
			if (soap_flag_hasprinter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasprinter", &(a->ns1__CSystem::hasprinter), "xsd:boolean"))
				{	soap_flag_hasprinter1--;
					continue;
				}
			if (soap_flag_printermodel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "printermodel", &(a->ns1__CSystem::printermodel), "xsd:string"))
				{	soap_flag_printermodel1--;
					continue;
				}
			if (soap_flag_otherhardware1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "otherhardware", &(a->ns1__CSystem::otherhardware), "xsd:string"))
				{	soap_flag_otherhardware1--;
					continue;
				}
			if (soap_flag_hasmultiplemonitors1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobool(soap, "hasmultiplemonitors", &(a->ns1__CSystem::hasmultiplemonitors), "xsd:boolean"))
				{	soap_flag_hasmultiplemonitors1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CSystem, 0, sizeof(ns1__CSystem), 0, soap_copy_ns1__CSystem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_systemname1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CSystem);
	if (this->soap_out(soap, tag?tag:"ns1:CSystem", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CSystem(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CSystem * SOAP_FMAC4 soap_get_ns1__CSystem(struct soap *soap, ns1__CSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CSystem * SOAP_FMAC2 soap_instantiate_ns1__CSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CSystem);
		if (size)
			*size = sizeof(ns1__CSystem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CSystem, n);
		if (size)
			*size = n * sizeof(ns1__CSystem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CSystem %p -> %p\n", q, p));
	*(ns1__CSystem*)p = *(ns1__CSystem*)q;
}

void ns1__CSystemBase::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CSystemBase::recordid);
	soap_default_string(soap, &this->ns1__CSystemBase::systemname);
}

void ns1__CSystemBase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CSystemBase::recordid, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &this->ns1__CSystemBase::systemname);
#endif
}

int ns1__CSystemBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CSystemBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CSystemBase(struct soap *soap, const char *tag, int id, const ns1__CSystemBase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CSystemBase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CSystemBase::recordid), ""))
		return soap->error;
	if (a->ns1__CSystemBase::systemname)
	{	if (soap_out_string(soap, "systemname", -1, &a->ns1__CSystemBase::systemname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "systemname"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CSystemBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CSystemBase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CSystemBase * SOAP_FMAC4 soap_in_ns1__CSystemBase(struct soap *soap, const char *tag, ns1__CSystemBase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CSystemBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CSystemBase, sizeof(ns1__CSystemBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CSystemBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CSystemBase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_systemname1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CSystemBase::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_systemname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "systemname", &(a->ns1__CSystemBase::systemname), "xsd:string"))
				{	soap_flag_systemname1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CSystemBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CSystemBase, 0, sizeof(ns1__CSystemBase), 0, soap_copy_ns1__CSystemBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_systemname1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CSystemBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CSystemBase);
	if (this->soap_out(soap, tag?tag:"ns1:CSystemBase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CSystemBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CSystemBase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CSystemBase * SOAP_FMAC4 soap_get_ns1__CSystemBase(struct soap *soap, ns1__CSystemBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CSystemBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CSystemBase * SOAP_FMAC2 soap_instantiate_ns1__CSystemBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CSystemBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CSystemBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CSystemBase);
		if (size)
			*size = sizeof(ns1__CSystemBase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CSystemBase, n);
		if (size)
			*size = n * sizeof(ns1__CSystemBase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CSystemBase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CSystemBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CSystemBase %p -> %p\n", q, p));
	*(ns1__CSystemBase*)p = *(ns1__CSystemBase*)q;
}

void ns1__COrderedItemWithDBRecordId::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__COrderedItemWithDBRecordId::recordid);
	soap_default_LONG64(soap, &this->ns1__COrderedItemWithDBRecordId::order);
}

void ns1__COrderedItemWithDBRecordId::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__COrderedItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	soap_embedded(soap, &this->ns1__COrderedItemWithDBRecordId::order, SOAP_TYPE_LONG64);
#endif
}

int ns1__COrderedItemWithDBRecordId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__COrderedItemWithDBRecordId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__COrderedItemWithDBRecordId(struct soap *soap, const char *tag, int id, const ns1__COrderedItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__COrderedItemWithDBRecordId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__COrderedItemWithDBRecordId::recordid), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "order", -1, &(a->ns1__COrderedItemWithDBRecordId::order), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__COrderedItemWithDBRecordId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__COrderedItemWithDBRecordId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__COrderedItemWithDBRecordId * SOAP_FMAC4 soap_in_ns1__COrderedItemWithDBRecordId(struct soap *soap, const char *tag, ns1__COrderedItemWithDBRecordId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__COrderedItemWithDBRecordId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__COrderedItemWithDBRecordId, sizeof(ns1__COrderedItemWithDBRecordId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__COrderedItemWithDBRecordId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__COrderedItemWithDBRecordId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	size_t soap_flag_order1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__COrderedItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap_flag_order1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "order", &(a->ns1__COrderedItemWithDBRecordId::order), "xsd:long"))
				{	soap_flag_order1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__COrderedItemWithDBRecordId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__COrderedItemWithDBRecordId, 0, sizeof(ns1__COrderedItemWithDBRecordId), 0, soap_copy_ns1__COrderedItemWithDBRecordId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0 || soap_flag_order1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__COrderedItemWithDBRecordId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__COrderedItemWithDBRecordId);
	if (this->soap_out(soap, tag?tag:"ns1:COrderedItemWithDBRecordId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__COrderedItemWithDBRecordId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__COrderedItemWithDBRecordId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__COrderedItemWithDBRecordId * SOAP_FMAC4 soap_get_ns1__COrderedItemWithDBRecordId(struct soap *soap, ns1__COrderedItemWithDBRecordId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__COrderedItemWithDBRecordId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__COrderedItemWithDBRecordId * SOAP_FMAC2 soap_instantiate_ns1__COrderedItemWithDBRecordId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__COrderedItemWithDBRecordId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__COrderedItemWithDBRecordId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__COrderedItemWithDBRecordId);
		if (size)
			*size = sizeof(ns1__COrderedItemWithDBRecordId);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__COrderedItemWithDBRecordId, n);
		if (size)
			*size = n * sizeof(ns1__COrderedItemWithDBRecordId);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__COrderedItemWithDBRecordId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__COrderedItemWithDBRecordId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__COrderedItemWithDBRecordId %p -> %p\n", q, p));
	*(ns1__COrderedItemWithDBRecordId*)p = *(ns1__COrderedItemWithDBRecordId*)q;
}

void ns1__CItemToTrack::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &this->ns1__CItemToTrack::recordid);
}

void ns1__CItemToTrack::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CItemToTrack::recordid, SOAP_TYPE_LONG64);
#endif
}

int ns1__CItemToTrack::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CItemToTrack(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CItemToTrack(struct soap *soap, const char *tag, int id, const ns1__CItemToTrack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CItemToTrack), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CItemToTrack::recordid), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__CItemToTrack::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CItemToTrack(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CItemToTrack * SOAP_FMAC4 soap_in_ns1__CItemToTrack(struct soap *soap, const char *tag, ns1__CItemToTrack *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CItemToTrack *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CItemToTrack, sizeof(ns1__CItemToTrack), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CItemToTrack)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CItemToTrack *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CItemToTrack::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CItemToTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CItemToTrack, 0, sizeof(ns1__CItemToTrack), 0, soap_copy_ns1__CItemToTrack);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CItemToTrack::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CItemToTrack);
	if (this->soap_out(soap, tag?tag:"ns1:CItemToTrack", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CItemToTrack::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CItemToTrack(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CItemToTrack * SOAP_FMAC4 soap_get_ns1__CItemToTrack(struct soap *soap, ns1__CItemToTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CItemToTrack * SOAP_FMAC2 soap_instantiate_ns1__CItemToTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CItemToTrack(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CItemToTrack, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CItemToTrack);
		if (size)
			*size = sizeof(ns1__CItemToTrack);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CItemToTrack, n);
		if (size)
			*size = n * sizeof(ns1__CItemToTrack);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CItemToTrack*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CItemToTrack(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CItemToTrack %p -> %p\n", q, p));
	*(ns1__CItemToTrack*)p = *(ns1__CItemToTrack*)q;
}

void ns1__CItemWithDBRecordId::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns1__CItemWithDBRecordId::recordid);
	/* transient soap skipped */
}

void ns1__CItemWithDBRecordId::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__CItemWithDBRecordId::recordid, SOAP_TYPE_LONG64);
	/* transient soap skipped */
#endif
}

int ns1__CItemWithDBRecordId::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CItemWithDBRecordId(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CItemWithDBRecordId(struct soap *soap, const char *tag, int id, const ns1__CItemWithDBRecordId *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CItemWithDBRecordId), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordid", -1, &(a->ns1__CItemWithDBRecordId::recordid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CItemWithDBRecordId::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CItemWithDBRecordId(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CItemWithDBRecordId * SOAP_FMAC4 soap_in_ns1__CItemWithDBRecordId(struct soap *soap, const char *tag, ns1__CItemWithDBRecordId *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CItemWithDBRecordId *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CItemWithDBRecordId, sizeof(ns1__CItemWithDBRecordId), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CItemWithDBRecordId)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CItemWithDBRecordId *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_recordid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordid1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordid", &(a->ns1__CItemWithDBRecordId::recordid), "xsd:long"))
				{	soap_flag_recordid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CItemWithDBRecordId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CItemWithDBRecordId, 0, sizeof(ns1__CItemWithDBRecordId), 0, soap_copy_ns1__CItemWithDBRecordId);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordid1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CItemWithDBRecordId::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CItemWithDBRecordId);
	if (this->soap_out(soap, tag?tag:"ns1:CItemWithDBRecordId", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CItemWithDBRecordId::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CItemWithDBRecordId(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CItemWithDBRecordId * SOAP_FMAC4 soap_get_ns1__CItemWithDBRecordId(struct soap *soap, ns1__CItemWithDBRecordId *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CItemWithDBRecordId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CItemWithDBRecordId * SOAP_FMAC2 soap_instantiate_ns1__CItemWithDBRecordId(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CItemWithDBRecordId(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CItemWithDBRecordId, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CItemWithDBRecordId);
		if (size)
			*size = sizeof(ns1__CItemWithDBRecordId);
		((ns1__CItemWithDBRecordId*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CItemWithDBRecordId, n);
		if (size)
			*size = n * sizeof(ns1__CItemWithDBRecordId);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CItemWithDBRecordId*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CItemWithDBRecordId*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CItemWithDBRecordId(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CItemWithDBRecordId %p -> %p\n", q, p));
	*(ns1__CItemWithDBRecordId*)p = *(ns1__CItemWithDBRecordId*)q;
}

void ns1__CRecordListSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CRecordListSoap::columnlist = NULL;
	this->ns1__CRecordListSoap::records = NULL;
	/* transient soap skipped */
}

void ns1__CRecordListSoap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCTableColumn(soap, &this->ns1__CRecordListSoap::columnlist);
	soap_serialize_PointerToArrayOfCRecordRowSoap(soap, &this->ns1__CRecordListSoap::records);
	/* transient soap skipped */
#endif
}

int ns1__CRecordListSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CRecordListSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CRecordListSoap(struct soap *soap, const char *tag, int id, const ns1__CRecordListSoap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CRecordListSoap), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCTableColumn(soap, "columnlist", -1, &(a->ns1__CRecordListSoap::columnlist), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCRecordRowSoap(soap, "records", -1, &(a->ns1__CRecordListSoap::records), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CRecordListSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CRecordListSoap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CRecordListSoap * SOAP_FMAC4 soap_in_ns1__CRecordListSoap(struct soap *soap, const char *tag, ns1__CRecordListSoap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CRecordListSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CRecordListSoap, sizeof(ns1__CRecordListSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CRecordListSoap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CRecordListSoap *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_columnlist1 = 1;
	size_t soap_flag_records1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_columnlist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTableColumn(soap, "columnlist", &(a->ns1__CRecordListSoap::columnlist), "ns1:CTableColumn"))
				{	soap_flag_columnlist1--;
					continue;
				}
			if (soap_flag_records1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCRecordRowSoap(soap, "records", &(a->ns1__CRecordListSoap::records), "ns1:CRecordRowSoap"))
				{	soap_flag_records1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CRecordListSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CRecordListSoap, 0, sizeof(ns1__CRecordListSoap), 0, soap_copy_ns1__CRecordListSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__CRecordListSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CRecordListSoap);
	if (this->soap_out(soap, tag?tag:"ns1:CRecordListSoap", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CRecordListSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CRecordListSoap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CRecordListSoap * SOAP_FMAC4 soap_get_ns1__CRecordListSoap(struct soap *soap, ns1__CRecordListSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CRecordListSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CRecordListSoap * SOAP_FMAC2 soap_instantiate_ns1__CRecordListSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CRecordListSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CRecordListSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CRecordListSoap);
		if (size)
			*size = sizeof(ns1__CRecordListSoap);
		((ns1__CRecordListSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CRecordListSoap, n);
		if (size)
			*size = n * sizeof(ns1__CRecordListSoap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CRecordListSoap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CRecordListSoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CRecordListSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CRecordListSoap %p -> %p\n", q, p));
	*(ns1__CRecordListSoap*)p = *(ns1__CRecordListSoap*)q;
}

void ArrayOfCRecordRowSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCRecordRowSoap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCRecordRowSoap))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CRecordRowSoap(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCRecordRowSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCRecordRowSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, int id, const ArrayOfCRecordRowSoap *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CRecordRowSoap", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCRecordRowSoap);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CRecordRowSoap(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCRecordRowSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCRecordRowSoap(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCRecordRowSoap * SOAP_FMAC4 soap_in_ArrayOfCRecordRowSoap(struct soap *soap, const char *tag, ArrayOfCRecordRowSoap *a, const char *type)
{	int i, j;
	ns1__CRecordRowSoap **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCRecordRowSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCRecordRowSoap, sizeof(ArrayOfCRecordRowSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CRecordRowSoap **)soap_malloc(soap, sizeof(ns1__CRecordRowSoap *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CRecordRowSoap(soap, NULL, a->__ptritem + i, "ns1:CRecordRowSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CRecordRowSoap **)soap_push_block(soap, NULL, sizeof(ns1__CRecordRowSoap *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CRecordRowSoap(soap, NULL, p, "ns1:CRecordRowSoap"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CRecordRowSoap **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCRecordRowSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCRecordRowSoap, 0, sizeof(ArrayOfCRecordRowSoap), 0, soap_copy_ArrayOfCRecordRowSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCRecordRowSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCRecordRowSoap);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCRecordRowSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCRecordRowSoap(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCRecordRowSoap * SOAP_FMAC4 soap_get_ArrayOfCRecordRowSoap(struct soap *soap, ArrayOfCRecordRowSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCRecordRowSoap * SOAP_FMAC2 soap_instantiate_ArrayOfCRecordRowSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCRecordRowSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCRecordRowSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCRecordRowSoap);
		if (size)
			*size = sizeof(ArrayOfCRecordRowSoap);
		((ArrayOfCRecordRowSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCRecordRowSoap, n);
		if (size)
			*size = n * sizeof(ArrayOfCRecordRowSoap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCRecordRowSoap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCRecordRowSoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCRecordRowSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCRecordRowSoap %p -> %p\n", q, p));
	*(ArrayOfCRecordRowSoap*)p = *(ArrayOfCRecordRowSoap*)q;
}

void ns1__CRecordRowSoap::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CRecordRowSoap::row = NULL;
	/* transient soap skipped */
}

void ns1__CRecordRowSoap::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCRecordData(soap, &this->ns1__CRecordRowSoap::row);
	/* transient soap skipped */
#endif
}

int ns1__CRecordRowSoap::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CRecordRowSoap(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CRecordRowSoap(struct soap *soap, const char *tag, int id, const ns1__CRecordRowSoap *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CRecordRowSoap), type))
		return soap->error;
	if (a->ns1__CRecordRowSoap::row)
	{	if (soap_out_PointerToArrayOfCRecordData(soap, "row", -1, &a->ns1__CRecordRowSoap::row, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "row"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CRecordRowSoap::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CRecordRowSoap(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CRecordRowSoap * SOAP_FMAC4 soap_in_ns1__CRecordRowSoap(struct soap *soap, const char *tag, ns1__CRecordRowSoap *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CRecordRowSoap *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CRecordRowSoap, sizeof(ns1__CRecordRowSoap), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CRecordRowSoap)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CRecordRowSoap *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_row1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_row1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCRecordData(soap, "row", &(a->ns1__CRecordRowSoap::row), "ns1:CRecordData"))
				{	soap_flag_row1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CRecordRowSoap *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CRecordRowSoap, 0, sizeof(ns1__CRecordRowSoap), 0, soap_copy_ns1__CRecordRowSoap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_row1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CRecordRowSoap::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CRecordRowSoap);
	if (this->soap_out(soap, tag?tag:"ns1:CRecordRowSoap", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CRecordRowSoap::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CRecordRowSoap(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CRecordRowSoap * SOAP_FMAC4 soap_get_ns1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CRecordRowSoap * SOAP_FMAC2 soap_instantiate_ns1__CRecordRowSoap(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CRecordRowSoap(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CRecordRowSoap, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CRecordRowSoap);
		if (size)
			*size = sizeof(ns1__CRecordRowSoap);
		((ns1__CRecordRowSoap*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CRecordRowSoap, n);
		if (size)
			*size = n * sizeof(ns1__CRecordRowSoap);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CRecordRowSoap*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CRecordRowSoap*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CRecordRowSoap(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CRecordRowSoap %p -> %p\n", q, p));
	*(ns1__CRecordRowSoap*)p = *(ns1__CRecordRowSoap*)q;
}

void ArrayOfCRecordData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCRecordData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCRecordData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CRecordData(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCRecordData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCRecordData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCRecordData(struct soap *soap, const char *tag, int id, const ArrayOfCRecordData *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CRecordData", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCRecordData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CRecordData(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCRecordData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCRecordData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCRecordData * SOAP_FMAC4 soap_in_ArrayOfCRecordData(struct soap *soap, const char *tag, ArrayOfCRecordData *a, const char *type)
{	int i, j;
	ns1__CRecordData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCRecordData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCRecordData, sizeof(ArrayOfCRecordData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CRecordData **)soap_malloc(soap, sizeof(ns1__CRecordData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CRecordData(soap, NULL, a->__ptritem + i, "ns1:CRecordData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CRecordData **)soap_push_block(soap, NULL, sizeof(ns1__CRecordData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CRecordData(soap, NULL, p, "ns1:CRecordData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CRecordData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCRecordData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCRecordData, 0, sizeof(ArrayOfCRecordData), 0, soap_copy_ArrayOfCRecordData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCRecordData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCRecordData);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCRecordData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCRecordData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCRecordData * SOAP_FMAC4 soap_get_ArrayOfCRecordData(struct soap *soap, ArrayOfCRecordData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCRecordData * SOAP_FMAC2 soap_instantiate_ArrayOfCRecordData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCRecordData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCRecordData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCRecordData);
		if (size)
			*size = sizeof(ArrayOfCRecordData);
		((ArrayOfCRecordData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCRecordData, n);
		if (size)
			*size = n * sizeof(ArrayOfCRecordData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCRecordData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCRecordData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCRecordData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCRecordData %p -> %p\n", q, p));
	*(ArrayOfCRecordData*)p = *(ArrayOfCRecordData*)q;
}

void ns1__CRecordData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CRecordData::value);
	/* transient soap skipped */
}

void ns1__CRecordData::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CRecordData::value);
	/* transient soap skipped */
#endif
}

int ns1__CRecordData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CRecordData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CRecordData(struct soap *soap, const char *tag, int id, const ns1__CRecordData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CRecordData), type))
		return soap->error;
	if (a->ns1__CRecordData::value)
	{	if (soap_out_string(soap, "value", -1, &a->ns1__CRecordData::value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "value"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CRecordData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CRecordData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CRecordData * SOAP_FMAC4 soap_in_ns1__CRecordData(struct soap *soap, const char *tag, ns1__CRecordData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CRecordData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CRecordData, sizeof(ns1__CRecordData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CRecordData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CRecordData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->ns1__CRecordData::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CRecordData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CRecordData, 0, sizeof(ns1__CRecordData), 0, soap_copy_ns1__CRecordData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CRecordData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CRecordData);
	if (this->soap_out(soap, tag?tag:"ns1:CRecordData", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CRecordData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CRecordData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CRecordData * SOAP_FMAC4 soap_get_ns1__CRecordData(struct soap *soap, ns1__CRecordData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CRecordData * SOAP_FMAC2 soap_instantiate_ns1__CRecordData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CRecordData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CRecordData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CRecordData);
		if (size)
			*size = sizeof(ns1__CRecordData);
		((ns1__CRecordData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CRecordData, n);
		if (size)
			*size = n * sizeof(ns1__CRecordData);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CRecordData*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CRecordData*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CRecordData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CRecordData %p -> %p\n", q, p));
	*(ns1__CRecordData*)p = *(ns1__CRecordData*)q;
}

void ArrayOfCFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFilter))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFilter(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFilter(struct soap *soap, const char *tag, int id, const ArrayOfCFilter *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFilter", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFilter);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFilter(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFilter(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFilter * SOAP_FMAC4 soap_in_ArrayOfCFilter(struct soap *soap, const char *tag, ArrayOfCFilter *a, const char *type)
{	int i, j;
	ns1__CFilter **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFilter, sizeof(ArrayOfCFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFilter **)soap_malloc(soap, sizeof(ns1__CFilter *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFilter(soap, NULL, a->__ptritem + i, "ns1:CFilter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFilter **)soap_push_block(soap, NULL, sizeof(ns1__CFilter *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFilter(soap, NULL, p, "ns1:CFilter"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFilter **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFilter, 0, sizeof(ArrayOfCFilter), 0, soap_copy_ArrayOfCFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFilter);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFilter(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFilter * SOAP_FMAC4 soap_get_ArrayOfCFilter(struct soap *soap, ArrayOfCFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFilter * SOAP_FMAC2 soap_instantiate_ArrayOfCFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFilter);
		if (size)
			*size = sizeof(ArrayOfCFilter);
		((ArrayOfCFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFilter, n);
		if (size)
			*size = n * sizeof(ArrayOfCFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFilter %p -> %p\n", q, p));
	*(ArrayOfCFilter*)p = *(ArrayOfCFilter*)q;
}

void ns1__CFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CFilter::name);
	/* transient soap skipped */
}

void ns1__CFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CFilter::name);
	/* transient soap skipped */
#endif
}

int ns1__CFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFilter(struct soap *soap, const char *tag, int id, const ns1__CFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFilter), type))
		return soap->error;
	if (a->ns1__CFilter::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CFilter::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFilter(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFilter * SOAP_FMAC4 soap_in_ns1__CFilter(struct soap *soap, const char *tag, ns1__CFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFilter, sizeof(ns1__CFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CFilter::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFilter, 0, sizeof(ns1__CFilter), 0, soap_copy_ns1__CFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFilter);
	if (this->soap_out(soap, tag?tag:"ns1:CFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFilter(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFilter * SOAP_FMAC4 soap_get_ns1__CFilter(struct soap *soap, ns1__CFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFilter * SOAP_FMAC2 soap_instantiate_ns1__CFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFilter);
		if (size)
			*size = sizeof(ns1__CFilter);
		((ns1__CFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFilter, n);
		if (size)
			*size = n * sizeof(ns1__CFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFilter %p -> %p\n", q, p));
	*(ns1__CFilter*)p = *(ns1__CFilter*)q;
}

void ArrayOfCTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCTableColumn::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCTableColumn))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTableColumn(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTableColumn(struct soap *soap, const char *tag, int id, const ArrayOfCTableColumn *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CTableColumn", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTableColumn);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTableColumn(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTableColumn * SOAP_FMAC4 soap_in_ArrayOfCTableColumn(struct soap *soap, const char *tag, ArrayOfCTableColumn *a, const char *type)
{	int i, j;
	ns1__CTableColumn **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTableColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTableColumn, sizeof(ArrayOfCTableColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CTableColumn **)soap_malloc(soap, sizeof(ns1__CTableColumn *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTableColumn(soap, NULL, a->__ptritem + i, "ns1:CTableColumn"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTableColumn **)soap_push_block(soap, NULL, sizeof(ns1__CTableColumn *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTableColumn(soap, NULL, p, "ns1:CTableColumn"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CTableColumn **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTableColumn, 0, sizeof(ArrayOfCTableColumn), 0, soap_copy_ArrayOfCTableColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCTableColumn);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTableColumn * SOAP_FMAC4 soap_get_ArrayOfCTableColumn(struct soap *soap, ArrayOfCTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCTableColumn * SOAP_FMAC2 soap_instantiate_ArrayOfCTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCTableColumn);
		if (size)
			*size = sizeof(ArrayOfCTableColumn);
		((ArrayOfCTableColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCTableColumn, n);
		if (size)
			*size = n * sizeof(ArrayOfCTableColumn);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCTableColumn*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCTableColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTableColumn %p -> %p\n", q, p));
	*(ArrayOfCTableColumn*)p = *(ArrayOfCTableColumn*)q;
}

void ns1__CTableColumn::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CTableColumn::name);
	/* transient soap skipped */
}

void ns1__CTableColumn::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CTableColumn::name);
	/* transient soap skipped */
#endif
}

int ns1__CTableColumn::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTableColumn(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTableColumn(struct soap *soap, const char *tag, int id, const ns1__CTableColumn *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTableColumn), type))
		return soap->error;
	if (a->ns1__CTableColumn::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CTableColumn::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CTableColumn::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTableColumn(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTableColumn * SOAP_FMAC4 soap_in_ns1__CTableColumn(struct soap *soap, const char *tag, ns1__CTableColumn *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTableColumn *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTableColumn, sizeof(ns1__CTableColumn), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTableColumn)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTableColumn *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CTableColumn::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTableColumn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTableColumn, 0, sizeof(ns1__CTableColumn), 0, soap_copy_ns1__CTableColumn);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTableColumn::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTableColumn);
	if (this->soap_out(soap, tag?tag:"ns1:CTableColumn", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTableColumn::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTableColumn(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTableColumn * SOAP_FMAC4 soap_get_ns1__CTableColumn(struct soap *soap, ns1__CTableColumn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTableColumn * SOAP_FMAC2 soap_instantiate_ns1__CTableColumn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTableColumn(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTableColumn, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTableColumn);
		if (size)
			*size = sizeof(ns1__CTableColumn);
		((ns1__CTableColumn*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTableColumn, n);
		if (size)
			*size = n * sizeof(ns1__CTableColumn);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CTableColumn*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTableColumn*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTableColumn(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTableColumn %p -> %p\n", q, p));
	*(ns1__CTableColumn*)p = *(ns1__CTableColumn*)q;
}

void ArrayOfCFieldValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCFieldValue::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCFieldValue))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CFieldValue(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCFieldValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCFieldValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCFieldValue(struct soap *soap, const char *tag, int id, const ArrayOfCFieldValue *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CFieldValue", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFieldValue);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CFieldValue(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCFieldValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCFieldValue(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCFieldValue * SOAP_FMAC4 soap_in_ArrayOfCFieldValue(struct soap *soap, const char *tag, ArrayOfCFieldValue *a, const char *type)
{	int i, j;
	ns1__CFieldValue **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCFieldValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCFieldValue, sizeof(ArrayOfCFieldValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CFieldValue **)soap_malloc(soap, sizeof(ns1__CFieldValue *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CFieldValue(soap, NULL, a->__ptritem + i, "ns1:CFieldValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CFieldValue **)soap_push_block(soap, NULL, sizeof(ns1__CFieldValue *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CFieldValue(soap, NULL, p, "ns1:CFieldValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CFieldValue **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCFieldValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCFieldValue, 0, sizeof(ArrayOfCFieldValue), 0, soap_copy_ArrayOfCFieldValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCFieldValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCFieldValue);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCFieldValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCFieldValue(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCFieldValue * SOAP_FMAC4 soap_get_ArrayOfCFieldValue(struct soap *soap, ArrayOfCFieldValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCFieldValue * SOAP_FMAC2 soap_instantiate_ArrayOfCFieldValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCFieldValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCFieldValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCFieldValue);
		if (size)
			*size = sizeof(ArrayOfCFieldValue);
		((ArrayOfCFieldValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCFieldValue, n);
		if (size)
			*size = n * sizeof(ArrayOfCFieldValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCFieldValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCFieldValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCFieldValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCFieldValue %p -> %p\n", q, p));
	*(ArrayOfCFieldValue*)p = *(ArrayOfCFieldValue*)q;
}

void ns1__CFieldValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CFieldValue::value);
	/* transient soap skipped */
}

void ns1__CFieldValue::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CFieldValue::value);
	/* transient soap skipped */
#endif
}

int ns1__CFieldValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CFieldValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CFieldValue(struct soap *soap, const char *tag, int id, const ns1__CFieldValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CFieldValue), type))
		return soap->error;
	if (a->ns1__CFieldValue::value)
	{	if (soap_out_string(soap, "value", -1, &a->ns1__CFieldValue::value, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "value"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CFieldValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CFieldValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CFieldValue * SOAP_FMAC4 soap_in_ns1__CFieldValue(struct soap *soap, const char *tag, ns1__CFieldValue *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CFieldValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CFieldValue, sizeof(ns1__CFieldValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CFieldValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CFieldValue *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "value", &(a->ns1__CFieldValue::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CFieldValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CFieldValue, 0, sizeof(ns1__CFieldValue), 0, soap_copy_ns1__CFieldValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CFieldValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CFieldValue);
	if (this->soap_out(soap, tag?tag:"ns1:CFieldValue", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CFieldValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CFieldValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CFieldValue * SOAP_FMAC4 soap_get_ns1__CFieldValue(struct soap *soap, ns1__CFieldValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CFieldValue * SOAP_FMAC2 soap_instantiate_ns1__CFieldValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CFieldValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CFieldValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CFieldValue);
		if (size)
			*size = sizeof(ns1__CFieldValue);
		((ns1__CFieldValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CFieldValue, n);
		if (size)
			*size = n * sizeof(ns1__CFieldValue);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CFieldValue*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CFieldValue*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CFieldValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CFieldValue %p -> %p\n", q, p));
	*(ns1__CFieldValue*)p = *(ns1__CFieldValue*)q;
}

void ArrayOfCTableField::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCTableField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCTableField))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTableField(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCTableField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTableField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTableField(struct soap *soap, const char *tag, int id, const ArrayOfCTableField *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CTableField", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTableField);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTableField(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCTableField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTableField(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTableField * SOAP_FMAC4 soap_in_ArrayOfCTableField(struct soap *soap, const char *tag, ArrayOfCTableField *a, const char *type)
{	int i, j;
	ns1__CTableField **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTableField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTableField, sizeof(ArrayOfCTableField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CTableField **)soap_malloc(soap, sizeof(ns1__CTableField *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTableField(soap, NULL, a->__ptritem + i, "ns1:CTableField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTableField **)soap_push_block(soap, NULL, sizeof(ns1__CTableField *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTableField(soap, NULL, p, "ns1:CTableField"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CTableField **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTableField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTableField, 0, sizeof(ArrayOfCTableField), 0, soap_copy_ArrayOfCTableField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCTableField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCTableField);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCTableField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTableField(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTableField * SOAP_FMAC4 soap_get_ArrayOfCTableField(struct soap *soap, ArrayOfCTableField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCTableField * SOAP_FMAC2 soap_instantiate_ArrayOfCTableField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTableField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTableField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCTableField);
		if (size)
			*size = sizeof(ArrayOfCTableField);
		((ArrayOfCTableField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCTableField, n);
		if (size)
			*size = n * sizeof(ArrayOfCTableField);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCTableField*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCTableField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTableField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTableField %p -> %p\n", q, p));
	*(ArrayOfCTableField*)p = *(ArrayOfCTableField*)q;
}

void ns1__CTableField::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CTableField::name);
	/* transient soap skipped */
}

void ns1__CTableField::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CTableField::name);
	/* transient soap skipped */
#endif
}

int ns1__CTableField::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTableField(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTableField(struct soap *soap, const char *tag, int id, const ns1__CTableField *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTableField), type))
		return soap->error;
	if (a->ns1__CTableField::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CTableField::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CTableField::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTableField(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTableField * SOAP_FMAC4 soap_in_ns1__CTableField(struct soap *soap, const char *tag, ns1__CTableField *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTableField *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTableField, sizeof(ns1__CTableField), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTableField)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTableField *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CTableField::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTableField *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTableField, 0, sizeof(ns1__CTableField), 0, soap_copy_ns1__CTableField);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CTableField::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTableField);
	if (this->soap_out(soap, tag?tag:"ns1:CTableField", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CTableField::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTableField(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTableField * SOAP_FMAC4 soap_get_ns1__CTableField(struct soap *soap, ns1__CTableField *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CTableField * SOAP_FMAC2 soap_instantiate_ns1__CTableField(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTableField(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTableField, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CTableField);
		if (size)
			*size = sizeof(ns1__CTableField);
		((ns1__CTableField*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CTableField, n);
		if (size)
			*size = n * sizeof(ns1__CTableField);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CTableField*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CTableField*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTableField(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTableField %p -> %p\n", q, p));
	*(ns1__CTableField*)p = *(ns1__CTableField*)q;
}

void ArrayOfCDatabaseTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCDatabaseTable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCDatabaseTable))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CDatabaseTable(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCDatabaseTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCDatabaseTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCDatabaseTable(struct soap *soap, const char *tag, int id, const ArrayOfCDatabaseTable *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CDatabaseTable", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDatabaseTable);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CDatabaseTable(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCDatabaseTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCDatabaseTable(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCDatabaseTable * SOAP_FMAC4 soap_in_ArrayOfCDatabaseTable(struct soap *soap, const char *tag, ArrayOfCDatabaseTable *a, const char *type)
{	int i, j;
	ns1__CDatabaseTable **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCDatabaseTable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCDatabaseTable, sizeof(ArrayOfCDatabaseTable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CDatabaseTable **)soap_malloc(soap, sizeof(ns1__CDatabaseTable *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CDatabaseTable(soap, NULL, a->__ptritem + i, "ns1:CDatabaseTable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CDatabaseTable **)soap_push_block(soap, NULL, sizeof(ns1__CDatabaseTable *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CDatabaseTable(soap, NULL, p, "ns1:CDatabaseTable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CDatabaseTable **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCDatabaseTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCDatabaseTable, 0, sizeof(ArrayOfCDatabaseTable), 0, soap_copy_ArrayOfCDatabaseTable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCDatabaseTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCDatabaseTable);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCDatabaseTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCDatabaseTable(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCDatabaseTable * SOAP_FMAC4 soap_get_ArrayOfCDatabaseTable(struct soap *soap, ArrayOfCDatabaseTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCDatabaseTable * SOAP_FMAC2 soap_instantiate_ArrayOfCDatabaseTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCDatabaseTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCDatabaseTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCDatabaseTable);
		if (size)
			*size = sizeof(ArrayOfCDatabaseTable);
		((ArrayOfCDatabaseTable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCDatabaseTable, n);
		if (size)
			*size = n * sizeof(ArrayOfCDatabaseTable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCDatabaseTable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCDatabaseTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCDatabaseTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCDatabaseTable %p -> %p\n", q, p));
	*(ArrayOfCDatabaseTable*)p = *(ArrayOfCDatabaseTable*)q;
}

void ns1__CDatabaseTable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CDatabaseTable::name);
	/* transient soap skipped */
}

void ns1__CDatabaseTable::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CDatabaseTable::name);
	/* transient soap skipped */
#endif
}

int ns1__CDatabaseTable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDatabaseTable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDatabaseTable(struct soap *soap, const char *tag, int id, const ns1__CDatabaseTable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDatabaseTable), type))
		return soap->error;
	if (a->ns1__CDatabaseTable::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDatabaseTable::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CDatabaseTable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDatabaseTable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDatabaseTable * SOAP_FMAC4 soap_in_ns1__CDatabaseTable(struct soap *soap, const char *tag, ns1__CDatabaseTable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDatabaseTable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDatabaseTable, sizeof(ns1__CDatabaseTable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDatabaseTable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDatabaseTable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDatabaseTable::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDatabaseTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDatabaseTable, 0, sizeof(ns1__CDatabaseTable), 0, soap_copy_ns1__CDatabaseTable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDatabaseTable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDatabaseTable);
	if (this->soap_out(soap, tag?tag:"ns1:CDatabaseTable", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDatabaseTable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDatabaseTable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDatabaseTable * SOAP_FMAC4 soap_get_ns1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDatabaseTable * SOAP_FMAC2 soap_instantiate_ns1__CDatabaseTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDatabaseTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDatabaseTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDatabaseTable);
		if (size)
			*size = sizeof(ns1__CDatabaseTable);
		((ns1__CDatabaseTable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDatabaseTable, n);
		if (size)
			*size = n * sizeof(ns1__CDatabaseTable);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CDatabaseTable*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDatabaseTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDatabaseTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDatabaseTable %p -> %p\n", q, p));
	*(ns1__CDatabaseTable*)p = *(ns1__CDatabaseTable*)q;
}

void ArrayOfCProject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCProject::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCProject))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CProject(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCProject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCProject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCProject(struct soap *soap, const char *tag, int id, const ArrayOfCProject *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CProject", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCProject);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CProject(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCProject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCProject(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCProject * SOAP_FMAC4 soap_in_ArrayOfCProject(struct soap *soap, const char *tag, ArrayOfCProject *a, const char *type)
{	int i, j;
	ns1__CProject **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCProject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCProject, sizeof(ArrayOfCProject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CProject **)soap_malloc(soap, sizeof(ns1__CProject *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CProject(soap, NULL, a->__ptritem + i, "ns1:CProject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CProject **)soap_push_block(soap, NULL, sizeof(ns1__CProject *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CProject(soap, NULL, p, "ns1:CProject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CProject **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCProject, 0, sizeof(ArrayOfCProject), 0, soap_copy_ArrayOfCProject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCProject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCProject);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCProject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCProject(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCProject * SOAP_FMAC4 soap_get_ArrayOfCProject(struct soap *soap, ArrayOfCProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCProject * SOAP_FMAC2 soap_instantiate_ArrayOfCProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCProject);
		if (size)
			*size = sizeof(ArrayOfCProject);
		((ArrayOfCProject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCProject, n);
		if (size)
			*size = n * sizeof(ArrayOfCProject);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCProject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCProject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCProject %p -> %p\n", q, p));
	*(ArrayOfCProject*)p = *(ArrayOfCProject*)q;
}

void ns1__CProject::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__CProject::database = NULL;
	this->ns1__CProject::options = NULL;
	this->ns1__CProject::servernumber = NULL;
	/* transient soap skipped */
}

void ns1__CProject::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDatabase(soap, &this->ns1__CProject::database);
	soap_serialize_PointerToArrayOfCProjectDataOption(soap, &this->ns1__CProject::options);
	soap_serialize_PointerToint(soap, &this->ns1__CProject::servernumber);
	/* transient soap skipped */
#endif
}

int ns1__CProject::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CProject(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CProject(struct soap *soap, const char *tag, int id, const ns1__CProject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CProject), type))
		return soap->error;
	if (a->ns1__CProject::database)
	{	if (soap_out_PointerTons1__CDatabase(soap, "database", -1, &a->ns1__CProject::database, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "database"))
		return soap->error;
	if (soap_out_PointerToArrayOfCProjectDataOption(soap, "options", -1, &(a->ns1__CProject::options), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "servernumber", -1, &(a->ns1__CProject::servernumber), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CProject::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CProject(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CProject * SOAP_FMAC4 soap_in_ns1__CProject(struct soap *soap, const char *tag, ns1__CProject *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CProject *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CProject, sizeof(ns1__CProject), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CProject)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CProject *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_database1 = 1;
	size_t soap_flag_options1 = 1;
	size_t soap_flag_servernumber1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_database1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDatabase(soap, "database", &(a->ns1__CProject::database), "ns1:CDatabase"))
				{	soap_flag_database1--;
					continue;
				}
			if (soap_flag_options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCProjectDataOption(soap, "options", &(a->ns1__CProject::options), "ns1:CProjectDataOption"))
				{	soap_flag_options1--;
					continue;
				}
			if (soap_flag_servernumber1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "servernumber", &(a->ns1__CProject::servernumber), "xsd:int"))
				{	soap_flag_servernumber1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CProject, 0, sizeof(ns1__CProject), 0, soap_copy_ns1__CProject);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_database1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CProject::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CProject);
	if (this->soap_out(soap, tag?tag:"ns1:CProject", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CProject::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CProject(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CProject * SOAP_FMAC4 soap_get_ns1__CProject(struct soap *soap, ns1__CProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CProject * SOAP_FMAC2 soap_instantiate_ns1__CProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CProject);
		if (size)
			*size = sizeof(ns1__CProject);
		((ns1__CProject*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CProject, n);
		if (size)
			*size = n * sizeof(ns1__CProject);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CProject*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CProject*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CProject %p -> %p\n", q, p));
	*(ns1__CProject*)p = *(ns1__CProject*)q;
}

void ArrayOfCProjectDataOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCProjectDataOption::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCProjectDataOption))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CProjectDataOption(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCProjectDataOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCProjectDataOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCProjectDataOption(struct soap *soap, const char *tag, int id, const ArrayOfCProjectDataOption *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CProjectDataOption", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCProjectDataOption);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CProjectDataOption(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCProjectDataOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCProjectDataOption(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCProjectDataOption * SOAP_FMAC4 soap_in_ArrayOfCProjectDataOption(struct soap *soap, const char *tag, ArrayOfCProjectDataOption *a, const char *type)
{	int i, j;
	ns1__CProjectDataOption **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCProjectDataOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCProjectDataOption, sizeof(ArrayOfCProjectDataOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CProjectDataOption **)soap_malloc(soap, sizeof(ns1__CProjectDataOption *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CProjectDataOption(soap, NULL, a->__ptritem + i, "ns1:CProjectDataOption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CProjectDataOption **)soap_push_block(soap, NULL, sizeof(ns1__CProjectDataOption *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CProjectDataOption(soap, NULL, p, "ns1:CProjectDataOption"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CProjectDataOption **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCProjectDataOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCProjectDataOption, 0, sizeof(ArrayOfCProjectDataOption), 0, soap_copy_ArrayOfCProjectDataOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCProjectDataOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCProjectDataOption);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCProjectDataOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCProjectDataOption(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCProjectDataOption * SOAP_FMAC4 soap_get_ArrayOfCProjectDataOption(struct soap *soap, ArrayOfCProjectDataOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCProjectDataOption * SOAP_FMAC2 soap_instantiate_ArrayOfCProjectDataOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCProjectDataOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCProjectDataOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCProjectDataOption);
		if (size)
			*size = sizeof(ArrayOfCProjectDataOption);
		((ArrayOfCProjectDataOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCProjectDataOption, n);
		if (size)
			*size = n * sizeof(ArrayOfCProjectDataOption);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCProjectDataOption*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCProjectDataOption*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCProjectDataOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCProjectDataOption %p -> %p\n", q, p));
	*(ArrayOfCProjectDataOption*)p = *(ArrayOfCProjectDataOption*)q;
}

void ns1__CProjectDataOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CProjectDataOption::name);
	/* transient soap skipped */
}

void ns1__CProjectDataOption::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CProjectDataOption::name);
	/* transient soap skipped */
#endif
}

int ns1__CProjectDataOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CProjectDataOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CProjectDataOption(struct soap *soap, const char *tag, int id, const ns1__CProjectDataOption *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CProjectDataOption), type))
		return soap->error;
	if (a->ns1__CProjectDataOption::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CProjectDataOption::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CProjectDataOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CProjectDataOption(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CProjectDataOption * SOAP_FMAC4 soap_in_ns1__CProjectDataOption(struct soap *soap, const char *tag, ns1__CProjectDataOption *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CProjectDataOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CProjectDataOption, sizeof(ns1__CProjectDataOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CProjectDataOption)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CProjectDataOption *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CProjectDataOption::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CProjectDataOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CProjectDataOption, 0, sizeof(ns1__CProjectDataOption), 0, soap_copy_ns1__CProjectDataOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CProjectDataOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CProjectDataOption);
	if (this->soap_out(soap, tag?tag:"ns1:CProjectDataOption", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CProjectDataOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CProjectDataOption(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CProjectDataOption * SOAP_FMAC4 soap_get_ns1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CProjectDataOption * SOAP_FMAC2 soap_instantiate_ns1__CProjectDataOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CProjectDataOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CProjectDataOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CProjectDataOption);
		if (size)
			*size = sizeof(ns1__CProjectDataOption);
		((ns1__CProjectDataOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CProjectDataOption, n);
		if (size)
			*size = n * sizeof(ns1__CProjectDataOption);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CProjectDataOption*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CProjectDataOption*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CProjectDataOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CProjectDataOption %p -> %p\n", q, p));
	*(ns1__CProjectDataOption*)p = *(ns1__CProjectDataOption*)q;
}

void ArrayOfCDatabase::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfCDatabase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfCDatabase))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CDatabase(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfCDatabase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCDatabase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCDatabase(struct soap *soap, const char *tag, int id, const ArrayOfCDatabase *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "ns1:CDatabase", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDatabase);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CDatabase(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfCDatabase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCDatabase(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCDatabase * SOAP_FMAC4 soap_in_ArrayOfCDatabase(struct soap *soap, const char *tag, ArrayOfCDatabase *a, const char *type)
{	int i, j;
	ns1__CDatabase **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCDatabase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCDatabase, sizeof(ArrayOfCDatabase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (ns1__CDatabase **)soap_malloc(soap, sizeof(ns1__CDatabase *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CDatabase(soap, NULL, a->__ptritem + i, "ns1:CDatabase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CDatabase **)soap_push_block(soap, NULL, sizeof(ns1__CDatabase *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CDatabase(soap, NULL, p, "ns1:CDatabase"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (ns1__CDatabase **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCDatabase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCDatabase, 0, sizeof(ArrayOfCDatabase), 0, soap_copy_ArrayOfCDatabase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfCDatabase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfCDatabase);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfCDatabase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCDatabase(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCDatabase * SOAP_FMAC4 soap_get_ArrayOfCDatabase(struct soap *soap, ArrayOfCDatabase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfCDatabase * SOAP_FMAC2 soap_instantiate_ArrayOfCDatabase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCDatabase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCDatabase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfCDatabase);
		if (size)
			*size = sizeof(ArrayOfCDatabase);
		((ArrayOfCDatabase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfCDatabase, n);
		if (size)
			*size = n * sizeof(ArrayOfCDatabase);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfCDatabase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfCDatabase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCDatabase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCDatabase %p -> %p\n", q, p));
	*(ArrayOfCDatabase*)p = *(ArrayOfCDatabase*)q;
}

void ns1__CDatabase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns1__CDatabase::name);
	/* transient soap skipped */
}

void ns1__CDatabase::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns1__CDatabase::name);
	/* transient soap skipped */
#endif
}

int ns1__CDatabase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CDatabase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CDatabase(struct soap *soap, const char *tag, int id, const ns1__CDatabase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CDatabase), type))
		return soap->error;
	if (a->ns1__CDatabase::name)
	{	if (soap_out_string(soap, "name", -1, &a->ns1__CDatabase::name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__CDatabase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CDatabase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CDatabase * SOAP_FMAC4 soap_in_ns1__CDatabase(struct soap *soap, const char *tag, ns1__CDatabase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CDatabase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CDatabase, sizeof(ns1__CDatabase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CDatabase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CDatabase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns1__CDatabase::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CDatabase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CDatabase, 0, sizeof(ns1__CDatabase), 0, soap_copy_ns1__CDatabase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__CDatabase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CDatabase);
	if (this->soap_out(soap, tag?tag:"ns1:CDatabase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__CDatabase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CDatabase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CDatabase * SOAP_FMAC4 soap_get_ns1__CDatabase(struct soap *soap, ns1__CDatabase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__CDatabase * SOAP_FMAC2 soap_instantiate_ns1__CDatabase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CDatabase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CDatabase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__CDatabase);
		if (size)
			*size = sizeof(ns1__CDatabase);
		((ns1__CDatabase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__CDatabase, n);
		if (size)
			*size = n * sizeof(ns1__CDatabase);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__CDatabase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__CDatabase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CDatabase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CDatabase %p -> %p\n", q, p));
	*(ns1__CDatabase*)p = *(ns1__CDatabase*)q;
}

void ArrayOflong::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOflong::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOflong))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptritem + i, SOAP_TYPE_LONG64);
		}
#endif
}

int ArrayOflong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOflong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOflong(struct soap *soap, const char *tag, int id, const ArrayOflong *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "xsd:long", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOflong);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_LONG64(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOflong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOflong(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOflong * SOAP_FMAC4 soap_in_ArrayOflong(struct soap *soap, const char *tag, ArrayOflong *a, const char *type)
{	int i, j;
	LONG64 *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOflong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOflong, sizeof(ArrayOflong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (LONG64 *)soap_malloc(soap, sizeof(LONG64) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_LONG64(soap, a->__ptritem+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_LONG64(soap, NULL, a->__ptritem + i, "xsd:long"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (LONG64 *)soap_push_block(soap, NULL, sizeof(LONG64));
				if (!p)
					return NULL;
				soap_default_LONG64(soap, p);
				if (!soap_in_LONG64(soap, NULL, p, "xsd:long"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (LONG64 *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOflong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOflong, 0, sizeof(ArrayOflong), 0, soap_copy_ArrayOflong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOflong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOflong);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOflong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOflong(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOflong * SOAP_FMAC4 soap_get_ArrayOflong(struct soap *soap, ArrayOflong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOflong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOflong * SOAP_FMAC2 soap_instantiate_ArrayOflong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOflong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOflong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOflong);
		if (size)
			*size = sizeof(ArrayOflong);
		((ArrayOflong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOflong, n);
		if (size)
			*size = n * sizeof(ArrayOflong);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOflong*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOflong*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOflong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOflong %p -> %p\n", q, p));
	*(ArrayOflong*)p = *(ArrayOflong*)q;
}

void ArrayOfstring::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptritem = NULL;
}

void ArrayOfstring::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptritem && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptritem, 1, SOAP_TYPE_ArrayOfstring))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_string(soap, this->__ptritem + i);
		}
#endif
}

int ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfstring(struct soap *soap, const char *tag, int id, const ArrayOfstring *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptritem ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptritem, 1, type, SOAP_TYPE_ArrayOfstring);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_string(soap, "item", -1, &a->__ptritem[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfstring * SOAP_FMAC4 soap_in_ArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptritem = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptritem[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_string(soap, NULL, a->__ptritem + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptritem = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptritem, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfstring *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfstring, 0, sizeof(ArrayOfstring), 0, soap_copy_ArrayOfstring);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptritem, 1, tag, SOAP_TYPE_ArrayOfstring);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfstring * SOAP_FMAC4 soap_get_ArrayOfstring(struct soap *soap, ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfstring * SOAP_FMAC2 soap_instantiate_ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfstring, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfstring);
		if (size)
			*size = sizeof(ArrayOfstring);
		((ArrayOfstring*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfstring, n);
		if (size)
			*size = n * sizeof(ArrayOfstring);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfstring*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfstring*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfstring(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfstring %p -> %p\n", q, p));
	*(ArrayOfstring*)p = *(ArrayOfstring*)q;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_xsd__base64Binary))
		if (this->id || this->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(xsd__base64Binary), 0, soap_copy_xsd__base64Binary);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (this->soap_out(soap, tag?tag:"xsd:base64Binary", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(xsd__base64Binary);
		if (size)
			*size = sizeof(xsd__base64Binary);
		((xsd__base64Binary*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(xsd__base64Binary, n);
		if (size)
			*size = n * sizeof(xsd__base64Binary);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((xsd__base64Binary*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (xsd__base64Binary*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__base64Binary(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__base64Binary %p -> %p\n", q, p));
	*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getItemHyperlinks(struct soap *soap, struct ns1__getItemHyperlinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->itemType);
	soap_default_LONG64(soap, &a->itemID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getItemHyperlinks(struct soap *soap, const struct ns1__getItemHyperlinks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->itemType);
	soap_embedded(soap, &a->itemID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getItemHyperlinks(struct soap *soap, const char *tag, int id, const struct ns1__getItemHyperlinks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getItemHyperlinks), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "itemType", -1, &a->itemType, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "itemID", -1, &a->itemID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getItemHyperlinks * SOAP_FMAC4 soap_in_ns1__getItemHyperlinks(struct soap *soap, const char *tag, struct ns1__getItemHyperlinks *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_itemType = 1;
	size_t soap_flag_itemID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getItemHyperlinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getItemHyperlinks, sizeof(struct ns1__getItemHyperlinks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getItemHyperlinks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_itemType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "itemType", &a->itemType, "xsd:string"))
				{	soap_flag_itemType--;
					continue;
				}
			if (soap_flag_itemID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "itemID", &a->itemID, "xsd:long"))
				{	soap_flag_itemID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getItemHyperlinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getItemHyperlinks, 0, sizeof(struct ns1__getItemHyperlinks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_itemID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getItemHyperlinks(struct soap *soap, const struct ns1__getItemHyperlinks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getItemHyperlinks);
	if (soap_out_ns1__getItemHyperlinks(soap, tag?tag:"ns1:getItemHyperlinks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getItemHyperlinks * SOAP_FMAC4 soap_get_ns1__getItemHyperlinks(struct soap *soap, struct ns1__getItemHyperlinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getItemHyperlinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getItemHyperlinks * SOAP_FMAC2 soap_instantiate_ns1__getItemHyperlinks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getItemHyperlinks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getItemHyperlinks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getItemHyperlinks);
		if (size)
			*size = sizeof(struct ns1__getItemHyperlinks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getItemHyperlinks, n);
		if (size)
			*size = n * sizeof(struct ns1__getItemHyperlinks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getItemHyperlinks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getItemHyperlinks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getItemHyperlinks %p -> %p\n", q, p));
	*(struct ns1__getItemHyperlinks*)p = *(struct ns1__getItemHyperlinks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getItemHyperlinksResponse(struct soap *soap, struct ns1__getItemHyperlinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->hyperlinks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getItemHyperlinksResponse(struct soap *soap, const struct ns1__getItemHyperlinksResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CItemHyperlinkContainer(soap, &a->hyperlinks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getItemHyperlinksResponse(struct soap *soap, const char *tag, int id, const struct ns1__getItemHyperlinksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getItemHyperlinksResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CItemHyperlinkContainer(soap, "hyperlinks", -1, &a->hyperlinks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getItemHyperlinksResponse * SOAP_FMAC4 soap_in_ns1__getItemHyperlinksResponse(struct soap *soap, const char *tag, struct ns1__getItemHyperlinksResponse *a, const char *type)
{
	size_t soap_flag_hyperlinks = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getItemHyperlinksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getItemHyperlinksResponse, sizeof(struct ns1__getItemHyperlinksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getItemHyperlinksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hyperlinks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CItemHyperlinkContainer(soap, "hyperlinks", &a->hyperlinks, "ns1:CItemHyperlinkContainer"))
				{	soap_flag_hyperlinks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getItemHyperlinksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getItemHyperlinksResponse, 0, sizeof(struct ns1__getItemHyperlinksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getItemHyperlinksResponse(struct soap *soap, const struct ns1__getItemHyperlinksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getItemHyperlinksResponse);
	if (soap_out_ns1__getItemHyperlinksResponse(soap, tag?tag:"ns1:getItemHyperlinksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getItemHyperlinksResponse * SOAP_FMAC4 soap_get_ns1__getItemHyperlinksResponse(struct soap *soap, struct ns1__getItemHyperlinksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getItemHyperlinksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getItemHyperlinksResponse * SOAP_FMAC2 soap_instantiate_ns1__getItemHyperlinksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getItemHyperlinksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getItemHyperlinksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getItemHyperlinksResponse);
		if (size)
			*size = sizeof(struct ns1__getItemHyperlinksResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getItemHyperlinksResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getItemHyperlinksResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getItemHyperlinksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getItemHyperlinksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getItemHyperlinksResponse %p -> %p\n", q, p));
	*(struct ns1__getItemHyperlinksResponse*)p = *(struct ns1__getItemHyperlinksResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTree(struct soap *soap, struct ns1__getFolderTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->treeRootFolderPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTree(struct soap *soap, const struct ns1__getFolderTree *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->treeRootFolderPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTree(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTree *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTree), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "treeRootFolderPath", -1, &a->treeRootFolderPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTree * SOAP_FMAC4 soap_in_ns1__getFolderTree(struct soap *soap, const char *tag, struct ns1__getFolderTree *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_treeRootFolderPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTree, sizeof(struct ns1__getFolderTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTree(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_treeRootFolderPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "treeRootFolderPath", &a->treeRootFolderPath, "xsd:string"))
				{	soap_flag_treeRootFolderPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTree, 0, sizeof(struct ns1__getFolderTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTree(struct soap *soap, const struct ns1__getFolderTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTree);
	if (soap_out_ns1__getFolderTree(soap, tag?tag:"ns1:getFolderTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTree * SOAP_FMAC4 soap_get_ns1__getFolderTree(struct soap *soap, struct ns1__getFolderTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTree * SOAP_FMAC2 soap_instantiate_ns1__getFolderTree(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTree(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTree, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTree);
		if (size)
			*size = sizeof(struct ns1__getFolderTree);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTree, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTree);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTree*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTree(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTree %p -> %p\n", q, p));
	*(struct ns1__getFolderTree*)p = *(struct ns1__getFolderTree*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTreeResponse(struct soap *soap, struct ns1__getFolderTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->folderTreeRoot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTreeResponse(struct soap *soap, const struct ns1__getFolderTreeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTreeNodeSoap(soap, &a->folderTreeRoot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTreeResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTreeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTreeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTreeNodeSoap(soap, "folderTreeRoot", -1, &a->folderTreeRoot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTreeResponse * SOAP_FMAC4 soap_in_ns1__getFolderTreeResponse(struct soap *soap, const char *tag, struct ns1__getFolderTreeResponse *a, const char *type)
{
	size_t soap_flag_folderTreeRoot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTreeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTreeResponse, sizeof(struct ns1__getFolderTreeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTreeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_folderTreeRoot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTreeNodeSoap(soap, "folderTreeRoot", &a->folderTreeRoot, "ns1:CTreeNodeSoap"))
				{	soap_flag_folderTreeRoot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTreeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTreeResponse, 0, sizeof(struct ns1__getFolderTreeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTreeResponse(struct soap *soap, const struct ns1__getFolderTreeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTreeResponse);
	if (soap_out_ns1__getFolderTreeResponse(soap, tag?tag:"ns1:getFolderTreeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTreeResponse * SOAP_FMAC4 soap_get_ns1__getFolderTreeResponse(struct soap *soap, struct ns1__getFolderTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTreeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTreeResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderTreeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTreeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTreeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTreeResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderTreeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTreeResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTreeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTreeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTreeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTreeResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderTreeResponse*)p = *(struct ns1__getFolderTreeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTreeByRecordID(struct soap *soap, struct ns1__getFolderTreeByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->treeRootFolderID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTreeByRecordID(struct soap *soap, const struct ns1__getFolderTreeByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->treeRootFolderID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTreeByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTreeByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTreeByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "treeRootFolderID", -1, &a->treeRootFolderID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTreeByRecordID * SOAP_FMAC4 soap_in_ns1__getFolderTreeByRecordID(struct soap *soap, const char *tag, struct ns1__getFolderTreeByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_treeRootFolderID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTreeByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTreeByRecordID, sizeof(struct ns1__getFolderTreeByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTreeByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_treeRootFolderID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "treeRootFolderID", &a->treeRootFolderID, "xsd:long"))
				{	soap_flag_treeRootFolderID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTreeByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTreeByRecordID, 0, sizeof(struct ns1__getFolderTreeByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_treeRootFolderID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTreeByRecordID(struct soap *soap, const struct ns1__getFolderTreeByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTreeByRecordID);
	if (soap_out_ns1__getFolderTreeByRecordID(soap, tag?tag:"ns1:getFolderTreeByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTreeByRecordID * SOAP_FMAC4 soap_get_ns1__getFolderTreeByRecordID(struct soap *soap, struct ns1__getFolderTreeByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTreeByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTreeByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getFolderTreeByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTreeByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTreeByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTreeByRecordID);
		if (size)
			*size = sizeof(struct ns1__getFolderTreeByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTreeByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTreeByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTreeByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTreeByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTreeByRecordID %p -> %p\n", q, p));
	*(struct ns1__getFolderTreeByRecordID*)p = *(struct ns1__getFolderTreeByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, struct ns1__getFolderTreeByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->folderTreeRoot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, const struct ns1__getFolderTreeByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTreeNodeSoap(soap, &a->folderTreeRoot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTreeByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTreeNodeSoap(soap, "folderTreeRoot", -1, &a->folderTreeRoot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTreeByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getFolderTreeByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_folderTreeRoot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTreeByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse, sizeof(struct ns1__getFolderTreeByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTreeByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_folderTreeRoot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTreeNodeSoap(soap, "folderTreeRoot", &a->folderTreeRoot, "ns1:CTreeNodeSoap"))
				{	soap_flag_folderTreeRoot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTreeByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse, 0, sizeof(struct ns1__getFolderTreeByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, const struct ns1__getFolderTreeByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse);
	if (soap_out_ns1__getFolderTreeByRecordIDResponse(soap, tag?tag:"ns1:getFolderTreeByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTreeByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, struct ns1__getFolderTreeByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTreeByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTreeByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTreeByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTreeByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTreeByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderTreeByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTreeByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTreeByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTreeByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTreeByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTreeByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderTreeByRecordIDResponse*)p = *(struct ns1__getFolderTreeByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocumentTree(struct soap *soap, struct ns1__getDocumentTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocumentTree(struct soap *soap, const struct ns1__getDocumentTree *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocumentTree(struct soap *soap, const char *tag, int id, const struct ns1__getDocumentTree *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocumentTree), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentID", -1, &a->documentID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocumentTree * SOAP_FMAC4 soap_in_ns1__getDocumentTree(struct soap *soap, const char *tag, struct ns1__getDocumentTree *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocumentTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocumentTree, sizeof(struct ns1__getDocumentTree), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocumentTree(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentID", &a->documentID, "xsd:long"))
				{	soap_flag_documentID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocumentTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocumentTree, 0, sizeof(struct ns1__getDocumentTree), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocumentTree(struct soap *soap, const struct ns1__getDocumentTree *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDocumentTree);
	if (soap_out_ns1__getDocumentTree(soap, tag?tag:"ns1:getDocumentTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocumentTree * SOAP_FMAC4 soap_get_ns1__getDocumentTree(struct soap *soap, struct ns1__getDocumentTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocumentTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDocumentTree * SOAP_FMAC2 soap_instantiate_ns1__getDocumentTree(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocumentTree(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDocumentTree, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDocumentTree);
		if (size)
			*size = sizeof(struct ns1__getDocumentTree);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDocumentTree, n);
		if (size)
			*size = n * sizeof(struct ns1__getDocumentTree);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDocumentTree*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDocumentTree(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDocumentTree %p -> %p\n", q, p));
	*(struct ns1__getDocumentTree*)p = *(struct ns1__getDocumentTree*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocumentTreeResponse(struct soap *soap, struct ns1__getDocumentTreeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->docTreeRootNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocumentTreeResponse(struct soap *soap, const struct ns1__getDocumentTreeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTreeNodeSoap(soap, &a->docTreeRootNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocumentTreeResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDocumentTreeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocumentTreeResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTreeNodeSoap(soap, "docTreeRootNode", -1, &a->docTreeRootNode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocumentTreeResponse * SOAP_FMAC4 soap_in_ns1__getDocumentTreeResponse(struct soap *soap, const char *tag, struct ns1__getDocumentTreeResponse *a, const char *type)
{
	size_t soap_flag_docTreeRootNode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocumentTreeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocumentTreeResponse, sizeof(struct ns1__getDocumentTreeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocumentTreeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_docTreeRootNode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTreeNodeSoap(soap, "docTreeRootNode", &a->docTreeRootNode, "ns1:CTreeNodeSoap"))
				{	soap_flag_docTreeRootNode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocumentTreeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocumentTreeResponse, 0, sizeof(struct ns1__getDocumentTreeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocumentTreeResponse(struct soap *soap, const struct ns1__getDocumentTreeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDocumentTreeResponse);
	if (soap_out_ns1__getDocumentTreeResponse(soap, tag?tag:"ns1:getDocumentTreeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocumentTreeResponse * SOAP_FMAC4 soap_get_ns1__getDocumentTreeResponse(struct soap *soap, struct ns1__getDocumentTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocumentTreeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDocumentTreeResponse * SOAP_FMAC2 soap_instantiate_ns1__getDocumentTreeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocumentTreeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDocumentTreeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDocumentTreeResponse);
		if (size)
			*size = sizeof(struct ns1__getDocumentTreeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDocumentTreeResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDocumentTreeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDocumentTreeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDocumentTreeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDocumentTreeResponse %p -> %p\n", q, p));
	*(struct ns1__getDocumentTreeResponse*)p = *(struct ns1__getDocumentTreeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementIDsForDocument(struct soap *soap, struct ns1__getRequirementIDsForDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementIDsForDocument(struct soap *soap, const struct ns1__getRequirementIDsForDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementIDsForDocument(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementIDsForDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementIDsForDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentID", -1, &a->documentID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementIDsForDocument * SOAP_FMAC4 soap_in_ns1__getRequirementIDsForDocument(struct soap *soap, const char *tag, struct ns1__getRequirementIDsForDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementIDsForDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementIDsForDocument, sizeof(struct ns1__getRequirementIDsForDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementIDsForDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentID", &a->documentID, "xsd:long"))
				{	soap_flag_documentID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementIDsForDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementIDsForDocument, 0, sizeof(struct ns1__getRequirementIDsForDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementIDsForDocument(struct soap *soap, const struct ns1__getRequirementIDsForDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementIDsForDocument);
	if (soap_out_ns1__getRequirementIDsForDocument(soap, tag?tag:"ns1:getRequirementIDsForDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementIDsForDocument * SOAP_FMAC4 soap_get_ns1__getRequirementIDsForDocument(struct soap *soap, struct ns1__getRequirementIDsForDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementIDsForDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementIDsForDocument * SOAP_FMAC2 soap_instantiate_ns1__getRequirementIDsForDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementIDsForDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementIDsForDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementIDsForDocument);
		if (size)
			*size = sizeof(struct ns1__getRequirementIDsForDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementIDsForDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementIDsForDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementIDsForDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementIDsForDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementIDsForDocument %p -> %p\n", q, p));
	*(struct ns1__getRequirementIDsForDocument*)p = *(struct ns1__getRequirementIDsForDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, struct ns1__getRequirementIDsForDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->recordIDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, const struct ns1__getRequirementIDsForDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOflong(soap, &a->recordIDs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementIDsForDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOflong(soap, "recordIDs", -1, &a->recordIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementIDsForDocumentResponse * SOAP_FMAC4 soap_in_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, const char *tag, struct ns1__getRequirementIDsForDocumentResponse *a, const char *type)
{
	size_t soap_flag_recordIDs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementIDsForDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse, sizeof(struct ns1__getRequirementIDsForDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementIDsForDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordIDs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOflong(soap, "recordIDs", &a->recordIDs, "xsd:long"))
				{	soap_flag_recordIDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementIDsForDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse, 0, sizeof(struct ns1__getRequirementIDsForDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, const struct ns1__getRequirementIDsForDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse);
	if (soap_out_ns1__getRequirementIDsForDocumentResponse(soap, tag?tag:"ns1:getRequirementIDsForDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementIDsForDocumentResponse * SOAP_FMAC4 soap_get_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, struct ns1__getRequirementIDsForDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementIDsForDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementIDsForDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementIDsForDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementIDsForDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementIDsForDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__getRequirementIDsForDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementIDsForDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementIDsForDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementIDsForDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementIDsForDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementIDsForDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__getRequirementIDsForDocumentResponse*)p = *(struct ns1__getRequirementIDsForDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createSnapshot(struct soap *soap, struct ns1__createSnapshot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentID);
	a->snapshot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createSnapshot(struct soap *soap, const struct ns1__createSnapshot *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentID, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CSnapshotInfo(soap, &a->snapshot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createSnapshot(struct soap *soap, const char *tag, int id, const struct ns1__createSnapshot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createSnapshot), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentID", -1, &a->documentID, ""))
		return soap->error;
	if (soap_out_PointerTons1__CSnapshotInfo(soap, "snapshot", -1, &a->snapshot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createSnapshot * SOAP_FMAC4 soap_in_ns1__createSnapshot(struct soap *soap, const char *tag, struct ns1__createSnapshot *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentID = 1;
	size_t soap_flag_snapshot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createSnapshot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createSnapshot, sizeof(struct ns1__createSnapshot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createSnapshot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentID", &a->documentID, "xsd:long"))
				{	soap_flag_documentID--;
					continue;
				}
			if (soap_flag_snapshot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSnapshotInfo(soap, "snapshot", &a->snapshot, "ns1:CSnapshotInfo"))
				{	soap_flag_snapshot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createSnapshot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createSnapshot, 0, sizeof(struct ns1__createSnapshot), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createSnapshot(struct soap *soap, const struct ns1__createSnapshot *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createSnapshot);
	if (soap_out_ns1__createSnapshot(soap, tag?tag:"ns1:createSnapshot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createSnapshot * SOAP_FMAC4 soap_get_ns1__createSnapshot(struct soap *soap, struct ns1__createSnapshot *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createSnapshot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__createSnapshot * SOAP_FMAC2 soap_instantiate_ns1__createSnapshot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createSnapshot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createSnapshot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__createSnapshot);
		if (size)
			*size = sizeof(struct ns1__createSnapshot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__createSnapshot, n);
		if (size)
			*size = n * sizeof(struct ns1__createSnapshot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__createSnapshot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createSnapshot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__createSnapshot %p -> %p\n", q, p));
	*(struct ns1__createSnapshot*)p = *(struct ns1__createSnapshot*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createSnapshotResponse(struct soap *soap, struct ns1__createSnapshotResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createSnapshotResponse(struct soap *soap, const struct ns1__createSnapshotResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createSnapshotResponse(struct soap *soap, const char *tag, int id, const struct ns1__createSnapshotResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createSnapshotResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createSnapshotResponse * SOAP_FMAC4 soap_in_ns1__createSnapshotResponse(struct soap *soap, const char *tag, struct ns1__createSnapshotResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createSnapshotResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createSnapshotResponse, sizeof(struct ns1__createSnapshotResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createSnapshotResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createSnapshotResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createSnapshotResponse, 0, sizeof(struct ns1__createSnapshotResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createSnapshotResponse(struct soap *soap, const struct ns1__createSnapshotResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createSnapshotResponse);
	if (soap_out_ns1__createSnapshotResponse(soap, tag?tag:"ns1:createSnapshotResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createSnapshotResponse * SOAP_FMAC4 soap_get_ns1__createSnapshotResponse(struct soap *soap, struct ns1__createSnapshotResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createSnapshotResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__createSnapshotResponse * SOAP_FMAC2 soap_instantiate_ns1__createSnapshotResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createSnapshotResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createSnapshotResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__createSnapshotResponse);
		if (size)
			*size = sizeof(struct ns1__createSnapshotResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__createSnapshotResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__createSnapshotResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__createSnapshotResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createSnapshotResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__createSnapshotResponse %p -> %p\n", q, p));
	*(struct ns1__createSnapshotResponse*)p = *(struct ns1__createSnapshotResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveRequirementDocument(struct soap *soap, struct ns1__cancelSaveRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveRequirementDocument(struct soap *soap, const struct ns1__cancelSaveRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementDocument * SOAP_FMAC4 soap_in_ns1__cancelSaveRequirementDocument(struct soap *soap, const char *tag, struct ns1__cancelSaveRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveRequirementDocument, sizeof(struct ns1__cancelSaveRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveRequirementDocument, 0, sizeof(struct ns1__cancelSaveRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveRequirementDocument(struct soap *soap, const struct ns1__cancelSaveRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveRequirementDocument);
	if (soap_out_ns1__cancelSaveRequirementDocument(soap, tag?tag:"ns1:cancelSaveRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementDocument * SOAP_FMAC4 soap_get_ns1__cancelSaveRequirementDocument(struct soap *soap, struct ns1__cancelSaveRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__cancelSaveRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__cancelSaveRequirementDocument*)p = *(struct ns1__cancelSaveRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, struct ns1__cancelSaveRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, const struct ns1__cancelSaveRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse, sizeof(struct ns1__cancelSaveRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse, 0, sizeof(struct ns1__cancelSaveRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, const struct ns1__cancelSaveRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse);
	if (soap_out_ns1__cancelSaveRequirementDocumentResponse(soap, tag?tag:"ns1:cancelSaveRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, struct ns1__cancelSaveRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveRequirementDocumentResponse*)p = *(struct ns1__cancelSaveRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveRequirementDocument(struct soap *soap, struct ns1__saveRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveRequirementDocument(struct soap *soap, const struct ns1__saveRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__saveRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveRequirementDocument * SOAP_FMAC4 soap_in_ns1__saveRequirementDocument(struct soap *soap, const char *tag, struct ns1__saveRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveRequirementDocument, sizeof(struct ns1__saveRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveRequirementDocument, 0, sizeof(struct ns1__saveRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveRequirementDocument(struct soap *soap, const struct ns1__saveRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveRequirementDocument);
	if (soap_out_ns1__saveRequirementDocument(soap, tag?tag:"ns1:saveRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveRequirementDocument * SOAP_FMAC4 soap_get_ns1__saveRequirementDocument(struct soap *soap, struct ns1__saveRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__saveRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__saveRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__saveRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__saveRequirementDocument*)p = *(struct ns1__saveRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveRequirementDocumentResponse(struct soap *soap, struct ns1__saveRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveRequirementDocumentResponse(struct soap *soap, const struct ns1__saveRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__saveRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__saveRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveRequirementDocumentResponse, sizeof(struct ns1__saveRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveRequirementDocumentResponse, 0, sizeof(struct ns1__saveRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveRequirementDocumentResponse(struct soap *soap, const struct ns1__saveRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveRequirementDocumentResponse);
	if (soap_out_ns1__saveRequirementDocumentResponse(soap, tag?tag:"ns1:saveRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__saveRequirementDocumentResponse(struct soap *soap, struct ns1__saveRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__saveRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__saveRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__saveRequirementDocumentResponse*)p = *(struct ns1__saveRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementDocumentByRecordID(struct soap *soap, struct ns1__editRequirementDocumentByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementDocumentByRecordID(struct soap *soap, const struct ns1__editRequirementDocumentByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementDocumentByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementDocumentByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementDocumentByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentByRecordID * SOAP_FMAC4 soap_in_ns1__editRequirementDocumentByRecordID(struct soap *soap, const char *tag, struct ns1__editRequirementDocumentByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementDocumentByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementDocumentByRecordID, sizeof(struct ns1__editRequirementDocumentByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementDocumentByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementDocumentByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementDocumentByRecordID, 0, sizeof(struct ns1__editRequirementDocumentByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementDocumentByRecordID(struct soap *soap, const struct ns1__editRequirementDocumentByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementDocumentByRecordID);
	if (soap_out_ns1__editRequirementDocumentByRecordID(soap, tag?tag:"ns1:editRequirementDocumentByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentByRecordID * SOAP_FMAC4 soap_get_ns1__editRequirementDocumentByRecordID(struct soap *soap, struct ns1__editRequirementDocumentByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementDocumentByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementDocumentByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editRequirementDocumentByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementDocumentByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementDocumentByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementDocumentByRecordID);
		if (size)
			*size = sizeof(struct ns1__editRequirementDocumentByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementDocumentByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementDocumentByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementDocumentByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementDocumentByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementDocumentByRecordID %p -> %p\n", q, p));
	*(struct ns1__editRequirementDocumentByRecordID*)p = *(struct ns1__editRequirementDocumentByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__editRequirementDocumentByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__editRequirementDocumentByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementDocumentByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editRequirementDocumentByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementDocumentByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse, sizeof(struct ns1__editRequirementDocumentByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementDocumentByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementDocumentByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse, 0, sizeof(struct ns1__editRequirementDocumentByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__editRequirementDocumentByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse);
	if (soap_out_ns1__editRequirementDocumentByRecordIDResponse(soap, tag?tag:"ns1:editRequirementDocumentByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__editRequirementDocumentByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementDocumentByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementDocumentByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementDocumentByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementDocumentByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementDocumentByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editRequirementDocumentByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementDocumentByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementDocumentByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementDocumentByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementDocumentByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementDocumentByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editRequirementDocumentByRecordIDResponse*)p = *(struct ns1__editRequirementDocumentByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementDocument(struct soap *soap, struct ns1__editRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentNumber);
	soap_default_string(soap, &a->name);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementDocument(struct soap *soap, const struct ns1__editRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentNumber", -1, &a->documentNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementDocument * SOAP_FMAC4 soap_in_ns1__editRequirementDocument(struct soap *soap, const char *tag, struct ns1__editRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentNumber = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementDocument, sizeof(struct ns1__editRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentNumber", &a->documentNumber, "xsd:long"))
				{	soap_flag_documentNumber--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementDocument, 0, sizeof(struct ns1__editRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementDocument(struct soap *soap, const struct ns1__editRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementDocument);
	if (soap_out_ns1__editRequirementDocument(soap, tag?tag:"ns1:editRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementDocument * SOAP_FMAC4 soap_get_ns1__editRequirementDocument(struct soap *soap, struct ns1__editRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__editRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__editRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__editRequirementDocument*)p = *(struct ns1__editRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementDocumentResponse(struct soap *soap, struct ns1__editRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementDocumentResponse(struct soap *soap, const struct ns1__editRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__editRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__editRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementDocumentResponse, sizeof(struct ns1__editRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementDocumentResponse, 0, sizeof(struct ns1__editRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementDocumentResponse(struct soap *soap, const struct ns1__editRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementDocumentResponse);
	if (soap_out_ns1__editRequirementDocumentResponse(soap, tag?tag:"ns1:editRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__editRequirementDocumentResponse(struct soap *soap, struct ns1__editRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__editRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__editRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__editRequirementDocumentResponse*)p = *(struct ns1__editRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, struct ns1__deleteRequirementDocumentByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDeleteAssociatedRequirements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, const struct ns1__deleteRequirementDocumentByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDeleteAssociatedRequirements, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementDocumentByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedRequirements", -1, &a->bDeleteAssociatedRequirements, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentByRecordID * SOAP_FMAC4 soap_in_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, const char *tag, struct ns1__deleteRequirementDocumentByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDeleteAssociatedRequirements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementDocumentByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID, sizeof(struct ns1__deleteRequirementDocumentByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementDocumentByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedRequirements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedRequirements", &a->bDeleteAssociatedRequirements, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedRequirements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementDocumentByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID, 0, sizeof(struct ns1__deleteRequirementDocumentByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDeleteAssociatedRequirements > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, const struct ns1__deleteRequirementDocumentByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID);
	if (soap_out_ns1__deleteRequirementDocumentByRecordID(soap, tag?tag:"ns1:deleteRequirementDocumentByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentByRecordID * SOAP_FMAC4 soap_get_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, struct ns1__deleteRequirementDocumentByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementDocumentByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementDocumentByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementDocumentByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementDocumentByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementDocumentByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementDocumentByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementDocumentByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementDocumentByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementDocumentByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementDocumentByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementDocumentByRecordID*)p = *(struct ns1__deleteRequirementDocumentByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__deleteRequirementDocumentByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__deleteRequirementDocumentByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementDocumentByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteRequirementDocumentByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementDocumentByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse, sizeof(struct ns1__deleteRequirementDocumentByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementDocumentByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementDocumentByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse, 0, sizeof(struct ns1__deleteRequirementDocumentByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__deleteRequirementDocumentByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse);
	if (soap_out_ns1__deleteRequirementDocumentByRecordIDResponse(soap, tag?tag:"ns1:deleteRequirementDocumentByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__deleteRequirementDocumentByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementDocumentByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementDocumentByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementDocumentByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementDocumentByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementDocumentByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementDocumentByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementDocumentByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementDocumentByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementDocumentByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementDocumentByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementDocumentByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementDocumentByRecordIDResponse*)p = *(struct ns1__deleteRequirementDocumentByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementDocument(struct soap *soap, struct ns1__deleteRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentNumber);
	soap_default_string(soap, &a->name);
	soap_default_bool(soap, &a->bDeleteAssociatedRequirements);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementDocument(struct soap *soap, const struct ns1__deleteRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->bDeleteAssociatedRequirements, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentNumber", -1, &a->documentNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedRequirements", -1, &a->bDeleteAssociatedRequirements, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocument * SOAP_FMAC4 soap_in_ns1__deleteRequirementDocument(struct soap *soap, const char *tag, struct ns1__deleteRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentNumber = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_bDeleteAssociatedRequirements = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementDocument, sizeof(struct ns1__deleteRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentNumber", &a->documentNumber, "xsd:long"))
				{	soap_flag_documentNumber--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedRequirements && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedRequirements", &a->bDeleteAssociatedRequirements, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedRequirements--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementDocument, 0, sizeof(struct ns1__deleteRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentNumber > 0 || soap_flag_bDeleteAssociatedRequirements > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementDocument(struct soap *soap, const struct ns1__deleteRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementDocument);
	if (soap_out_ns1__deleteRequirementDocument(soap, tag?tag:"ns1:deleteRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocument * SOAP_FMAC4 soap_get_ns1__deleteRequirementDocument(struct soap *soap, struct ns1__deleteRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementDocument*)p = *(struct ns1__deleteRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementDocumentResponse(struct soap *soap, struct ns1__deleteRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementDocumentResponse(struct soap *soap, const struct ns1__deleteRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__deleteRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__deleteRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementDocumentResponse, sizeof(struct ns1__deleteRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementDocumentResponse, 0, sizeof(struct ns1__deleteRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementDocumentResponse(struct soap *soap, const struct ns1__deleteRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementDocumentResponse);
	if (soap_out_ns1__deleteRequirementDocumentResponse(soap, tag?tag:"ns1:deleteRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__deleteRequirementDocumentResponse(struct soap *soap, struct ns1__deleteRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementDocumentResponse*)p = *(struct ns1__deleteRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addRequirementDocument(struct soap *soap, struct ns1__addRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addRequirementDocument(struct soap *soap, const struct ns1__addRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__addRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addRequirementDocument * SOAP_FMAC4 soap_in_ns1__addRequirementDocument(struct soap *soap, const char *tag, struct ns1__addRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addRequirementDocument, sizeof(struct ns1__addRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addRequirementDocument, 0, sizeof(struct ns1__addRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addRequirementDocument(struct soap *soap, const struct ns1__addRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addRequirementDocument);
	if (soap_out_ns1__addRequirementDocument(soap, tag?tag:"ns1:addRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addRequirementDocument * SOAP_FMAC4 soap_get_ns1__addRequirementDocument(struct soap *soap, struct ns1__addRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__addRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__addRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__addRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__addRequirementDocument*)p = *(struct ns1__addRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addRequirementDocumentResponse(struct soap *soap, struct ns1__addRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addRequirementDocumentResponse(struct soap *soap, const struct ns1__addRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__addRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__addRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__addRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addRequirementDocumentResponse, sizeof(struct ns1__addRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addRequirementDocumentResponse, 0, sizeof(struct ns1__addRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addRequirementDocumentResponse(struct soap *soap, const struct ns1__addRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addRequirementDocumentResponse);
	if (soap_out_ns1__addRequirementDocumentResponse(soap, tag?tag:"ns1:addRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__addRequirementDocumentResponse(struct soap *soap, struct ns1__addRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__addRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__addRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__addRequirementDocumentResponse*)p = *(struct ns1__addRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementDocumentByRecordID(struct soap *soap, struct ns1__getRequirementDocumentByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementDocumentByRecordID(struct soap *soap, const struct ns1__getRequirementDocumentByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementDocumentByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementDocumentByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementDocumentByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentByRecordID * SOAP_FMAC4 soap_in_ns1__getRequirementDocumentByRecordID(struct soap *soap, const char *tag, struct ns1__getRequirementDocumentByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementDocumentByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementDocumentByRecordID, sizeof(struct ns1__getRequirementDocumentByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementDocumentByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementDocumentByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementDocumentByRecordID, 0, sizeof(struct ns1__getRequirementDocumentByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementDocumentByRecordID(struct soap *soap, const struct ns1__getRequirementDocumentByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementDocumentByRecordID);
	if (soap_out_ns1__getRequirementDocumentByRecordID(soap, tag?tag:"ns1:getRequirementDocumentByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentByRecordID * SOAP_FMAC4 soap_get_ns1__getRequirementDocumentByRecordID(struct soap *soap, struct ns1__getRequirementDocumentByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementDocumentByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementDocumentByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getRequirementDocumentByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementDocumentByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementDocumentByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementDocumentByRecordID);
		if (size)
			*size = sizeof(struct ns1__getRequirementDocumentByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementDocumentByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementDocumentByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementDocumentByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementDocumentByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementDocumentByRecordID %p -> %p\n", q, p));
	*(struct ns1__getRequirementDocumentByRecordID*)p = *(struct ns1__getRequirementDocumentByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__getRequirementDocumentByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__getRequirementDocumentByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementDocumentByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getRequirementDocumentByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementDocumentByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse, sizeof(struct ns1__getRequirementDocumentByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementDocumentByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementDocumentByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse, 0, sizeof(struct ns1__getRequirementDocumentByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, const struct ns1__getRequirementDocumentByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse);
	if (soap_out_ns1__getRequirementDocumentByRecordIDResponse(soap, tag?tag:"ns1:getRequirementDocumentByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, struct ns1__getRequirementDocumentByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementDocumentByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementDocumentByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementDocumentByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementDocumentByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementDocumentByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getRequirementDocumentByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementDocumentByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementDocumentByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementDocumentByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementDocumentByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementDocumentByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getRequirementDocumentByRecordIDResponse*)p = *(struct ns1__getRequirementDocumentByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementDocument(struct soap *soap, struct ns1__getRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->documentNumber);
	soap_default_string(soap, &a->name);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementDocument(struct soap *soap, const struct ns1__getRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentNumber", -1, &a->documentNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementDocument * SOAP_FMAC4 soap_in_ns1__getRequirementDocument(struct soap *soap, const char *tag, struct ns1__getRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_documentNumber = 1;
	size_t soap_flag_name = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementDocument, sizeof(struct ns1__getRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_documentNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentNumber", &a->documentNumber, "xsd:long"))
				{	soap_flag_documentNumber--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementDocument, 0, sizeof(struct ns1__getRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_documentNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementDocument(struct soap *soap, const struct ns1__getRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementDocument);
	if (soap_out_ns1__getRequirementDocument(soap, tag?tag:"ns1:getRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementDocument * SOAP_FMAC4 soap_get_ns1__getRequirementDocument(struct soap *soap, struct ns1__getRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__getRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__getRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__getRequirementDocument*)p = *(struct ns1__getRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementDocumentResponse(struct soap *soap, struct ns1__getRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirementDocument = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementDocumentResponse(struct soap *soap, const struct ns1__getRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirementDocument(soap, &a->pRequirementDocument);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", -1, &a->pRequirementDocument, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__getRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__getRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_pRequirementDocument = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementDocumentResponse, sizeof(struct ns1__getRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirementDocument && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirementDocument(soap, "pRequirementDocument", &a->pRequirementDocument, "ns1:CRequirementDocument"))
				{	soap_flag_pRequirementDocument--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementDocumentResponse, 0, sizeof(struct ns1__getRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementDocumentResponse(struct soap *soap, const struct ns1__getRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementDocumentResponse);
	if (soap_out_ns1__getRequirementDocumentResponse(soap, tag?tag:"ns1:getRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__getRequirementDocumentResponse(struct soap *soap, struct ns1__getRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__getRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__getRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__getRequirementDocumentResponse*)p = *(struct ns1__getRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__changeRequirementType(struct soap *soap, struct ns1__changeRequirementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementID);
	soap_default_string(soap, &a->newTypeName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__changeRequirementType(struct soap *soap, const struct ns1__changeRequirementType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->newTypeName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__changeRequirementType(struct soap *soap, const char *tag, int id, const struct ns1__changeRequirementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__changeRequirementType), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementID", -1, &a->requirementID, ""))
		return soap->error;
	if (soap_out_string(soap, "newTypeName", -1, &a->newTypeName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__changeRequirementType * SOAP_FMAC4 soap_in_ns1__changeRequirementType(struct soap *soap, const char *tag, struct ns1__changeRequirementType *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementID = 1;
	size_t soap_flag_newTypeName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__changeRequirementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__changeRequirementType, sizeof(struct ns1__changeRequirementType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__changeRequirementType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementID", &a->requirementID, "xsd:long"))
				{	soap_flag_requirementID--;
					continue;
				}
			if (soap_flag_newTypeName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "newTypeName", &a->newTypeName, "xsd:string"))
				{	soap_flag_newTypeName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__changeRequirementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__changeRequirementType, 0, sizeof(struct ns1__changeRequirementType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__changeRequirementType(struct soap *soap, const struct ns1__changeRequirementType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__changeRequirementType);
	if (soap_out_ns1__changeRequirementType(soap, tag?tag:"ns1:changeRequirementType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__changeRequirementType * SOAP_FMAC4 soap_get_ns1__changeRequirementType(struct soap *soap, struct ns1__changeRequirementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__changeRequirementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__changeRequirementType * SOAP_FMAC2 soap_instantiate_ns1__changeRequirementType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__changeRequirementType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__changeRequirementType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__changeRequirementType);
		if (size)
			*size = sizeof(struct ns1__changeRequirementType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__changeRequirementType, n);
		if (size)
			*size = n * sizeof(struct ns1__changeRequirementType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__changeRequirementType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__changeRequirementType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__changeRequirementType %p -> %p\n", q, p));
	*(struct ns1__changeRequirementType*)p = *(struct ns1__changeRequirementType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__changeRequirementTypeResponse(struct soap *soap, struct ns1__changeRequirementTypeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__changeRequirementTypeResponse(struct soap *soap, const struct ns1__changeRequirementTypeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__changeRequirementTypeResponse(struct soap *soap, const char *tag, int id, const struct ns1__changeRequirementTypeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__changeRequirementTypeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__changeRequirementTypeResponse * SOAP_FMAC4 soap_in_ns1__changeRequirementTypeResponse(struct soap *soap, const char *tag, struct ns1__changeRequirementTypeResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__changeRequirementTypeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__changeRequirementTypeResponse, sizeof(struct ns1__changeRequirementTypeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__changeRequirementTypeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__changeRequirementTypeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__changeRequirementTypeResponse, 0, sizeof(struct ns1__changeRequirementTypeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__changeRequirementTypeResponse(struct soap *soap, const struct ns1__changeRequirementTypeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__changeRequirementTypeResponse);
	if (soap_out_ns1__changeRequirementTypeResponse(soap, tag?tag:"ns1:changeRequirementTypeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__changeRequirementTypeResponse * SOAP_FMAC4 soap_get_ns1__changeRequirementTypeResponse(struct soap *soap, struct ns1__changeRequirementTypeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__changeRequirementTypeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__changeRequirementTypeResponse * SOAP_FMAC2 soap_instantiate_ns1__changeRequirementTypeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__changeRequirementTypeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__changeRequirementTypeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__changeRequirementTypeResponse);
		if (size)
			*size = sizeof(struct ns1__changeRequirementTypeResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__changeRequirementTypeResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__changeRequirementTypeResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__changeRequirementTypeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__changeRequirementTypeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__changeRequirementTypeResponse %p -> %p\n", q, p));
	*(struct ns1__changeRequirementTypeResponse*)p = *(struct ns1__changeRequirementTypeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocumentIDsForRequirement(struct soap *soap, struct ns1__getDocumentIDsForRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocumentIDsForRequirement(struct soap *soap, const struct ns1__getDocumentIDsForRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocumentIDsForRequirement(struct soap *soap, const char *tag, int id, const struct ns1__getDocumentIDsForRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocumentIDsForRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementID", -1, &a->requirementID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocumentIDsForRequirement * SOAP_FMAC4 soap_in_ns1__getDocumentIDsForRequirement(struct soap *soap, const char *tag, struct ns1__getDocumentIDsForRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocumentIDsForRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocumentIDsForRequirement, sizeof(struct ns1__getDocumentIDsForRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocumentIDsForRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementID", &a->requirementID, "xsd:long"))
				{	soap_flag_requirementID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocumentIDsForRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocumentIDsForRequirement, 0, sizeof(struct ns1__getDocumentIDsForRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocumentIDsForRequirement(struct soap *soap, const struct ns1__getDocumentIDsForRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDocumentIDsForRequirement);
	if (soap_out_ns1__getDocumentIDsForRequirement(soap, tag?tag:"ns1:getDocumentIDsForRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocumentIDsForRequirement * SOAP_FMAC4 soap_get_ns1__getDocumentIDsForRequirement(struct soap *soap, struct ns1__getDocumentIDsForRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocumentIDsForRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDocumentIDsForRequirement * SOAP_FMAC2 soap_instantiate_ns1__getDocumentIDsForRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocumentIDsForRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDocumentIDsForRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDocumentIDsForRequirement);
		if (size)
			*size = sizeof(struct ns1__getDocumentIDsForRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDocumentIDsForRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__getDocumentIDsForRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDocumentIDsForRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDocumentIDsForRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDocumentIDsForRequirement %p -> %p\n", q, p));
	*(struct ns1__getDocumentIDsForRequirement*)p = *(struct ns1__getDocumentIDsForRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, struct ns1__getDocumentIDsForRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->recordIDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, const struct ns1__getDocumentIDsForRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOflong(soap, &a->recordIDs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDocumentIDsForRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOflong(soap, "recordIDs", -1, &a->recordIDs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocumentIDsForRequirementResponse * SOAP_FMAC4 soap_in_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, const char *tag, struct ns1__getDocumentIDsForRequirementResponse *a, const char *type)
{
	size_t soap_flag_recordIDs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocumentIDsForRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse, sizeof(struct ns1__getDocumentIDsForRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocumentIDsForRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordIDs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOflong(soap, "recordIDs", &a->recordIDs, "xsd:long"))
				{	soap_flag_recordIDs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocumentIDsForRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse, 0, sizeof(struct ns1__getDocumentIDsForRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, const struct ns1__getDocumentIDsForRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse);
	if (soap_out_ns1__getDocumentIDsForRequirementResponse(soap, tag?tag:"ns1:getDocumentIDsForRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocumentIDsForRequirementResponse * SOAP_FMAC4 soap_get_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, struct ns1__getDocumentIDsForRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocumentIDsForRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDocumentIDsForRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocumentIDsForRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDocumentIDsForRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDocumentIDsForRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__getDocumentIDsForRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDocumentIDsForRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDocumentIDsForRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDocumentIDsForRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDocumentIDsForRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDocumentIDsForRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__getDocumentIDsForRequirementResponse*)p = *(struct ns1__getDocumentIDsForRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__appendToRequirementDocument(struct soap *soap, struct ns1__appendToRequirementDocument *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementID);
	soap_default_LONG64(soap, &a->documentID);
	soap_default_LONG64(soap, &a->parentRequirementID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__appendToRequirementDocument(struct soap *soap, const struct ns1__appendToRequirementDocument *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->documentID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->parentRequirementID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__appendToRequirementDocument(struct soap *soap, const char *tag, int id, const struct ns1__appendToRequirementDocument *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__appendToRequirementDocument), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementID", -1, &a->requirementID, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "documentID", -1, &a->documentID, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "parentRequirementID", -1, &a->parentRequirementID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__appendToRequirementDocument * SOAP_FMAC4 soap_in_ns1__appendToRequirementDocument(struct soap *soap, const char *tag, struct ns1__appendToRequirementDocument *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementID = 1;
	size_t soap_flag_documentID = 1;
	size_t soap_flag_parentRequirementID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__appendToRequirementDocument *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__appendToRequirementDocument, sizeof(struct ns1__appendToRequirementDocument), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__appendToRequirementDocument(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementID", &a->requirementID, "xsd:long"))
				{	soap_flag_requirementID--;
					continue;
				}
			if (soap_flag_documentID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "documentID", &a->documentID, "xsd:long"))
				{	soap_flag_documentID--;
					continue;
				}
			if (soap_flag_parentRequirementID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "parentRequirementID", &a->parentRequirementID, "xsd:long"))
				{	soap_flag_parentRequirementID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__appendToRequirementDocument *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__appendToRequirementDocument, 0, sizeof(struct ns1__appendToRequirementDocument), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementID > 0 || soap_flag_documentID > 0 || soap_flag_parentRequirementID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__appendToRequirementDocument(struct soap *soap, const struct ns1__appendToRequirementDocument *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__appendToRequirementDocument);
	if (soap_out_ns1__appendToRequirementDocument(soap, tag?tag:"ns1:appendToRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__appendToRequirementDocument * SOAP_FMAC4 soap_get_ns1__appendToRequirementDocument(struct soap *soap, struct ns1__appendToRequirementDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__appendToRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__appendToRequirementDocument * SOAP_FMAC2 soap_instantiate_ns1__appendToRequirementDocument(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__appendToRequirementDocument(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__appendToRequirementDocument, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__appendToRequirementDocument);
		if (size)
			*size = sizeof(struct ns1__appendToRequirementDocument);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__appendToRequirementDocument, n);
		if (size)
			*size = n * sizeof(struct ns1__appendToRequirementDocument);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__appendToRequirementDocument*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__appendToRequirementDocument(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__appendToRequirementDocument %p -> %p\n", q, p));
	*(struct ns1__appendToRequirementDocument*)p = *(struct ns1__appendToRequirementDocument*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__appendToRequirementDocumentResponse(struct soap *soap, struct ns1__appendToRequirementDocumentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__appendToRequirementDocumentResponse(struct soap *soap, const struct ns1__appendToRequirementDocumentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__appendToRequirementDocumentResponse(struct soap *soap, const char *tag, int id, const struct ns1__appendToRequirementDocumentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__appendToRequirementDocumentResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__appendToRequirementDocumentResponse * SOAP_FMAC4 soap_in_ns1__appendToRequirementDocumentResponse(struct soap *soap, const char *tag, struct ns1__appendToRequirementDocumentResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__appendToRequirementDocumentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__appendToRequirementDocumentResponse, sizeof(struct ns1__appendToRequirementDocumentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__appendToRequirementDocumentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__appendToRequirementDocumentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__appendToRequirementDocumentResponse, 0, sizeof(struct ns1__appendToRequirementDocumentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__appendToRequirementDocumentResponse(struct soap *soap, const struct ns1__appendToRequirementDocumentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__appendToRequirementDocumentResponse);
	if (soap_out_ns1__appendToRequirementDocumentResponse(soap, tag?tag:"ns1:appendToRequirementDocumentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__appendToRequirementDocumentResponse * SOAP_FMAC4 soap_get_ns1__appendToRequirementDocumentResponse(struct soap *soap, struct ns1__appendToRequirementDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__appendToRequirementDocumentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__appendToRequirementDocumentResponse * SOAP_FMAC2 soap_instantiate_ns1__appendToRequirementDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__appendToRequirementDocumentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__appendToRequirementDocumentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__appendToRequirementDocumentResponse);
		if (size)
			*size = sizeof(struct ns1__appendToRequirementDocumentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__appendToRequirementDocumentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__appendToRequirementDocumentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__appendToRequirementDocumentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__appendToRequirementDocumentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__appendToRequirementDocumentResponse %p -> %p\n", q, p));
	*(struct ns1__appendToRequirementDocumentResponse*)p = *(struct ns1__appendToRequirementDocumentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveRequirement(struct soap *soap, struct ns1__cancelSaveRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveRequirement(struct soap *soap, const struct ns1__cancelSaveRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveRequirement(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirement * SOAP_FMAC4 soap_in_ns1__cancelSaveRequirement(struct soap *soap, const char *tag, struct ns1__cancelSaveRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveRequirement, sizeof(struct ns1__cancelSaveRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveRequirement, 0, sizeof(struct ns1__cancelSaveRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveRequirement(struct soap *soap, const struct ns1__cancelSaveRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveRequirement);
	if (soap_out_ns1__cancelSaveRequirement(soap, tag?tag:"ns1:cancelSaveRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirement * SOAP_FMAC4 soap_get_ns1__cancelSaveRequirement(struct soap *soap, struct ns1__cancelSaveRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveRequirement * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveRequirement);
		if (size)
			*size = sizeof(struct ns1__cancelSaveRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveRequirement %p -> %p\n", q, p));
	*(struct ns1__cancelSaveRequirement*)p = *(struct ns1__cancelSaveRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveRequirementResponse(struct soap *soap, struct ns1__cancelSaveRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveRequirementResponse(struct soap *soap, const struct ns1__cancelSaveRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveRequirementResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveRequirementResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveRequirementResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveRequirementResponse, sizeof(struct ns1__cancelSaveRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveRequirementResponse, 0, sizeof(struct ns1__cancelSaveRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveRequirementResponse(struct soap *soap, const struct ns1__cancelSaveRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveRequirementResponse);
	if (soap_out_ns1__cancelSaveRequirementResponse(soap, tag?tag:"ns1:cancelSaveRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveRequirementResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveRequirementResponse(struct soap *soap, struct ns1__cancelSaveRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveRequirementResponse*)p = *(struct ns1__cancelSaveRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveRequirement(struct soap *soap, struct ns1__saveRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveRequirement(struct soap *soap, const struct ns1__saveRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveRequirement(struct soap *soap, const char *tag, int id, const struct ns1__saveRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveRequirement * SOAP_FMAC4 soap_in_ns1__saveRequirement(struct soap *soap, const char *tag, struct ns1__saveRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveRequirement, sizeof(struct ns1__saveRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveRequirement, 0, sizeof(struct ns1__saveRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveRequirement(struct soap *soap, const struct ns1__saveRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveRequirement);
	if (soap_out_ns1__saveRequirement(soap, tag?tag:"ns1:saveRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveRequirement * SOAP_FMAC4 soap_get_ns1__saveRequirement(struct soap *soap, struct ns1__saveRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveRequirement * SOAP_FMAC2 soap_instantiate_ns1__saveRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveRequirement);
		if (size)
			*size = sizeof(struct ns1__saveRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__saveRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveRequirement %p -> %p\n", q, p));
	*(struct ns1__saveRequirement*)p = *(struct ns1__saveRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveRequirementResponse(struct soap *soap, struct ns1__saveRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveRequirementResponse(struct soap *soap, const struct ns1__saveRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveRequirementResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveRequirementResponse * SOAP_FMAC4 soap_in_ns1__saveRequirementResponse(struct soap *soap, const char *tag, struct ns1__saveRequirementResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveRequirementResponse, sizeof(struct ns1__saveRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveRequirementResponse, 0, sizeof(struct ns1__saveRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveRequirementResponse(struct soap *soap, const struct ns1__saveRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveRequirementResponse);
	if (soap_out_ns1__saveRequirementResponse(soap, tag?tag:"ns1:saveRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveRequirementResponse * SOAP_FMAC4 soap_get_ns1__saveRequirementResponse(struct soap *soap, struct ns1__saveRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__saveRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__saveRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__saveRequirementResponse*)p = *(struct ns1__saveRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementByRecordID(struct soap *soap, struct ns1__editRequirementByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementByRecordID(struct soap *soap, const struct ns1__editRequirementByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementByRecordID * SOAP_FMAC4 soap_in_ns1__editRequirementByRecordID(struct soap *soap, const char *tag, struct ns1__editRequirementByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementByRecordID, sizeof(struct ns1__editRequirementByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementByRecordID, 0, sizeof(struct ns1__editRequirementByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementByRecordID(struct soap *soap, const struct ns1__editRequirementByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementByRecordID);
	if (soap_out_ns1__editRequirementByRecordID(soap, tag?tag:"ns1:editRequirementByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementByRecordID * SOAP_FMAC4 soap_get_ns1__editRequirementByRecordID(struct soap *soap, struct ns1__editRequirementByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editRequirementByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementByRecordID);
		if (size)
			*size = sizeof(struct ns1__editRequirementByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementByRecordID %p -> %p\n", q, p));
	*(struct ns1__editRequirementByRecordID*)p = *(struct ns1__editRequirementByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementByRecordIDResponse(struct soap *soap, struct ns1__editRequirementByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementByRecordIDResponse(struct soap *soap, const struct ns1__editRequirementByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editRequirementByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editRequirementByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementByRecordIDResponse, sizeof(struct ns1__editRequirementByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementByRecordIDResponse, 0, sizeof(struct ns1__editRequirementByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementByRecordIDResponse(struct soap *soap, const struct ns1__editRequirementByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementByRecordIDResponse);
	if (soap_out_ns1__editRequirementByRecordIDResponse(soap, tag?tag:"ns1:editRequirementByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editRequirementByRecordIDResponse(struct soap *soap, struct ns1__editRequirementByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editRequirementByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editRequirementByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editRequirementByRecordIDResponse*)p = *(struct ns1__editRequirementByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirement(struct soap *soap, struct ns1__editRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirement(struct soap *soap, const struct ns1__editRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirement(struct soap *soap, const char *tag, int id, const struct ns1__editRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementNumber", -1, &a->requirementNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirement * SOAP_FMAC4 soap_in_ns1__editRequirement(struct soap *soap, const char *tag, struct ns1__editRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirement, sizeof(struct ns1__editRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementNumber", &a->requirementNumber, "xsd:long"))
				{	soap_flag_requirementNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirement, 0, sizeof(struct ns1__editRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirement(struct soap *soap, const struct ns1__editRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirement);
	if (soap_out_ns1__editRequirement(soap, tag?tag:"ns1:editRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirement * SOAP_FMAC4 soap_get_ns1__editRequirement(struct soap *soap, struct ns1__editRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirement * SOAP_FMAC2 soap_instantiate_ns1__editRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirement);
		if (size)
			*size = sizeof(struct ns1__editRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirement %p -> %p\n", q, p));
	*(struct ns1__editRequirement*)p = *(struct ns1__editRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editRequirementResponse(struct soap *soap, struct ns1__editRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editRequirementResponse(struct soap *soap, const struct ns1__editRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__editRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editRequirementResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editRequirementResponse * SOAP_FMAC4 soap_in_ns1__editRequirementResponse(struct soap *soap, const char *tag, struct ns1__editRequirementResponse *a, const char *type)
{
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editRequirementResponse, sizeof(struct ns1__editRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editRequirementResponse, 0, sizeof(struct ns1__editRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editRequirementResponse(struct soap *soap, const struct ns1__editRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editRequirementResponse);
	if (soap_out_ns1__editRequirementResponse(soap, tag?tag:"ns1:editRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editRequirementResponse * SOAP_FMAC4 soap_get_ns1__editRequirementResponse(struct soap *soap, struct ns1__editRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__editRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__editRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__editRequirementResponse*)p = *(struct ns1__editRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementByRecordID(struct soap *soap, struct ns1__deleteRequirementByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementByRecordID(struct soap *soap, const struct ns1__deleteRequirementByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementByRecordID * SOAP_FMAC4 soap_in_ns1__deleteRequirementByRecordID(struct soap *soap, const char *tag, struct ns1__deleteRequirementByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementByRecordID, sizeof(struct ns1__deleteRequirementByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementByRecordID, 0, sizeof(struct ns1__deleteRequirementByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementByRecordID(struct soap *soap, const struct ns1__deleteRequirementByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementByRecordID);
	if (soap_out_ns1__deleteRequirementByRecordID(soap, tag?tag:"ns1:deleteRequirementByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementByRecordID * SOAP_FMAC4 soap_get_ns1__deleteRequirementByRecordID(struct soap *soap, struct ns1__deleteRequirementByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementByRecordID*)p = *(struct ns1__deleteRequirementByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, struct ns1__deleteRequirementByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, const struct ns1__deleteRequirementByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteRequirementByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse, sizeof(struct ns1__deleteRequirementByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse, 0, sizeof(struct ns1__deleteRequirementByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, const struct ns1__deleteRequirementByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse);
	if (soap_out_ns1__deleteRequirementByRecordIDResponse(soap, tag?tag:"ns1:deleteRequirementByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, struct ns1__deleteRequirementByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementByRecordIDResponse*)p = *(struct ns1__deleteRequirementByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirement(struct soap *soap, struct ns1__deleteRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementNumber);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirement(struct soap *soap, const struct ns1__deleteRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirement(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementNumber", -1, &a->requirementNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirement * SOAP_FMAC4 soap_in_ns1__deleteRequirement(struct soap *soap, const char *tag, struct ns1__deleteRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementNumber = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirement, sizeof(struct ns1__deleteRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementNumber", &a->requirementNumber, "xsd:long"))
				{	soap_flag_requirementNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirement, 0, sizeof(struct ns1__deleteRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirement(struct soap *soap, const struct ns1__deleteRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirement);
	if (soap_out_ns1__deleteRequirement(soap, tag?tag:"ns1:deleteRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirement * SOAP_FMAC4 soap_get_ns1__deleteRequirement(struct soap *soap, struct ns1__deleteRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirement * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirement);
		if (size)
			*size = sizeof(struct ns1__deleteRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirement %p -> %p\n", q, p));
	*(struct ns1__deleteRequirement*)p = *(struct ns1__deleteRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteRequirementResponse(struct soap *soap, struct ns1__deleteRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteRequirementResponse(struct soap *soap, const struct ns1__deleteRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteRequirementResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteRequirementResponse * SOAP_FMAC4 soap_in_ns1__deleteRequirementResponse(struct soap *soap, const char *tag, struct ns1__deleteRequirementResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteRequirementResponse, sizeof(struct ns1__deleteRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteRequirementResponse, 0, sizeof(struct ns1__deleteRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteRequirementResponse(struct soap *soap, const struct ns1__deleteRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteRequirementResponse);
	if (soap_out_ns1__deleteRequirementResponse(soap, tag?tag:"ns1:deleteRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteRequirementResponse * SOAP_FMAC4 soap_get_ns1__deleteRequirementResponse(struct soap *soap, struct ns1__deleteRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__deleteRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__deleteRequirementResponse*)p = *(struct ns1__deleteRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addRequirement(struct soap *soap, struct ns1__addRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addRequirement(struct soap *soap, const struct ns1__addRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addRequirement(struct soap *soap, const char *tag, int id, const struct ns1__addRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addRequirement * SOAP_FMAC4 soap_in_ns1__addRequirement(struct soap *soap, const char *tag, struct ns1__addRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addRequirement, sizeof(struct ns1__addRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addRequirement, 0, sizeof(struct ns1__addRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addRequirement(struct soap *soap, const struct ns1__addRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addRequirement);
	if (soap_out_ns1__addRequirement(soap, tag?tag:"ns1:addRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addRequirement * SOAP_FMAC4 soap_get_ns1__addRequirement(struct soap *soap, struct ns1__addRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addRequirement * SOAP_FMAC2 soap_instantiate_ns1__addRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addRequirement);
		if (size)
			*size = sizeof(struct ns1__addRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__addRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addRequirement %p -> %p\n", q, p));
	*(struct ns1__addRequirement*)p = *(struct ns1__addRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addRequirementResponse(struct soap *soap, struct ns1__addRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addRequirementResponse(struct soap *soap, const struct ns1__addRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__addRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addRequirementResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addRequirementResponse * SOAP_FMAC4 soap_in_ns1__addRequirementResponse(struct soap *soap, const char *tag, struct ns1__addRequirementResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addRequirementResponse, sizeof(struct ns1__addRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addRequirementResponse, 0, sizeof(struct ns1__addRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addRequirementResponse(struct soap *soap, const struct ns1__addRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addRequirementResponse);
	if (soap_out_ns1__addRequirementResponse(soap, tag?tag:"ns1:addRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addRequirementResponse * SOAP_FMAC4 soap_get_ns1__addRequirementResponse(struct soap *soap, struct ns1__addRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__addRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__addRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__addRequirementResponse*)p = *(struct ns1__addRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementByRecordID(struct soap *soap, struct ns1__getRequirementByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementByRecordID(struct soap *soap, const struct ns1__getRequirementByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementByRecordID * SOAP_FMAC4 soap_in_ns1__getRequirementByRecordID(struct soap *soap, const char *tag, struct ns1__getRequirementByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementByRecordID, sizeof(struct ns1__getRequirementByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementByRecordID, 0, sizeof(struct ns1__getRequirementByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementByRecordID(struct soap *soap, const struct ns1__getRequirementByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementByRecordID);
	if (soap_out_ns1__getRequirementByRecordID(soap, tag?tag:"ns1:getRequirementByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementByRecordID * SOAP_FMAC4 soap_get_ns1__getRequirementByRecordID(struct soap *soap, struct ns1__getRequirementByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getRequirementByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementByRecordID);
		if (size)
			*size = sizeof(struct ns1__getRequirementByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementByRecordID %p -> %p\n", q, p));
	*(struct ns1__getRequirementByRecordID*)p = *(struct ns1__getRequirementByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementByRecordIDResponse(struct soap *soap, struct ns1__getRequirementByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementByRecordIDResponse(struct soap *soap, const struct ns1__getRequirementByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getRequirementByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getRequirementByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementByRecordIDResponse, sizeof(struct ns1__getRequirementByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementByRecordIDResponse, 0, sizeof(struct ns1__getRequirementByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementByRecordIDResponse(struct soap *soap, const struct ns1__getRequirementByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementByRecordIDResponse);
	if (soap_out_ns1__getRequirementByRecordIDResponse(soap, tag?tag:"ns1:getRequirementByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getRequirementByRecordIDResponse(struct soap *soap, struct ns1__getRequirementByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getRequirementByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getRequirementByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getRequirementByRecordIDResponse*)p = *(struct ns1__getRequirementByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirement(struct soap *soap, struct ns1__getRequirement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->requirementNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirement(struct soap *soap, const struct ns1__getRequirement *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->requirementNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirement(struct soap *soap, const char *tag, int id, const struct ns1__getRequirement *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirement), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "requirementNumber", -1, &a->requirementNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirement * SOAP_FMAC4 soap_in_ns1__getRequirement(struct soap *soap, const char *tag, struct ns1__getRequirement *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_requirementNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirement, sizeof(struct ns1__getRequirement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_requirementNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "requirementNumber", &a->requirementNumber, "xsd:long"))
				{	soap_flag_requirementNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirement, 0, sizeof(struct ns1__getRequirement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_requirementNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirement(struct soap *soap, const struct ns1__getRequirement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirement);
	if (soap_out_ns1__getRequirement(soap, tag?tag:"ns1:getRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirement * SOAP_FMAC4 soap_get_ns1__getRequirement(struct soap *soap, struct ns1__getRequirement *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirement * SOAP_FMAC2 soap_instantiate_ns1__getRequirement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirement);
		if (size)
			*size = sizeof(struct ns1__getRequirement);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirement, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirement);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirement*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirement %p -> %p\n", q, p));
	*(struct ns1__getRequirement*)p = *(struct ns1__getRequirement*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRequirementResponse(struct soap *soap, struct ns1__getRequirementResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pRequirement = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRequirementResponse(struct soap *soap, const struct ns1__getRequirementResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRequirement(soap, &a->pRequirement);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRequirementResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRequirementResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRequirementResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRequirement(soap, "pRequirement", -1, &a->pRequirement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRequirementResponse * SOAP_FMAC4 soap_in_ns1__getRequirementResponse(struct soap *soap, const char *tag, struct ns1__getRequirementResponse *a, const char *type)
{
	size_t soap_flag_pRequirement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRequirementResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRequirementResponse, sizeof(struct ns1__getRequirementResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRequirementResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pRequirement && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRequirement(soap, "pRequirement", &a->pRequirement, "ns1:CRequirement"))
				{	soap_flag_pRequirement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRequirementResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRequirementResponse, 0, sizeof(struct ns1__getRequirementResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRequirementResponse(struct soap *soap, const struct ns1__getRequirementResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRequirementResponse);
	if (soap_out_ns1__getRequirementResponse(soap, tag?tag:"ns1:getRequirementResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRequirementResponse * SOAP_FMAC4 soap_get_ns1__getRequirementResponse(struct soap *soap, struct ns1__getRequirementResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRequirementResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRequirementResponse * SOAP_FMAC2 soap_instantiate_ns1__getRequirementResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRequirementResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRequirementResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRequirementResponse);
		if (size)
			*size = sizeof(struct ns1__getRequirementResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRequirementResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRequirementResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRequirementResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRequirementResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRequirementResponse %p -> %p\n", q, p));
	*(struct ns1__getRequirementResponse*)p = *(struct ns1__getRequirementResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveFolderItemRank(struct soap *soap, struct ns1__cancelSaveFolderItemRank *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveFolderItemRank(struct soap *soap, const struct ns1__cancelSaveFolderItemRank *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveFolderItemRank(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveFolderItemRank *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveFolderItemRank), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderItemRank * SOAP_FMAC4 soap_in_ns1__cancelSaveFolderItemRank(struct soap *soap, const char *tag, struct ns1__cancelSaveFolderItemRank *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveFolderItemRank *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveFolderItemRank, sizeof(struct ns1__cancelSaveFolderItemRank), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveFolderItemRank(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveFolderItemRank *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveFolderItemRank, 0, sizeof(struct ns1__cancelSaveFolderItemRank), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveFolderItemRank(struct soap *soap, const struct ns1__cancelSaveFolderItemRank *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveFolderItemRank);
	if (soap_out_ns1__cancelSaveFolderItemRank(soap, tag?tag:"ns1:cancelSaveFolderItemRank", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderItemRank * SOAP_FMAC4 soap_get_ns1__cancelSaveFolderItemRank(struct soap *soap, struct ns1__cancelSaveFolderItemRank *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveFolderItemRank(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveFolderItemRank * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveFolderItemRank(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveFolderItemRank(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveFolderItemRank, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveFolderItemRank);
		if (size)
			*size = sizeof(struct ns1__cancelSaveFolderItemRank);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveFolderItemRank, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveFolderItemRank);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveFolderItemRank*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveFolderItemRank(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveFolderItemRank %p -> %p\n", q, p));
	*(struct ns1__cancelSaveFolderItemRank*)p = *(struct ns1__cancelSaveFolderItemRank*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, struct ns1__cancelSaveFolderItemRankResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, const struct ns1__cancelSaveFolderItemRankResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveFolderItemRankResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderItemRankResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveFolderItemRankResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveFolderItemRankResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse, sizeof(struct ns1__cancelSaveFolderItemRankResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveFolderItemRankResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveFolderItemRankResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse, 0, sizeof(struct ns1__cancelSaveFolderItemRankResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, const struct ns1__cancelSaveFolderItemRankResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse);
	if (soap_out_ns1__cancelSaveFolderItemRankResponse(soap, tag?tag:"ns1:cancelSaveFolderItemRankResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderItemRankResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, struct ns1__cancelSaveFolderItemRankResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveFolderItemRankResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveFolderItemRankResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveFolderItemRankResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveFolderItemRankResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveFolderItemRankResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveFolderItemRankResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveFolderItemRankResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveFolderItemRankResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveFolderItemRankResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveFolderItemRankResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveFolderItemRankResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveFolderItemRankResponse*)p = *(struct ns1__cancelSaveFolderItemRankResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveFolderItemRank(struct soap *soap, struct ns1__saveFolderItemRank *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
	a->folderItemList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveFolderItemRank(struct soap *soap, const struct ns1__saveFolderItemRank *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
	soap_serialize_PointerToArrayOfCFolderItem(soap, &a->folderItemList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveFolderItemRank(struct soap *soap, const char *tag, int id, const struct ns1__saveFolderItemRank *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveFolderItemRank), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFolderItem(soap, "folderItemList", -1, &a->folderItemList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveFolderItemRank * SOAP_FMAC4 soap_in_ns1__saveFolderItemRank(struct soap *soap, const char *tag, struct ns1__saveFolderItemRank *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	size_t soap_flag_folderItemList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveFolderItemRank *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveFolderItemRank, sizeof(struct ns1__saveFolderItemRank), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveFolderItemRank(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap_flag_folderItemList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFolderItem(soap, "folderItemList", &a->folderItemList, "ns1:CFolderItem"))
				{	soap_flag_folderItemList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveFolderItemRank *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveFolderItemRank, 0, sizeof(struct ns1__saveFolderItemRank), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveFolderItemRank(struct soap *soap, const struct ns1__saveFolderItemRank *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveFolderItemRank);
	if (soap_out_ns1__saveFolderItemRank(soap, tag?tag:"ns1:saveFolderItemRank", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveFolderItemRank * SOAP_FMAC4 soap_get_ns1__saveFolderItemRank(struct soap *soap, struct ns1__saveFolderItemRank *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveFolderItemRank(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveFolderItemRank * SOAP_FMAC2 soap_instantiate_ns1__saveFolderItemRank(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveFolderItemRank(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveFolderItemRank, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveFolderItemRank);
		if (size)
			*size = sizeof(struct ns1__saveFolderItemRank);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveFolderItemRank, n);
		if (size)
			*size = n * sizeof(struct ns1__saveFolderItemRank);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveFolderItemRank*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveFolderItemRank(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveFolderItemRank %p -> %p\n", q, p));
	*(struct ns1__saveFolderItemRank*)p = *(struct ns1__saveFolderItemRank*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveFolderItemRankResponse(struct soap *soap, struct ns1__saveFolderItemRankResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveFolderItemRankResponse(struct soap *soap, const struct ns1__saveFolderItemRankResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveFolderItemRankResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveFolderItemRankResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveFolderItemRankResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveFolderItemRankResponse * SOAP_FMAC4 soap_in_ns1__saveFolderItemRankResponse(struct soap *soap, const char *tag, struct ns1__saveFolderItemRankResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveFolderItemRankResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveFolderItemRankResponse, sizeof(struct ns1__saveFolderItemRankResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveFolderItemRankResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveFolderItemRankResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveFolderItemRankResponse, 0, sizeof(struct ns1__saveFolderItemRankResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveFolderItemRankResponse(struct soap *soap, const struct ns1__saveFolderItemRankResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveFolderItemRankResponse);
	if (soap_out_ns1__saveFolderItemRankResponse(soap, tag?tag:"ns1:saveFolderItemRankResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveFolderItemRankResponse * SOAP_FMAC4 soap_get_ns1__saveFolderItemRankResponse(struct soap *soap, struct ns1__saveFolderItemRankResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveFolderItemRankResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveFolderItemRankResponse * SOAP_FMAC2 soap_instantiate_ns1__saveFolderItemRankResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveFolderItemRankResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveFolderItemRankResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveFolderItemRankResponse);
		if (size)
			*size = sizeof(struct ns1__saveFolderItemRankResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveFolderItemRankResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveFolderItemRankResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveFolderItemRankResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveFolderItemRankResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveFolderItemRankResponse %p -> %p\n", q, p));
	*(struct ns1__saveFolderItemRankResponse*)p = *(struct ns1__saveFolderItemRankResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolderItemRank(struct soap *soap, struct ns1__editFolderItemRank *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolderItemRank(struct soap *soap, const struct ns1__editFolderItemRank *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolderItemRank(struct soap *soap, const char *tag, int id, const struct ns1__editFolderItemRank *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolderItemRank), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolderItemRank * SOAP_FMAC4 soap_in_ns1__editFolderItemRank(struct soap *soap, const char *tag, struct ns1__editFolderItemRank *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolderItemRank *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolderItemRank, sizeof(struct ns1__editFolderItemRank), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolderItemRank(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolderItemRank *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolderItemRank, 0, sizeof(struct ns1__editFolderItemRank), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolderItemRank(struct soap *soap, const struct ns1__editFolderItemRank *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolderItemRank);
	if (soap_out_ns1__editFolderItemRank(soap, tag?tag:"ns1:editFolderItemRank", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolderItemRank * SOAP_FMAC4 soap_get_ns1__editFolderItemRank(struct soap *soap, struct ns1__editFolderItemRank *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolderItemRank(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolderItemRank * SOAP_FMAC2 soap_instantiate_ns1__editFolderItemRank(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolderItemRank(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolderItemRank, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolderItemRank);
		if (size)
			*size = sizeof(struct ns1__editFolderItemRank);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolderItemRank, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolderItemRank);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolderItemRank*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolderItemRank(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolderItemRank %p -> %p\n", q, p));
	*(struct ns1__editFolderItemRank*)p = *(struct ns1__editFolderItemRank*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolderItemRankResponse(struct soap *soap, struct ns1__editFolderItemRankResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pEntityList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolderItemRankResponse(struct soap *soap, const struct ns1__editFolderItemRankResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFolderItem(soap, &a->pEntityList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolderItemRankResponse(struct soap *soap, const char *tag, int id, const struct ns1__editFolderItemRankResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolderItemRankResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFolderItem(soap, "pEntityList", -1, &a->pEntityList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolderItemRankResponse * SOAP_FMAC4 soap_in_ns1__editFolderItemRankResponse(struct soap *soap, const char *tag, struct ns1__editFolderItemRankResponse *a, const char *type)
{
	size_t soap_flag_pEntityList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolderItemRankResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolderItemRankResponse, sizeof(struct ns1__editFolderItemRankResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolderItemRankResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pEntityList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFolderItem(soap, "pEntityList", &a->pEntityList, "ns1:CFolderItem"))
				{	soap_flag_pEntityList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolderItemRankResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolderItemRankResponse, 0, sizeof(struct ns1__editFolderItemRankResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolderItemRankResponse(struct soap *soap, const struct ns1__editFolderItemRankResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolderItemRankResponse);
	if (soap_out_ns1__editFolderItemRankResponse(soap, tag?tag:"ns1:editFolderItemRankResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolderItemRankResponse * SOAP_FMAC4 soap_get_ns1__editFolderItemRankResponse(struct soap *soap, struct ns1__editFolderItemRankResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolderItemRankResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolderItemRankResponse * SOAP_FMAC2 soap_instantiate_ns1__editFolderItemRankResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolderItemRankResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolderItemRankResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolderItemRankResponse);
		if (size)
			*size = sizeof(struct ns1__editFolderItemRankResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolderItemRankResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolderItemRankResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolderItemRankResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolderItemRankResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolderItemRankResponse %p -> %p\n", q, p));
	*(struct ns1__editFolderItemRankResponse*)p = *(struct ns1__editFolderItemRankResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRootPrivateFolderPath(struct soap *soap, struct ns1__getRootPrivateFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRootPrivateFolderPath(struct soap *soap, const struct ns1__getRootPrivateFolderPath *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRootPrivateFolderPath(struct soap *soap, const char *tag, int id, const struct ns1__getRootPrivateFolderPath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRootPrivateFolderPath), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRootPrivateFolderPath * SOAP_FMAC4 soap_in_ns1__getRootPrivateFolderPath(struct soap *soap, const char *tag, struct ns1__getRootPrivateFolderPath *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRootPrivateFolderPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRootPrivateFolderPath, sizeof(struct ns1__getRootPrivateFolderPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRootPrivateFolderPath(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRootPrivateFolderPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRootPrivateFolderPath, 0, sizeof(struct ns1__getRootPrivateFolderPath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRootPrivateFolderPath(struct soap *soap, const struct ns1__getRootPrivateFolderPath *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRootPrivateFolderPath);
	if (soap_out_ns1__getRootPrivateFolderPath(soap, tag?tag:"ns1:getRootPrivateFolderPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRootPrivateFolderPath * SOAP_FMAC4 soap_get_ns1__getRootPrivateFolderPath(struct soap *soap, struct ns1__getRootPrivateFolderPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRootPrivateFolderPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRootPrivateFolderPath * SOAP_FMAC2 soap_instantiate_ns1__getRootPrivateFolderPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRootPrivateFolderPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRootPrivateFolderPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRootPrivateFolderPath);
		if (size)
			*size = sizeof(struct ns1__getRootPrivateFolderPath);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRootPrivateFolderPath, n);
		if (size)
			*size = n * sizeof(struct ns1__getRootPrivateFolderPath);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRootPrivateFolderPath*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRootPrivateFolderPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRootPrivateFolderPath %p -> %p\n", q, p));
	*(struct ns1__getRootPrivateFolderPath*)p = *(struct ns1__getRootPrivateFolderPath*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRootPrivateFolderPathResponse(struct soap *soap, struct ns1__getRootPrivateFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->strPrivatePath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRootPrivateFolderPathResponse(struct soap *soap, const struct ns1__getRootPrivateFolderPathResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->strPrivatePath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRootPrivateFolderPathResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRootPrivateFolderPathResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRootPrivateFolderPathResponse), type))
		return soap->error;
	if (a->strPrivatePath)
	{	if (soap_out_string(soap, "strPrivatePath", -1, &a->strPrivatePath, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "strPrivatePath"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRootPrivateFolderPathResponse * SOAP_FMAC4 soap_in_ns1__getRootPrivateFolderPathResponse(struct soap *soap, const char *tag, struct ns1__getRootPrivateFolderPathResponse *a, const char *type)
{
	size_t soap_flag_strPrivatePath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRootPrivateFolderPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRootPrivateFolderPathResponse, sizeof(struct ns1__getRootPrivateFolderPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRootPrivateFolderPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strPrivatePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "strPrivatePath", &a->strPrivatePath, "xsd:string"))
				{	soap_flag_strPrivatePath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRootPrivateFolderPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRootPrivateFolderPathResponse, 0, sizeof(struct ns1__getRootPrivateFolderPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strPrivatePath > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRootPrivateFolderPathResponse(struct soap *soap, const struct ns1__getRootPrivateFolderPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRootPrivateFolderPathResponse);
	if (soap_out_ns1__getRootPrivateFolderPathResponse(soap, tag?tag:"ns1:getRootPrivateFolderPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRootPrivateFolderPathResponse * SOAP_FMAC4 soap_get_ns1__getRootPrivateFolderPathResponse(struct soap *soap, struct ns1__getRootPrivateFolderPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRootPrivateFolderPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRootPrivateFolderPathResponse * SOAP_FMAC2 soap_instantiate_ns1__getRootPrivateFolderPathResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRootPrivateFolderPathResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRootPrivateFolderPathResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRootPrivateFolderPathResponse);
		if (size)
			*size = sizeof(struct ns1__getRootPrivateFolderPathResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRootPrivateFolderPathResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRootPrivateFolderPathResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRootPrivateFolderPathResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRootPrivateFolderPathResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRootPrivateFolderPathResponse %p -> %p\n", q, p));
	*(struct ns1__getRootPrivateFolderPathResponse*)p = *(struct ns1__getRootPrivateFolderPathResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRootPublicFolderPath(struct soap *soap, struct ns1__getRootPublicFolderPath *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRootPublicFolderPath(struct soap *soap, const struct ns1__getRootPublicFolderPath *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRootPublicFolderPath(struct soap *soap, const char *tag, int id, const struct ns1__getRootPublicFolderPath *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRootPublicFolderPath), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRootPublicFolderPath * SOAP_FMAC4 soap_in_ns1__getRootPublicFolderPath(struct soap *soap, const char *tag, struct ns1__getRootPublicFolderPath *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRootPublicFolderPath *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRootPublicFolderPath, sizeof(struct ns1__getRootPublicFolderPath), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRootPublicFolderPath(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRootPublicFolderPath *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRootPublicFolderPath, 0, sizeof(struct ns1__getRootPublicFolderPath), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRootPublicFolderPath(struct soap *soap, const struct ns1__getRootPublicFolderPath *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRootPublicFolderPath);
	if (soap_out_ns1__getRootPublicFolderPath(soap, tag?tag:"ns1:getRootPublicFolderPath", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRootPublicFolderPath * SOAP_FMAC4 soap_get_ns1__getRootPublicFolderPath(struct soap *soap, struct ns1__getRootPublicFolderPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRootPublicFolderPath(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRootPublicFolderPath * SOAP_FMAC2 soap_instantiate_ns1__getRootPublicFolderPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRootPublicFolderPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRootPublicFolderPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRootPublicFolderPath);
		if (size)
			*size = sizeof(struct ns1__getRootPublicFolderPath);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRootPublicFolderPath, n);
		if (size)
			*size = n * sizeof(struct ns1__getRootPublicFolderPath);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRootPublicFolderPath*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRootPublicFolderPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRootPublicFolderPath %p -> %p\n", q, p));
	*(struct ns1__getRootPublicFolderPath*)p = *(struct ns1__getRootPublicFolderPath*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRootPublicFolderPathResponse(struct soap *soap, struct ns1__getRootPublicFolderPathResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->strPublicPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRootPublicFolderPathResponse(struct soap *soap, const struct ns1__getRootPublicFolderPathResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->strPublicPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRootPublicFolderPathResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRootPublicFolderPathResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRootPublicFolderPathResponse), type))
		return soap->error;
	if (a->strPublicPath)
	{	if (soap_out_string(soap, "strPublicPath", -1, &a->strPublicPath, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "strPublicPath"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRootPublicFolderPathResponse * SOAP_FMAC4 soap_in_ns1__getRootPublicFolderPathResponse(struct soap *soap, const char *tag, struct ns1__getRootPublicFolderPathResponse *a, const char *type)
{
	size_t soap_flag_strPublicPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRootPublicFolderPathResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRootPublicFolderPathResponse, sizeof(struct ns1__getRootPublicFolderPathResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRootPublicFolderPathResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_strPublicPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "strPublicPath", &a->strPublicPath, "xsd:string"))
				{	soap_flag_strPublicPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRootPublicFolderPathResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRootPublicFolderPathResponse, 0, sizeof(struct ns1__getRootPublicFolderPathResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_strPublicPath > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRootPublicFolderPathResponse(struct soap *soap, const struct ns1__getRootPublicFolderPathResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRootPublicFolderPathResponse);
	if (soap_out_ns1__getRootPublicFolderPathResponse(soap, tag?tag:"ns1:getRootPublicFolderPathResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRootPublicFolderPathResponse * SOAP_FMAC4 soap_get_ns1__getRootPublicFolderPathResponse(struct soap *soap, struct ns1__getRootPublicFolderPathResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRootPublicFolderPathResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRootPublicFolderPathResponse * SOAP_FMAC2 soap_instantiate_ns1__getRootPublicFolderPathResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRootPublicFolderPathResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRootPublicFolderPathResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRootPublicFolderPathResponse);
		if (size)
			*size = sizeof(struct ns1__getRootPublicFolderPathResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRootPublicFolderPathResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRootPublicFolderPathResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRootPublicFolderPathResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRootPublicFolderPathResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRootPublicFolderPathResponse %p -> %p\n", q, p));
	*(struct ns1__getRootPublicFolderPathResponse*)p = *(struct ns1__getRootPublicFolderPathResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderPathSeparator(struct soap *soap, struct ns1__getFolderPathSeparator *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderPathSeparator(struct soap *soap, const struct ns1__getFolderPathSeparator *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderPathSeparator(struct soap *soap, const char *tag, int id, const struct ns1__getFolderPathSeparator *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderPathSeparator), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderPathSeparator * SOAP_FMAC4 soap_in_ns1__getFolderPathSeparator(struct soap *soap, const char *tag, struct ns1__getFolderPathSeparator *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderPathSeparator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderPathSeparator, sizeof(struct ns1__getFolderPathSeparator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderPathSeparator(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderPathSeparator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderPathSeparator, 0, sizeof(struct ns1__getFolderPathSeparator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderPathSeparator(struct soap *soap, const struct ns1__getFolderPathSeparator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderPathSeparator);
	if (soap_out_ns1__getFolderPathSeparator(soap, tag?tag:"ns1:getFolderPathSeparator", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderPathSeparator * SOAP_FMAC4 soap_get_ns1__getFolderPathSeparator(struct soap *soap, struct ns1__getFolderPathSeparator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderPathSeparator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderPathSeparator * SOAP_FMAC2 soap_instantiate_ns1__getFolderPathSeparator(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderPathSeparator(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderPathSeparator, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderPathSeparator);
		if (size)
			*size = sizeof(struct ns1__getFolderPathSeparator);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderPathSeparator, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderPathSeparator);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderPathSeparator*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderPathSeparator(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderPathSeparator %p -> %p\n", q, p));
	*(struct ns1__getFolderPathSeparator*)p = *(struct ns1__getFolderPathSeparator*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderPathSeparatorResponse(struct soap *soap, struct ns1__getFolderPathSeparatorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__byte(soap, &a->separator);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderPathSeparatorResponse(struct soap *soap, const struct ns1__getFolderPathSeparatorResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderPathSeparatorResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderPathSeparatorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderPathSeparatorResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "separator", -1, &a->separator, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderPathSeparatorResponse * SOAP_FMAC4 soap_in_ns1__getFolderPathSeparatorResponse(struct soap *soap, const char *tag, struct ns1__getFolderPathSeparatorResponse *a, const char *type)
{
	size_t soap_flag_separator = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderPathSeparatorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderPathSeparatorResponse, sizeof(struct ns1__getFolderPathSeparatorResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderPathSeparatorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_separator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "separator", &a->separator, "xsd:byte"))
				{	soap_flag_separator--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderPathSeparatorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderPathSeparatorResponse, 0, sizeof(struct ns1__getFolderPathSeparatorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_separator > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderPathSeparatorResponse(struct soap *soap, const struct ns1__getFolderPathSeparatorResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderPathSeparatorResponse);
	if (soap_out_ns1__getFolderPathSeparatorResponse(soap, tag?tag:"ns1:getFolderPathSeparatorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderPathSeparatorResponse * SOAP_FMAC4 soap_get_ns1__getFolderPathSeparatorResponse(struct soap *soap, struct ns1__getFolderPathSeparatorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderPathSeparatorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderPathSeparatorResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderPathSeparatorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderPathSeparatorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderPathSeparatorResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderPathSeparatorResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderPathSeparatorResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderPathSeparatorResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderPathSeparatorResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderPathSeparatorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderPathSeparatorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderPathSeparatorResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderPathSeparatorResponse*)p = *(struct ns1__getFolderPathSeparatorResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderListForEntityByRecordID(struct soap *soap, struct ns1__getFolderListForEntityByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderListForEntityByRecordID(struct soap *soap, const struct ns1__getFolderListForEntityByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderListForEntityByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getFolderListForEntityByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderListForEntityByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderListForEntityByRecordID * SOAP_FMAC4 soap_in_ns1__getFolderListForEntityByRecordID(struct soap *soap, const char *tag, struct ns1__getFolderListForEntityByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderListForEntityByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderListForEntityByRecordID, sizeof(struct ns1__getFolderListForEntityByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderListForEntityByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderListForEntityByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderListForEntityByRecordID, 0, sizeof(struct ns1__getFolderListForEntityByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderListForEntityByRecordID(struct soap *soap, const struct ns1__getFolderListForEntityByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderListForEntityByRecordID);
	if (soap_out_ns1__getFolderListForEntityByRecordID(soap, tag?tag:"ns1:getFolderListForEntityByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderListForEntityByRecordID * SOAP_FMAC4 soap_get_ns1__getFolderListForEntityByRecordID(struct soap *soap, struct ns1__getFolderListForEntityByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderListForEntityByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderListForEntityByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getFolderListForEntityByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderListForEntityByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderListForEntityByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderListForEntityByRecordID);
		if (size)
			*size = sizeof(struct ns1__getFolderListForEntityByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderListForEntityByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderListForEntityByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderListForEntityByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderListForEntityByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderListForEntityByRecordID %p -> %p\n", q, p));
	*(struct ns1__getFolderListForEntityByRecordID*)p = *(struct ns1__getFolderListForEntityByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, struct ns1__getFolderListForEntityByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolderList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, const struct ns1__getFolderListForEntityByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFolder(soap, &a->pFolderList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderListForEntityByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFolder(soap, "pFolderList", -1, &a->pFolderList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderListForEntityByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getFolderListForEntityByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pFolderList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderListForEntityByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse, sizeof(struct ns1__getFolderListForEntityByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderListForEntityByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolderList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFolder(soap, "pFolderList", &a->pFolderList, "ns1:CFolder"))
				{	soap_flag_pFolderList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderListForEntityByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse, 0, sizeof(struct ns1__getFolderListForEntityByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, const struct ns1__getFolderListForEntityByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse);
	if (soap_out_ns1__getFolderListForEntityByRecordIDResponse(soap, tag?tag:"ns1:getFolderListForEntityByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderListForEntityByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, struct ns1__getFolderListForEntityByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderListForEntityByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderListForEntityByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderListForEntityByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderListForEntityByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderListForEntityByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderListForEntityByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderListForEntityByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderListForEntityByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderListForEntityByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderListForEntityByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderListForEntityByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderListForEntityByRecordIDResponse*)p = *(struct ns1__getFolderListForEntityByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getEntityListForFolderByRecordID(struct soap *soap, struct ns1__getEntityListForFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getEntityListForFolderByRecordID(struct soap *soap, const struct ns1__getEntityListForFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityListForFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getEntityListForFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEntityListForFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getEntityListForFolderByRecordID * SOAP_FMAC4 soap_in_ns1__getEntityListForFolderByRecordID(struct soap *soap, const char *tag, struct ns1__getEntityListForFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getEntityListForFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEntityListForFolderByRecordID, sizeof(struct ns1__getEntityListForFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getEntityListForFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getEntityListForFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEntityListForFolderByRecordID, 0, sizeof(struct ns1__getEntityListForFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getEntityListForFolderByRecordID(struct soap *soap, const struct ns1__getEntityListForFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getEntityListForFolderByRecordID);
	if (soap_out_ns1__getEntityListForFolderByRecordID(soap, tag?tag:"ns1:getEntityListForFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getEntityListForFolderByRecordID * SOAP_FMAC4 soap_get_ns1__getEntityListForFolderByRecordID(struct soap *soap, struct ns1__getEntityListForFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEntityListForFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getEntityListForFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getEntityListForFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityListForFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEntityListForFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getEntityListForFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__getEntityListForFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getEntityListForFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getEntityListForFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getEntityListForFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityListForFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getEntityListForFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__getEntityListForFolderByRecordID*)p = *(struct ns1__getEntityListForFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, struct ns1__getEntityListForFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pEntityList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const struct ns1__getEntityListForFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFolderItem(soap, &a->pEntityList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getEntityListForFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFolderItem(soap, "pEntityList", -1, &a->pEntityList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getEntityListForFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pEntityList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getEntityListForFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse, sizeof(struct ns1__getEntityListForFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getEntityListForFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pEntityList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFolderItem(soap, "pEntityList", &a->pEntityList, "ns1:CFolderItem"))
				{	soap_flag_pEntityList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getEntityListForFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse, 0, sizeof(struct ns1__getEntityListForFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, const struct ns1__getEntityListForFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse);
	if (soap_out_ns1__getEntityListForFolderByRecordIDResponse(soap, tag?tag:"ns1:getEntityListForFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, struct ns1__getEntityListForFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEntityListForFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getEntityListForFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityListForFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEntityListForFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getEntityListForFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getEntityListForFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getEntityListForFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getEntityListForFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getEntityListForFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityListForFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getEntityListForFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getEntityListForFolderByRecordIDResponse*)p = *(struct ns1__getEntityListForFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeEntityFromFolderByRecordID(struct soap *soap, struct ns1__removeEntityFromFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
	a->entity = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeEntityFromFolderByRecordID(struct soap *soap, const struct ns1__removeEntityFromFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
	soap_serialize_PointerTons1__CFolderItem(soap, &a->entity);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeEntityFromFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__removeEntityFromFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeEntityFromFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	if (soap_out_PointerTons1__CFolderItem(soap, "entity", -1, &a->entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeEntityFromFolderByRecordID * SOAP_FMAC4 soap_in_ns1__removeEntityFromFolderByRecordID(struct soap *soap, const char *tag, struct ns1__removeEntityFromFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	size_t soap_flag_entity = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeEntityFromFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeEntityFromFolderByRecordID, sizeof(struct ns1__removeEntityFromFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__removeEntityFromFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap_flag_entity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolderItem(soap, "entity", &a->entity, "ns1:CFolderItem"))
				{	soap_flag_entity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeEntityFromFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeEntityFromFolderByRecordID, 0, sizeof(struct ns1__removeEntityFromFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeEntityFromFolderByRecordID(struct soap *soap, const struct ns1__removeEntityFromFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeEntityFromFolderByRecordID);
	if (soap_out_ns1__removeEntityFromFolderByRecordID(soap, tag?tag:"ns1:removeEntityFromFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeEntityFromFolderByRecordID * SOAP_FMAC4 soap_get_ns1__removeEntityFromFolderByRecordID(struct soap *soap, struct ns1__removeEntityFromFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeEntityFromFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeEntityFromFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__removeEntityFromFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeEntityFromFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeEntityFromFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeEntityFromFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__removeEntityFromFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__removeEntityFromFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__removeEntityFromFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__removeEntityFromFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeEntityFromFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeEntityFromFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__removeEntityFromFolderByRecordID*)p = *(struct ns1__removeEntityFromFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, struct ns1__removeEntityFromFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const struct ns1__removeEntityFromFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__removeEntityFromFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__removeEntityFromFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__removeEntityFromFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse, sizeof(struct ns1__removeEntityFromFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__removeEntityFromFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__removeEntityFromFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse, 0, sizeof(struct ns1__removeEntityFromFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, const struct ns1__removeEntityFromFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse);
	if (soap_out_ns1__removeEntityFromFolderByRecordIDResponse(soap, tag?tag:"ns1:removeEntityFromFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, struct ns1__removeEntityFromFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeEntityFromFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__removeEntityFromFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeEntityFromFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeEntityFromFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__removeEntityFromFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__removeEntityFromFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__removeEntityFromFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__removeEntityFromFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__removeEntityFromFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeEntityFromFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__removeEntityFromFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__removeEntityFromFolderByRecordIDResponse*)p = *(struct ns1__removeEntityFromFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addEntityToFolderByRecordID(struct soap *soap, struct ns1__addEntityToFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
	soap_default_LONG64(soap, &a->entityRecordID);
	soap_default_string(soap, &a->entityTableName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addEntityToFolderByRecordID(struct soap *soap, const struct ns1__addEntityToFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
	soap_embedded(soap, &a->entityRecordID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->entityTableName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addEntityToFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__addEntityToFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addEntityToFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "entityRecordID", -1, &a->entityRecordID, ""))
		return soap->error;
	if (soap_out_string(soap, "entityTableName", -1, &a->entityTableName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addEntityToFolderByRecordID * SOAP_FMAC4 soap_in_ns1__addEntityToFolderByRecordID(struct soap *soap, const char *tag, struct ns1__addEntityToFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	size_t soap_flag_entityRecordID = 1;
	size_t soap_flag_entityTableName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addEntityToFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addEntityToFolderByRecordID, sizeof(struct ns1__addEntityToFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addEntityToFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap_flag_entityRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "entityRecordID", &a->entityRecordID, "xsd:long"))
				{	soap_flag_entityRecordID--;
					continue;
				}
			if (soap_flag_entityTableName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "entityTableName", &a->entityTableName, "xsd:string"))
				{	soap_flag_entityTableName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addEntityToFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addEntityToFolderByRecordID, 0, sizeof(struct ns1__addEntityToFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0 || soap_flag_entityRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addEntityToFolderByRecordID(struct soap *soap, const struct ns1__addEntityToFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addEntityToFolderByRecordID);
	if (soap_out_ns1__addEntityToFolderByRecordID(soap, tag?tag:"ns1:addEntityToFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addEntityToFolderByRecordID * SOAP_FMAC4 soap_get_ns1__addEntityToFolderByRecordID(struct soap *soap, struct ns1__addEntityToFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addEntityToFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addEntityToFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__addEntityToFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addEntityToFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addEntityToFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addEntityToFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__addEntityToFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addEntityToFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__addEntityToFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addEntityToFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addEntityToFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addEntityToFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__addEntityToFolderByRecordID*)p = *(struct ns1__addEntityToFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, struct ns1__addEntityToFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->itemRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, const struct ns1__addEntityToFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->itemRecordID, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__addEntityToFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "itemRecordID", -1, &a->itemRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addEntityToFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__addEntityToFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_itemRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addEntityToFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse, sizeof(struct ns1__addEntityToFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addEntityToFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_itemRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "itemRecordID", &a->itemRecordID, "xsd:int"))
				{	soap_flag_itemRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addEntityToFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse, 0, sizeof(struct ns1__addEntityToFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_itemRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, const struct ns1__addEntityToFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse);
	if (soap_out_ns1__addEntityToFolderByRecordIDResponse(soap, tag?tag:"ns1:addEntityToFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addEntityToFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, struct ns1__addEntityToFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addEntityToFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addEntityToFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addEntityToFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addEntityToFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addEntityToFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__addEntityToFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addEntityToFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addEntityToFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addEntityToFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addEntityToFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addEntityToFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__addEntityToFolderByRecordIDResponse*)p = *(struct ns1__addEntityToFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteFolderByRecordID(struct soap *soap, struct ns1__deleteFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteFolderByRecordID(struct soap *soap, const struct ns1__deleteFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteFolderByRecordID * SOAP_FMAC4 soap_in_ns1__deleteFolderByRecordID(struct soap *soap, const char *tag, struct ns1__deleteFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteFolderByRecordID, sizeof(struct ns1__deleteFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteFolderByRecordID, 0, sizeof(struct ns1__deleteFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteFolderByRecordID(struct soap *soap, const struct ns1__deleteFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteFolderByRecordID);
	if (soap_out_ns1__deleteFolderByRecordID(soap, tag?tag:"ns1:deleteFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteFolderByRecordID * SOAP_FMAC4 soap_get_ns1__deleteFolderByRecordID(struct soap *soap, struct ns1__deleteFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteFolderByRecordID*)p = *(struct ns1__deleteFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteFolderByRecordIDResponse(struct soap *soap, struct ns1__deleteFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteFolderByRecordIDResponse(struct soap *soap, const struct ns1__deleteFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteFolderByRecordIDResponse, sizeof(struct ns1__deleteFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteFolderByRecordIDResponse, 0, sizeof(struct ns1__deleteFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteFolderByRecordIDResponse(struct soap *soap, const struct ns1__deleteFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteFolderByRecordIDResponse);
	if (soap_out_ns1__deleteFolderByRecordIDResponse(soap, tag?tag:"ns1:deleteFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteFolderByRecordIDResponse(struct soap *soap, struct ns1__deleteFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteFolderByRecordIDResponse*)p = *(struct ns1__deleteFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteFolder(struct soap *soap, struct ns1__deleteFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->folderPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteFolder(struct soap *soap, const struct ns1__deleteFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->folderPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteFolder(struct soap *soap, const char *tag, int id, const struct ns1__deleteFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "folderPath", -1, &a->folderPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteFolder * SOAP_FMAC4 soap_in_ns1__deleteFolder(struct soap *soap, const char *tag, struct ns1__deleteFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_folderPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteFolder, sizeof(struct ns1__deleteFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_folderPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "folderPath", &a->folderPath, "xsd:string"))
				{	soap_flag_folderPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteFolder, 0, sizeof(struct ns1__deleteFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteFolder(struct soap *soap, const struct ns1__deleteFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteFolder);
	if (soap_out_ns1__deleteFolder(soap, tag?tag:"ns1:deleteFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteFolder * SOAP_FMAC4 soap_get_ns1__deleteFolder(struct soap *soap, struct ns1__deleteFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteFolder * SOAP_FMAC2 soap_instantiate_ns1__deleteFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteFolder);
		if (size)
			*size = sizeof(struct ns1__deleteFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteFolder %p -> %p\n", q, p));
	*(struct ns1__deleteFolder*)p = *(struct ns1__deleteFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteFolderResponse(struct soap *soap, struct ns1__deleteFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteFolderResponse(struct soap *soap, const struct ns1__deleteFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteFolderResponse * SOAP_FMAC4 soap_in_ns1__deleteFolderResponse(struct soap *soap, const char *tag, struct ns1__deleteFolderResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteFolderResponse, sizeof(struct ns1__deleteFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteFolderResponse, 0, sizeof(struct ns1__deleteFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteFolderResponse(struct soap *soap, const struct ns1__deleteFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteFolderResponse);
	if (soap_out_ns1__deleteFolderResponse(soap, tag?tag:"ns1:deleteFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteFolderResponse * SOAP_FMAC4 soap_get_ns1__deleteFolderResponse(struct soap *soap, struct ns1__deleteFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteFolderResponse);
		if (size)
			*size = sizeof(struct ns1__deleteFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteFolderResponse %p -> %p\n", q, p));
	*(struct ns1__deleteFolderResponse*)p = *(struct ns1__deleteFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderByRecordID(struct soap *soap, struct ns1__getFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderByRecordID(struct soap *soap, const struct ns1__getFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderByRecordID * SOAP_FMAC4 soap_in_ns1__getFolderByRecordID(struct soap *soap, const char *tag, struct ns1__getFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderByRecordID, sizeof(struct ns1__getFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderByRecordID, 0, sizeof(struct ns1__getFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderByRecordID(struct soap *soap, const struct ns1__getFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderByRecordID);
	if (soap_out_ns1__getFolderByRecordID(soap, tag?tag:"ns1:getFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderByRecordID * SOAP_FMAC4 soap_get_ns1__getFolderByRecordID(struct soap *soap, struct ns1__getFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__getFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__getFolderByRecordID*)p = *(struct ns1__getFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderByRecordIDResponse(struct soap *soap, struct ns1__getFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderByRecordIDResponse(struct soap *soap, const struct ns1__getFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderByRecordIDResponse, sizeof(struct ns1__getFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderByRecordIDResponse, 0, sizeof(struct ns1__getFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderByRecordIDResponse(struct soap *soap, const struct ns1__getFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderByRecordIDResponse);
	if (soap_out_ns1__getFolderByRecordIDResponse(soap, tag?tag:"ns1:getFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getFolderByRecordIDResponse(struct soap *soap, struct ns1__getFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderByRecordIDResponse*)p = *(struct ns1__getFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolder(struct soap *soap, struct ns1__getFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->path);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolder(struct soap *soap, const struct ns1__getFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->path);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolder(struct soap *soap, const char *tag, int id, const struct ns1__getFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "path", -1, &a->path, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolder * SOAP_FMAC4 soap_in_ns1__getFolder(struct soap *soap, const char *tag, struct ns1__getFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_path = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolder, sizeof(struct ns1__getFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_path && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "path", &a->path, "xsd:string"))
				{	soap_flag_path--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolder, 0, sizeof(struct ns1__getFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolder(struct soap *soap, const struct ns1__getFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolder);
	if (soap_out_ns1__getFolder(soap, tag?tag:"ns1:getFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolder * SOAP_FMAC4 soap_get_ns1__getFolder(struct soap *soap, struct ns1__getFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolder * SOAP_FMAC2 soap_instantiate_ns1__getFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolder);
		if (size)
			*size = sizeof(struct ns1__getFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolder %p -> %p\n", q, p));
	*(struct ns1__getFolder*)p = *(struct ns1__getFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderResponse(struct soap *soap, struct ns1__getFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderResponse(struct soap *soap, const struct ns1__getFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderResponse * SOAP_FMAC4 soap_in_ns1__getFolderResponse(struct soap *soap, const char *tag, struct ns1__getFolderResponse *a, const char *type)
{
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderResponse, sizeof(struct ns1__getFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderResponse, 0, sizeof(struct ns1__getFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderResponse(struct soap *soap, const struct ns1__getFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderResponse);
	if (soap_out_ns1__getFolderResponse(soap, tag?tag:"ns1:getFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderResponse * SOAP_FMAC4 soap_get_ns1__getFolderResponse(struct soap *soap, struct ns1__getFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderResponse*)p = *(struct ns1__getFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveFolder(struct soap *soap, struct ns1__cancelSaveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveFolder(struct soap *soap, const struct ns1__cancelSaveFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveFolder(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveFolder * SOAP_FMAC4 soap_in_ns1__cancelSaveFolder(struct soap *soap, const char *tag, struct ns1__cancelSaveFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveFolder, sizeof(struct ns1__cancelSaveFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveFolder, 0, sizeof(struct ns1__cancelSaveFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveFolder(struct soap *soap, const struct ns1__cancelSaveFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveFolder);
	if (soap_out_ns1__cancelSaveFolder(soap, tag?tag:"ns1:cancelSaveFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveFolder * SOAP_FMAC4 soap_get_ns1__cancelSaveFolder(struct soap *soap, struct ns1__cancelSaveFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveFolder * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveFolder);
		if (size)
			*size = sizeof(struct ns1__cancelSaveFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveFolder %p -> %p\n", q, p));
	*(struct ns1__cancelSaveFolder*)p = *(struct ns1__cancelSaveFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveFolderResponse(struct soap *soap, struct ns1__cancelSaveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveFolderResponse(struct soap *soap, const struct ns1__cancelSaveFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveFolderResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveFolderResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveFolderResponse, sizeof(struct ns1__cancelSaveFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveFolderResponse, 0, sizeof(struct ns1__cancelSaveFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveFolderResponse(struct soap *soap, const struct ns1__cancelSaveFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveFolderResponse);
	if (soap_out_ns1__cancelSaveFolderResponse(soap, tag?tag:"ns1:cancelSaveFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveFolderResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveFolderResponse(struct soap *soap, struct ns1__cancelSaveFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveFolderResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveFolderResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveFolderResponse*)p = *(struct ns1__cancelSaveFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveFolder(struct soap *soap, struct ns1__saveFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveFolder(struct soap *soap, const struct ns1__saveFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveFolder(struct soap *soap, const char *tag, int id, const struct ns1__saveFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveFolder * SOAP_FMAC4 soap_in_ns1__saveFolder(struct soap *soap, const char *tag, struct ns1__saveFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveFolder, sizeof(struct ns1__saveFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveFolder, 0, sizeof(struct ns1__saveFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveFolder(struct soap *soap, const struct ns1__saveFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveFolder);
	if (soap_out_ns1__saveFolder(soap, tag?tag:"ns1:saveFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveFolder * SOAP_FMAC4 soap_get_ns1__saveFolder(struct soap *soap, struct ns1__saveFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveFolder * SOAP_FMAC2 soap_instantiate_ns1__saveFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveFolder);
		if (size)
			*size = sizeof(struct ns1__saveFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__saveFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveFolder %p -> %p\n", q, p));
	*(struct ns1__saveFolder*)p = *(struct ns1__saveFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveFolderResponse(struct soap *soap, struct ns1__saveFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveFolderResponse(struct soap *soap, const struct ns1__saveFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveFolderResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveFolderResponse * SOAP_FMAC4 soap_in_ns1__saveFolderResponse(struct soap *soap, const char *tag, struct ns1__saveFolderResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveFolderResponse, sizeof(struct ns1__saveFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveFolderResponse, 0, sizeof(struct ns1__saveFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveFolderResponse(struct soap *soap, const struct ns1__saveFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveFolderResponse);
	if (soap_out_ns1__saveFolderResponse(soap, tag?tag:"ns1:saveFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveFolderResponse * SOAP_FMAC4 soap_get_ns1__saveFolderResponse(struct soap *soap, struct ns1__saveFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__saveFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveFolderResponse);
		if (size)
			*size = sizeof(struct ns1__saveFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveFolderResponse %p -> %p\n", q, p));
	*(struct ns1__saveFolderResponse*)p = *(struct ns1__saveFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolderByRecordID(struct soap *soap, struct ns1__editFolderByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->publicFolder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolderByRecordID(struct soap *soap, const struct ns1__editFolderByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->publicFolder, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolderByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editFolderByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolderByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "publicFolder", -1, &a->publicFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolderByRecordID * SOAP_FMAC4 soap_in_ns1__editFolderByRecordID(struct soap *soap, const char *tag, struct ns1__editFolderByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_publicFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolderByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolderByRecordID, sizeof(struct ns1__editFolderByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolderByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_publicFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "publicFolder", &a->publicFolder, "xsd:boolean"))
				{	soap_flag_publicFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolderByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolderByRecordID, 0, sizeof(struct ns1__editFolderByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_publicFolder > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolderByRecordID(struct soap *soap, const struct ns1__editFolderByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolderByRecordID);
	if (soap_out_ns1__editFolderByRecordID(soap, tag?tag:"ns1:editFolderByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolderByRecordID * SOAP_FMAC4 soap_get_ns1__editFolderByRecordID(struct soap *soap, struct ns1__editFolderByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolderByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolderByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editFolderByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolderByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolderByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolderByRecordID);
		if (size)
			*size = sizeof(struct ns1__editFolderByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolderByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolderByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolderByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolderByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolderByRecordID %p -> %p\n", q, p));
	*(struct ns1__editFolderByRecordID*)p = *(struct ns1__editFolderByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolderByRecordIDResponse(struct soap *soap, struct ns1__editFolderByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolderByRecordIDResponse(struct soap *soap, const struct ns1__editFolderByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolderByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editFolderByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolderByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolderByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editFolderByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editFolderByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolderByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolderByRecordIDResponse, sizeof(struct ns1__editFolderByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolderByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolderByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolderByRecordIDResponse, 0, sizeof(struct ns1__editFolderByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolderByRecordIDResponse(struct soap *soap, const struct ns1__editFolderByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolderByRecordIDResponse);
	if (soap_out_ns1__editFolderByRecordIDResponse(soap, tag?tag:"ns1:editFolderByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolderByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editFolderByRecordIDResponse(struct soap *soap, struct ns1__editFolderByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolderByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolderByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editFolderByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolderByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolderByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolderByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editFolderByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolderByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolderByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolderByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolderByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolderByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editFolderByRecordIDResponse*)p = *(struct ns1__editFolderByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolder(struct soap *soap, struct ns1__editFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->folderPath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolder(struct soap *soap, const struct ns1__editFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->folderPath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolder(struct soap *soap, const char *tag, int id, const struct ns1__editFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "folderPath", -1, &a->folderPath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolder * SOAP_FMAC4 soap_in_ns1__editFolder(struct soap *soap, const char *tag, struct ns1__editFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_folderPath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolder, sizeof(struct ns1__editFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_folderPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "folderPath", &a->folderPath, "xsd:string"))
				{	soap_flag_folderPath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolder, 0, sizeof(struct ns1__editFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolder(struct soap *soap, const struct ns1__editFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolder);
	if (soap_out_ns1__editFolder(soap, tag?tag:"ns1:editFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolder * SOAP_FMAC4 soap_get_ns1__editFolder(struct soap *soap, struct ns1__editFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolder * SOAP_FMAC2 soap_instantiate_ns1__editFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolder);
		if (size)
			*size = sizeof(struct ns1__editFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolder %p -> %p\n", q, p));
	*(struct ns1__editFolder*)p = *(struct ns1__editFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editFolderResponse(struct soap *soap, struct ns1__editFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editFolderResponse(struct soap *soap, const struct ns1__editFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__editFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editFolderResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editFolderResponse * SOAP_FMAC4 soap_in_ns1__editFolderResponse(struct soap *soap, const char *tag, struct ns1__editFolderResponse *a, const char *type)
{
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editFolderResponse, sizeof(struct ns1__editFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editFolderResponse, 0, sizeof(struct ns1__editFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editFolderResponse(struct soap *soap, const struct ns1__editFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editFolderResponse);
	if (soap_out_ns1__editFolderResponse(soap, tag?tag:"ns1:editFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editFolderResponse * SOAP_FMAC4 soap_get_ns1__editFolderResponse(struct soap *soap, struct ns1__editFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__editFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editFolderResponse);
		if (size)
			*size = sizeof(struct ns1__editFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editFolderResponse %p -> %p\n", q, p));
	*(struct ns1__editFolderResponse*)p = *(struct ns1__editFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addFolder(struct soap *soap, struct ns1__addFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pFolder = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addFolder(struct soap *soap, const struct ns1__addFolder *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CFolder(soap, &a->pFolder);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addFolder(struct soap *soap, const char *tag, int id, const struct ns1__addFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addFolder), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CFolder(soap, "pFolder", -1, &a->pFolder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addFolder * SOAP_FMAC4 soap_in_ns1__addFolder(struct soap *soap, const char *tag, struct ns1__addFolder *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pFolder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addFolder, sizeof(struct ns1__addFolder), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pFolder && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolder(soap, "pFolder", &a->pFolder, "ns1:CFolder"))
				{	soap_flag_pFolder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addFolder, 0, sizeof(struct ns1__addFolder), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addFolder(struct soap *soap, const struct ns1__addFolder *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addFolder);
	if (soap_out_ns1__addFolder(soap, tag?tag:"ns1:addFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addFolder * SOAP_FMAC4 soap_get_ns1__addFolder(struct soap *soap, struct ns1__addFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addFolder * SOAP_FMAC2 soap_instantiate_ns1__addFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addFolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addFolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addFolder);
		if (size)
			*size = sizeof(struct ns1__addFolder);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addFolder, n);
		if (size)
			*size = n * sizeof(struct ns1__addFolder);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addFolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addFolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addFolder %p -> %p\n", q, p));
	*(struct ns1__addFolder*)p = *(struct ns1__addFolder*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addFolderResponse(struct soap *soap, struct ns1__addFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addFolderResponse(struct soap *soap, const struct ns1__addFolderResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__addFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addFolderResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addFolderResponse * SOAP_FMAC4 soap_in_ns1__addFolderResponse(struct soap *soap, const char *tag, struct ns1__addFolderResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addFolderResponse, sizeof(struct ns1__addFolderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addFolderResponse, 0, sizeof(struct ns1__addFolderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addFolderResponse(struct soap *soap, const struct ns1__addFolderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addFolderResponse);
	if (soap_out_ns1__addFolderResponse(soap, tag?tag:"ns1:addFolderResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addFolderResponse * SOAP_FMAC4 soap_get_ns1__addFolderResponse(struct soap *soap, struct ns1__addFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__addFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addFolderResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addFolderResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addFolderResponse);
		if (size)
			*size = sizeof(struct ns1__addFolderResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addFolderResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addFolderResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addFolderResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addFolderResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addFolderResponse %p -> %p\n", q, p));
	*(struct ns1__addFolderResponse*)p = *(struct ns1__addFolderResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTypeList(struct soap *soap, struct ns1__getFolderTypeList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTypeList(struct soap *soap, const struct ns1__getFolderTypeList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTypeList(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTypeList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTypeList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTypeList * SOAP_FMAC4 soap_in_ns1__getFolderTypeList(struct soap *soap, const char *tag, struct ns1__getFolderTypeList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTypeList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTypeList, sizeof(struct ns1__getFolderTypeList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTypeList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTypeList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTypeList, 0, sizeof(struct ns1__getFolderTypeList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTypeList(struct soap *soap, const struct ns1__getFolderTypeList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTypeList);
	if (soap_out_ns1__getFolderTypeList(soap, tag?tag:"ns1:getFolderTypeList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTypeList * SOAP_FMAC4 soap_get_ns1__getFolderTypeList(struct soap *soap, struct ns1__getFolderTypeList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTypeList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTypeList * SOAP_FMAC2 soap_instantiate_ns1__getFolderTypeList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTypeList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTypeList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTypeList);
		if (size)
			*size = sizeof(struct ns1__getFolderTypeList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTypeList, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTypeList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTypeList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTypeList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTypeList %p -> %p\n", q, p));
	*(struct ns1__getFolderTypeList*)p = *(struct ns1__getFolderTypeList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTypeListResponse(struct soap *soap, struct ns1__getFolderTypeListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTypeListResponse(struct soap *soap, const struct ns1__getFolderTypeListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFolderType(soap, &a->pTypeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTypeListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTypeListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTypeListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFolderType(soap, "pTypeList", -1, &a->pTypeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTypeListResponse * SOAP_FMAC4 soap_in_ns1__getFolderTypeListResponse(struct soap *soap, const char *tag, struct ns1__getFolderTypeListResponse *a, const char *type)
{
	size_t soap_flag_pTypeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTypeListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTypeListResponse, sizeof(struct ns1__getFolderTypeListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTypeListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTypeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFolderType(soap, "pTypeList", &a->pTypeList, "ns1:CFolderType"))
				{	soap_flag_pTypeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTypeListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTypeListResponse, 0, sizeof(struct ns1__getFolderTypeListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTypeListResponse(struct soap *soap, const struct ns1__getFolderTypeListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTypeListResponse);
	if (soap_out_ns1__getFolderTypeListResponse(soap, tag?tag:"ns1:getFolderTypeListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTypeListResponse * SOAP_FMAC4 soap_get_ns1__getFolderTypeListResponse(struct soap *soap, struct ns1__getFolderTypeListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTypeListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTypeListResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderTypeListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTypeListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTypeListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTypeListResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderTypeListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTypeListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTypeListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTypeListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTypeListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTypeListResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderTypeListResponse*)p = *(struct ns1__getFolderTypeListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTypeByName(struct soap *soap, struct ns1__getFolderTypeByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTypeByName(struct soap *soap, const struct ns1__getFolderTypeByName *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTypeByName(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTypeByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTypeByName), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTypeByName * SOAP_FMAC4 soap_in_ns1__getFolderTypeByName(struct soap *soap, const char *tag, struct ns1__getFolderTypeByName *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTypeByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTypeByName, sizeof(struct ns1__getFolderTypeByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTypeByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTypeByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTypeByName, 0, sizeof(struct ns1__getFolderTypeByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTypeByName(struct soap *soap, const struct ns1__getFolderTypeByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTypeByName);
	if (soap_out_ns1__getFolderTypeByName(soap, tag?tag:"ns1:getFolderTypeByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTypeByName * SOAP_FMAC4 soap_get_ns1__getFolderTypeByName(struct soap *soap, struct ns1__getFolderTypeByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTypeByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTypeByName * SOAP_FMAC2 soap_instantiate_ns1__getFolderTypeByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTypeByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTypeByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTypeByName);
		if (size)
			*size = sizeof(struct ns1__getFolderTypeByName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTypeByName, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTypeByName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTypeByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTypeByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTypeByName %p -> %p\n", q, p));
	*(struct ns1__getFolderTypeByName*)p = *(struct ns1__getFolderTypeByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderTypeByNameResponse(struct soap *soap, struct ns1__getFolderTypeByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderTypeByNameResponse(struct soap *soap, const struct ns1__getFolderTypeByNameResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFolderType(soap, &a->pType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderTypeByNameResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderTypeByNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderTypeByNameResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFolderType(soap, "pType", -1, &a->pType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderTypeByNameResponse * SOAP_FMAC4 soap_in_ns1__getFolderTypeByNameResponse(struct soap *soap, const char *tag, struct ns1__getFolderTypeByNameResponse *a, const char *type)
{
	size_t soap_flag_pType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderTypeByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderTypeByNameResponse, sizeof(struct ns1__getFolderTypeByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderTypeByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFolderType(soap, "pType", &a->pType, "ns1:CFolderType"))
				{	soap_flag_pType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolderTypeByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderTypeByNameResponse, 0, sizeof(struct ns1__getFolderTypeByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderTypeByNameResponse(struct soap *soap, const struct ns1__getFolderTypeByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFolderTypeByNameResponse);
	if (soap_out_ns1__getFolderTypeByNameResponse(soap, tag?tag:"ns1:getFolderTypeByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderTypeByNameResponse * SOAP_FMAC4 soap_get_ns1__getFolderTypeByNameResponse(struct soap *soap, struct ns1__getFolderTypeByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderTypeByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFolderTypeByNameResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderTypeByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderTypeByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFolderTypeByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFolderTypeByNameResponse);
		if (size)
			*size = sizeof(struct ns1__getFolderTypeByNameResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFolderTypeByNameResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFolderTypeByNameResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFolderTypeByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFolderTypeByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFolderTypeByNameResponse %p -> %p\n", q, p));
	*(struct ns1__getFolderTypeByNameResponse*)p = *(struct ns1__getFolderTypeByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__generateTestRuns(struct soap *soap, struct ns1__generateTestRuns *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	a->testVariants = NULL;
	soap_default_string(soap, &a->testRunSet);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__generateTestRuns(struct soap *soap, const struct ns1__generateTestRuns *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_serialize_PointerToArrayOfCTestRunVariantField(soap, &a->testVariants);
	soap_serialize_string(soap, &a->testRunSet);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__generateTestRuns(struct soap *soap, const char *tag, int id, const struct ns1__generateTestRuns *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__generateTestRuns), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTestRunVariantField(soap, "testVariants", -1, &a->testVariants, ""))
		return soap->error;
	if (soap_out_string(soap, "testRunSet", -1, &a->testRunSet, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__generateTestRuns * SOAP_FMAC4 soap_in_ns1__generateTestRuns(struct soap *soap, const char *tag, struct ns1__generateTestRuns *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_testVariants = 1;
	size_t soap_flag_testRunSet = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__generateTestRuns *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__generateTestRuns, sizeof(struct ns1__generateTestRuns), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__generateTestRuns(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_testVariants && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTestRunVariantField(soap, "testVariants", &a->testVariants, "ns1:CTestRunVariantField"))
				{	soap_flag_testVariants--;
					continue;
				}
			if (soap_flag_testRunSet && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "testRunSet", &a->testRunSet, "xsd:string"))
				{	soap_flag_testRunSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__generateTestRuns *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__generateTestRuns, 0, sizeof(struct ns1__generateTestRuns), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__generateTestRuns(struct soap *soap, const struct ns1__generateTestRuns *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__generateTestRuns);
	if (soap_out_ns1__generateTestRuns(soap, tag?tag:"ns1:generateTestRuns", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__generateTestRuns * SOAP_FMAC4 soap_get_ns1__generateTestRuns(struct soap *soap, struct ns1__generateTestRuns *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__generateTestRuns(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__generateTestRuns * SOAP_FMAC2 soap_instantiate_ns1__generateTestRuns(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__generateTestRuns(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__generateTestRuns, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__generateTestRuns);
		if (size)
			*size = sizeof(struct ns1__generateTestRuns);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__generateTestRuns, n);
		if (size)
			*size = n * sizeof(struct ns1__generateTestRuns);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__generateTestRuns*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__generateTestRuns(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__generateTestRuns %p -> %p\n", q, p));
	*(struct ns1__generateTestRuns*)p = *(struct ns1__generateTestRuns*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__generateTestRunsResponse(struct soap *soap, struct ns1__generateTestRunsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__generateTestRunsResponse(struct soap *soap, const struct ns1__generateTestRunsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCItemToTrack(soap, &a->pResults);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__generateTestRunsResponse(struct soap *soap, const char *tag, int id, const struct ns1__generateTestRunsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__generateTestRunsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCItemToTrack(soap, "pResults", -1, &a->pResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__generateTestRunsResponse * SOAP_FMAC4 soap_in_ns1__generateTestRunsResponse(struct soap *soap, const char *tag, struct ns1__generateTestRunsResponse *a, const char *type)
{
	size_t soap_flag_pResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__generateTestRunsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__generateTestRunsResponse, sizeof(struct ns1__generateTestRunsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__generateTestRunsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCItemToTrack(soap, "pResults", &a->pResults, "ns1:CItemToTrack"))
				{	soap_flag_pResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__generateTestRunsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__generateTestRunsResponse, 0, sizeof(struct ns1__generateTestRunsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__generateTestRunsResponse(struct soap *soap, const struct ns1__generateTestRunsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__generateTestRunsResponse);
	if (soap_out_ns1__generateTestRunsResponse(soap, tag?tag:"ns1:generateTestRunsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__generateTestRunsResponse * SOAP_FMAC4 soap_get_ns1__generateTestRunsResponse(struct soap *soap, struct ns1__generateTestRunsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__generateTestRunsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__generateTestRunsResponse * SOAP_FMAC2 soap_instantiate_ns1__generateTestRunsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__generateTestRunsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__generateTestRunsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__generateTestRunsResponse);
		if (size)
			*size = sizeof(struct ns1__generateTestRunsResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__generateTestRunsResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__generateTestRunsResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__generateTestRunsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__generateTestRunsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__generateTestRunsResponse %p -> %p\n", q, p));
	*(struct ns1__generateTestRunsResponse*)p = *(struct ns1__generateTestRunsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createDefectForTestRun(struct soap *soap, struct ns1__createDefectForTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createDefectForTestRun(struct soap *soap, const struct ns1__createDefectForTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDefectForTestRun(struct soap *soap, const char *tag, int id, const struct ns1__createDefectForTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDefectForTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createDefectForTestRun * SOAP_FMAC4 soap_in_ns1__createDefectForTestRun(struct soap *soap, const char *tag, struct ns1__createDefectForTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createDefectForTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDefectForTestRun, sizeof(struct ns1__createDefectForTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createDefectForTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createDefectForTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDefectForTestRun, 0, sizeof(struct ns1__createDefectForTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createDefectForTestRun(struct soap *soap, const struct ns1__createDefectForTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createDefectForTestRun);
	if (soap_out_ns1__createDefectForTestRun(soap, tag?tag:"ns1:createDefectForTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createDefectForTestRun * SOAP_FMAC4 soap_get_ns1__createDefectForTestRun(struct soap *soap, struct ns1__createDefectForTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDefectForTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__createDefectForTestRun * SOAP_FMAC2 soap_instantiate_ns1__createDefectForTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDefectForTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDefectForTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__createDefectForTestRun);
		if (size)
			*size = sizeof(struct ns1__createDefectForTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__createDefectForTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__createDefectForTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__createDefectForTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDefectForTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__createDefectForTestRun %p -> %p\n", q, p));
	*(struct ns1__createDefectForTestRun*)p = *(struct ns1__createDefectForTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__createDefectForTestRunResponse(struct soap *soap, struct ns1__createDefectForTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__createDefectForTestRunResponse(struct soap *soap, const struct ns1__createDefectForTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__createDefectForTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__createDefectForTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__createDefectForTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__createDefectForTestRunResponse * SOAP_FMAC4 soap_in_ns1__createDefectForTestRunResponse(struct soap *soap, const char *tag, struct ns1__createDefectForTestRunResponse *a, const char *type)
{
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__createDefectForTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__createDefectForTestRunResponse, sizeof(struct ns1__createDefectForTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__createDefectForTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__createDefectForTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__createDefectForTestRunResponse, 0, sizeof(struct ns1__createDefectForTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__createDefectForTestRunResponse(struct soap *soap, const struct ns1__createDefectForTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__createDefectForTestRunResponse);
	if (soap_out_ns1__createDefectForTestRunResponse(soap, tag?tag:"ns1:createDefectForTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__createDefectForTestRunResponse * SOAP_FMAC4 soap_get_ns1__createDefectForTestRunResponse(struct soap *soap, struct ns1__createDefectForTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__createDefectForTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__createDefectForTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__createDefectForTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__createDefectForTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__createDefectForTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__createDefectForTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__createDefectForTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__createDefectForTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__createDefectForTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__createDefectForTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__createDefectForTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__createDefectForTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__createDefectForTestRunResponse*)p = *(struct ns1__createDefectForTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestRun(struct soap *soap, struct ns1__cancelSaveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestRun(struct soap *soap, const struct ns1__cancelSaveTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestRun(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestRun * SOAP_FMAC4 soap_in_ns1__cancelSaveTestRun(struct soap *soap, const char *tag, struct ns1__cancelSaveTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestRun, sizeof(struct ns1__cancelSaveTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestRun, 0, sizeof(struct ns1__cancelSaveTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestRun(struct soap *soap, const struct ns1__cancelSaveTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestRun);
	if (soap_out_ns1__cancelSaveTestRun(soap, tag?tag:"ns1:cancelSaveTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestRun * SOAP_FMAC4 soap_get_ns1__cancelSaveTestRun(struct soap *soap, struct ns1__cancelSaveTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestRun * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestRun);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestRun %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestRun*)p = *(struct ns1__cancelSaveTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestRunResponse(struct soap *soap, struct ns1__cancelSaveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestRunResponse(struct soap *soap, const struct ns1__cancelSaveTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestRunResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveTestRunResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveTestRunResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestRunResponse, sizeof(struct ns1__cancelSaveTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestRunResponse, 0, sizeof(struct ns1__cancelSaveTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestRunResponse(struct soap *soap, const struct ns1__cancelSaveTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestRunResponse);
	if (soap_out_ns1__cancelSaveTestRunResponse(soap, tag?tag:"ns1:cancelSaveTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestRunResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveTestRunResponse(struct soap *soap, struct ns1__cancelSaveTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestRunResponse*)p = *(struct ns1__cancelSaveTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestRun(struct soap *soap, struct ns1__saveTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestRun(struct soap *soap, const struct ns1__saveTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CTestRun(soap, &a->pTestRun);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestRun(struct soap *soap, const char *tag, int id, const struct ns1__saveTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestRun * SOAP_FMAC4 soap_in_ns1__saveTestRun(struct soap *soap, const char *tag, struct ns1__saveTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestRun, sizeof(struct ns1__saveTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestRun(soap, "pTestRun", &a->pTestRun, "ns1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestRun, 0, sizeof(struct ns1__saveTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestRun(struct soap *soap, const struct ns1__saveTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestRun);
	if (soap_out_ns1__saveTestRun(soap, tag?tag:"ns1:saveTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestRun * SOAP_FMAC4 soap_get_ns1__saveTestRun(struct soap *soap, struct ns1__saveTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestRun * SOAP_FMAC2 soap_instantiate_ns1__saveTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestRun);
		if (size)
			*size = sizeof(struct ns1__saveTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestRun %p -> %p\n", q, p));
	*(struct ns1__saveTestRun*)p = *(struct ns1__saveTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestRunResponse(struct soap *soap, struct ns1__saveTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestRunResponse(struct soap *soap, const struct ns1__saveTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestRunResponse * SOAP_FMAC4 soap_in_ns1__saveTestRunResponse(struct soap *soap, const char *tag, struct ns1__saveTestRunResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestRunResponse, sizeof(struct ns1__saveTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestRunResponse, 0, sizeof(struct ns1__saveTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestRunResponse(struct soap *soap, const struct ns1__saveTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestRunResponse);
	if (soap_out_ns1__saveTestRunResponse(soap, tag?tag:"ns1:saveTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestRunResponse * SOAP_FMAC4 soap_get_ns1__saveTestRunResponse(struct soap *soap, struct ns1__saveTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__saveTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__saveTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__saveTestRunResponse*)p = *(struct ns1__saveTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestRunByRecordID(struct soap *soap, struct ns1__editTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestRunByRecordID(struct soap *soap, const struct ns1__editTestRunByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editTestRunByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestRunByRecordID * SOAP_FMAC4 soap_in_ns1__editTestRunByRecordID(struct soap *soap, const char *tag, struct ns1__editTestRunByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestRunByRecordID, sizeof(struct ns1__editTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestRunByRecordID, 0, sizeof(struct ns1__editTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestRunByRecordID(struct soap *soap, const struct ns1__editTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestRunByRecordID);
	if (soap_out_ns1__editTestRunByRecordID(soap, tag?tag:"ns1:editTestRunByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestRunByRecordID * SOAP_FMAC4 soap_get_ns1__editTestRunByRecordID(struct soap *soap, struct ns1__editTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestRunByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestRunByRecordID);
		if (size)
			*size = sizeof(struct ns1__editTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestRunByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestRunByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestRunByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestRunByRecordID %p -> %p\n", q, p));
	*(struct ns1__editTestRunByRecordID*)p = *(struct ns1__editTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestRunByRecordIDResponse(struct soap *soap, struct ns1__editTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestRunByRecordIDResponse(struct soap *soap, const struct ns1__editTestRunByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestRun(soap, &a->pTestRun);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestRunByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editTestRunByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestRunByRecordIDResponse, sizeof(struct ns1__editTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestRun(soap, "pTestRun", &a->pTestRun, "ns1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestRunByRecordIDResponse, 0, sizeof(struct ns1__editTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestRunByRecordIDResponse(struct soap *soap, const struct ns1__editTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestRunByRecordIDResponse);
	if (soap_out_ns1__editTestRunByRecordIDResponse(soap, tag?tag:"ns1:editTestRunByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editTestRunByRecordIDResponse(struct soap *soap, struct ns1__editTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestRunByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestRunByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestRunByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestRunByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestRunByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editTestRunByRecordIDResponse*)p = *(struct ns1__editTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestRun(struct soap *soap, struct ns1__editTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestRun(struct soap *soap, const struct ns1__editTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestRun(struct soap *soap, const char *tag, int id, const struct ns1__editTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestRun * SOAP_FMAC4 soap_in_ns1__editTestRun(struct soap *soap, const char *tag, struct ns1__editTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testRunNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestRun, sizeof(struct ns1__editTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestRun, 0, sizeof(struct ns1__editTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestRun(struct soap *soap, const struct ns1__editTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestRun);
	if (soap_out_ns1__editTestRun(soap, tag?tag:"ns1:editTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestRun * SOAP_FMAC4 soap_get_ns1__editTestRun(struct soap *soap, struct ns1__editTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestRun * SOAP_FMAC2 soap_instantiate_ns1__editTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestRun);
		if (size)
			*size = sizeof(struct ns1__editTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestRun %p -> %p\n", q, p));
	*(struct ns1__editTestRun*)p = *(struct ns1__editTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestRunResponse(struct soap *soap, struct ns1__editTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestRunResponse(struct soap *soap, const struct ns1__editTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestRun(soap, &a->pTestRun);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestRunResponse * SOAP_FMAC4 soap_in_ns1__editTestRunResponse(struct soap *soap, const char *tag, struct ns1__editTestRunResponse *a, const char *type)
{
	size_t soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestRunResponse, sizeof(struct ns1__editTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestRun(soap, "pTestRun", &a->pTestRun, "ns1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestRunResponse, 0, sizeof(struct ns1__editTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestRunResponse(struct soap *soap, const struct ns1__editTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestRunResponse);
	if (soap_out_ns1__editTestRunResponse(soap, tag?tag:"ns1:editTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestRunResponse * SOAP_FMAC4 soap_get_ns1__editTestRunResponse(struct soap *soap, struct ns1__editTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__editTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__editTestRunResponse*)p = *(struct ns1__editTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestRunByRecordID(struct soap *soap, struct ns1__deleteTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestRunByRecordID(struct soap *soap, const struct ns1__deleteTestRunByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestRunByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestRunByRecordID * SOAP_FMAC4 soap_in_ns1__deleteTestRunByRecordID(struct soap *soap, const char *tag, struct ns1__deleteTestRunByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestRunByRecordID, sizeof(struct ns1__deleteTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestRunByRecordID, 0, sizeof(struct ns1__deleteTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestRunByRecordID(struct soap *soap, const struct ns1__deleteTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestRunByRecordID);
	if (soap_out_ns1__deleteTestRunByRecordID(soap, tag?tag:"ns1:deleteTestRunByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestRunByRecordID * SOAP_FMAC4 soap_get_ns1__deleteTestRunByRecordID(struct soap *soap, struct ns1__deleteTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestRunByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestRunByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestRunByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestRunByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestRunByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestRunByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteTestRunByRecordID*)p = *(struct ns1__deleteTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, struct ns1__deleteTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestRunByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestRunByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteTestRunByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse, sizeof(struct ns1__deleteTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse, 0, sizeof(struct ns1__deleteTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse);
	if (soap_out_ns1__deleteTestRunByRecordIDResponse(soap, tag?tag:"ns1:deleteTestRunByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, struct ns1__deleteTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestRunByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestRunByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestRunByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestRunByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestRunByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestRunByRecordIDResponse*)p = *(struct ns1__deleteTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestRun(struct soap *soap, struct ns1__deleteTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestRun(struct soap *soap, const struct ns1__deleteTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestRun(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestRun * SOAP_FMAC4 soap_in_ns1__deleteTestRun(struct soap *soap, const char *tag, struct ns1__deleteTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testRunNumber = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestRun, sizeof(struct ns1__deleteTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestRun, 0, sizeof(struct ns1__deleteTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestRun(struct soap *soap, const struct ns1__deleteTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestRun);
	if (soap_out_ns1__deleteTestRun(soap, tag?tag:"ns1:deleteTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestRun * SOAP_FMAC4 soap_get_ns1__deleteTestRun(struct soap *soap, struct ns1__deleteTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestRun * SOAP_FMAC2 soap_instantiate_ns1__deleteTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestRun);
		if (size)
			*size = sizeof(struct ns1__deleteTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestRun %p -> %p\n", q, p));
	*(struct ns1__deleteTestRun*)p = *(struct ns1__deleteTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestRunResponse(struct soap *soap, struct ns1__deleteTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestRunResponse(struct soap *soap, const struct ns1__deleteTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestRunResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestRunResponse * SOAP_FMAC4 soap_in_ns1__deleteTestRunResponse(struct soap *soap, const char *tag, struct ns1__deleteTestRunResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestRunResponse, sizeof(struct ns1__deleteTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestRunResponse, 0, sizeof(struct ns1__deleteTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestRunResponse(struct soap *soap, const struct ns1__deleteTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestRunResponse);
	if (soap_out_ns1__deleteTestRunResponse(soap, tag?tag:"ns1:deleteTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestRunResponse * SOAP_FMAC4 soap_get_ns1__deleteTestRunResponse(struct soap *soap, struct ns1__deleteTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestRunResponse*)p = *(struct ns1__deleteTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRunByRecordID(struct soap *soap, struct ns1__getTestRunByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRunByRecordID(struct soap *soap, const struct ns1__getTestRunByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRunByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getTestRunByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRunByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRunByRecordID * SOAP_FMAC4 soap_in_ns1__getTestRunByRecordID(struct soap *soap, const char *tag, struct ns1__getTestRunByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRunByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRunByRecordID, sizeof(struct ns1__getTestRunByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRunByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRunByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRunByRecordID, 0, sizeof(struct ns1__getTestRunByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRunByRecordID(struct soap *soap, const struct ns1__getTestRunByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRunByRecordID);
	if (soap_out_ns1__getTestRunByRecordID(soap, tag?tag:"ns1:getTestRunByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRunByRecordID * SOAP_FMAC4 soap_get_ns1__getTestRunByRecordID(struct soap *soap, struct ns1__getTestRunByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRunByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRunByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getTestRunByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRunByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRunByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRunByRecordID);
		if (size)
			*size = sizeof(struct ns1__getTestRunByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRunByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRunByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRunByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRunByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRunByRecordID %p -> %p\n", q, p));
	*(struct ns1__getTestRunByRecordID*)p = *(struct ns1__getTestRunByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRunByRecordIDResponse(struct soap *soap, struct ns1__getTestRunByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRunByRecordIDResponse(struct soap *soap, const struct ns1__getTestRunByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestRun(soap, &a->pTestRun);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRunByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestRunByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRunByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRunByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getTestRunByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getTestRunByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRunByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRunByRecordIDResponse, sizeof(struct ns1__getTestRunByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRunByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestRun(soap, "pTestRun", &a->pTestRun, "ns1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRunByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRunByRecordIDResponse, 0, sizeof(struct ns1__getTestRunByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRunByRecordIDResponse(struct soap *soap, const struct ns1__getTestRunByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRunByRecordIDResponse);
	if (soap_out_ns1__getTestRunByRecordIDResponse(soap, tag?tag:"ns1:getTestRunByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRunByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getTestRunByRecordIDResponse(struct soap *soap, struct ns1__getTestRunByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRunByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRunByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestRunByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRunByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRunByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRunByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getTestRunByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRunByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRunByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRunByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRunByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRunByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getTestRunByRecordIDResponse*)p = *(struct ns1__getTestRunByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRun(struct soap *soap, struct ns1__getTestRun *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testRunNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRun(struct soap *soap, const struct ns1__getTestRun *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testRunNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRun(struct soap *soap, const char *tag, int id, const struct ns1__getTestRun *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRun), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunNumber", -1, &a->testRunNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRun * SOAP_FMAC4 soap_in_ns1__getTestRun(struct soap *soap, const char *tag, struct ns1__getTestRun *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testRunNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRun *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRun, sizeof(struct ns1__getTestRun), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRun(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testRunNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunNumber", &a->testRunNumber, "xsd:long"))
				{	soap_flag_testRunNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRun *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRun, 0, sizeof(struct ns1__getTestRun), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRun(struct soap *soap, const struct ns1__getTestRun *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRun);
	if (soap_out_ns1__getTestRun(soap, tag?tag:"ns1:getTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRun * SOAP_FMAC4 soap_get_ns1__getTestRun(struct soap *soap, struct ns1__getTestRun *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRun * SOAP_FMAC2 soap_instantiate_ns1__getTestRun(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRun(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRun, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRun);
		if (size)
			*size = sizeof(struct ns1__getTestRun);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRun, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRun);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRun*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRun(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRun %p -> %p\n", q, p));
	*(struct ns1__getTestRun*)p = *(struct ns1__getTestRun*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRunResponse(struct soap *soap, struct ns1__getTestRunResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestRun = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRunResponse(struct soap *soap, const struct ns1__getTestRunResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestRun(soap, &a->pTestRun);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRunResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestRunResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRunResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestRun(soap, "pTestRun", -1, &a->pTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRunResponse * SOAP_FMAC4 soap_in_ns1__getTestRunResponse(struct soap *soap, const char *tag, struct ns1__getTestRunResponse *a, const char *type)
{
	size_t soap_flag_pTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRunResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRunResponse, sizeof(struct ns1__getTestRunResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRunResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestRun(soap, "pTestRun", &a->pTestRun, "ns1:CTestRun"))
				{	soap_flag_pTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRunResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRunResponse, 0, sizeof(struct ns1__getTestRunResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRunResponse(struct soap *soap, const struct ns1__getTestRunResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRunResponse);
	if (soap_out_ns1__getTestRunResponse(soap, tag?tag:"ns1:getTestRunResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRunResponse * SOAP_FMAC4 soap_get_ns1__getTestRunResponse(struct soap *soap, struct ns1__getTestRunResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRunResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRunResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestRunResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRunResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRunResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRunResponse);
		if (size)
			*size = sizeof(struct ns1__getTestRunResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRunResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRunResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRunResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRunResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRunResponse %p -> %p\n", q, p));
	*(struct ns1__getTestRunResponse*)p = *(struct ns1__getTestRunResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestCase(struct soap *soap, struct ns1__cancelSaveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestCase(struct soap *soap, const struct ns1__cancelSaveTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestCase(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestCase * SOAP_FMAC4 soap_in_ns1__cancelSaveTestCase(struct soap *soap, const char *tag, struct ns1__cancelSaveTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestCase, sizeof(struct ns1__cancelSaveTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestCase, 0, sizeof(struct ns1__cancelSaveTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestCase(struct soap *soap, const struct ns1__cancelSaveTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestCase);
	if (soap_out_ns1__cancelSaveTestCase(soap, tag?tag:"ns1:cancelSaveTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestCase * SOAP_FMAC4 soap_get_ns1__cancelSaveTestCase(struct soap *soap, struct ns1__cancelSaveTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestCase * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestCase);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestCase %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestCase*)p = *(struct ns1__cancelSaveTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestCaseResponse(struct soap *soap, struct ns1__cancelSaveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestCaseResponse(struct soap *soap, const struct ns1__cancelSaveTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestCaseResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveTestCaseResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveTestCaseResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestCaseResponse, sizeof(struct ns1__cancelSaveTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestCaseResponse, 0, sizeof(struct ns1__cancelSaveTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestCaseResponse(struct soap *soap, const struct ns1__cancelSaveTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestCaseResponse);
	if (soap_out_ns1__cancelSaveTestCaseResponse(soap, tag?tag:"ns1:cancelSaveTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestCaseResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveTestCaseResponse(struct soap *soap, struct ns1__cancelSaveTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestCaseResponse*)p = *(struct ns1__cancelSaveTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestCase(struct soap *soap, struct ns1__saveTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestCase(struct soap *soap, const struct ns1__saveTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestCase(struct soap *soap, const char *tag, int id, const struct ns1__saveTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestCase * SOAP_FMAC4 soap_in_ns1__saveTestCase(struct soap *soap, const char *tag, struct ns1__saveTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestCase, sizeof(struct ns1__saveTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestCase, 0, sizeof(struct ns1__saveTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestCase(struct soap *soap, const struct ns1__saveTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestCase);
	if (soap_out_ns1__saveTestCase(soap, tag?tag:"ns1:saveTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestCase * SOAP_FMAC4 soap_get_ns1__saveTestCase(struct soap *soap, struct ns1__saveTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestCase * SOAP_FMAC2 soap_instantiate_ns1__saveTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestCase);
		if (size)
			*size = sizeof(struct ns1__saveTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestCase %p -> %p\n", q, p));
	*(struct ns1__saveTestCase*)p = *(struct ns1__saveTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestCaseResponse(struct soap *soap, struct ns1__saveTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestCaseResponse(struct soap *soap, const struct ns1__saveTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestCaseResponse * SOAP_FMAC4 soap_in_ns1__saveTestCaseResponse(struct soap *soap, const char *tag, struct ns1__saveTestCaseResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestCaseResponse, sizeof(struct ns1__saveTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestCaseResponse, 0, sizeof(struct ns1__saveTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestCaseResponse(struct soap *soap, const struct ns1__saveTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestCaseResponse);
	if (soap_out_ns1__saveTestCaseResponse(soap, tag?tag:"ns1:saveTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestCaseResponse * SOAP_FMAC4 soap_get_ns1__saveTestCaseResponse(struct soap *soap, struct ns1__saveTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__saveTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__saveTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__saveTestCaseResponse*)p = *(struct ns1__saveTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestCaseByRecordID(struct soap *soap, struct ns1__editTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestCaseByRecordID(struct soap *soap, const struct ns1__editTestCaseByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editTestCaseByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestCaseByRecordID * SOAP_FMAC4 soap_in_ns1__editTestCaseByRecordID(struct soap *soap, const char *tag, struct ns1__editTestCaseByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestCaseByRecordID, sizeof(struct ns1__editTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestCaseByRecordID, 0, sizeof(struct ns1__editTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestCaseByRecordID(struct soap *soap, const struct ns1__editTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestCaseByRecordID);
	if (soap_out_ns1__editTestCaseByRecordID(soap, tag?tag:"ns1:editTestCaseByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestCaseByRecordID * SOAP_FMAC4 soap_get_ns1__editTestCaseByRecordID(struct soap *soap, struct ns1__editTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestCaseByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestCaseByRecordID);
		if (size)
			*size = sizeof(struct ns1__editTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestCaseByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestCaseByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestCaseByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestCaseByRecordID %p -> %p\n", q, p));
	*(struct ns1__editTestCaseByRecordID*)p = *(struct ns1__editTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestCaseByRecordIDResponse(struct soap *soap, struct ns1__editTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__editTestCaseByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestCaseByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editTestCaseByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestCaseByRecordIDResponse, sizeof(struct ns1__editTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestCaseByRecordIDResponse, 0, sizeof(struct ns1__editTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__editTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestCaseByRecordIDResponse);
	if (soap_out_ns1__editTestCaseByRecordIDResponse(soap, tag?tag:"ns1:editTestCaseByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editTestCaseByRecordIDResponse(struct soap *soap, struct ns1__editTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestCaseByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestCaseByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestCaseByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestCaseByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestCaseByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editTestCaseByRecordIDResponse*)p = *(struct ns1__editTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestCase(struct soap *soap, struct ns1__editTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestCase(struct soap *soap, const struct ns1__editTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestCase(struct soap *soap, const char *tag, int id, const struct ns1__editTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestCase * SOAP_FMAC4 soap_in_ns1__editTestCase(struct soap *soap, const char *tag, struct ns1__editTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testCaseNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestCase, sizeof(struct ns1__editTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestCase, 0, sizeof(struct ns1__editTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestCase(struct soap *soap, const struct ns1__editTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestCase);
	if (soap_out_ns1__editTestCase(soap, tag?tag:"ns1:editTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestCase * SOAP_FMAC4 soap_get_ns1__editTestCase(struct soap *soap, struct ns1__editTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestCase * SOAP_FMAC2 soap_instantiate_ns1__editTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestCase);
		if (size)
			*size = sizeof(struct ns1__editTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestCase %p -> %p\n", q, p));
	*(struct ns1__editTestCase*)p = *(struct ns1__editTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestCaseResponse(struct soap *soap, struct ns1__editTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestCaseResponse(struct soap *soap, const struct ns1__editTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestCaseResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestCaseResponse * SOAP_FMAC4 soap_in_ns1__editTestCaseResponse(struct soap *soap, const char *tag, struct ns1__editTestCaseResponse *a, const char *type)
{
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestCaseResponse, sizeof(struct ns1__editTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestCaseResponse, 0, sizeof(struct ns1__editTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestCaseResponse(struct soap *soap, const struct ns1__editTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestCaseResponse);
	if (soap_out_ns1__editTestCaseResponse(soap, tag?tag:"ns1:editTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestCaseResponse * SOAP_FMAC4 soap_get_ns1__editTestCaseResponse(struct soap *soap, struct ns1__editTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__editTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__editTestCaseResponse*)p = *(struct ns1__editTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestCaseByRecordID(struct soap *soap, struct ns1__deleteTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDeleteAssociatedTestRun);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestCaseByRecordID(struct soap *soap, const struct ns1__deleteTestCaseByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDeleteAssociatedTestRun, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestCaseByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedTestRun", -1, &a->bDeleteAssociatedTestRun, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestCaseByRecordID * SOAP_FMAC4 soap_in_ns1__deleteTestCaseByRecordID(struct soap *soap, const char *tag, struct ns1__deleteTestCaseByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDeleteAssociatedTestRun = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestCaseByRecordID, sizeof(struct ns1__deleteTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedTestRun && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedTestRun", &a->bDeleteAssociatedTestRun, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedTestRun--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestCaseByRecordID, 0, sizeof(struct ns1__deleteTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDeleteAssociatedTestRun > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestCaseByRecordID(struct soap *soap, const struct ns1__deleteTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestCaseByRecordID);
	if (soap_out_ns1__deleteTestCaseByRecordID(soap, tag?tag:"ns1:deleteTestCaseByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestCaseByRecordID * SOAP_FMAC4 soap_get_ns1__deleteTestCaseByRecordID(struct soap *soap, struct ns1__deleteTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestCaseByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestCaseByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestCaseByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestCaseByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestCaseByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestCaseByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteTestCaseByRecordID*)p = *(struct ns1__deleteTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, struct ns1__deleteTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestCaseByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestCaseByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteTestCaseByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse, sizeof(struct ns1__deleteTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse, 0, sizeof(struct ns1__deleteTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse);
	if (soap_out_ns1__deleteTestCaseByRecordIDResponse(soap, tag?tag:"ns1:deleteTestCaseByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, struct ns1__deleteTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestCaseByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestCaseByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestCaseByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestCaseByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestCaseByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestCaseByRecordIDResponse*)p = *(struct ns1__deleteTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestCase(struct soap *soap, struct ns1__deleteTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDeleteAssociatedTestRuns);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestCase(struct soap *soap, const struct ns1__deleteTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDeleteAssociatedTestRuns, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestCase(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDeleteAssociatedTestRuns", -1, &a->bDeleteAssociatedTestRuns, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestCase * SOAP_FMAC4 soap_in_ns1__deleteTestCase(struct soap *soap, const char *tag, struct ns1__deleteTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testCaseNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDeleteAssociatedTestRuns = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestCase, sizeof(struct ns1__deleteTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDeleteAssociatedTestRuns && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDeleteAssociatedTestRuns", &a->bDeleteAssociatedTestRuns, "xsd:boolean"))
				{	soap_flag_bDeleteAssociatedTestRuns--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestCase, 0, sizeof(struct ns1__deleteTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDeleteAssociatedTestRuns > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestCase(struct soap *soap, const struct ns1__deleteTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestCase);
	if (soap_out_ns1__deleteTestCase(soap, tag?tag:"ns1:deleteTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestCase * SOAP_FMAC4 soap_get_ns1__deleteTestCase(struct soap *soap, struct ns1__deleteTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestCase * SOAP_FMAC2 soap_instantiate_ns1__deleteTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestCase);
		if (size)
			*size = sizeof(struct ns1__deleteTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestCase %p -> %p\n", q, p));
	*(struct ns1__deleteTestCase*)p = *(struct ns1__deleteTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestCaseResponse(struct soap *soap, struct ns1__deleteTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestCaseResponse(struct soap *soap, const struct ns1__deleteTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestCaseResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestCaseResponse * SOAP_FMAC4 soap_in_ns1__deleteTestCaseResponse(struct soap *soap, const char *tag, struct ns1__deleteTestCaseResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestCaseResponse, sizeof(struct ns1__deleteTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestCaseResponse, 0, sizeof(struct ns1__deleteTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestCaseResponse(struct soap *soap, const struct ns1__deleteTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestCaseResponse);
	if (soap_out_ns1__deleteTestCaseResponse(soap, tag?tag:"ns1:deleteTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestCaseResponse * SOAP_FMAC4 soap_get_ns1__deleteTestCaseResponse(struct soap *soap, struct ns1__deleteTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestCaseResponse*)p = *(struct ns1__deleteTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTestCase(struct soap *soap, struct ns1__addTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTestCase(struct soap *soap, const struct ns1__addTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTestCase(struct soap *soap, const char *tag, int id, const struct ns1__addTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTestCase * SOAP_FMAC4 soap_in_ns1__addTestCase(struct soap *soap, const char *tag, struct ns1__addTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTestCase, sizeof(struct ns1__addTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTestCase, 0, sizeof(struct ns1__addTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTestCase(struct soap *soap, const struct ns1__addTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTestCase);
	if (soap_out_ns1__addTestCase(soap, tag?tag:"ns1:addTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTestCase * SOAP_FMAC4 soap_get_ns1__addTestCase(struct soap *soap, struct ns1__addTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTestCase * SOAP_FMAC2 soap_instantiate_ns1__addTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTestCase);
		if (size)
			*size = sizeof(struct ns1__addTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__addTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTestCase %p -> %p\n", q, p));
	*(struct ns1__addTestCase*)p = *(struct ns1__addTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTestCaseResponse(struct soap *soap, struct ns1__addTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTestCaseResponse(struct soap *soap, const struct ns1__addTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__addTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTestCaseResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTestCaseResponse * SOAP_FMAC4 soap_in_ns1__addTestCaseResponse(struct soap *soap, const char *tag, struct ns1__addTestCaseResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTestCaseResponse, sizeof(struct ns1__addTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTestCaseResponse, 0, sizeof(struct ns1__addTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTestCaseResponse(struct soap *soap, const struct ns1__addTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTestCaseResponse);
	if (soap_out_ns1__addTestCaseResponse(soap, tag?tag:"ns1:addTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTestCaseResponse * SOAP_FMAC4 soap_get_ns1__addTestCaseResponse(struct soap *soap, struct ns1__addTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__addTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__addTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__addTestCaseResponse*)p = *(struct ns1__addTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestCaseByRecordID(struct soap *soap, struct ns1__getTestCaseByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestCaseByRecordID(struct soap *soap, const struct ns1__getTestCaseByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestCaseByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getTestCaseByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestCaseByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestCaseByRecordID * SOAP_FMAC4 soap_in_ns1__getTestCaseByRecordID(struct soap *soap, const char *tag, struct ns1__getTestCaseByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestCaseByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestCaseByRecordID, sizeof(struct ns1__getTestCaseByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestCaseByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestCaseByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestCaseByRecordID, 0, sizeof(struct ns1__getTestCaseByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestCaseByRecordID(struct soap *soap, const struct ns1__getTestCaseByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestCaseByRecordID);
	if (soap_out_ns1__getTestCaseByRecordID(soap, tag?tag:"ns1:getTestCaseByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestCaseByRecordID * SOAP_FMAC4 soap_get_ns1__getTestCaseByRecordID(struct soap *soap, struct ns1__getTestCaseByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestCaseByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestCaseByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getTestCaseByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestCaseByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestCaseByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestCaseByRecordID);
		if (size)
			*size = sizeof(struct ns1__getTestCaseByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestCaseByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestCaseByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestCaseByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestCaseByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestCaseByRecordID %p -> %p\n", q, p));
	*(struct ns1__getTestCaseByRecordID*)p = *(struct ns1__getTestCaseByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestCaseByRecordIDResponse(struct soap *soap, struct ns1__getTestCaseByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__getTestCaseByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestCaseByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestCaseByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestCaseByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestCaseByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getTestCaseByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getTestCaseByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestCaseByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestCaseByRecordIDResponse, sizeof(struct ns1__getTestCaseByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestCaseByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestCaseByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestCaseByRecordIDResponse, 0, sizeof(struct ns1__getTestCaseByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestCaseByRecordIDResponse(struct soap *soap, const struct ns1__getTestCaseByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestCaseByRecordIDResponse);
	if (soap_out_ns1__getTestCaseByRecordIDResponse(soap, tag?tag:"ns1:getTestCaseByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestCaseByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getTestCaseByRecordIDResponse(struct soap *soap, struct ns1__getTestCaseByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestCaseByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestCaseByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestCaseByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestCaseByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestCaseByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestCaseByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getTestCaseByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestCaseByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestCaseByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestCaseByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestCaseByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestCaseByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getTestCaseByRecordIDResponse*)p = *(struct ns1__getTestCaseByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestCase(struct soap *soap, struct ns1__getTestCase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->testCaseNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestCase(struct soap *soap, const struct ns1__getTestCase *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->testCaseNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestCase(struct soap *soap, const char *tag, int id, const struct ns1__getTestCase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestCase), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testCaseNumber", -1, &a->testCaseNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestCase * SOAP_FMAC4 soap_in_ns1__getTestCase(struct soap *soap, const char *tag, struct ns1__getTestCase *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_testCaseNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestCase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestCase, sizeof(struct ns1__getTestCase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestCase(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_testCaseNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testCaseNumber", &a->testCaseNumber, "xsd:long"))
				{	soap_flag_testCaseNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestCase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestCase, 0, sizeof(struct ns1__getTestCase), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testCaseNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestCase(struct soap *soap, const struct ns1__getTestCase *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestCase);
	if (soap_out_ns1__getTestCase(soap, tag?tag:"ns1:getTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestCase * SOAP_FMAC4 soap_get_ns1__getTestCase(struct soap *soap, struct ns1__getTestCase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestCase * SOAP_FMAC2 soap_instantiate_ns1__getTestCase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestCase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestCase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestCase);
		if (size)
			*size = sizeof(struct ns1__getTestCase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestCase, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestCase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestCase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestCase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestCase %p -> %p\n", q, p));
	*(struct ns1__getTestCase*)p = *(struct ns1__getTestCase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestCaseResponse(struct soap *soap, struct ns1__getTestCaseResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestCase = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestCaseResponse(struct soap *soap, const struct ns1__getTestCaseResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTestCase(soap, &a->pTestCase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestCaseResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestCaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestCaseResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTestCase(soap, "pTestCase", -1, &a->pTestCase, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestCaseResponse * SOAP_FMAC4 soap_in_ns1__getTestCaseResponse(struct soap *soap, const char *tag, struct ns1__getTestCaseResponse *a, const char *type)
{
	size_t soap_flag_pTestCase = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestCaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestCaseResponse, sizeof(struct ns1__getTestCaseResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestCaseResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestCase && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTestCase(soap, "pTestCase", &a->pTestCase, "ns1:CTestCase"))
				{	soap_flag_pTestCase--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestCaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestCaseResponse, 0, sizeof(struct ns1__getTestCaseResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestCaseResponse(struct soap *soap, const struct ns1__getTestCaseResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestCaseResponse);
	if (soap_out_ns1__getTestCaseResponse(soap, tag?tag:"ns1:getTestCaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestCaseResponse * SOAP_FMAC4 soap_get_ns1__getTestCaseResponse(struct soap *soap, struct ns1__getTestCaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestCaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestCaseResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestCaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestCaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestCaseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestCaseResponse);
		if (size)
			*size = sizeof(struct ns1__getTestCaseResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestCaseResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestCaseResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestCaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestCaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestCaseResponse %p -> %p\n", q, p));
	*(struct ns1__getTestCaseResponse*)p = *(struct ns1__getTestCaseResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRunStepsModes(struct soap *soap, struct ns1__getTestRunStepsModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRunStepsModes(struct soap *soap, const struct ns1__getTestRunStepsModes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRunStepsModes(struct soap *soap, const char *tag, int id, const struct ns1__getTestRunStepsModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRunStepsModes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRunStepsModes * SOAP_FMAC4 soap_in_ns1__getTestRunStepsModes(struct soap *soap, const char *tag, struct ns1__getTestRunStepsModes *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRunStepsModes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRunStepsModes, sizeof(struct ns1__getTestRunStepsModes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRunStepsModes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRunStepsModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRunStepsModes, 0, sizeof(struct ns1__getTestRunStepsModes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRunStepsModes(struct soap *soap, const struct ns1__getTestRunStepsModes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRunStepsModes);
	if (soap_out_ns1__getTestRunStepsModes(soap, tag?tag:"ns1:getTestRunStepsModes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRunStepsModes * SOAP_FMAC4 soap_get_ns1__getTestRunStepsModes(struct soap *soap, struct ns1__getTestRunStepsModes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRunStepsModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRunStepsModes * SOAP_FMAC2 soap_instantiate_ns1__getTestRunStepsModes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRunStepsModes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRunStepsModes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRunStepsModes);
		if (size)
			*size = sizeof(struct ns1__getTestRunStepsModes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRunStepsModes, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRunStepsModes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRunStepsModes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRunStepsModes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRunStepsModes %p -> %p\n", q, p));
	*(struct ns1__getTestRunStepsModes*)p = *(struct ns1__getTestRunStepsModes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestRunStepsModesResponse(struct soap *soap, struct ns1__getTestRunStepsModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pModeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestRunStepsModesResponse(struct soap *soap, const struct ns1__getTestRunStepsModesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->pModeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestRunStepsModesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestRunStepsModesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestRunStepsModesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfstring(soap, "pModeList", -1, &a->pModeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestRunStepsModesResponse * SOAP_FMAC4 soap_in_ns1__getTestRunStepsModesResponse(struct soap *soap, const char *tag, struct ns1__getTestRunStepsModesResponse *a, const char *type)
{
	size_t soap_flag_pModeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestRunStepsModesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestRunStepsModesResponse, sizeof(struct ns1__getTestRunStepsModesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestRunStepsModesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pModeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "pModeList", &a->pModeList, "xsd:string"))
				{	soap_flag_pModeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestRunStepsModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestRunStepsModesResponse, 0, sizeof(struct ns1__getTestRunStepsModesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestRunStepsModesResponse(struct soap *soap, const struct ns1__getTestRunStepsModesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestRunStepsModesResponse);
	if (soap_out_ns1__getTestRunStepsModesResponse(soap, tag?tag:"ns1:getTestRunStepsModesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestRunStepsModesResponse * SOAP_FMAC4 soap_get_ns1__getTestRunStepsModesResponse(struct soap *soap, struct ns1__getTestRunStepsModesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestRunStepsModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestRunStepsModesResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestRunStepsModesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestRunStepsModesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestRunStepsModesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestRunStepsModesResponse);
		if (size)
			*size = sizeof(struct ns1__getTestRunStepsModesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestRunStepsModesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestRunStepsModesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestRunStepsModesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestRunStepsModesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestRunStepsModesResponse %p -> %p\n", q, p));
	*(struct ns1__getTestRunStepsModesResponse*)p = *(struct ns1__getTestRunStepsModesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestVariantTypes(struct soap *soap, struct ns1__getTestVariantTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestVariantTypes(struct soap *soap, const struct ns1__getTestVariantTypes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestVariantTypes(struct soap *soap, const char *tag, int id, const struct ns1__getTestVariantTypes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestVariantTypes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestVariantTypes * SOAP_FMAC4 soap_in_ns1__getTestVariantTypes(struct soap *soap, const char *tag, struct ns1__getTestVariantTypes *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestVariantTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestVariantTypes, sizeof(struct ns1__getTestVariantTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestVariantTypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestVariantTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestVariantTypes, 0, sizeof(struct ns1__getTestVariantTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestVariantTypes(struct soap *soap, const struct ns1__getTestVariantTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestVariantTypes);
	if (soap_out_ns1__getTestVariantTypes(soap, tag?tag:"ns1:getTestVariantTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestVariantTypes * SOAP_FMAC4 soap_get_ns1__getTestVariantTypes(struct soap *soap, struct ns1__getTestVariantTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestVariantTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestVariantTypes * SOAP_FMAC2 soap_instantiate_ns1__getTestVariantTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestVariantTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestVariantTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestVariantTypes);
		if (size)
			*size = sizeof(struct ns1__getTestVariantTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestVariantTypes, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestVariantTypes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestVariantTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestVariantTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestVariantTypes %p -> %p\n", q, p));
	*(struct ns1__getTestVariantTypes*)p = *(struct ns1__getTestVariantTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestVariantTypesResponse(struct soap *soap, struct ns1__getTestVariantTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestVariantTypesResponse(struct soap *soap, const struct ns1__getTestVariantTypesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->pTypeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestVariantTypesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestVariantTypesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestVariantTypesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfstring(soap, "pTypeList", -1, &a->pTypeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestVariantTypesResponse * SOAP_FMAC4 soap_in_ns1__getTestVariantTypesResponse(struct soap *soap, const char *tag, struct ns1__getTestVariantTypesResponse *a, const char *type)
{
	size_t soap_flag_pTypeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestVariantTypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestVariantTypesResponse, sizeof(struct ns1__getTestVariantTypesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestVariantTypesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTypeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "pTypeList", &a->pTypeList, "xsd:string"))
				{	soap_flag_pTypeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestVariantTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestVariantTypesResponse, 0, sizeof(struct ns1__getTestVariantTypesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestVariantTypesResponse(struct soap *soap, const struct ns1__getTestVariantTypesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestVariantTypesResponse);
	if (soap_out_ns1__getTestVariantTypesResponse(soap, tag?tag:"ns1:getTestVariantTypesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestVariantTypesResponse * SOAP_FMAC4 soap_get_ns1__getTestVariantTypesResponse(struct soap *soap, struct ns1__getTestVariantTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestVariantTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestVariantTypesResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestVariantTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestVariantTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestVariantTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestVariantTypesResponse);
		if (size)
			*size = sizeof(struct ns1__getTestVariantTypesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestVariantTypesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestVariantTypesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestVariantTypesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestVariantTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestVariantTypesResponse %p -> %p\n", q, p));
	*(struct ns1__getTestVariantTypesResponse*)p = *(struct ns1__getTestVariantTypesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveLink(struct soap *soap, struct ns1__cancelSaveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveLink(struct soap *soap, const struct ns1__cancelSaveLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveLink(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveLink * SOAP_FMAC4 soap_in_ns1__cancelSaveLink(struct soap *soap, const char *tag, struct ns1__cancelSaveLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveLink, sizeof(struct ns1__cancelSaveLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveLink, 0, sizeof(struct ns1__cancelSaveLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveLink(struct soap *soap, const struct ns1__cancelSaveLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveLink);
	if (soap_out_ns1__cancelSaveLink(soap, tag?tag:"ns1:cancelSaveLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveLink * SOAP_FMAC4 soap_get_ns1__cancelSaveLink(struct soap *soap, struct ns1__cancelSaveLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveLink * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveLink);
		if (size)
			*size = sizeof(struct ns1__cancelSaveLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveLink, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveLink %p -> %p\n", q, p));
	*(struct ns1__cancelSaveLink*)p = *(struct ns1__cancelSaveLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveLinkResponse(struct soap *soap, struct ns1__cancelSaveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveLinkResponse(struct soap *soap, const struct ns1__cancelSaveLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveLinkResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveLinkResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveLinkResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveLinkResponse, sizeof(struct ns1__cancelSaveLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveLinkResponse, 0, sizeof(struct ns1__cancelSaveLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveLinkResponse(struct soap *soap, const struct ns1__cancelSaveLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveLinkResponse);
	if (soap_out_ns1__cancelSaveLinkResponse(soap, tag?tag:"ns1:cancelSaveLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveLinkResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveLinkResponse(struct soap *soap, struct ns1__cancelSaveLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveLinkResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveLinkResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveLinkResponse*)p = *(struct ns1__cancelSaveLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveLink(struct soap *soap, struct ns1__saveLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveLink(struct soap *soap, const struct ns1__saveLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CLink(soap, &a->pLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveLink(struct soap *soap, const char *tag, int id, const struct ns1__saveLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveLink * SOAP_FMAC4 soap_in_ns1__saveLink(struct soap *soap, const char *tag, struct ns1__saveLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveLink, sizeof(struct ns1__saveLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CLink(soap, "pLink", &a->pLink, "ns1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveLink, 0, sizeof(struct ns1__saveLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveLink(struct soap *soap, const struct ns1__saveLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveLink);
	if (soap_out_ns1__saveLink(soap, tag?tag:"ns1:saveLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveLink * SOAP_FMAC4 soap_get_ns1__saveLink(struct soap *soap, struct ns1__saveLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveLink * SOAP_FMAC2 soap_instantiate_ns1__saveLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveLink);
		if (size)
			*size = sizeof(struct ns1__saveLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveLink, n);
		if (size)
			*size = n * sizeof(struct ns1__saveLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveLink %p -> %p\n", q, p));
	*(struct ns1__saveLink*)p = *(struct ns1__saveLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveLinkResponse(struct soap *soap, struct ns1__saveLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveLinkResponse(struct soap *soap, const struct ns1__saveLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveLinkResponse * SOAP_FMAC4 soap_in_ns1__saveLinkResponse(struct soap *soap, const char *tag, struct ns1__saveLinkResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveLinkResponse, sizeof(struct ns1__saveLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveLinkResponse, 0, sizeof(struct ns1__saveLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveLinkResponse(struct soap *soap, const struct ns1__saveLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveLinkResponse);
	if (soap_out_ns1__saveLinkResponse(soap, tag?tag:"ns1:saveLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveLinkResponse * SOAP_FMAC4 soap_get_ns1__saveLinkResponse(struct soap *soap, struct ns1__saveLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__saveLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveLinkResponse);
		if (size)
			*size = sizeof(struct ns1__saveLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveLinkResponse %p -> %p\n", q, p));
	*(struct ns1__saveLinkResponse*)p = *(struct ns1__saveLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editLink(struct soap *soap, struct ns1__editLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editLink(struct soap *soap, const struct ns1__editLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editLink(struct soap *soap, const char *tag, int id, const struct ns1__editLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editLink * SOAP_FMAC4 soap_in_ns1__editLink(struct soap *soap, const char *tag, struct ns1__editLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editLink, sizeof(struct ns1__editLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editLink, 0, sizeof(struct ns1__editLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editLink(struct soap *soap, const struct ns1__editLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editLink);
	if (soap_out_ns1__editLink(soap, tag?tag:"ns1:editLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editLink * SOAP_FMAC4 soap_get_ns1__editLink(struct soap *soap, struct ns1__editLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editLink * SOAP_FMAC2 soap_instantiate_ns1__editLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editLink);
		if (size)
			*size = sizeof(struct ns1__editLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editLink, n);
		if (size)
			*size = n * sizeof(struct ns1__editLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editLink %p -> %p\n", q, p));
	*(struct ns1__editLink*)p = *(struct ns1__editLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editLinkResponse(struct soap *soap, struct ns1__editLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editLinkResponse(struct soap *soap, const struct ns1__editLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CLink(soap, &a->pLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__editLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editLinkResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editLinkResponse * SOAP_FMAC4 soap_in_ns1__editLinkResponse(struct soap *soap, const char *tag, struct ns1__editLinkResponse *a, const char *type)
{
	size_t soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editLinkResponse, sizeof(struct ns1__editLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CLink(soap, "pLink", &a->pLink, "ns1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editLinkResponse, 0, sizeof(struct ns1__editLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editLinkResponse(struct soap *soap, const struct ns1__editLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editLinkResponse);
	if (soap_out_ns1__editLinkResponse(soap, tag?tag:"ns1:editLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editLinkResponse * SOAP_FMAC4 soap_get_ns1__editLinkResponse(struct soap *soap, struct ns1__editLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__editLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editLinkResponse);
		if (size)
			*size = sizeof(struct ns1__editLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editLinkResponse %p -> %p\n", q, p));
	*(struct ns1__editLinkResponse*)p = *(struct ns1__editLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteLink(struct soap *soap, struct ns1__deleteLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteLink(struct soap *soap, const struct ns1__deleteLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteLink(struct soap *soap, const char *tag, int id, const struct ns1__deleteLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteLink * SOAP_FMAC4 soap_in_ns1__deleteLink(struct soap *soap, const char *tag, struct ns1__deleteLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteLink, sizeof(struct ns1__deleteLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteLink, 0, sizeof(struct ns1__deleteLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteLink(struct soap *soap, const struct ns1__deleteLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteLink);
	if (soap_out_ns1__deleteLink(soap, tag?tag:"ns1:deleteLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteLink * SOAP_FMAC4 soap_get_ns1__deleteLink(struct soap *soap, struct ns1__deleteLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteLink * SOAP_FMAC2 soap_instantiate_ns1__deleteLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteLink);
		if (size)
			*size = sizeof(struct ns1__deleteLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteLink, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteLink %p -> %p\n", q, p));
	*(struct ns1__deleteLink*)p = *(struct ns1__deleteLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteLinkResponse(struct soap *soap, struct ns1__deleteLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteLinkResponse(struct soap *soap, const struct ns1__deleteLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteLinkResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteLinkResponse * SOAP_FMAC4 soap_in_ns1__deleteLinkResponse(struct soap *soap, const char *tag, struct ns1__deleteLinkResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteLinkResponse, sizeof(struct ns1__deleteLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteLinkResponse, 0, sizeof(struct ns1__deleteLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteLinkResponse(struct soap *soap, const struct ns1__deleteLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteLinkResponse);
	if (soap_out_ns1__deleteLinkResponse(soap, tag?tag:"ns1:deleteLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteLinkResponse * SOAP_FMAC4 soap_get_ns1__deleteLinkResponse(struct soap *soap, struct ns1__deleteLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteLinkResponse);
		if (size)
			*size = sizeof(struct ns1__deleteLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteLinkResponse %p -> %p\n", q, p));
	*(struct ns1__deleteLinkResponse*)p = *(struct ns1__deleteLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addLink(struct soap *soap, struct ns1__addLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addLink(struct soap *soap, const struct ns1__addLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CLink(soap, &a->pLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addLink(struct soap *soap, const char *tag, int id, const struct ns1__addLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addLink * SOAP_FMAC4 soap_in_ns1__addLink(struct soap *soap, const char *tag, struct ns1__addLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addLink, sizeof(struct ns1__addLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CLink(soap, "pLink", &a->pLink, "ns1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addLink, 0, sizeof(struct ns1__addLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addLink(struct soap *soap, const struct ns1__addLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addLink);
	if (soap_out_ns1__addLink(soap, tag?tag:"ns1:addLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addLink * SOAP_FMAC4 soap_get_ns1__addLink(struct soap *soap, struct ns1__addLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addLink * SOAP_FMAC2 soap_instantiate_ns1__addLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addLink);
		if (size)
			*size = sizeof(struct ns1__addLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addLink, n);
		if (size)
			*size = n * sizeof(struct ns1__addLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addLink %p -> %p\n", q, p));
	*(struct ns1__addLink*)p = *(struct ns1__addLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addLinkResponse(struct soap *soap, struct ns1__addLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addLinkResponse(struct soap *soap, const struct ns1__addLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__addLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addLinkResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addLinkResponse * SOAP_FMAC4 soap_in_ns1__addLinkResponse(struct soap *soap, const char *tag, struct ns1__addLinkResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addLinkResponse, sizeof(struct ns1__addLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addLinkResponse, 0, sizeof(struct ns1__addLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addLinkResponse(struct soap *soap, const struct ns1__addLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addLinkResponse);
	if (soap_out_ns1__addLinkResponse(soap, tag?tag:"ns1:addLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addLinkResponse * SOAP_FMAC4 soap_get_ns1__addLinkResponse(struct soap *soap, struct ns1__addLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__addLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addLinkResponse);
		if (size)
			*size = sizeof(struct ns1__addLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addLinkResponse %p -> %p\n", q, p));
	*(struct ns1__addLinkResponse*)p = *(struct ns1__addLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLink(struct soap *soap, struct ns1__getLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->linkID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLink(struct soap *soap, const struct ns1__getLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->linkID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLink(struct soap *soap, const char *tag, int id, const struct ns1__getLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "linkID", -1, &a->linkID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLink * SOAP_FMAC4 soap_in_ns1__getLink(struct soap *soap, const char *tag, struct ns1__getLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_linkID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLink, sizeof(struct ns1__getLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_linkID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "linkID", &a->linkID, "xsd:long"))
				{	soap_flag_linkID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLink, 0, sizeof(struct ns1__getLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_linkID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLink(struct soap *soap, const struct ns1__getLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLink);
	if (soap_out_ns1__getLink(soap, tag?tag:"ns1:getLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLink * SOAP_FMAC4 soap_get_ns1__getLink(struct soap *soap, struct ns1__getLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLink * SOAP_FMAC2 soap_instantiate_ns1__getLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLink);
		if (size)
			*size = sizeof(struct ns1__getLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLink, n);
		if (size)
			*size = n * sizeof(struct ns1__getLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLink %p -> %p\n", q, p));
	*(struct ns1__getLink*)p = *(struct ns1__getLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLinkResponse(struct soap *soap, struct ns1__getLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLink = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLinkResponse(struct soap *soap, const struct ns1__getLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CLink(soap, &a->pLink);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__getLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLinkResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CLink(soap, "pLink", -1, &a->pLink, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLinkResponse * SOAP_FMAC4 soap_in_ns1__getLinkResponse(struct soap *soap, const char *tag, struct ns1__getLinkResponse *a, const char *type)
{
	size_t soap_flag_pLink = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLinkResponse, sizeof(struct ns1__getLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLink && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CLink(soap, "pLink", &a->pLink, "ns1:CLink"))
				{	soap_flag_pLink--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLinkResponse, 0, sizeof(struct ns1__getLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLinkResponse(struct soap *soap, const struct ns1__getLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLinkResponse);
	if (soap_out_ns1__getLinkResponse(soap, tag?tag:"ns1:getLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLinkResponse * SOAP_FMAC4 soap_get_ns1__getLinkResponse(struct soap *soap, struct ns1__getLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__getLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLinkResponse);
		if (size)
			*size = sizeof(struct ns1__getLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLinkResponse %p -> %p\n", q, p));
	*(struct ns1__getLinkResponse*)p = *(struct ns1__getLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLinksForDefect(struct soap *soap, struct ns1__getLinksForDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLinksForDefect(struct soap *soap, const struct ns1__getLinksForDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectRecordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLinksForDefect(struct soap *soap, const char *tag, int id, const struct ns1__getLinksForDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLinksForDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectRecordID", -1, &a->defectRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLinksForDefect * SOAP_FMAC4 soap_in_ns1__getLinksForDefect(struct soap *soap, const char *tag, struct ns1__getLinksForDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_defectRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLinksForDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLinksForDefect, sizeof(struct ns1__getLinksForDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLinksForDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectRecordID", &a->defectRecordID, "xsd:long"))
				{	soap_flag_defectRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLinksForDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLinksForDefect, 0, sizeof(struct ns1__getLinksForDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLinksForDefect(struct soap *soap, const struct ns1__getLinksForDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLinksForDefect);
	if (soap_out_ns1__getLinksForDefect(soap, tag?tag:"ns1:getLinksForDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLinksForDefect * SOAP_FMAC4 soap_get_ns1__getLinksForDefect(struct soap *soap, struct ns1__getLinksForDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLinksForDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLinksForDefect * SOAP_FMAC2 soap_instantiate_ns1__getLinksForDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLinksForDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLinksForDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLinksForDefect);
		if (size)
			*size = sizeof(struct ns1__getLinksForDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLinksForDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__getLinksForDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLinksForDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLinksForDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLinksForDefect %p -> %p\n", q, p));
	*(struct ns1__getLinksForDefect*)p = *(struct ns1__getLinksForDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLinksForDefectResponse(struct soap *soap, struct ns1__getLinksForDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLinkList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLinksForDefectResponse(struct soap *soap, const struct ns1__getLinksForDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCLink(soap, &a->pLinkList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLinksForDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__getLinksForDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLinksForDefectResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCLink(soap, "pLinkList", -1, &a->pLinkList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLinksForDefectResponse * SOAP_FMAC4 soap_in_ns1__getLinksForDefectResponse(struct soap *soap, const char *tag, struct ns1__getLinksForDefectResponse *a, const char *type)
{
	size_t soap_flag_pLinkList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLinksForDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLinksForDefectResponse, sizeof(struct ns1__getLinksForDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLinksForDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLinkList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCLink(soap, "pLinkList", &a->pLinkList, "ns1:CLink"))
				{	soap_flag_pLinkList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLinksForDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLinksForDefectResponse, 0, sizeof(struct ns1__getLinksForDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLinksForDefectResponse(struct soap *soap, const struct ns1__getLinksForDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLinksForDefectResponse);
	if (soap_out_ns1__getLinksForDefectResponse(soap, tag?tag:"ns1:getLinksForDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLinksForDefectResponse * SOAP_FMAC4 soap_get_ns1__getLinksForDefectResponse(struct soap *soap, struct ns1__getLinksForDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLinksForDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLinksForDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__getLinksForDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLinksForDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLinksForDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLinksForDefectResponse);
		if (size)
			*size = sizeof(struct ns1__getLinksForDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLinksForDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getLinksForDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLinksForDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLinksForDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLinksForDefectResponse %p -> %p\n", q, p));
	*(struct ns1__getLinksForDefectResponse*)p = *(struct ns1__getLinksForDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLinksForItem(struct soap *soap, struct ns1__getLinksForItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_LONG64(soap, &a->itemRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLinksForItem(struct soap *soap, const struct ns1__getLinksForItem *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_embedded(soap, &a->itemRecordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLinksForItem(struct soap *soap, const char *tag, int id, const struct ns1__getLinksForItem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLinksForItem), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "itemRecordID", -1, &a->itemRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLinksForItem * SOAP_FMAC4 soap_in_ns1__getLinksForItem(struct soap *soap, const char *tag, struct ns1__getLinksForItem *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_itemRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLinksForItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLinksForItem, sizeof(struct ns1__getLinksForItem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLinksForItem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_itemRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "itemRecordID", &a->itemRecordID, "xsd:long"))
				{	soap_flag_itemRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLinksForItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLinksForItem, 0, sizeof(struct ns1__getLinksForItem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_itemRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLinksForItem(struct soap *soap, const struct ns1__getLinksForItem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLinksForItem);
	if (soap_out_ns1__getLinksForItem(soap, tag?tag:"ns1:getLinksForItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLinksForItem * SOAP_FMAC4 soap_get_ns1__getLinksForItem(struct soap *soap, struct ns1__getLinksForItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLinksForItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLinksForItem * SOAP_FMAC2 soap_instantiate_ns1__getLinksForItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLinksForItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLinksForItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLinksForItem);
		if (size)
			*size = sizeof(struct ns1__getLinksForItem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLinksForItem, n);
		if (size)
			*size = n * sizeof(struct ns1__getLinksForItem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLinksForItem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLinksForItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLinksForItem %p -> %p\n", q, p));
	*(struct ns1__getLinksForItem*)p = *(struct ns1__getLinksForItem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLinksForItemResponse(struct soap *soap, struct ns1__getLinksForItemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pLinkList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLinksForItemResponse(struct soap *soap, const struct ns1__getLinksForItemResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCLink(soap, &a->pLinkList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLinksForItemResponse(struct soap *soap, const char *tag, int id, const struct ns1__getLinksForItemResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLinksForItemResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCLink(soap, "pLinkList", -1, &a->pLinkList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLinksForItemResponse * SOAP_FMAC4 soap_in_ns1__getLinksForItemResponse(struct soap *soap, const char *tag, struct ns1__getLinksForItemResponse *a, const char *type)
{
	size_t soap_flag_pLinkList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLinksForItemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLinksForItemResponse, sizeof(struct ns1__getLinksForItemResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLinksForItemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pLinkList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCLink(soap, "pLinkList", &a->pLinkList, "ns1:CLink"))
				{	soap_flag_pLinkList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLinksForItemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLinksForItemResponse, 0, sizeof(struct ns1__getLinksForItemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLinksForItemResponse(struct soap *soap, const struct ns1__getLinksForItemResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLinksForItemResponse);
	if (soap_out_ns1__getLinksForItemResponse(soap, tag?tag:"ns1:getLinksForItemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getLinksForItemResponse * SOAP_FMAC4 soap_get_ns1__getLinksForItemResponse(struct soap *soap, struct ns1__getLinksForItemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLinksForItemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getLinksForItemResponse * SOAP_FMAC2 soap_instantiate_ns1__getLinksForItemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLinksForItemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLinksForItemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getLinksForItemResponse);
		if (size)
			*size = sizeof(struct ns1__getLinksForItemResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getLinksForItemResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getLinksForItemResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getLinksForItemResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLinksForItemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLinksForItemResponse %p -> %p\n", q, p));
	*(struct ns1__getLinksForItemResponse*)p = *(struct ns1__getLinksForItemResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addGlobalCustomer(struct soap *soap, struct ns1__addGlobalCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addGlobalCustomer(struct soap *soap, const struct ns1__addGlobalCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CGlobalUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addGlobalCustomer(struct soap *soap, const char *tag, int id, const struct ns1__addGlobalCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addGlobalCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CGlobalUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addGlobalCustomer * SOAP_FMAC4 soap_in_ns1__addGlobalCustomer(struct soap *soap, const char *tag, struct ns1__addGlobalCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addGlobalCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addGlobalCustomer, sizeof(struct ns1__addGlobalCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addGlobalCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CGlobalUser(soap, "pUser", &a->pUser, "ns1:CGlobalUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addGlobalCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addGlobalCustomer, 0, sizeof(struct ns1__addGlobalCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addGlobalCustomer(struct soap *soap, const struct ns1__addGlobalCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addGlobalCustomer);
	if (soap_out_ns1__addGlobalCustomer(soap, tag?tag:"ns1:addGlobalCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addGlobalCustomer * SOAP_FMAC4 soap_get_ns1__addGlobalCustomer(struct soap *soap, struct ns1__addGlobalCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addGlobalCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addGlobalCustomer * SOAP_FMAC2 soap_instantiate_ns1__addGlobalCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addGlobalCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addGlobalCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addGlobalCustomer);
		if (size)
			*size = sizeof(struct ns1__addGlobalCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addGlobalCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__addGlobalCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addGlobalCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addGlobalCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addGlobalCustomer %p -> %p\n", q, p));
	*(struct ns1__addGlobalCustomer*)p = *(struct ns1__addGlobalCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addGlobalCustomerResponse(struct soap *soap, struct ns1__addGlobalCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addGlobalCustomerResponse(struct soap *soap, const struct ns1__addGlobalCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addGlobalCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__addGlobalCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addGlobalCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addGlobalCustomerResponse * SOAP_FMAC4 soap_in_ns1__addGlobalCustomerResponse(struct soap *soap, const char *tag, struct ns1__addGlobalCustomerResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addGlobalCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addGlobalCustomerResponse, sizeof(struct ns1__addGlobalCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addGlobalCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addGlobalCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addGlobalCustomerResponse, 0, sizeof(struct ns1__addGlobalCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addGlobalCustomerResponse(struct soap *soap, const struct ns1__addGlobalCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addGlobalCustomerResponse);
	if (soap_out_ns1__addGlobalCustomerResponse(soap, tag?tag:"ns1:addGlobalCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addGlobalCustomerResponse * SOAP_FMAC4 soap_get_ns1__addGlobalCustomerResponse(struct soap *soap, struct ns1__addGlobalCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addGlobalCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addGlobalCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__addGlobalCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addGlobalCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addGlobalCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addGlobalCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__addGlobalCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addGlobalCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addGlobalCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addGlobalCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addGlobalCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addGlobalCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__addGlobalCustomerResponse*)p = *(struct ns1__addGlobalCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__promoteCustomer(struct soap *soap, struct ns1__promoteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->localCustomer);
	soap_default_string(soap, &a->globalUser);
	soap_default_string(soap, &a->loginname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__promoteCustomer(struct soap *soap, const struct ns1__promoteCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->localCustomer);
	soap_serialize_string(soap, &a->globalUser);
	soap_serialize_string(soap, &a->loginname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__promoteCustomer(struct soap *soap, const char *tag, int id, const struct ns1__promoteCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__promoteCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "localCustomer", -1, &a->localCustomer, ""))
		return soap->error;
	if (soap_out_string(soap, "globalUser", -1, &a->globalUser, ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &a->loginname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__promoteCustomer * SOAP_FMAC4 soap_in_ns1__promoteCustomer(struct soap *soap, const char *tag, struct ns1__promoteCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_localCustomer = 1;
	size_t soap_flag_globalUser = 1;
	size_t soap_flag_loginname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__promoteCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__promoteCustomer, sizeof(struct ns1__promoteCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__promoteCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_localCustomer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "localCustomer", &a->localCustomer, "xsd:string"))
				{	soap_flag_localCustomer--;
					continue;
				}
			if (soap_flag_globalUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "globalUser", &a->globalUser, "xsd:string"))
				{	soap_flag_globalUser--;
					continue;
				}
			if (soap_flag_loginname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &a->loginname, "xsd:string"))
				{	soap_flag_loginname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__promoteCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__promoteCustomer, 0, sizeof(struct ns1__promoteCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__promoteCustomer(struct soap *soap, const struct ns1__promoteCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__promoteCustomer);
	if (soap_out_ns1__promoteCustomer(soap, tag?tag:"ns1:promoteCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__promoteCustomer * SOAP_FMAC4 soap_get_ns1__promoteCustomer(struct soap *soap, struct ns1__promoteCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__promoteCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__promoteCustomer * SOAP_FMAC2 soap_instantiate_ns1__promoteCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__promoteCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__promoteCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__promoteCustomer);
		if (size)
			*size = sizeof(struct ns1__promoteCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__promoteCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__promoteCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__promoteCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__promoteCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__promoteCustomer %p -> %p\n", q, p));
	*(struct ns1__promoteCustomer*)p = *(struct ns1__promoteCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__promoteCustomerResponse(struct soap *soap, struct ns1__promoteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__promoteCustomerResponse(struct soap *soap, const struct ns1__promoteCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__promoteCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__promoteCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__promoteCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__promoteCustomerResponse * SOAP_FMAC4 soap_in_ns1__promoteCustomerResponse(struct soap *soap, const char *tag, struct ns1__promoteCustomerResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__promoteCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__promoteCustomerResponse, sizeof(struct ns1__promoteCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__promoteCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__promoteCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__promoteCustomerResponse, 0, sizeof(struct ns1__promoteCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__promoteCustomerResponse(struct soap *soap, const struct ns1__promoteCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__promoteCustomerResponse);
	if (soap_out_ns1__promoteCustomerResponse(soap, tag?tag:"ns1:promoteCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__promoteCustomerResponse * SOAP_FMAC4 soap_get_ns1__promoteCustomerResponse(struct soap *soap, struct ns1__promoteCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__promoteCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__promoteCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__promoteCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__promoteCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__promoteCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__promoteCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__promoteCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__promoteCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__promoteCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__promoteCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__promoteCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__promoteCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__promoteCustomerResponse*)p = *(struct ns1__promoteCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveCustomer(struct soap *soap, struct ns1__cancelSaveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveCustomer(struct soap *soap, const struct ns1__cancelSaveCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveCustomer(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveCustomer * SOAP_FMAC4 soap_in_ns1__cancelSaveCustomer(struct soap *soap, const char *tag, struct ns1__cancelSaveCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveCustomer, sizeof(struct ns1__cancelSaveCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveCustomer, 0, sizeof(struct ns1__cancelSaveCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveCustomer(struct soap *soap, const struct ns1__cancelSaveCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveCustomer);
	if (soap_out_ns1__cancelSaveCustomer(soap, tag?tag:"ns1:cancelSaveCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveCustomer * SOAP_FMAC4 soap_get_ns1__cancelSaveCustomer(struct soap *soap, struct ns1__cancelSaveCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveCustomer * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveCustomer);
		if (size)
			*size = sizeof(struct ns1__cancelSaveCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveCustomer %p -> %p\n", q, p));
	*(struct ns1__cancelSaveCustomer*)p = *(struct ns1__cancelSaveCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveCustomerResponse(struct soap *soap, struct ns1__cancelSaveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveCustomerResponse(struct soap *soap, const struct ns1__cancelSaveCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveCustomerResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveCustomerResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveCustomerResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveCustomerResponse, sizeof(struct ns1__cancelSaveCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveCustomerResponse, 0, sizeof(struct ns1__cancelSaveCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveCustomerResponse(struct soap *soap, const struct ns1__cancelSaveCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveCustomerResponse);
	if (soap_out_ns1__cancelSaveCustomerResponse(soap, tag?tag:"ns1:cancelSaveCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveCustomerResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveCustomerResponse(struct soap *soap, struct ns1__cancelSaveCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveCustomerResponse*)p = *(struct ns1__cancelSaveCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteCustomerByRecordID(struct soap *soap, struct ns1__deleteCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteCustomerByRecordID(struct soap *soap, const struct ns1__deleteCustomerByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteCustomerByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteCustomerByRecordID * SOAP_FMAC4 soap_in_ns1__deleteCustomerByRecordID(struct soap *soap, const char *tag, struct ns1__deleteCustomerByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteCustomerByRecordID, sizeof(struct ns1__deleteCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteCustomerByRecordID, 0, sizeof(struct ns1__deleteCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteCustomerByRecordID(struct soap *soap, const struct ns1__deleteCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteCustomerByRecordID);
	if (soap_out_ns1__deleteCustomerByRecordID(soap, tag?tag:"ns1:deleteCustomerByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteCustomerByRecordID * SOAP_FMAC4 soap_get_ns1__deleteCustomerByRecordID(struct soap *soap, struct ns1__deleteCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteCustomerByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteCustomerByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteCustomerByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteCustomerByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteCustomerByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteCustomerByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteCustomerByRecordID*)p = *(struct ns1__deleteCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, struct ns1__deleteCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, const struct ns1__deleteCustomerByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteCustomerByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteCustomerByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse, sizeof(struct ns1__deleteCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse, 0, sizeof(struct ns1__deleteCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, const struct ns1__deleteCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse);
	if (soap_out_ns1__deleteCustomerByRecordIDResponse(soap, tag?tag:"ns1:deleteCustomerByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, struct ns1__deleteCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteCustomerByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteCustomerByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteCustomerByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteCustomerByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteCustomerByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteCustomerByRecordIDResponse*)p = *(struct ns1__deleteCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteCustomer(struct soap *soap, struct ns1__deleteCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteCustomer(struct soap *soap, const struct ns1__deleteCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteCustomer(struct soap *soap, const char *tag, int id, const struct ns1__deleteCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteCustomer * SOAP_FMAC4 soap_in_ns1__deleteCustomer(struct soap *soap, const char *tag, struct ns1__deleteCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteCustomer, sizeof(struct ns1__deleteCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteCustomer, 0, sizeof(struct ns1__deleteCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteCustomer(struct soap *soap, const struct ns1__deleteCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteCustomer);
	if (soap_out_ns1__deleteCustomer(soap, tag?tag:"ns1:deleteCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteCustomer * SOAP_FMAC4 soap_get_ns1__deleteCustomer(struct soap *soap, struct ns1__deleteCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteCustomer * SOAP_FMAC2 soap_instantiate_ns1__deleteCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteCustomer);
		if (size)
			*size = sizeof(struct ns1__deleteCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteCustomer %p -> %p\n", q, p));
	*(struct ns1__deleteCustomer*)p = *(struct ns1__deleteCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteCustomerResponse(struct soap *soap, struct ns1__deleteCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteCustomerResponse(struct soap *soap, const struct ns1__deleteCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteCustomerResponse * SOAP_FMAC4 soap_in_ns1__deleteCustomerResponse(struct soap *soap, const char *tag, struct ns1__deleteCustomerResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteCustomerResponse, sizeof(struct ns1__deleteCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteCustomerResponse, 0, sizeof(struct ns1__deleteCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteCustomerResponse(struct soap *soap, const struct ns1__deleteCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteCustomerResponse);
	if (soap_out_ns1__deleteCustomerResponse(soap, tag?tag:"ns1:deleteCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteCustomerResponse * SOAP_FMAC4 soap_get_ns1__deleteCustomerResponse(struct soap *soap, struct ns1__deleteCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__deleteCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__deleteCustomerResponse*)p = *(struct ns1__deleteCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveCustomer(struct soap *soap, struct ns1__saveCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveCustomer(struct soap *soap, const struct ns1__saveCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveCustomer(struct soap *soap, const char *tag, int id, const struct ns1__saveCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveCustomer * SOAP_FMAC4 soap_in_ns1__saveCustomer(struct soap *soap, const char *tag, struct ns1__saveCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveCustomer, sizeof(struct ns1__saveCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveCustomer, 0, sizeof(struct ns1__saveCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveCustomer(struct soap *soap, const struct ns1__saveCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveCustomer);
	if (soap_out_ns1__saveCustomer(soap, tag?tag:"ns1:saveCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveCustomer * SOAP_FMAC4 soap_get_ns1__saveCustomer(struct soap *soap, struct ns1__saveCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveCustomer * SOAP_FMAC2 soap_instantiate_ns1__saveCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveCustomer);
		if (size)
			*size = sizeof(struct ns1__saveCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__saveCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveCustomer %p -> %p\n", q, p));
	*(struct ns1__saveCustomer*)p = *(struct ns1__saveCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveCustomerResponse(struct soap *soap, struct ns1__saveCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveCustomerResponse(struct soap *soap, const struct ns1__saveCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveCustomerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveCustomerResponse * SOAP_FMAC4 soap_in_ns1__saveCustomerResponse(struct soap *soap, const char *tag, struct ns1__saveCustomerResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveCustomerResponse, sizeof(struct ns1__saveCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveCustomerResponse, 0, sizeof(struct ns1__saveCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveCustomerResponse(struct soap *soap, const struct ns1__saveCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveCustomerResponse);
	if (soap_out_ns1__saveCustomerResponse(soap, tag?tag:"ns1:saveCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveCustomerResponse * SOAP_FMAC4 soap_get_ns1__saveCustomerResponse(struct soap *soap, struct ns1__saveCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__saveCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__saveCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__saveCustomerResponse*)p = *(struct ns1__saveCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editCustomerByRecordID(struct soap *soap, struct ns1__editCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editCustomerByRecordID(struct soap *soap, const struct ns1__editCustomerByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editCustomerByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editCustomerByRecordID * SOAP_FMAC4 soap_in_ns1__editCustomerByRecordID(struct soap *soap, const char *tag, struct ns1__editCustomerByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editCustomerByRecordID, sizeof(struct ns1__editCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editCustomerByRecordID, 0, sizeof(struct ns1__editCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editCustomerByRecordID(struct soap *soap, const struct ns1__editCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editCustomerByRecordID);
	if (soap_out_ns1__editCustomerByRecordID(soap, tag?tag:"ns1:editCustomerByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editCustomerByRecordID * SOAP_FMAC4 soap_get_ns1__editCustomerByRecordID(struct soap *soap, struct ns1__editCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editCustomerByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editCustomerByRecordID);
		if (size)
			*size = sizeof(struct ns1__editCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editCustomerByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editCustomerByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editCustomerByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editCustomerByRecordID %p -> %p\n", q, p));
	*(struct ns1__editCustomerByRecordID*)p = *(struct ns1__editCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editCustomerByRecordIDResponse(struct soap *soap, struct ns1__editCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editCustomerByRecordIDResponse(struct soap *soap, const struct ns1__editCustomerByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editCustomerByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editCustomerByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editCustomerByRecordIDResponse, sizeof(struct ns1__editCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editCustomerByRecordIDResponse, 0, sizeof(struct ns1__editCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editCustomerByRecordIDResponse(struct soap *soap, const struct ns1__editCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editCustomerByRecordIDResponse);
	if (soap_out_ns1__editCustomerByRecordIDResponse(soap, tag?tag:"ns1:editCustomerByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editCustomerByRecordIDResponse(struct soap *soap, struct ns1__editCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editCustomerByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editCustomerByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editCustomerByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editCustomerByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editCustomerByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editCustomerByRecordIDResponse*)p = *(struct ns1__editCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editCustomer(struct soap *soap, struct ns1__editCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editCustomer(struct soap *soap, const struct ns1__editCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editCustomer(struct soap *soap, const char *tag, int id, const struct ns1__editCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editCustomer * SOAP_FMAC4 soap_in_ns1__editCustomer(struct soap *soap, const char *tag, struct ns1__editCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editCustomer, sizeof(struct ns1__editCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editCustomer, 0, sizeof(struct ns1__editCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editCustomer(struct soap *soap, const struct ns1__editCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editCustomer);
	if (soap_out_ns1__editCustomer(soap, tag?tag:"ns1:editCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editCustomer * SOAP_FMAC4 soap_get_ns1__editCustomer(struct soap *soap, struct ns1__editCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editCustomer * SOAP_FMAC2 soap_instantiate_ns1__editCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editCustomer);
		if (size)
			*size = sizeof(struct ns1__editCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__editCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editCustomer %p -> %p\n", q, p));
	*(struct ns1__editCustomer*)p = *(struct ns1__editCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editCustomerResponse(struct soap *soap, struct ns1__editCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editCustomerResponse(struct soap *soap, const struct ns1__editCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__editCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editCustomerResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editCustomerResponse * SOAP_FMAC4 soap_in_ns1__editCustomerResponse(struct soap *soap, const char *tag, struct ns1__editCustomerResponse *a, const char *type)
{
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editCustomerResponse, sizeof(struct ns1__editCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editCustomerResponse, 0, sizeof(struct ns1__editCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editCustomerResponse(struct soap *soap, const struct ns1__editCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editCustomerResponse);
	if (soap_out_ns1__editCustomerResponse(soap, tag?tag:"ns1:editCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editCustomerResponse * SOAP_FMAC4 soap_get_ns1__editCustomerResponse(struct soap *soap, struct ns1__editCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__editCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__editCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__editCustomerResponse*)p = *(struct ns1__editCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCustomer(struct soap *soap, struct ns1__addCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCustomer(struct soap *soap, const struct ns1__addCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCustomer(struct soap *soap, const char *tag, int id, const struct ns1__addCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCustomer * SOAP_FMAC4 soap_in_ns1__addCustomer(struct soap *soap, const char *tag, struct ns1__addCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCustomer, sizeof(struct ns1__addCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCustomer, 0, sizeof(struct ns1__addCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCustomer(struct soap *soap, const struct ns1__addCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCustomer);
	if (soap_out_ns1__addCustomer(soap, tag?tag:"ns1:addCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCustomer * SOAP_FMAC4 soap_get_ns1__addCustomer(struct soap *soap, struct ns1__addCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCustomer * SOAP_FMAC2 soap_instantiate_ns1__addCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCustomer);
		if (size)
			*size = sizeof(struct ns1__addCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__addCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCustomer %p -> %p\n", q, p));
	*(struct ns1__addCustomer*)p = *(struct ns1__addCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addCustomerResponse(struct soap *soap, struct ns1__addCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addCustomerResponse(struct soap *soap, const struct ns1__addCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__addCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addCustomerResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addCustomerResponse * SOAP_FMAC4 soap_in_ns1__addCustomerResponse(struct soap *soap, const char *tag, struct ns1__addCustomerResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addCustomerResponse, sizeof(struct ns1__addCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addCustomerResponse, 0, sizeof(struct ns1__addCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addCustomerResponse(struct soap *soap, const struct ns1__addCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addCustomerResponse);
	if (soap_out_ns1__addCustomerResponse(soap, tag?tag:"ns1:addCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addCustomerResponse * SOAP_FMAC4 soap_get_ns1__addCustomerResponse(struct soap *soap, struct ns1__addCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__addCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__addCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__addCustomerResponse*)p = *(struct ns1__addCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomerByRecordID(struct soap *soap, struct ns1__getCustomerByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomerByRecordID(struct soap *soap, const struct ns1__getCustomerByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomerByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getCustomerByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomerByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomerByRecordID * SOAP_FMAC4 soap_in_ns1__getCustomerByRecordID(struct soap *soap, const char *tag, struct ns1__getCustomerByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomerByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomerByRecordID, sizeof(struct ns1__getCustomerByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomerByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomerByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomerByRecordID, 0, sizeof(struct ns1__getCustomerByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomerByRecordID(struct soap *soap, const struct ns1__getCustomerByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomerByRecordID);
	if (soap_out_ns1__getCustomerByRecordID(soap, tag?tag:"ns1:getCustomerByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomerByRecordID * SOAP_FMAC4 soap_get_ns1__getCustomerByRecordID(struct soap *soap, struct ns1__getCustomerByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomerByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomerByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getCustomerByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomerByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomerByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomerByRecordID);
		if (size)
			*size = sizeof(struct ns1__getCustomerByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomerByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomerByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomerByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomerByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomerByRecordID %p -> %p\n", q, p));
	*(struct ns1__getCustomerByRecordID*)p = *(struct ns1__getCustomerByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomerByRecordIDResponse(struct soap *soap, struct ns1__getCustomerByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomerByRecordIDResponse(struct soap *soap, const struct ns1__getCustomerByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomerByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCustomerByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomerByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomerByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getCustomerByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getCustomerByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomerByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomerByRecordIDResponse, sizeof(struct ns1__getCustomerByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomerByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomerByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomerByRecordIDResponse, 0, sizeof(struct ns1__getCustomerByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomerByRecordIDResponse(struct soap *soap, const struct ns1__getCustomerByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomerByRecordIDResponse);
	if (soap_out_ns1__getCustomerByRecordIDResponse(soap, tag?tag:"ns1:getCustomerByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomerByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getCustomerByRecordIDResponse(struct soap *soap, struct ns1__getCustomerByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomerByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomerByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getCustomerByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomerByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomerByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomerByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getCustomerByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomerByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomerByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomerByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomerByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomerByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getCustomerByRecordIDResponse*)p = *(struct ns1__getCustomerByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomer(struct soap *soap, struct ns1__getCustomer *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomer(struct soap *soap, const struct ns1__getCustomer *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomer(struct soap *soap, const char *tag, int id, const struct ns1__getCustomer *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomer), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomer * SOAP_FMAC4 soap_in_ns1__getCustomer(struct soap *soap, const char *tag, struct ns1__getCustomer *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomer *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomer, sizeof(struct ns1__getCustomer), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomer(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomer, 0, sizeof(struct ns1__getCustomer), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomer(struct soap *soap, const struct ns1__getCustomer *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomer);
	if (soap_out_ns1__getCustomer(soap, tag?tag:"ns1:getCustomer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomer * SOAP_FMAC4 soap_get_ns1__getCustomer(struct soap *soap, struct ns1__getCustomer *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomer * SOAP_FMAC2 soap_instantiate_ns1__getCustomer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomer);
		if (size)
			*size = sizeof(struct ns1__getCustomer);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomer, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomer);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomer*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomer %p -> %p\n", q, p));
	*(struct ns1__getCustomer*)p = *(struct ns1__getCustomer*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomerResponse(struct soap *soap, struct ns1__getCustomerResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pCustomer = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomerResponse(struct soap *soap, const struct ns1__getCustomerResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pCustomer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomerResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCustomerResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomerResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pCustomer", -1, &a->pCustomer, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomerResponse * SOAP_FMAC4 soap_in_ns1__getCustomerResponse(struct soap *soap, const char *tag, struct ns1__getCustomerResponse *a, const char *type)
{
	size_t soap_flag_pCustomer = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomerResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomerResponse, sizeof(struct ns1__getCustomerResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomerResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pCustomer && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pCustomer", &a->pCustomer, "ns1:CUser"))
				{	soap_flag_pCustomer--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomerResponse, 0, sizeof(struct ns1__getCustomerResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomerResponse(struct soap *soap, const struct ns1__getCustomerResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomerResponse);
	if (soap_out_ns1__getCustomerResponse(soap, tag?tag:"ns1:getCustomerResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomerResponse * SOAP_FMAC4 soap_get_ns1__getCustomerResponse(struct soap *soap, struct ns1__getCustomerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomerResponse * SOAP_FMAC2 soap_instantiate_ns1__getCustomerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomerResponse);
		if (size)
			*size = sizeof(struct ns1__getCustomerResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomerResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomerResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomerResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomerResponse %p -> %p\n", q, p));
	*(struct ns1__getCustomerResponse*)p = *(struct ns1__getCustomerResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addGlobalUser(struct soap *soap, struct ns1__addGlobalUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addGlobalUser(struct soap *soap, const struct ns1__addGlobalUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CGlobalUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addGlobalUser(struct soap *soap, const char *tag, int id, const struct ns1__addGlobalUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addGlobalUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CGlobalUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addGlobalUser * SOAP_FMAC4 soap_in_ns1__addGlobalUser(struct soap *soap, const char *tag, struct ns1__addGlobalUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addGlobalUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addGlobalUser, sizeof(struct ns1__addGlobalUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addGlobalUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CGlobalUser(soap, "pUser", &a->pUser, "ns1:CGlobalUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addGlobalUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addGlobalUser, 0, sizeof(struct ns1__addGlobalUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addGlobalUser(struct soap *soap, const struct ns1__addGlobalUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addGlobalUser);
	if (soap_out_ns1__addGlobalUser(soap, tag?tag:"ns1:addGlobalUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addGlobalUser * SOAP_FMAC4 soap_get_ns1__addGlobalUser(struct soap *soap, struct ns1__addGlobalUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addGlobalUser * SOAP_FMAC2 soap_instantiate_ns1__addGlobalUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addGlobalUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addGlobalUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addGlobalUser);
		if (size)
			*size = sizeof(struct ns1__addGlobalUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addGlobalUser, n);
		if (size)
			*size = n * sizeof(struct ns1__addGlobalUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addGlobalUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addGlobalUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addGlobalUser %p -> %p\n", q, p));
	*(struct ns1__addGlobalUser*)p = *(struct ns1__addGlobalUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addGlobalUserResponse(struct soap *soap, struct ns1__addGlobalUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addGlobalUserResponse(struct soap *soap, const struct ns1__addGlobalUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addGlobalUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__addGlobalUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addGlobalUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addGlobalUserResponse * SOAP_FMAC4 soap_in_ns1__addGlobalUserResponse(struct soap *soap, const char *tag, struct ns1__addGlobalUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addGlobalUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addGlobalUserResponse, sizeof(struct ns1__addGlobalUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addGlobalUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addGlobalUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addGlobalUserResponse, 0, sizeof(struct ns1__addGlobalUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addGlobalUserResponse(struct soap *soap, const struct ns1__addGlobalUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addGlobalUserResponse);
	if (soap_out_ns1__addGlobalUserResponse(soap, tag?tag:"ns1:addGlobalUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addGlobalUserResponse * SOAP_FMAC4 soap_get_ns1__addGlobalUserResponse(struct soap *soap, struct ns1__addGlobalUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addGlobalUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addGlobalUserResponse * SOAP_FMAC2 soap_instantiate_ns1__addGlobalUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addGlobalUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addGlobalUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addGlobalUserResponse);
		if (size)
			*size = sizeof(struct ns1__addGlobalUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addGlobalUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addGlobalUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addGlobalUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addGlobalUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addGlobalUserResponse %p -> %p\n", q, p));
	*(struct ns1__addGlobalUserResponse*)p = *(struct ns1__addGlobalUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__promoteUser(struct soap *soap, struct ns1__promoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->localUser);
	soap_default_string(soap, &a->globalUser);
	soap_default_string(soap, &a->loginname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__promoteUser(struct soap *soap, const struct ns1__promoteUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->localUser);
	soap_serialize_string(soap, &a->globalUser);
	soap_serialize_string(soap, &a->loginname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__promoteUser(struct soap *soap, const char *tag, int id, const struct ns1__promoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__promoteUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "localUser", -1, &a->localUser, ""))
		return soap->error;
	if (soap_out_string(soap, "globalUser", -1, &a->globalUser, ""))
		return soap->error;
	if (soap_out_string(soap, "loginname", -1, &a->loginname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__promoteUser * SOAP_FMAC4 soap_in_ns1__promoteUser(struct soap *soap, const char *tag, struct ns1__promoteUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_localUser = 1;
	size_t soap_flag_globalUser = 1;
	size_t soap_flag_loginname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__promoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__promoteUser, sizeof(struct ns1__promoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__promoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_localUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "localUser", &a->localUser, "xsd:string"))
				{	soap_flag_localUser--;
					continue;
				}
			if (soap_flag_globalUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "globalUser", &a->globalUser, "xsd:string"))
				{	soap_flag_globalUser--;
					continue;
				}
			if (soap_flag_loginname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "loginname", &a->loginname, "xsd:string"))
				{	soap_flag_loginname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__promoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__promoteUser, 0, sizeof(struct ns1__promoteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__promoteUser(struct soap *soap, const struct ns1__promoteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__promoteUser);
	if (soap_out_ns1__promoteUser(soap, tag?tag:"ns1:promoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__promoteUser * SOAP_FMAC4 soap_get_ns1__promoteUser(struct soap *soap, struct ns1__promoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__promoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__promoteUser * SOAP_FMAC2 soap_instantiate_ns1__promoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__promoteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__promoteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__promoteUser);
		if (size)
			*size = sizeof(struct ns1__promoteUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__promoteUser, n);
		if (size)
			*size = n * sizeof(struct ns1__promoteUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__promoteUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__promoteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__promoteUser %p -> %p\n", q, p));
	*(struct ns1__promoteUser*)p = *(struct ns1__promoteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__promoteUserResponse(struct soap *soap, struct ns1__promoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__promoteUserResponse(struct soap *soap, const struct ns1__promoteUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__promoteUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__promoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__promoteUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__promoteUserResponse * SOAP_FMAC4 soap_in_ns1__promoteUserResponse(struct soap *soap, const char *tag, struct ns1__promoteUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__promoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__promoteUserResponse, sizeof(struct ns1__promoteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__promoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__promoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__promoteUserResponse, 0, sizeof(struct ns1__promoteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__promoteUserResponse(struct soap *soap, const struct ns1__promoteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__promoteUserResponse);
	if (soap_out_ns1__promoteUserResponse(soap, tag?tag:"ns1:promoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__promoteUserResponse * SOAP_FMAC4 soap_get_ns1__promoteUserResponse(struct soap *soap, struct ns1__promoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__promoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__promoteUserResponse * SOAP_FMAC2 soap_instantiate_ns1__promoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__promoteUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__promoteUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__promoteUserResponse);
		if (size)
			*size = sizeof(struct ns1__promoteUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__promoteUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__promoteUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__promoteUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__promoteUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__promoteUserResponse %p -> %p\n", q, p));
	*(struct ns1__promoteUserResponse*)p = *(struct ns1__promoteUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveUser(struct soap *soap, struct ns1__cancelSaveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveUser(struct soap *soap, const struct ns1__cancelSaveUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveUser(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveUser * SOAP_FMAC4 soap_in_ns1__cancelSaveUser(struct soap *soap, const char *tag, struct ns1__cancelSaveUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveUser, sizeof(struct ns1__cancelSaveUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveUser, 0, sizeof(struct ns1__cancelSaveUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveUser(struct soap *soap, const struct ns1__cancelSaveUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveUser);
	if (soap_out_ns1__cancelSaveUser(soap, tag?tag:"ns1:cancelSaveUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveUser * SOAP_FMAC4 soap_get_ns1__cancelSaveUser(struct soap *soap, struct ns1__cancelSaveUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveUser * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveUser);
		if (size)
			*size = sizeof(struct ns1__cancelSaveUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveUser, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveUser %p -> %p\n", q, p));
	*(struct ns1__cancelSaveUser*)p = *(struct ns1__cancelSaveUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveUserResponse(struct soap *soap, struct ns1__cancelSaveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveUserResponse(struct soap *soap, const struct ns1__cancelSaveUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveUserResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveUserResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveUserResponse, sizeof(struct ns1__cancelSaveUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveUserResponse, 0, sizeof(struct ns1__cancelSaveUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveUserResponse(struct soap *soap, const struct ns1__cancelSaveUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveUserResponse);
	if (soap_out_ns1__cancelSaveUserResponse(soap, tag?tag:"ns1:cancelSaveUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveUserResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveUserResponse(struct soap *soap, struct ns1__cancelSaveUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveUserResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveUserResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveUserResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveUserResponse*)p = *(struct ns1__cancelSaveUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteUserByRecordID(struct soap *soap, struct ns1__deleteUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteUserByRecordID(struct soap *soap, const struct ns1__deleteUserByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteUserByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteUserByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteUserByRecordID * SOAP_FMAC4 soap_in_ns1__deleteUserByRecordID(struct soap *soap, const char *tag, struct ns1__deleteUserByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteUserByRecordID, sizeof(struct ns1__deleteUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteUserByRecordID, 0, sizeof(struct ns1__deleteUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteUserByRecordID(struct soap *soap, const struct ns1__deleteUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteUserByRecordID);
	if (soap_out_ns1__deleteUserByRecordID(soap, tag?tag:"ns1:deleteUserByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteUserByRecordID * SOAP_FMAC4 soap_get_ns1__deleteUserByRecordID(struct soap *soap, struct ns1__deleteUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteUserByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteUserByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteUserByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteUserByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteUserByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteUserByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteUserByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteUserByRecordID*)p = *(struct ns1__deleteUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteUserByRecordIDResponse(struct soap *soap, struct ns1__deleteUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteUserByRecordIDResponse(struct soap *soap, const struct ns1__deleteUserByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteUserByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteUserByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteUserByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteUserByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteUserByRecordIDResponse, sizeof(struct ns1__deleteUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteUserByRecordIDResponse, 0, sizeof(struct ns1__deleteUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteUserByRecordIDResponse(struct soap *soap, const struct ns1__deleteUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteUserByRecordIDResponse);
	if (soap_out_ns1__deleteUserByRecordIDResponse(soap, tag?tag:"ns1:deleteUserByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteUserByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteUserByRecordIDResponse(struct soap *soap, struct ns1__deleteUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteUserByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteUserByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteUserByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteUserByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteUserByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteUserByRecordIDResponse*)p = *(struct ns1__deleteUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteUser(struct soap *soap, struct ns1__deleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteUser(struct soap *soap, const struct ns1__deleteUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteUser(struct soap *soap, const char *tag, int id, const struct ns1__deleteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteUser * SOAP_FMAC4 soap_in_ns1__deleteUser(struct soap *soap, const char *tag, struct ns1__deleteUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteUser, sizeof(struct ns1__deleteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteUser, 0, sizeof(struct ns1__deleteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteUser(struct soap *soap, const struct ns1__deleteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteUser);
	if (soap_out_ns1__deleteUser(soap, tag?tag:"ns1:deleteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteUser * SOAP_FMAC4 soap_get_ns1__deleteUser(struct soap *soap, struct ns1__deleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteUser * SOAP_FMAC2 soap_instantiate_ns1__deleteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteUser);
		if (size)
			*size = sizeof(struct ns1__deleteUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteUser, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteUser %p -> %p\n", q, p));
	*(struct ns1__deleteUser*)p = *(struct ns1__deleteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteUserResponse(struct soap *soap, struct ns1__deleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteUserResponse(struct soap *soap, const struct ns1__deleteUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteUserResponse * SOAP_FMAC4 soap_in_ns1__deleteUserResponse(struct soap *soap, const char *tag, struct ns1__deleteUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteUserResponse, sizeof(struct ns1__deleteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteUserResponse, 0, sizeof(struct ns1__deleteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteUserResponse(struct soap *soap, const struct ns1__deleteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteUserResponse);
	if (soap_out_ns1__deleteUserResponse(soap, tag?tag:"ns1:deleteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteUserResponse * SOAP_FMAC4 soap_get_ns1__deleteUserResponse(struct soap *soap, struct ns1__deleteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteUserResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteUserResponse);
		if (size)
			*size = sizeof(struct ns1__deleteUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteUserResponse %p -> %p\n", q, p));
	*(struct ns1__deleteUserResponse*)p = *(struct ns1__deleteUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUser(struct soap *soap, struct ns1__saveUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUser(struct soap *soap, const struct ns1__saveUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUser(struct soap *soap, const char *tag, int id, const struct ns1__saveUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUser * SOAP_FMAC4 soap_in_ns1__saveUser(struct soap *soap, const char *tag, struct ns1__saveUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUser, sizeof(struct ns1__saveUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUser, 0, sizeof(struct ns1__saveUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUser(struct soap *soap, const struct ns1__saveUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUser);
	if (soap_out_ns1__saveUser(soap, tag?tag:"ns1:saveUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUser * SOAP_FMAC4 soap_get_ns1__saveUser(struct soap *soap, struct ns1__saveUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUser * SOAP_FMAC2 soap_instantiate_ns1__saveUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUser);
		if (size)
			*size = sizeof(struct ns1__saveUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUser, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUser %p -> %p\n", q, p));
	*(struct ns1__saveUser*)p = *(struct ns1__saveUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveUserResponse(struct soap *soap, struct ns1__saveUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveUserResponse(struct soap *soap, const struct ns1__saveUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveUserResponse * SOAP_FMAC4 soap_in_ns1__saveUserResponse(struct soap *soap, const char *tag, struct ns1__saveUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveUserResponse, sizeof(struct ns1__saveUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveUserResponse, 0, sizeof(struct ns1__saveUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveUserResponse(struct soap *soap, const struct ns1__saveUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveUserResponse);
	if (soap_out_ns1__saveUserResponse(soap, tag?tag:"ns1:saveUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveUserResponse * SOAP_FMAC4 soap_get_ns1__saveUserResponse(struct soap *soap, struct ns1__saveUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveUserResponse * SOAP_FMAC2 soap_instantiate_ns1__saveUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveUserResponse);
		if (size)
			*size = sizeof(struct ns1__saveUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveUserResponse %p -> %p\n", q, p));
	*(struct ns1__saveUserResponse*)p = *(struct ns1__saveUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editUserByRecordID(struct soap *soap, struct ns1__editUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editUserByRecordID(struct soap *soap, const struct ns1__editUserByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editUserByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editUserByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editUserByRecordID * SOAP_FMAC4 soap_in_ns1__editUserByRecordID(struct soap *soap, const char *tag, struct ns1__editUserByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editUserByRecordID, sizeof(struct ns1__editUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editUserByRecordID, 0, sizeof(struct ns1__editUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editUserByRecordID(struct soap *soap, const struct ns1__editUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editUserByRecordID);
	if (soap_out_ns1__editUserByRecordID(soap, tag?tag:"ns1:editUserByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editUserByRecordID * SOAP_FMAC4 soap_get_ns1__editUserByRecordID(struct soap *soap, struct ns1__editUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editUserByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editUserByRecordID);
		if (size)
			*size = sizeof(struct ns1__editUserByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editUserByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editUserByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editUserByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editUserByRecordID %p -> %p\n", q, p));
	*(struct ns1__editUserByRecordID*)p = *(struct ns1__editUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editUserByRecordIDResponse(struct soap *soap, struct ns1__editUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editUserByRecordIDResponse(struct soap *soap, const struct ns1__editUserByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editUserByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editUserByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editUserByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editUserByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editUserByRecordIDResponse, sizeof(struct ns1__editUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editUserByRecordIDResponse, 0, sizeof(struct ns1__editUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editUserByRecordIDResponse(struct soap *soap, const struct ns1__editUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editUserByRecordIDResponse);
	if (soap_out_ns1__editUserByRecordIDResponse(soap, tag?tag:"ns1:editUserByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editUserByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editUserByRecordIDResponse(struct soap *soap, struct ns1__editUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editUserByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editUserByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editUserByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editUserByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editUserByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editUserByRecordIDResponse*)p = *(struct ns1__editUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editUser(struct soap *soap, struct ns1__editUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editUser(struct soap *soap, const struct ns1__editUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editUser(struct soap *soap, const char *tag, int id, const struct ns1__editUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editUser * SOAP_FMAC4 soap_in_ns1__editUser(struct soap *soap, const char *tag, struct ns1__editUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editUser, sizeof(struct ns1__editUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editUser, 0, sizeof(struct ns1__editUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editUser(struct soap *soap, const struct ns1__editUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editUser);
	if (soap_out_ns1__editUser(soap, tag?tag:"ns1:editUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editUser * SOAP_FMAC4 soap_get_ns1__editUser(struct soap *soap, struct ns1__editUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editUser * SOAP_FMAC2 soap_instantiate_ns1__editUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editUser);
		if (size)
			*size = sizeof(struct ns1__editUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editUser, n);
		if (size)
			*size = n * sizeof(struct ns1__editUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editUser %p -> %p\n", q, p));
	*(struct ns1__editUser*)p = *(struct ns1__editUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editUserResponse(struct soap *soap, struct ns1__editUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editUserResponse(struct soap *soap, const struct ns1__editUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__editUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editUserResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editUserResponse * SOAP_FMAC4 soap_in_ns1__editUserResponse(struct soap *soap, const char *tag, struct ns1__editUserResponse *a, const char *type)
{
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editUserResponse, sizeof(struct ns1__editUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editUserResponse, 0, sizeof(struct ns1__editUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editUserResponse(struct soap *soap, const struct ns1__editUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editUserResponse);
	if (soap_out_ns1__editUserResponse(soap, tag?tag:"ns1:editUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editUserResponse * SOAP_FMAC4 soap_get_ns1__editUserResponse(struct soap *soap, struct ns1__editUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editUserResponse * SOAP_FMAC2 soap_instantiate_ns1__editUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editUserResponse);
		if (size)
			*size = sizeof(struct ns1__editUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editUserResponse %p -> %p\n", q, p));
	*(struct ns1__editUserResponse*)p = *(struct ns1__editUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addUser(struct soap *soap, struct ns1__addUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addUser(struct soap *soap, const struct ns1__addUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addUser(struct soap *soap, const char *tag, int id, const struct ns1__addUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addUser * SOAP_FMAC4 soap_in_ns1__addUser(struct soap *soap, const char *tag, struct ns1__addUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addUser, sizeof(struct ns1__addUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addUser, 0, sizeof(struct ns1__addUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addUser(struct soap *soap, const struct ns1__addUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addUser);
	if (soap_out_ns1__addUser(soap, tag?tag:"ns1:addUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addUser * SOAP_FMAC4 soap_get_ns1__addUser(struct soap *soap, struct ns1__addUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addUser * SOAP_FMAC2 soap_instantiate_ns1__addUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addUser);
		if (size)
			*size = sizeof(struct ns1__addUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addUser, n);
		if (size)
			*size = n * sizeof(struct ns1__addUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addUser %p -> %p\n", q, p));
	*(struct ns1__addUser*)p = *(struct ns1__addUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addUserResponse(struct soap *soap, struct ns1__addUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addUserResponse(struct soap *soap, const struct ns1__addUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__addUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addUserResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addUserResponse * SOAP_FMAC4 soap_in_ns1__addUserResponse(struct soap *soap, const char *tag, struct ns1__addUserResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addUserResponse, sizeof(struct ns1__addUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addUserResponse, 0, sizeof(struct ns1__addUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addUserResponse(struct soap *soap, const struct ns1__addUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addUserResponse);
	if (soap_out_ns1__addUserResponse(soap, tag?tag:"ns1:addUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addUserResponse * SOAP_FMAC4 soap_get_ns1__addUserResponse(struct soap *soap, struct ns1__addUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addUserResponse * SOAP_FMAC2 soap_instantiate_ns1__addUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addUserResponse);
		if (size)
			*size = sizeof(struct ns1__addUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addUserResponse %p -> %p\n", q, p));
	*(struct ns1__addUserResponse*)p = *(struct ns1__addUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserForCurrentSession(struct soap *soap, struct ns1__getUserForCurrentSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserForCurrentSession(struct soap *soap, const struct ns1__getUserForCurrentSession *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserForCurrentSession(struct soap *soap, const char *tag, int id, const struct ns1__getUserForCurrentSession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserForCurrentSession), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserForCurrentSession * SOAP_FMAC4 soap_in_ns1__getUserForCurrentSession(struct soap *soap, const char *tag, struct ns1__getUserForCurrentSession *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserForCurrentSession *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserForCurrentSession, sizeof(struct ns1__getUserForCurrentSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserForCurrentSession(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserForCurrentSession *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserForCurrentSession, 0, sizeof(struct ns1__getUserForCurrentSession), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserForCurrentSession(struct soap *soap, const struct ns1__getUserForCurrentSession *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserForCurrentSession);
	if (soap_out_ns1__getUserForCurrentSession(soap, tag?tag:"ns1:getUserForCurrentSession", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserForCurrentSession * SOAP_FMAC4 soap_get_ns1__getUserForCurrentSession(struct soap *soap, struct ns1__getUserForCurrentSession *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserForCurrentSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserForCurrentSession * SOAP_FMAC2 soap_instantiate_ns1__getUserForCurrentSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserForCurrentSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserForCurrentSession, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserForCurrentSession);
		if (size)
			*size = sizeof(struct ns1__getUserForCurrentSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserForCurrentSession, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserForCurrentSession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserForCurrentSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserForCurrentSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserForCurrentSession %p -> %p\n", q, p));
	*(struct ns1__getUserForCurrentSession*)p = *(struct ns1__getUserForCurrentSession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserForCurrentSessionResponse(struct soap *soap, struct ns1__getUserForCurrentSessionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserForCurrentSessionResponse(struct soap *soap, const struct ns1__getUserForCurrentSessionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserForCurrentSessionResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserForCurrentSessionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserForCurrentSessionResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserForCurrentSessionResponse * SOAP_FMAC4 soap_in_ns1__getUserForCurrentSessionResponse(struct soap *soap, const char *tag, struct ns1__getUserForCurrentSessionResponse *a, const char *type)
{
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserForCurrentSessionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserForCurrentSessionResponse, sizeof(struct ns1__getUserForCurrentSessionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserForCurrentSessionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserForCurrentSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserForCurrentSessionResponse, 0, sizeof(struct ns1__getUserForCurrentSessionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserForCurrentSessionResponse(struct soap *soap, const struct ns1__getUserForCurrentSessionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserForCurrentSessionResponse);
	if (soap_out_ns1__getUserForCurrentSessionResponse(soap, tag?tag:"ns1:getUserForCurrentSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserForCurrentSessionResponse * SOAP_FMAC4 soap_get_ns1__getUserForCurrentSessionResponse(struct soap *soap, struct ns1__getUserForCurrentSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserForCurrentSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserForCurrentSessionResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserForCurrentSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserForCurrentSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserForCurrentSessionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserForCurrentSessionResponse);
		if (size)
			*size = sizeof(struct ns1__getUserForCurrentSessionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserForCurrentSessionResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserForCurrentSessionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserForCurrentSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserForCurrentSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserForCurrentSessionResponse %p -> %p\n", q, p));
	*(struct ns1__getUserForCurrentSessionResponse*)p = *(struct ns1__getUserForCurrentSessionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserByRecordID(struct soap *soap, struct ns1__getUserByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserByRecordID(struct soap *soap, const struct ns1__getUserByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getUserByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserByRecordID * SOAP_FMAC4 soap_in_ns1__getUserByRecordID(struct soap *soap, const char *tag, struct ns1__getUserByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserByRecordID, sizeof(struct ns1__getUserByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserByRecordID, 0, sizeof(struct ns1__getUserByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserByRecordID(struct soap *soap, const struct ns1__getUserByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserByRecordID);
	if (soap_out_ns1__getUserByRecordID(soap, tag?tag:"ns1:getUserByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserByRecordID * SOAP_FMAC4 soap_get_ns1__getUserByRecordID(struct soap *soap, struct ns1__getUserByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getUserByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserByRecordID);
		if (size)
			*size = sizeof(struct ns1__getUserByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserByRecordID %p -> %p\n", q, p));
	*(struct ns1__getUserByRecordID*)p = *(struct ns1__getUserByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserByRecordIDResponse(struct soap *soap, struct ns1__getUserByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserByRecordIDResponse(struct soap *soap, const struct ns1__getUserByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getUserByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getUserByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserByRecordIDResponse, sizeof(struct ns1__getUserByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserByRecordIDResponse, 0, sizeof(struct ns1__getUserByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserByRecordIDResponse(struct soap *soap, const struct ns1__getUserByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserByRecordIDResponse);
	if (soap_out_ns1__getUserByRecordIDResponse(soap, tag?tag:"ns1:getUserByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getUserByRecordIDResponse(struct soap *soap, struct ns1__getUserByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getUserByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getUserByRecordIDResponse*)p = *(struct ns1__getUserByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUser(struct soap *soap, struct ns1__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->firstName);
	soap_default_string(soap, &a->middleInitials);
	soap_default_string(soap, &a->lastName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUser(struct soap *soap, const struct ns1__getUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->firstName);
	soap_serialize_string(soap, &a->middleInitials);
	soap_serialize_string(soap, &a->lastName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUser(struct soap *soap, const char *tag, int id, const struct ns1__getUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUser), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "firstName", -1, &a->firstName, ""))
		return soap->error;
	if (soap_out_string(soap, "middleInitials", -1, &a->middleInitials, ""))
		return soap->error;
	if (soap_out_string(soap, "lastName", -1, &a->lastName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUser * SOAP_FMAC4 soap_in_ns1__getUser(struct soap *soap, const char *tag, struct ns1__getUser *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_firstName = 1;
	size_t soap_flag_middleInitials = 1;
	size_t soap_flag_lastName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUser, sizeof(struct ns1__getUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_firstName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "firstName", &a->firstName, "xsd:string"))
				{	soap_flag_firstName--;
					continue;
				}
			if (soap_flag_middleInitials && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "middleInitials", &a->middleInitials, "xsd:string"))
				{	soap_flag_middleInitials--;
					continue;
				}
			if (soap_flag_lastName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "lastName", &a->lastName, "xsd:string"))
				{	soap_flag_lastName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUser, 0, sizeof(struct ns1__getUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUser(struct soap *soap, const struct ns1__getUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUser);
	if (soap_out_ns1__getUser(soap, tag?tag:"ns1:getUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUser * SOAP_FMAC4 soap_get_ns1__getUser(struct soap *soap, struct ns1__getUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUser * SOAP_FMAC2 soap_instantiate_ns1__getUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUser);
		if (size)
			*size = sizeof(struct ns1__getUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUser, n);
		if (size)
			*size = n * sizeof(struct ns1__getUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUser %p -> %p\n", q, p));
	*(struct ns1__getUser*)p = *(struct ns1__getUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserResponse(struct soap *soap, struct ns1__getUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserResponse(struct soap *soap, const struct ns1__getUserResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CUser(soap, &a->pUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CUser(soap, "pUser", -1, &a->pUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserResponse * SOAP_FMAC4 soap_in_ns1__getUserResponse(struct soap *soap, const char *tag, struct ns1__getUserResponse *a, const char *type)
{
	size_t soap_flag_pUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserResponse, sizeof(struct ns1__getUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CUser(soap, "pUser", &a->pUser, "ns1:CUser"))
				{	soap_flag_pUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserResponse, 0, sizeof(struct ns1__getUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserResponse(struct soap *soap, const struct ns1__getUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserResponse);
	if (soap_out_ns1__getUserResponse(soap, tag?tag:"ns1:getUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserResponse * SOAP_FMAC4 soap_get_ns1__getUserResponse(struct soap *soap, struct ns1__getUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserResponse);
		if (size)
			*size = sizeof(struct ns1__getUserResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserResponse %p -> %p\n", q, p));
	*(struct ns1__getUserResponse*)p = *(struct ns1__getUserResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserLicenseList(struct soap *soap, struct ns1__getUserLicenseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserLicenseList(struct soap *soap, const struct ns1__getUserLicenseList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserLicenseList(struct soap *soap, const char *tag, int id, const struct ns1__getUserLicenseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserLicenseList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserLicenseList * SOAP_FMAC4 soap_in_ns1__getUserLicenseList(struct soap *soap, const char *tag, struct ns1__getUserLicenseList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserLicenseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserLicenseList, sizeof(struct ns1__getUserLicenseList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserLicenseList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserLicenseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserLicenseList, 0, sizeof(struct ns1__getUserLicenseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserLicenseList(struct soap *soap, const struct ns1__getUserLicenseList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserLicenseList);
	if (soap_out_ns1__getUserLicenseList(soap, tag?tag:"ns1:getUserLicenseList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserLicenseList * SOAP_FMAC4 soap_get_ns1__getUserLicenseList(struct soap *soap, struct ns1__getUserLicenseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserLicenseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserLicenseList * SOAP_FMAC2 soap_instantiate_ns1__getUserLicenseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserLicenseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserLicenseList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserLicenseList);
		if (size)
			*size = sizeof(struct ns1__getUserLicenseList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserLicenseList, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserLicenseList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserLicenseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserLicenseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserLicenseList %p -> %p\n", q, p));
	*(struct ns1__getUserLicenseList*)p = *(struct ns1__getUserLicenseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getUserLicenseListResponse(struct soap *soap, struct ns1__getUserLicenseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->UserLicenseList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getUserLicenseListResponse(struct soap *soap, const struct ns1__getUserLicenseListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCUserLicense(soap, &a->UserLicenseList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getUserLicenseListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getUserLicenseListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getUserLicenseListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCUserLicense(soap, "UserLicenseList", -1, &a->UserLicenseList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getUserLicenseListResponse * SOAP_FMAC4 soap_in_ns1__getUserLicenseListResponse(struct soap *soap, const char *tag, struct ns1__getUserLicenseListResponse *a, const char *type)
{
	size_t soap_flag_UserLicenseList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getUserLicenseListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getUserLicenseListResponse, sizeof(struct ns1__getUserLicenseListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getUserLicenseListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserLicenseList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCUserLicense(soap, "UserLicenseList", &a->UserLicenseList, "ns1:CUserLicense"))
				{	soap_flag_UserLicenseList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getUserLicenseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getUserLicenseListResponse, 0, sizeof(struct ns1__getUserLicenseListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getUserLicenseListResponse(struct soap *soap, const struct ns1__getUserLicenseListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getUserLicenseListResponse);
	if (soap_out_ns1__getUserLicenseListResponse(soap, tag?tag:"ns1:getUserLicenseListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getUserLicenseListResponse * SOAP_FMAC4 soap_get_ns1__getUserLicenseListResponse(struct soap *soap, struct ns1__getUserLicenseListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getUserLicenseListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getUserLicenseListResponse * SOAP_FMAC2 soap_instantiate_ns1__getUserLicenseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getUserLicenseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getUserLicenseListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getUserLicenseListResponse);
		if (size)
			*size = sizeof(struct ns1__getUserLicenseListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getUserLicenseListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getUserLicenseListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getUserLicenseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getUserLicenseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getUserLicenseListResponse %p -> %p\n", q, p));
	*(struct ns1__getUserLicenseListResponse*)p = *(struct ns1__getUserLicenseListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getGlobalCustomerList(struct soap *soap, struct ns1__getGlobalCustomerList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getGlobalCustomerList(struct soap *soap, const struct ns1__getGlobalCustomerList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalCustomerList(struct soap *soap, const char *tag, int id, const struct ns1__getGlobalCustomerList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalCustomerList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getGlobalCustomerList * SOAP_FMAC4 soap_in_ns1__getGlobalCustomerList(struct soap *soap, const char *tag, struct ns1__getGlobalCustomerList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getGlobalCustomerList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalCustomerList, sizeof(struct ns1__getGlobalCustomerList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getGlobalCustomerList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getGlobalCustomerList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalCustomerList, 0, sizeof(struct ns1__getGlobalCustomerList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getGlobalCustomerList(struct soap *soap, const struct ns1__getGlobalCustomerList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalCustomerList);
	if (soap_out_ns1__getGlobalCustomerList(soap, tag?tag:"ns1:getGlobalCustomerList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getGlobalCustomerList * SOAP_FMAC4 soap_get_ns1__getGlobalCustomerList(struct soap *soap, struct ns1__getGlobalCustomerList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalCustomerList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getGlobalCustomerList * SOAP_FMAC2 soap_instantiate_ns1__getGlobalCustomerList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalCustomerList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalCustomerList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getGlobalCustomerList);
		if (size)
			*size = sizeof(struct ns1__getGlobalCustomerList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getGlobalCustomerList, n);
		if (size)
			*size = n * sizeof(struct ns1__getGlobalCustomerList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getGlobalCustomerList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalCustomerList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getGlobalCustomerList %p -> %p\n", q, p));
	*(struct ns1__getGlobalCustomerList*)p = *(struct ns1__getGlobalCustomerList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getGlobalCustomerListResponse(struct soap *soap, struct ns1__getGlobalCustomerListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GlobalCustomerList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getGlobalCustomerListResponse(struct soap *soap, const struct ns1__getGlobalCustomerListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCGlobalUser(soap, &a->GlobalCustomerList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalCustomerListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getGlobalCustomerListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalCustomerListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCGlobalUser(soap, "GlobalCustomerList", -1, &a->GlobalCustomerList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getGlobalCustomerListResponse * SOAP_FMAC4 soap_in_ns1__getGlobalCustomerListResponse(struct soap *soap, const char *tag, struct ns1__getGlobalCustomerListResponse *a, const char *type)
{
	size_t soap_flag_GlobalCustomerList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getGlobalCustomerListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalCustomerListResponse, sizeof(struct ns1__getGlobalCustomerListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getGlobalCustomerListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GlobalCustomerList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCGlobalUser(soap, "GlobalCustomerList", &a->GlobalCustomerList, "ns1:CGlobalUser"))
				{	soap_flag_GlobalCustomerList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getGlobalCustomerListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalCustomerListResponse, 0, sizeof(struct ns1__getGlobalCustomerListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getGlobalCustomerListResponse(struct soap *soap, const struct ns1__getGlobalCustomerListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalCustomerListResponse);
	if (soap_out_ns1__getGlobalCustomerListResponse(soap, tag?tag:"ns1:getGlobalCustomerListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getGlobalCustomerListResponse * SOAP_FMAC4 soap_get_ns1__getGlobalCustomerListResponse(struct soap *soap, struct ns1__getGlobalCustomerListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalCustomerListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getGlobalCustomerListResponse * SOAP_FMAC2 soap_instantiate_ns1__getGlobalCustomerListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalCustomerListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalCustomerListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getGlobalCustomerListResponse);
		if (size)
			*size = sizeof(struct ns1__getGlobalCustomerListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getGlobalCustomerListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getGlobalCustomerListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getGlobalCustomerListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalCustomerListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getGlobalCustomerListResponse %p -> %p\n", q, p));
	*(struct ns1__getGlobalCustomerListResponse*)p = *(struct ns1__getGlobalCustomerListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getGlobalUserList(struct soap *soap, struct ns1__getGlobalUserList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getGlobalUserList(struct soap *soap, const struct ns1__getGlobalUserList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalUserList(struct soap *soap, const char *tag, int id, const struct ns1__getGlobalUserList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalUserList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getGlobalUserList * SOAP_FMAC4 soap_in_ns1__getGlobalUserList(struct soap *soap, const char *tag, struct ns1__getGlobalUserList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getGlobalUserList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalUserList, sizeof(struct ns1__getGlobalUserList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getGlobalUserList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getGlobalUserList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalUserList, 0, sizeof(struct ns1__getGlobalUserList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getGlobalUserList(struct soap *soap, const struct ns1__getGlobalUserList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalUserList);
	if (soap_out_ns1__getGlobalUserList(soap, tag?tag:"ns1:getGlobalUserList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getGlobalUserList * SOAP_FMAC4 soap_get_ns1__getGlobalUserList(struct soap *soap, struct ns1__getGlobalUserList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalUserList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getGlobalUserList * SOAP_FMAC2 soap_instantiate_ns1__getGlobalUserList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalUserList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalUserList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getGlobalUserList);
		if (size)
			*size = sizeof(struct ns1__getGlobalUserList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getGlobalUserList, n);
		if (size)
			*size = n * sizeof(struct ns1__getGlobalUserList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getGlobalUserList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalUserList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getGlobalUserList %p -> %p\n", q, p));
	*(struct ns1__getGlobalUserList*)p = *(struct ns1__getGlobalUserList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getGlobalUserListResponse(struct soap *soap, struct ns1__getGlobalUserListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->GlobalUserList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getGlobalUserListResponse(struct soap *soap, const struct ns1__getGlobalUserListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCGlobalUser(soap, &a->GlobalUserList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalUserListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getGlobalUserListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalUserListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCGlobalUser(soap, "GlobalUserList", -1, &a->GlobalUserList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getGlobalUserListResponse * SOAP_FMAC4 soap_in_ns1__getGlobalUserListResponse(struct soap *soap, const char *tag, struct ns1__getGlobalUserListResponse *a, const char *type)
{
	size_t soap_flag_GlobalUserList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getGlobalUserListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalUserListResponse, sizeof(struct ns1__getGlobalUserListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getGlobalUserListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GlobalUserList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCGlobalUser(soap, "GlobalUserList", &a->GlobalUserList, "ns1:CGlobalUser"))
				{	soap_flag_GlobalUserList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getGlobalUserListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalUserListResponse, 0, sizeof(struct ns1__getGlobalUserListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getGlobalUserListResponse(struct soap *soap, const struct ns1__getGlobalUserListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalUserListResponse);
	if (soap_out_ns1__getGlobalUserListResponse(soap, tag?tag:"ns1:getGlobalUserListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getGlobalUserListResponse * SOAP_FMAC4 soap_get_ns1__getGlobalUserListResponse(struct soap *soap, struct ns1__getGlobalUserListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalUserListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getGlobalUserListResponse * SOAP_FMAC2 soap_instantiate_ns1__getGlobalUserListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalUserListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalUserListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getGlobalUserListResponse);
		if (size)
			*size = sizeof(struct ns1__getGlobalUserListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getGlobalUserListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getGlobalUserListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getGlobalUserListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalUserListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getGlobalUserListResponse %p -> %p\n", q, p));
	*(struct ns1__getGlobalUserListResponse*)p = *(struct ns1__getGlobalUserListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTask(struct soap *soap, struct ns1__cancelSaveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTask(struct soap *soap, const struct ns1__cancelSaveTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTask(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTask * SOAP_FMAC4 soap_in_ns1__cancelSaveTask(struct soap *soap, const char *tag, struct ns1__cancelSaveTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTask, sizeof(struct ns1__cancelSaveTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTask, 0, sizeof(struct ns1__cancelSaveTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTask(struct soap *soap, const struct ns1__cancelSaveTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTask);
	if (soap_out_ns1__cancelSaveTask(soap, tag?tag:"ns1:cancelSaveTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTask * SOAP_FMAC4 soap_get_ns1__cancelSaveTask(struct soap *soap, struct ns1__cancelSaveTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTask * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTask);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTask, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTask %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTask*)p = *(struct ns1__cancelSaveTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTaskResponse(struct soap *soap, struct ns1__cancelSaveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTaskResponse(struct soap *soap, const struct ns1__cancelSaveTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTaskResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveTaskResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveTaskResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTaskResponse, sizeof(struct ns1__cancelSaveTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTaskResponse, 0, sizeof(struct ns1__cancelSaveTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTaskResponse(struct soap *soap, const struct ns1__cancelSaveTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTaskResponse);
	if (soap_out_ns1__cancelSaveTaskResponse(soap, tag?tag:"ns1:cancelSaveTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTaskResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveTaskResponse(struct soap *soap, struct ns1__cancelSaveTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTaskResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTaskResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTaskResponse*)p = *(struct ns1__cancelSaveTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTask(struct soap *soap, struct ns1__saveTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTask(struct soap *soap, const struct ns1__saveTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTask(struct soap *soap, const char *tag, int id, const struct ns1__saveTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTask * SOAP_FMAC4 soap_in_ns1__saveTask(struct soap *soap, const char *tag, struct ns1__saveTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTask, sizeof(struct ns1__saveTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTask, 0, sizeof(struct ns1__saveTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTask(struct soap *soap, const struct ns1__saveTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTask);
	if (soap_out_ns1__saveTask(soap, tag?tag:"ns1:saveTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTask * SOAP_FMAC4 soap_get_ns1__saveTask(struct soap *soap, struct ns1__saveTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTask * SOAP_FMAC2 soap_instantiate_ns1__saveTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTask);
		if (size)
			*size = sizeof(struct ns1__saveTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTask, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTask %p -> %p\n", q, p));
	*(struct ns1__saveTask*)p = *(struct ns1__saveTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTaskResponse(struct soap *soap, struct ns1__saveTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTaskResponse(struct soap *soap, const struct ns1__saveTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTaskResponse * SOAP_FMAC4 soap_in_ns1__saveTaskResponse(struct soap *soap, const char *tag, struct ns1__saveTaskResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTaskResponse, sizeof(struct ns1__saveTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTaskResponse, 0, sizeof(struct ns1__saveTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTaskResponse(struct soap *soap, const struct ns1__saveTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTaskResponse);
	if (soap_out_ns1__saveTaskResponse(soap, tag?tag:"ns1:saveTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTaskResponse * SOAP_FMAC4 soap_get_ns1__saveTaskResponse(struct soap *soap, struct ns1__saveTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__saveTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTaskResponse);
		if (size)
			*size = sizeof(struct ns1__saveTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTaskResponse %p -> %p\n", q, p));
	*(struct ns1__saveTaskResponse*)p = *(struct ns1__saveTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTaskByRecordID(struct soap *soap, struct ns1__editTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTaskByRecordID(struct soap *soap, const struct ns1__editTaskByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTaskByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editTaskByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTaskByRecordID * SOAP_FMAC4 soap_in_ns1__editTaskByRecordID(struct soap *soap, const char *tag, struct ns1__editTaskByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTaskByRecordID, sizeof(struct ns1__editTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTaskByRecordID, 0, sizeof(struct ns1__editTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTaskByRecordID(struct soap *soap, const struct ns1__editTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTaskByRecordID);
	if (soap_out_ns1__editTaskByRecordID(soap, tag?tag:"ns1:editTaskByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTaskByRecordID * SOAP_FMAC4 soap_get_ns1__editTaskByRecordID(struct soap *soap, struct ns1__editTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTaskByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTaskByRecordID);
		if (size)
			*size = sizeof(struct ns1__editTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTaskByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editTaskByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTaskByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTaskByRecordID %p -> %p\n", q, p));
	*(struct ns1__editTaskByRecordID*)p = *(struct ns1__editTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTaskByRecordIDResponse(struct soap *soap, struct ns1__editTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTaskByRecordIDResponse(struct soap *soap, const struct ns1__editTaskByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTaskByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTaskByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editTaskByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editTaskByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTaskByRecordIDResponse, sizeof(struct ns1__editTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTaskByRecordIDResponse, 0, sizeof(struct ns1__editTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTaskByRecordIDResponse(struct soap *soap, const struct ns1__editTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTaskByRecordIDResponse);
	if (soap_out_ns1__editTaskByRecordIDResponse(soap, tag?tag:"ns1:editTaskByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTaskByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editTaskByRecordIDResponse(struct soap *soap, struct ns1__editTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTaskByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTaskByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTaskByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTaskByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTaskByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editTaskByRecordIDResponse*)p = *(struct ns1__editTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTask(struct soap *soap, struct ns1__editTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTask(struct soap *soap, const struct ns1__editTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTask(struct soap *soap, const char *tag, int id, const struct ns1__editTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTask * SOAP_FMAC4 soap_in_ns1__editTask(struct soap *soap, const char *tag, struct ns1__editTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTask, sizeof(struct ns1__editTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTask, 0, sizeof(struct ns1__editTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTask(struct soap *soap, const struct ns1__editTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTask);
	if (soap_out_ns1__editTask(soap, tag?tag:"ns1:editTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTask * SOAP_FMAC4 soap_get_ns1__editTask(struct soap *soap, struct ns1__editTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTask * SOAP_FMAC2 soap_instantiate_ns1__editTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTask);
		if (size)
			*size = sizeof(struct ns1__editTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTask, n);
		if (size)
			*size = n * sizeof(struct ns1__editTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTask %p -> %p\n", q, p));
	*(struct ns1__editTask*)p = *(struct ns1__editTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTaskResponse(struct soap *soap, struct ns1__editTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTaskResponse(struct soap *soap, const struct ns1__editTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTaskResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTaskResponse * SOAP_FMAC4 soap_in_ns1__editTaskResponse(struct soap *soap, const char *tag, struct ns1__editTaskResponse *a, const char *type)
{
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTaskResponse, sizeof(struct ns1__editTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTaskResponse, 0, sizeof(struct ns1__editTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTaskResponse(struct soap *soap, const struct ns1__editTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTaskResponse);
	if (soap_out_ns1__editTaskResponse(soap, tag?tag:"ns1:editTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTaskResponse * SOAP_FMAC4 soap_get_ns1__editTaskResponse(struct soap *soap, struct ns1__editTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__editTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTaskResponse);
		if (size)
			*size = sizeof(struct ns1__editTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTaskResponse %p -> %p\n", q, p));
	*(struct ns1__editTaskResponse*)p = *(struct ns1__editTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTaskByRecordID(struct soap *soap, struct ns1__deleteTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTaskByRecordID(struct soap *soap, const struct ns1__deleteTaskByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTaskByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteTaskByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTaskByRecordID * SOAP_FMAC4 soap_in_ns1__deleteTaskByRecordID(struct soap *soap, const char *tag, struct ns1__deleteTaskByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTaskByRecordID, sizeof(struct ns1__deleteTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTaskByRecordID, 0, sizeof(struct ns1__deleteTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTaskByRecordID(struct soap *soap, const struct ns1__deleteTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTaskByRecordID);
	if (soap_out_ns1__deleteTaskByRecordID(soap, tag?tag:"ns1:deleteTaskByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTaskByRecordID * SOAP_FMAC4 soap_get_ns1__deleteTaskByRecordID(struct soap *soap, struct ns1__deleteTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTaskByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTaskByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTaskByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTaskByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTaskByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTaskByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteTaskByRecordID*)p = *(struct ns1__deleteTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTaskByRecordIDResponse(struct soap *soap, struct ns1__deleteTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTaskByRecordIDResponse(struct soap *soap, const struct ns1__deleteTaskByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTaskByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTaskByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteTaskByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteTaskByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTaskByRecordIDResponse, sizeof(struct ns1__deleteTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTaskByRecordIDResponse, 0, sizeof(struct ns1__deleteTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTaskByRecordIDResponse(struct soap *soap, const struct ns1__deleteTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTaskByRecordIDResponse);
	if (soap_out_ns1__deleteTaskByRecordIDResponse(soap, tag?tag:"ns1:deleteTaskByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTaskByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteTaskByRecordIDResponse(struct soap *soap, struct ns1__deleteTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTaskByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTaskByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTaskByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTaskByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTaskByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTaskByRecordIDResponse*)p = *(struct ns1__deleteTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTask(struct soap *soap, struct ns1__deleteTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTask(struct soap *soap, const struct ns1__deleteTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTask(struct soap *soap, const char *tag, int id, const struct ns1__deleteTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTask * SOAP_FMAC4 soap_in_ns1__deleteTask(struct soap *soap, const char *tag, struct ns1__deleteTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTask, sizeof(struct ns1__deleteTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTask, 0, sizeof(struct ns1__deleteTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTask(struct soap *soap, const struct ns1__deleteTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTask);
	if (soap_out_ns1__deleteTask(soap, tag?tag:"ns1:deleteTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTask * SOAP_FMAC4 soap_get_ns1__deleteTask(struct soap *soap, struct ns1__deleteTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTask * SOAP_FMAC2 soap_instantiate_ns1__deleteTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTask);
		if (size)
			*size = sizeof(struct ns1__deleteTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTask, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTask %p -> %p\n", q, p));
	*(struct ns1__deleteTask*)p = *(struct ns1__deleteTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTaskResponse(struct soap *soap, struct ns1__deleteTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTaskResponse(struct soap *soap, const struct ns1__deleteTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTaskResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTaskResponse * SOAP_FMAC4 soap_in_ns1__deleteTaskResponse(struct soap *soap, const char *tag, struct ns1__deleteTaskResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTaskResponse, sizeof(struct ns1__deleteTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTaskResponse, 0, sizeof(struct ns1__deleteTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTaskResponse(struct soap *soap, const struct ns1__deleteTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTaskResponse);
	if (soap_out_ns1__deleteTaskResponse(soap, tag?tag:"ns1:deleteTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTaskResponse * SOAP_FMAC4 soap_get_ns1__deleteTaskResponse(struct soap *soap, struct ns1__deleteTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTaskResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTaskResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTaskResponse*)p = *(struct ns1__deleteTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTask(struct soap *soap, struct ns1__addTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTask(struct soap *soap, const struct ns1__addTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTask(struct soap *soap, const char *tag, int id, const struct ns1__addTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTask * SOAP_FMAC4 soap_in_ns1__addTask(struct soap *soap, const char *tag, struct ns1__addTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTask, sizeof(struct ns1__addTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTask, 0, sizeof(struct ns1__addTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTask(struct soap *soap, const struct ns1__addTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTask);
	if (soap_out_ns1__addTask(soap, tag?tag:"ns1:addTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTask * SOAP_FMAC4 soap_get_ns1__addTask(struct soap *soap, struct ns1__addTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTask * SOAP_FMAC2 soap_instantiate_ns1__addTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTask);
		if (size)
			*size = sizeof(struct ns1__addTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTask, n);
		if (size)
			*size = n * sizeof(struct ns1__addTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTask %p -> %p\n", q, p));
	*(struct ns1__addTask*)p = *(struct ns1__addTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTaskResponse(struct soap *soap, struct ns1__addTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTaskResponse(struct soap *soap, const struct ns1__addTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__addTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTaskResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTaskResponse * SOAP_FMAC4 soap_in_ns1__addTaskResponse(struct soap *soap, const char *tag, struct ns1__addTaskResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTaskResponse, sizeof(struct ns1__addTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTaskResponse, 0, sizeof(struct ns1__addTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTaskResponse(struct soap *soap, const struct ns1__addTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTaskResponse);
	if (soap_out_ns1__addTaskResponse(soap, tag?tag:"ns1:addTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTaskResponse * SOAP_FMAC4 soap_get_ns1__addTaskResponse(struct soap *soap, struct ns1__addTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__addTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTaskResponse);
		if (size)
			*size = sizeof(struct ns1__addTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTaskResponse %p -> %p\n", q, p));
	*(struct ns1__addTaskResponse*)p = *(struct ns1__addTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTaskByRecordID(struct soap *soap, struct ns1__getTaskByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTaskByRecordID(struct soap *soap, const struct ns1__getTaskByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getTaskByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTaskByRecordID * SOAP_FMAC4 soap_in_ns1__getTaskByRecordID(struct soap *soap, const char *tag, struct ns1__getTaskByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTaskByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskByRecordID, sizeof(struct ns1__getTaskByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTaskByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTaskByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskByRecordID, 0, sizeof(struct ns1__getTaskByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTaskByRecordID(struct soap *soap, const struct ns1__getTaskByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTaskByRecordID);
	if (soap_out_ns1__getTaskByRecordID(soap, tag?tag:"ns1:getTaskByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTaskByRecordID * SOAP_FMAC4 soap_get_ns1__getTaskByRecordID(struct soap *soap, struct ns1__getTaskByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTaskByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getTaskByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTaskByRecordID);
		if (size)
			*size = sizeof(struct ns1__getTaskByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTaskByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getTaskByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTaskByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTaskByRecordID %p -> %p\n", q, p));
	*(struct ns1__getTaskByRecordID*)p = *(struct ns1__getTaskByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTaskByRecordIDResponse(struct soap *soap, struct ns1__getTaskByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTaskByRecordIDResponse(struct soap *soap, const struct ns1__getTaskByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTaskByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTaskByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getTaskByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getTaskByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTaskByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskByRecordIDResponse, sizeof(struct ns1__getTaskByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTaskByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTaskByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskByRecordIDResponse, 0, sizeof(struct ns1__getTaskByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTaskByRecordIDResponse(struct soap *soap, const struct ns1__getTaskByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTaskByRecordIDResponse);
	if (soap_out_ns1__getTaskByRecordIDResponse(soap, tag?tag:"ns1:getTaskByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTaskByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getTaskByRecordIDResponse(struct soap *soap, struct ns1__getTaskByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTaskByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTaskByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getTaskByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTaskByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTaskByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTaskByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTaskByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getTaskByRecordIDResponse*)p = *(struct ns1__getTaskByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTask(struct soap *soap, struct ns1__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTask(struct soap *soap, const struct ns1__getTask *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTask(struct soap *soap, const char *tag, int id, const struct ns1__getTask *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTask), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTask * SOAP_FMAC4 soap_in_ns1__getTask(struct soap *soap, const char *tag, struct ns1__getTask *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTask, sizeof(struct ns1__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTask, 0, sizeof(struct ns1__getTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTask(struct soap *soap, const struct ns1__getTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTask);
	if (soap_out_ns1__getTask(soap, tag?tag:"ns1:getTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTask * SOAP_FMAC4 soap_get_ns1__getTask(struct soap *soap, struct ns1__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTask * SOAP_FMAC2 soap_instantiate_ns1__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTask);
		if (size)
			*size = sizeof(struct ns1__getTask);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTask, n);
		if (size)
			*size = n * sizeof(struct ns1__getTask);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTask*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTask %p -> %p\n", q, p));
	*(struct ns1__getTask*)p = *(struct ns1__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTaskResponse(struct soap *soap, struct ns1__getTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTask = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTaskResponse(struct soap *soap, const struct ns1__getTaskResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTask(soap, &a->pTask);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTaskResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CTask(soap, "pTask", -1, &a->pTask, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTaskResponse * SOAP_FMAC4 soap_in_ns1__getTaskResponse(struct soap *soap, const char *tag, struct ns1__getTaskResponse *a, const char *type)
{
	size_t soap_flag_pTask = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskResponse, sizeof(struct ns1__getTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTask && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTask(soap, "pTask", &a->pTask, "ns1:CTask"))
				{	soap_flag_pTask--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskResponse, 0, sizeof(struct ns1__getTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTaskResponse(struct soap *soap, const struct ns1__getTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTaskResponse);
	if (soap_out_ns1__getTaskResponse(soap, tag?tag:"ns1:getTaskResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTaskResponse * SOAP_FMAC4 soap_get_ns1__getTaskResponse(struct soap *soap, struct ns1__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTaskResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTaskResponse);
		if (size)
			*size = sizeof(struct ns1__getTaskResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTaskResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTaskResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTaskResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTaskResponse %p -> %p\n", q, p));
	*(struct ns1__getTaskResponse*)p = *(struct ns1__getTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectAttachment(struct soap *soap, struct ns1__getDefectAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectAttachment(struct soap *soap, const struct ns1__getDefectAttachment *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->pszArchiveName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectAttachment(struct soap *soap, const char *tag, int id, const struct ns1__getDefectAttachment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectAttachment), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "pszArchiveName", -1, &a->pszArchiveName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectAttachment * SOAP_FMAC4 soap_in_ns1__getDefectAttachment(struct soap *soap, const char *tag, struct ns1__getDefectAttachment *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pszArchiveName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectAttachment, sizeof(struct ns1__getDefectAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pszArchiveName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pszArchiveName", &a->pszArchiveName, "xsd:string"))
				{	soap_flag_pszArchiveName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectAttachment, 0, sizeof(struct ns1__getDefectAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectAttachment(struct soap *soap, const struct ns1__getDefectAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectAttachment);
	if (soap_out_ns1__getDefectAttachment(soap, tag?tag:"ns1:getDefectAttachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectAttachment * SOAP_FMAC4 soap_get_ns1__getDefectAttachment(struct soap *soap, struct ns1__getDefectAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectAttachment * SOAP_FMAC2 soap_instantiate_ns1__getDefectAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectAttachment);
		if (size)
			*size = sizeof(struct ns1__getDefectAttachment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectAttachment, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectAttachment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectAttachment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectAttachment %p -> %p\n", q, p));
	*(struct ns1__getDefectAttachment*)p = *(struct ns1__getDefectAttachment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectAttachmentResponse(struct soap *soap, struct ns1__getDefectAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectAttachmentResponse(struct soap *soap, const struct ns1__getDefectAttachmentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFileAttachment(soap, &a->pAttachment);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectAttachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDefectAttachmentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectAttachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFileAttachment(soap, "pAttachment", -1, &a->pAttachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectAttachmentResponse * SOAP_FMAC4 soap_in_ns1__getDefectAttachmentResponse(struct soap *soap, const char *tag, struct ns1__getDefectAttachmentResponse *a, const char *type)
{
	size_t soap_flag_pAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectAttachmentResponse, sizeof(struct ns1__getDefectAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFileAttachment(soap, "pAttachment", &a->pAttachment, "ns1:CFileAttachment"))
				{	soap_flag_pAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectAttachmentResponse, 0, sizeof(struct ns1__getDefectAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectAttachmentResponse(struct soap *soap, const struct ns1__getDefectAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectAttachmentResponse);
	if (soap_out_ns1__getDefectAttachmentResponse(soap, tag?tag:"ns1:getDefectAttachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectAttachmentResponse * SOAP_FMAC4 soap_get_ns1__getDefectAttachmentResponse(struct soap *soap, struct ns1__getDefectAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectAttachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectAttachmentResponse * SOAP_FMAC2 soap_instantiate_ns1__getDefectAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectAttachmentResponse);
		if (size)
			*size = sizeof(struct ns1__getDefectAttachmentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectAttachmentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectAttachmentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectAttachmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectAttachmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectAttachmentResponse %p -> %p\n", q, p));
	*(struct ns1__getDefectAttachmentResponse*)p = *(struct ns1__getDefectAttachmentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAttachment(struct soap *soap, struct ns1__getAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_LONG64(soap, &a->eventID);
	soap_default_string(soap, &a->pszArchiveName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAttachment(struct soap *soap, const struct ns1__getAttachment *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->eventID, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->pszArchiveName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAttachment(struct soap *soap, const char *tag, int id, const struct ns1__getAttachment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAttachment), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "eventID", -1, &a->eventID, ""))
		return soap->error;
	if (soap_out_string(soap, "pszArchiveName", -1, &a->pszArchiveName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAttachment * SOAP_FMAC4 soap_in_ns1__getAttachment(struct soap *soap, const char *tag, struct ns1__getAttachment *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_eventID = 1;
	size_t soap_flag_pszArchiveName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAttachment, sizeof(struct ns1__getAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_eventID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "eventID", &a->eventID, "xsd:long"))
				{	soap_flag_eventID--;
					continue;
				}
			if (soap_flag_pszArchiveName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pszArchiveName", &a->pszArchiveName, "xsd:string"))
				{	soap_flag_pszArchiveName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAttachment, 0, sizeof(struct ns1__getAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_eventID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAttachment(struct soap *soap, const struct ns1__getAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAttachment);
	if (soap_out_ns1__getAttachment(soap, tag?tag:"ns1:getAttachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAttachment * SOAP_FMAC4 soap_get_ns1__getAttachment(struct soap *soap, struct ns1__getAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAttachment * SOAP_FMAC2 soap_instantiate_ns1__getAttachment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAttachment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAttachment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAttachment);
		if (size)
			*size = sizeof(struct ns1__getAttachment);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAttachment, n);
		if (size)
			*size = n * sizeof(struct ns1__getAttachment);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAttachment*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAttachment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAttachment %p -> %p\n", q, p));
	*(struct ns1__getAttachment*)p = *(struct ns1__getAttachment*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAttachmentResponse(struct soap *soap, struct ns1__getAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAttachmentResponse(struct soap *soap, const struct ns1__getAttachmentResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CFileAttachment(soap, &a->pAttachment);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAttachmentResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAttachmentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAttachmentResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CFileAttachment(soap, "pAttachment", -1, &a->pAttachment, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAttachmentResponse * SOAP_FMAC4 soap_in_ns1__getAttachmentResponse(struct soap *soap, const char *tag, struct ns1__getAttachmentResponse *a, const char *type)
{
	size_t soap_flag_pAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAttachmentResponse, sizeof(struct ns1__getAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CFileAttachment(soap, "pAttachment", &a->pAttachment, "ns1:CFileAttachment"))
				{	soap_flag_pAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAttachmentResponse, 0, sizeof(struct ns1__getAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAttachmentResponse(struct soap *soap, const struct ns1__getAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAttachmentResponse);
	if (soap_out_ns1__getAttachmentResponse(soap, tag?tag:"ns1:getAttachmentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAttachmentResponse * SOAP_FMAC4 soap_get_ns1__getAttachmentResponse(struct soap *soap, struct ns1__getAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAttachmentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAttachmentResponse * SOAP_FMAC2 soap_instantiate_ns1__getAttachmentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAttachmentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAttachmentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAttachmentResponse);
		if (size)
			*size = sizeof(struct ns1__getAttachmentResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAttachmentResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAttachmentResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAttachmentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAttachmentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAttachmentResponse %p -> %p\n", q, p));
	*(struct ns1__getAttachmentResponse*)p = *(struct ns1__getAttachmentResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveDefect(struct soap *soap, struct ns1__cancelSaveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveDefect(struct soap *soap, const struct ns1__cancelSaveDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveDefect(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveDefect * SOAP_FMAC4 soap_in_ns1__cancelSaveDefect(struct soap *soap, const char *tag, struct ns1__cancelSaveDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveDefect, sizeof(struct ns1__cancelSaveDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveDefect, 0, sizeof(struct ns1__cancelSaveDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveDefect(struct soap *soap, const struct ns1__cancelSaveDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveDefect);
	if (soap_out_ns1__cancelSaveDefect(soap, tag?tag:"ns1:cancelSaveDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveDefect * SOAP_FMAC4 soap_get_ns1__cancelSaveDefect(struct soap *soap, struct ns1__cancelSaveDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveDefect * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveDefect);
		if (size)
			*size = sizeof(struct ns1__cancelSaveDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveDefect %p -> %p\n", q, p));
	*(struct ns1__cancelSaveDefect*)p = *(struct ns1__cancelSaveDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveDefectResponse(struct soap *soap, struct ns1__cancelSaveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveDefectResponse(struct soap *soap, const struct ns1__cancelSaveDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveDefectResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveDefectResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveDefectResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveDefectResponse, sizeof(struct ns1__cancelSaveDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveDefectResponse, 0, sizeof(struct ns1__cancelSaveDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveDefectResponse(struct soap *soap, const struct ns1__cancelSaveDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveDefectResponse);
	if (soap_out_ns1__cancelSaveDefectResponse(soap, tag?tag:"ns1:cancelSaveDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveDefectResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveDefectResponse(struct soap *soap, struct ns1__cancelSaveDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveDefectResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveDefectResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveDefectResponse*)p = *(struct ns1__cancelSaveDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveDefect(struct soap *soap, struct ns1__saveDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveDefect(struct soap *soap, const struct ns1__saveDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveDefect(struct soap *soap, const char *tag, int id, const struct ns1__saveDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveDefect * SOAP_FMAC4 soap_in_ns1__saveDefect(struct soap *soap, const char *tag, struct ns1__saveDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveDefect, sizeof(struct ns1__saveDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveDefect, 0, sizeof(struct ns1__saveDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveDefect(struct soap *soap, const struct ns1__saveDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveDefect);
	if (soap_out_ns1__saveDefect(soap, tag?tag:"ns1:saveDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveDefect * SOAP_FMAC4 soap_get_ns1__saveDefect(struct soap *soap, struct ns1__saveDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveDefect * SOAP_FMAC2 soap_instantiate_ns1__saveDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveDefect);
		if (size)
			*size = sizeof(struct ns1__saveDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__saveDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveDefect %p -> %p\n", q, p));
	*(struct ns1__saveDefect*)p = *(struct ns1__saveDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveDefectResponse(struct soap *soap, struct ns1__saveDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveDefectResponse(struct soap *soap, const struct ns1__saveDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveDefectResponse * SOAP_FMAC4 soap_in_ns1__saveDefectResponse(struct soap *soap, const char *tag, struct ns1__saveDefectResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveDefectResponse, sizeof(struct ns1__saveDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveDefectResponse, 0, sizeof(struct ns1__saveDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveDefectResponse(struct soap *soap, const struct ns1__saveDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveDefectResponse);
	if (soap_out_ns1__saveDefectResponse(soap, tag?tag:"ns1:saveDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveDefectResponse * SOAP_FMAC4 soap_get_ns1__saveDefectResponse(struct soap *soap, struct ns1__saveDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__saveDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveDefectResponse);
		if (size)
			*size = sizeof(struct ns1__saveDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveDefectResponse %p -> %p\n", q, p));
	*(struct ns1__saveDefectResponse*)p = *(struct ns1__saveDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editDefectByRecordID(struct soap *soap, struct ns1__editDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editDefectByRecordID(struct soap *soap, const struct ns1__editDefectByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editDefectByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editDefectByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editDefectByRecordID * SOAP_FMAC4 soap_in_ns1__editDefectByRecordID(struct soap *soap, const char *tag, struct ns1__editDefectByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editDefectByRecordID, sizeof(struct ns1__editDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editDefectByRecordID, 0, sizeof(struct ns1__editDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editDefectByRecordID(struct soap *soap, const struct ns1__editDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editDefectByRecordID);
	if (soap_out_ns1__editDefectByRecordID(soap, tag?tag:"ns1:editDefectByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editDefectByRecordID * SOAP_FMAC4 soap_get_ns1__editDefectByRecordID(struct soap *soap, struct ns1__editDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editDefectByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editDefectByRecordID);
		if (size)
			*size = sizeof(struct ns1__editDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editDefectByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editDefectByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editDefectByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editDefectByRecordID %p -> %p\n", q, p));
	*(struct ns1__editDefectByRecordID*)p = *(struct ns1__editDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editDefectByRecordIDResponse(struct soap *soap, struct ns1__editDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editDefectByRecordIDResponse(struct soap *soap, const struct ns1__editDefectByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editDefectByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editDefectByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editDefectByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editDefectByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editDefectByRecordIDResponse, sizeof(struct ns1__editDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editDefectByRecordIDResponse, 0, sizeof(struct ns1__editDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editDefectByRecordIDResponse(struct soap *soap, const struct ns1__editDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editDefectByRecordIDResponse);
	if (soap_out_ns1__editDefectByRecordIDResponse(soap, tag?tag:"ns1:editDefectByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editDefectByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editDefectByRecordIDResponse(struct soap *soap, struct ns1__editDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editDefectByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editDefectByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editDefectByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editDefectByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editDefectByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editDefectByRecordIDResponse*)p = *(struct ns1__editDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editDefect(struct soap *soap, struct ns1__editDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editDefect(struct soap *soap, const struct ns1__editDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editDefect(struct soap *soap, const char *tag, int id, const struct ns1__editDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editDefect * SOAP_FMAC4 soap_in_ns1__editDefect(struct soap *soap, const char *tag, struct ns1__editDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_defectNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editDefect, sizeof(struct ns1__editDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editDefect, 0, sizeof(struct ns1__editDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editDefect(struct soap *soap, const struct ns1__editDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editDefect);
	if (soap_out_ns1__editDefect(soap, tag?tag:"ns1:editDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editDefect * SOAP_FMAC4 soap_get_ns1__editDefect(struct soap *soap, struct ns1__editDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editDefect * SOAP_FMAC2 soap_instantiate_ns1__editDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editDefect);
		if (size)
			*size = sizeof(struct ns1__editDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__editDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editDefect %p -> %p\n", q, p));
	*(struct ns1__editDefect*)p = *(struct ns1__editDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editDefectResponse(struct soap *soap, struct ns1__editDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editDefectResponse(struct soap *soap, const struct ns1__editDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__editDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editDefectResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editDefectResponse * SOAP_FMAC4 soap_in_ns1__editDefectResponse(struct soap *soap, const char *tag, struct ns1__editDefectResponse *a, const char *type)
{
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editDefectResponse, sizeof(struct ns1__editDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editDefectResponse, 0, sizeof(struct ns1__editDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editDefectResponse(struct soap *soap, const struct ns1__editDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editDefectResponse);
	if (soap_out_ns1__editDefectResponse(soap, tag?tag:"ns1:editDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editDefectResponse * SOAP_FMAC4 soap_get_ns1__editDefectResponse(struct soap *soap, struct ns1__editDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__editDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editDefectResponse);
		if (size)
			*size = sizeof(struct ns1__editDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editDefectResponse %p -> %p\n", q, p));
	*(struct ns1__editDefectResponse*)p = *(struct ns1__editDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteDefectByRecordID(struct soap *soap, struct ns1__deleteDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteDefectByRecordID(struct soap *soap, const struct ns1__deleteDefectByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDefectByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteDefectByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteDefectByRecordID * SOAP_FMAC4 soap_in_ns1__deleteDefectByRecordID(struct soap *soap, const char *tag, struct ns1__deleteDefectByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDefectByRecordID, sizeof(struct ns1__deleteDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDefectByRecordID, 0, sizeof(struct ns1__deleteDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteDefectByRecordID(struct soap *soap, const struct ns1__deleteDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteDefectByRecordID);
	if (soap_out_ns1__deleteDefectByRecordID(soap, tag?tag:"ns1:deleteDefectByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteDefectByRecordID * SOAP_FMAC4 soap_get_ns1__deleteDefectByRecordID(struct soap *soap, struct ns1__deleteDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteDefectByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteDefectByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteDefectByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteDefectByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteDefectByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteDefectByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteDefectByRecordID*)p = *(struct ns1__deleteDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteDefectByRecordIDResponse(struct soap *soap, struct ns1__deleteDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteDefectByRecordIDResponse(struct soap *soap, const struct ns1__deleteDefectByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteDefectByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteDefectByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteDefectByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteDefectByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDefectByRecordIDResponse, sizeof(struct ns1__deleteDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDefectByRecordIDResponse, 0, sizeof(struct ns1__deleteDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteDefectByRecordIDResponse(struct soap *soap, const struct ns1__deleteDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteDefectByRecordIDResponse);
	if (soap_out_ns1__deleteDefectByRecordIDResponse(soap, tag?tag:"ns1:deleteDefectByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteDefectByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteDefectByRecordIDResponse(struct soap *soap, struct ns1__deleteDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteDefectByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteDefectByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteDefectByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteDefectByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteDefectByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteDefectByRecordIDResponse*)p = *(struct ns1__deleteDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteDefect(struct soap *soap, struct ns1__deleteDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteDefect(struct soap *soap, const struct ns1__deleteDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDefect(struct soap *soap, const char *tag, int id, const struct ns1__deleteDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteDefect * SOAP_FMAC4 soap_in_ns1__deleteDefect(struct soap *soap, const char *tag, struct ns1__deleteDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_defectNumber = 1;
	size_t soap_flag_summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDefect, sizeof(struct ns1__deleteDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDefect, 0, sizeof(struct ns1__deleteDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteDefect(struct soap *soap, const struct ns1__deleteDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteDefect);
	if (soap_out_ns1__deleteDefect(soap, tag?tag:"ns1:deleteDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteDefect * SOAP_FMAC4 soap_get_ns1__deleteDefect(struct soap *soap, struct ns1__deleteDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteDefect * SOAP_FMAC2 soap_instantiate_ns1__deleteDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteDefect);
		if (size)
			*size = sizeof(struct ns1__deleteDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteDefect %p -> %p\n", q, p));
	*(struct ns1__deleteDefect*)p = *(struct ns1__deleteDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteDefectResponse(struct soap *soap, struct ns1__deleteDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteDefectResponse(struct soap *soap, const struct ns1__deleteDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteDefectResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteDefectResponse * SOAP_FMAC4 soap_in_ns1__deleteDefectResponse(struct soap *soap, const char *tag, struct ns1__deleteDefectResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteDefectResponse, sizeof(struct ns1__deleteDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteDefectResponse, 0, sizeof(struct ns1__deleteDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteDefectResponse(struct soap *soap, const struct ns1__deleteDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteDefectResponse);
	if (soap_out_ns1__deleteDefectResponse(soap, tag?tag:"ns1:deleteDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteDefectResponse * SOAP_FMAC4 soap_get_ns1__deleteDefectResponse(struct soap *soap, struct ns1__deleteDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteDefectResponse);
		if (size)
			*size = sizeof(struct ns1__deleteDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteDefectResponse %p -> %p\n", q, p));
	*(struct ns1__deleteDefectResponse*)p = *(struct ns1__deleteDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDefectWithLink(struct soap *soap, struct ns1__addDefectWithLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
	soap_default_LONG64(soap, &a->testRunRecordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDefectWithLink(struct soap *soap, const struct ns1__addDefectWithLink *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
	soap_embedded(soap, &a->testRunRecordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDefectWithLink(struct soap *soap, const char *tag, int id, const struct ns1__addDefectWithLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDefectWithLink), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "testRunRecordID", -1, &a->testRunRecordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDefectWithLink * SOAP_FMAC4 soap_in_ns1__addDefectWithLink(struct soap *soap, const char *tag, struct ns1__addDefectWithLink *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pDefect = 1;
	size_t soap_flag_testRunRecordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDefectWithLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDefectWithLink, sizeof(struct ns1__addDefectWithLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDefectWithLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap_flag_testRunRecordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "testRunRecordID", &a->testRunRecordID, "xsd:long"))
				{	soap_flag_testRunRecordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDefectWithLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDefectWithLink, 0, sizeof(struct ns1__addDefectWithLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_testRunRecordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDefectWithLink(struct soap *soap, const struct ns1__addDefectWithLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDefectWithLink);
	if (soap_out_ns1__addDefectWithLink(soap, tag?tag:"ns1:addDefectWithLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDefectWithLink * SOAP_FMAC4 soap_get_ns1__addDefectWithLink(struct soap *soap, struct ns1__addDefectWithLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDefectWithLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDefectWithLink * SOAP_FMAC2 soap_instantiate_ns1__addDefectWithLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDefectWithLink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDefectWithLink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDefectWithLink);
		if (size)
			*size = sizeof(struct ns1__addDefectWithLink);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDefectWithLink, n);
		if (size)
			*size = n * sizeof(struct ns1__addDefectWithLink);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDefectWithLink*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDefectWithLink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDefectWithLink %p -> %p\n", q, p));
	*(struct ns1__addDefectWithLink*)p = *(struct ns1__addDefectWithLink*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDefectWithLinkResponse(struct soap *soap, struct ns1__addDefectWithLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDefectWithLinkResponse(struct soap *soap, const struct ns1__addDefectWithLinkResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDefectWithLinkResponse(struct soap *soap, const char *tag, int id, const struct ns1__addDefectWithLinkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDefectWithLinkResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDefectWithLinkResponse * SOAP_FMAC4 soap_in_ns1__addDefectWithLinkResponse(struct soap *soap, const char *tag, struct ns1__addDefectWithLinkResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDefectWithLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDefectWithLinkResponse, sizeof(struct ns1__addDefectWithLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDefectWithLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDefectWithLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDefectWithLinkResponse, 0, sizeof(struct ns1__addDefectWithLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDefectWithLinkResponse(struct soap *soap, const struct ns1__addDefectWithLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDefectWithLinkResponse);
	if (soap_out_ns1__addDefectWithLinkResponse(soap, tag?tag:"ns1:addDefectWithLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDefectWithLinkResponse * SOAP_FMAC4 soap_get_ns1__addDefectWithLinkResponse(struct soap *soap, struct ns1__addDefectWithLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDefectWithLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDefectWithLinkResponse * SOAP_FMAC2 soap_instantiate_ns1__addDefectWithLinkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDefectWithLinkResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDefectWithLinkResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDefectWithLinkResponse);
		if (size)
			*size = sizeof(struct ns1__addDefectWithLinkResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDefectWithLinkResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addDefectWithLinkResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDefectWithLinkResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDefectWithLinkResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDefectWithLinkResponse %p -> %p\n", q, p));
	*(struct ns1__addDefectWithLinkResponse*)p = *(struct ns1__addDefectWithLinkResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDefect(struct soap *soap, struct ns1__addDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDefect(struct soap *soap, const struct ns1__addDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDefect(struct soap *soap, const char *tag, int id, const struct ns1__addDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDefect * SOAP_FMAC4 soap_in_ns1__addDefect(struct soap *soap, const char *tag, struct ns1__addDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDefect, sizeof(struct ns1__addDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDefect, 0, sizeof(struct ns1__addDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDefect(struct soap *soap, const struct ns1__addDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDefect);
	if (soap_out_ns1__addDefect(soap, tag?tag:"ns1:addDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDefect * SOAP_FMAC4 soap_get_ns1__addDefect(struct soap *soap, struct ns1__addDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDefect * SOAP_FMAC2 soap_instantiate_ns1__addDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDefect);
		if (size)
			*size = sizeof(struct ns1__addDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__addDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDefect %p -> %p\n", q, p));
	*(struct ns1__addDefect*)p = *(struct ns1__addDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDefectResponse(struct soap *soap, struct ns1__addDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDefectResponse(struct soap *soap, const struct ns1__addDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__addDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDefectResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDefectResponse * SOAP_FMAC4 soap_in_ns1__addDefectResponse(struct soap *soap, const char *tag, struct ns1__addDefectResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDefectResponse, sizeof(struct ns1__addDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDefectResponse, 0, sizeof(struct ns1__addDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDefectResponse(struct soap *soap, const struct ns1__addDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDefectResponse);
	if (soap_out_ns1__addDefectResponse(soap, tag?tag:"ns1:addDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDefectResponse * SOAP_FMAC4 soap_get_ns1__addDefectResponse(struct soap *soap, struct ns1__addDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__addDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDefectResponse);
		if (size)
			*size = sizeof(struct ns1__addDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDefectResponse %p -> %p\n", q, p));
	*(struct ns1__addDefectResponse*)p = *(struct ns1__addDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectByRecordID(struct soap *soap, struct ns1__getDefectByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectByRecordID(struct soap *soap, const struct ns1__getDefectByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getDefectByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectByRecordID * SOAP_FMAC4 soap_in_ns1__getDefectByRecordID(struct soap *soap, const char *tag, struct ns1__getDefectByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectByRecordID, sizeof(struct ns1__getDefectByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectByRecordID, 0, sizeof(struct ns1__getDefectByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectByRecordID(struct soap *soap, const struct ns1__getDefectByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectByRecordID);
	if (soap_out_ns1__getDefectByRecordID(soap, tag?tag:"ns1:getDefectByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectByRecordID * SOAP_FMAC4 soap_get_ns1__getDefectByRecordID(struct soap *soap, struct ns1__getDefectByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getDefectByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectByRecordID);
		if (size)
			*size = sizeof(struct ns1__getDefectByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectByRecordID %p -> %p\n", q, p));
	*(struct ns1__getDefectByRecordID*)p = *(struct ns1__getDefectByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectByRecordIDResponse(struct soap *soap, struct ns1__getDefectByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectByRecordIDResponse(struct soap *soap, const struct ns1__getDefectByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDefectByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getDefectByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getDefectByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectByRecordIDResponse, sizeof(struct ns1__getDefectByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectByRecordIDResponse, 0, sizeof(struct ns1__getDefectByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectByRecordIDResponse(struct soap *soap, const struct ns1__getDefectByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectByRecordIDResponse);
	if (soap_out_ns1__getDefectByRecordIDResponse(soap, tag?tag:"ns1:getDefectByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getDefectByRecordIDResponse(struct soap *soap, struct ns1__getDefectByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getDefectByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getDefectByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getDefectByRecordIDResponse*)p = *(struct ns1__getDefectByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefect(struct soap *soap, struct ns1__getDefect *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->defectNumber);
	soap_default_string(soap, &a->summary);
	soap_default_bool(soap, &a->bDownloadAttachments);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefect(struct soap *soap, const struct ns1__getDefect *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->defectNumber, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->summary);
	soap_embedded(soap, &a->bDownloadAttachments, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefect(struct soap *soap, const char *tag, int id, const struct ns1__getDefect *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefect), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "defectNumber", -1, &a->defectNumber, ""))
		return soap->error;
	if (soap_out_string(soap, "summary", -1, &a->summary, ""))
		return soap->error;
	if (soap_out_bool(soap, "bDownloadAttachments", -1, &a->bDownloadAttachments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefect * SOAP_FMAC4 soap_in_ns1__getDefect(struct soap *soap, const char *tag, struct ns1__getDefect *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_defectNumber = 1;
	size_t soap_flag_summary = 1;
	size_t soap_flag_bDownloadAttachments = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefect *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefect, sizeof(struct ns1__getDefect), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefect(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_defectNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "defectNumber", &a->defectNumber, "xsd:long"))
				{	soap_flag_defectNumber--;
					continue;
				}
			if (soap_flag_summary && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "summary", &a->summary, "xsd:string"))
				{	soap_flag_summary--;
					continue;
				}
			if (soap_flag_bDownloadAttachments && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bDownloadAttachments", &a->bDownloadAttachments, "xsd:boolean"))
				{	soap_flag_bDownloadAttachments--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefect *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefect, 0, sizeof(struct ns1__getDefect), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_defectNumber > 0 || soap_flag_bDownloadAttachments > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefect(struct soap *soap, const struct ns1__getDefect *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefect);
	if (soap_out_ns1__getDefect(soap, tag?tag:"ns1:getDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefect * SOAP_FMAC4 soap_get_ns1__getDefect(struct soap *soap, struct ns1__getDefect *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefect * SOAP_FMAC2 soap_instantiate_ns1__getDefect(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefect(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefect, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefect);
		if (size)
			*size = sizeof(struct ns1__getDefect);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefect, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefect);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefect*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefect(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefect %p -> %p\n", q, p));
	*(struct ns1__getDefect*)p = *(struct ns1__getDefect*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectResponse(struct soap *soap, struct ns1__getDefectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDefect = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectResponse(struct soap *soap, const struct ns1__getDefectResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CDefect(soap, &a->pDefect);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDefectResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CDefect(soap, "pDefect", -1, &a->pDefect, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectResponse * SOAP_FMAC4 soap_in_ns1__getDefectResponse(struct soap *soap, const char *tag, struct ns1__getDefectResponse *a, const char *type)
{
	size_t soap_flag_pDefect = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectResponse, sizeof(struct ns1__getDefectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDefect && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CDefect(soap, "pDefect", &a->pDefect, "ns1:CDefect"))
				{	soap_flag_pDefect--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectResponse, 0, sizeof(struct ns1__getDefectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectResponse(struct soap *soap, const struct ns1__getDefectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectResponse);
	if (soap_out_ns1__getDefectResponse(soap, tag?tag:"ns1:getDefectResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectResponse * SOAP_FMAC4 soap_get_ns1__getDefectResponse(struct soap *soap, struct ns1__getDefectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectResponse * SOAP_FMAC2 soap_instantiate_ns1__getDefectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectResponse);
		if (size)
			*size = sizeof(struct ns1__getDefectResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectResponse %p -> %p\n", q, p));
	*(struct ns1__getDefectResponse*)p = *(struct ns1__getDefectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, struct ns1__getDefectCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, const struct ns1__getDefectCustomFieldsDefinitionList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, const char *tag, int id, const struct ns1__getDefectCustomFieldsDefinitionList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectCustomFieldsDefinitionList * SOAP_FMAC4 soap_in_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, const char *tag, struct ns1__getDefectCustomFieldsDefinitionList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectCustomFieldsDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList, sizeof(struct ns1__getDefectCustomFieldsDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectCustomFieldsDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectCustomFieldsDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList, 0, sizeof(struct ns1__getDefectCustomFieldsDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, const struct ns1__getDefectCustomFieldsDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList);
	if (soap_out_ns1__getDefectCustomFieldsDefinitionList(soap, tag?tag:"ns1:getDefectCustomFieldsDefinitionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectCustomFieldsDefinitionList * SOAP_FMAC4 soap_get_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, struct ns1__getDefectCustomFieldsDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectCustomFieldsDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectCustomFieldsDefinitionList * SOAP_FMAC2 soap_instantiate_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectCustomFieldsDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectCustomFieldsDefinitionList);
		if (size)
			*size = sizeof(struct ns1__getDefectCustomFieldsDefinitionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectCustomFieldsDefinitionList, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectCustomFieldsDefinitionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectCustomFieldsDefinitionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectCustomFieldsDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectCustomFieldsDefinitionList %p -> %p\n", q, p));
	*(struct ns1__getDefectCustomFieldsDefinitionList*)p = *(struct ns1__getDefectCustomFieldsDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, struct ns1__getDefectCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->customFields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const struct ns1__getDefectCustomFieldsDefinitionListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCField(soap, &a->customFields);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDefectCustomFieldsDefinitionListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFields", -1, &a->customFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_in_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, struct ns1__getDefectCustomFieldsDefinitionListResponse *a, const char *type)
{
	size_t soap_flag_customFields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectCustomFieldsDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse, sizeof(struct ns1__getDefectCustomFieldsDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectCustomFieldsDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customFields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFields", &a->customFields, "ns1:CField"))
				{	soap_flag_customFields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectCustomFieldsDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse, 0, sizeof(struct ns1__getDefectCustomFieldsDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, const struct ns1__getDefectCustomFieldsDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse);
	if (soap_out_ns1__getDefectCustomFieldsDefinitionListResponse(soap, tag?tag:"ns1:getDefectCustomFieldsDefinitionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_get_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, struct ns1__getDefectCustomFieldsDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectCustomFieldsDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectCustomFieldsDefinitionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectCustomFieldsDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectCustomFieldsDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectCustomFieldsDefinitionListResponse);
		if (size)
			*size = sizeof(struct ns1__getDefectCustomFieldsDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectCustomFieldsDefinitionListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectCustomFieldsDefinitionListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectCustomFieldsDefinitionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectCustomFieldsDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectCustomFieldsDefinitionListResponse %p -> %p\n", q, p));
	*(struct ns1__getDefectCustomFieldsDefinitionListResponse*)p = *(struct ns1__getDefectCustomFieldsDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomFieldsDefinitionList(struct soap *soap, struct ns1__getCustomFieldsDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomFieldsDefinitionList(struct soap *soap, const struct ns1__getCustomFieldsDefinitionList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomFieldsDefinitionList(struct soap *soap, const char *tag, int id, const struct ns1__getCustomFieldsDefinitionList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomFieldsDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomFieldsDefinitionList * SOAP_FMAC4 soap_in_ns1__getCustomFieldsDefinitionList(struct soap *soap, const char *tag, struct ns1__getCustomFieldsDefinitionList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomFieldsDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomFieldsDefinitionList, sizeof(struct ns1__getCustomFieldsDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomFieldsDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomFieldsDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomFieldsDefinitionList, 0, sizeof(struct ns1__getCustomFieldsDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomFieldsDefinitionList(struct soap *soap, const struct ns1__getCustomFieldsDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomFieldsDefinitionList);
	if (soap_out_ns1__getCustomFieldsDefinitionList(soap, tag?tag:"ns1:getCustomFieldsDefinitionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomFieldsDefinitionList * SOAP_FMAC4 soap_get_ns1__getCustomFieldsDefinitionList(struct soap *soap, struct ns1__getCustomFieldsDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomFieldsDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomFieldsDefinitionList * SOAP_FMAC2 soap_instantiate_ns1__getCustomFieldsDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomFieldsDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomFieldsDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomFieldsDefinitionList);
		if (size)
			*size = sizeof(struct ns1__getCustomFieldsDefinitionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomFieldsDefinitionList, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomFieldsDefinitionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomFieldsDefinitionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomFieldsDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomFieldsDefinitionList %p -> %p\n", q, p));
	*(struct ns1__getCustomFieldsDefinitionList*)p = *(struct ns1__getCustomFieldsDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, struct ns1__getCustomFieldsDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->customFields = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, const struct ns1__getCustomFieldsDefinitionListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCField(soap, &a->customFields);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getCustomFieldsDefinitionListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCField(soap, "customFields", -1, &a->customFields, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_in_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, const char *tag, struct ns1__getCustomFieldsDefinitionListResponse *a, const char *type)
{
	size_t soap_flag_customFields = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getCustomFieldsDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse, sizeof(struct ns1__getCustomFieldsDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getCustomFieldsDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customFields && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCField(soap, "customFields", &a->customFields, "ns1:CField"))
				{	soap_flag_customFields--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getCustomFieldsDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse, 0, sizeof(struct ns1__getCustomFieldsDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, const struct ns1__getCustomFieldsDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse);
	if (soap_out_ns1__getCustomFieldsDefinitionListResponse(soap, tag?tag:"ns1:getCustomFieldsDefinitionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getCustomFieldsDefinitionListResponse * SOAP_FMAC4 soap_get_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, struct ns1__getCustomFieldsDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomFieldsDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getCustomFieldsDefinitionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomFieldsDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomFieldsDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getCustomFieldsDefinitionListResponse);
		if (size)
			*size = sizeof(struct ns1__getCustomFieldsDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getCustomFieldsDefinitionListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getCustomFieldsDefinitionListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getCustomFieldsDefinitionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomFieldsDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getCustomFieldsDefinitionListResponse %p -> %p\n", q, p));
	*(struct ns1__getCustomFieldsDefinitionListResponse*)p = *(struct ns1__getCustomFieldsDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectEventDefinitionList(struct soap *soap, struct ns1__getDefectEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectEventDefinitionList(struct soap *soap, const struct ns1__getDefectEventDefinitionList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectEventDefinitionList(struct soap *soap, const char *tag, int id, const struct ns1__getDefectEventDefinitionList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectEventDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectEventDefinitionList * SOAP_FMAC4 soap_in_ns1__getDefectEventDefinitionList(struct soap *soap, const char *tag, struct ns1__getDefectEventDefinitionList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectEventDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectEventDefinitionList, sizeof(struct ns1__getDefectEventDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectEventDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectEventDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectEventDefinitionList, 0, sizeof(struct ns1__getDefectEventDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectEventDefinitionList(struct soap *soap, const struct ns1__getDefectEventDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectEventDefinitionList);
	if (soap_out_ns1__getDefectEventDefinitionList(soap, tag?tag:"ns1:getDefectEventDefinitionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectEventDefinitionList * SOAP_FMAC4 soap_get_ns1__getDefectEventDefinitionList(struct soap *soap, struct ns1__getDefectEventDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectEventDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectEventDefinitionList * SOAP_FMAC2 soap_instantiate_ns1__getDefectEventDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectEventDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectEventDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectEventDefinitionList);
		if (size)
			*size = sizeof(struct ns1__getDefectEventDefinitionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectEventDefinitionList, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectEventDefinitionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectEventDefinitionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectEventDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectEventDefinitionList %p -> %p\n", q, p));
	*(struct ns1__getDefectEventDefinitionList*)p = *(struct ns1__getDefectEventDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDefectEventDefinitionListResponse(struct soap *soap, struct ns1__getDefectEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventDefinitionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDefectEventDefinitionListResponse(struct soap *soap, const struct ns1__getDefectEventDefinitionListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCDefectEventDefinition(soap, &a->EventDefinitionList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDefectEventDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDefectEventDefinitionListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDefectEventDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCDefectEventDefinition(soap, "EventDefinitionList", -1, &a->EventDefinitionList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDefectEventDefinitionListResponse * SOAP_FMAC4 soap_in_ns1__getDefectEventDefinitionListResponse(struct soap *soap, const char *tag, struct ns1__getDefectEventDefinitionListResponse *a, const char *type)
{
	size_t soap_flag_EventDefinitionList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDefectEventDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDefectEventDefinitionListResponse, sizeof(struct ns1__getDefectEventDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDefectEventDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventDefinitionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCDefectEventDefinition(soap, "EventDefinitionList", &a->EventDefinitionList, "ns1:CDefectEventDefinition"))
				{	soap_flag_EventDefinitionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDefectEventDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDefectEventDefinitionListResponse, 0, sizeof(struct ns1__getDefectEventDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDefectEventDefinitionListResponse(struct soap *soap, const struct ns1__getDefectEventDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDefectEventDefinitionListResponse);
	if (soap_out_ns1__getDefectEventDefinitionListResponse(soap, tag?tag:"ns1:getDefectEventDefinitionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDefectEventDefinitionListResponse * SOAP_FMAC4 soap_get_ns1__getDefectEventDefinitionListResponse(struct soap *soap, struct ns1__getDefectEventDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDefectEventDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDefectEventDefinitionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getDefectEventDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDefectEventDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDefectEventDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDefectEventDefinitionListResponse);
		if (size)
			*size = sizeof(struct ns1__getDefectEventDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDefectEventDefinitionListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDefectEventDefinitionListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDefectEventDefinitionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDefectEventDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDefectEventDefinitionListResponse %p -> %p\n", q, p));
	*(struct ns1__getDefectEventDefinitionListResponse*)p = *(struct ns1__getDefectEventDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getEventDefinitionList(struct soap *soap, struct ns1__getEventDefinitionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getEventDefinitionList(struct soap *soap, const struct ns1__getEventDefinitionList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventDefinitionList(struct soap *soap, const char *tag, int id, const struct ns1__getEventDefinitionList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventDefinitionList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getEventDefinitionList * SOAP_FMAC4 soap_in_ns1__getEventDefinitionList(struct soap *soap, const char *tag, struct ns1__getEventDefinitionList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getEventDefinitionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventDefinitionList, sizeof(struct ns1__getEventDefinitionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getEventDefinitionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getEventDefinitionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventDefinitionList, 0, sizeof(struct ns1__getEventDefinitionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getEventDefinitionList(struct soap *soap, const struct ns1__getEventDefinitionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getEventDefinitionList);
	if (soap_out_ns1__getEventDefinitionList(soap, tag?tag:"ns1:getEventDefinitionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getEventDefinitionList * SOAP_FMAC4 soap_get_ns1__getEventDefinitionList(struct soap *soap, struct ns1__getEventDefinitionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventDefinitionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getEventDefinitionList * SOAP_FMAC2 soap_instantiate_ns1__getEventDefinitionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventDefinitionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventDefinitionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getEventDefinitionList);
		if (size)
			*size = sizeof(struct ns1__getEventDefinitionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getEventDefinitionList, n);
		if (size)
			*size = n * sizeof(struct ns1__getEventDefinitionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getEventDefinitionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventDefinitionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getEventDefinitionList %p -> %p\n", q, p));
	*(struct ns1__getEventDefinitionList*)p = *(struct ns1__getEventDefinitionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getEventDefinitionListResponse(struct soap *soap, struct ns1__getEventDefinitionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EventDefinitionList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getEventDefinitionListResponse(struct soap *soap, const struct ns1__getEventDefinitionListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCEventDefinition(soap, &a->EventDefinitionList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventDefinitionListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getEventDefinitionListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventDefinitionListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCEventDefinition(soap, "EventDefinitionList", -1, &a->EventDefinitionList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getEventDefinitionListResponse * SOAP_FMAC4 soap_in_ns1__getEventDefinitionListResponse(struct soap *soap, const char *tag, struct ns1__getEventDefinitionListResponse *a, const char *type)
{
	size_t soap_flag_EventDefinitionList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getEventDefinitionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventDefinitionListResponse, sizeof(struct ns1__getEventDefinitionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getEventDefinitionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EventDefinitionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCEventDefinition(soap, "EventDefinitionList", &a->EventDefinitionList, "ns1:CEventDefinition"))
				{	soap_flag_EventDefinitionList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getEventDefinitionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventDefinitionListResponse, 0, sizeof(struct ns1__getEventDefinitionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getEventDefinitionListResponse(struct soap *soap, const struct ns1__getEventDefinitionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getEventDefinitionListResponse);
	if (soap_out_ns1__getEventDefinitionListResponse(soap, tag?tag:"ns1:getEventDefinitionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getEventDefinitionListResponse * SOAP_FMAC4 soap_get_ns1__getEventDefinitionListResponse(struct soap *soap, struct ns1__getEventDefinitionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventDefinitionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getEventDefinitionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getEventDefinitionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventDefinitionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventDefinitionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getEventDefinitionListResponse);
		if (size)
			*size = sizeof(struct ns1__getEventDefinitionListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getEventDefinitionListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getEventDefinitionListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getEventDefinitionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventDefinitionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getEventDefinitionListResponse %p -> %p\n", q, p));
	*(struct ns1__getEventDefinitionListResponse*)p = *(struct ns1__getEventDefinitionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getReportRunResultsByRecordID(struct soap *soap, struct ns1__getReportRunResultsByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getReportRunResultsByRecordID(struct soap *soap, const struct ns1__getReportRunResultsByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReportRunResultsByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getReportRunResultsByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReportRunResultsByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByRecordID * SOAP_FMAC4 soap_in_ns1__getReportRunResultsByRecordID(struct soap *soap, const char *tag, struct ns1__getReportRunResultsByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getReportRunResultsByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReportRunResultsByRecordID, sizeof(struct ns1__getReportRunResultsByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getReportRunResultsByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getReportRunResultsByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReportRunResultsByRecordID, 0, sizeof(struct ns1__getReportRunResultsByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getReportRunResultsByRecordID(struct soap *soap, const struct ns1__getReportRunResultsByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getReportRunResultsByRecordID);
	if (soap_out_ns1__getReportRunResultsByRecordID(soap, tag?tag:"ns1:getReportRunResultsByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByRecordID * SOAP_FMAC4 soap_get_ns1__getReportRunResultsByRecordID(struct soap *soap, struct ns1__getReportRunResultsByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReportRunResultsByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getReportRunResultsByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getReportRunResultsByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReportRunResultsByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReportRunResultsByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getReportRunResultsByRecordID);
		if (size)
			*size = sizeof(struct ns1__getReportRunResultsByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getReportRunResultsByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getReportRunResultsByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getReportRunResultsByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReportRunResultsByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getReportRunResultsByRecordID %p -> %p\n", q, p));
	*(struct ns1__getReportRunResultsByRecordID*)p = *(struct ns1__getReportRunResultsByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, struct ns1__getReportRunResultsByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->results = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, const struct ns1__getReportRunResultsByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CReportRunResults(soap, &a->results);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getReportRunResultsByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CReportRunResults(soap, "results", -1, &a->results, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getReportRunResultsByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_results = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getReportRunResultsByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse, sizeof(struct ns1__getReportRunResultsByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getReportRunResultsByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_results && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CReportRunResults(soap, "results", &a->results, "ns1:CReportRunResults"))
				{	soap_flag_results--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getReportRunResultsByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse, 0, sizeof(struct ns1__getReportRunResultsByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, const struct ns1__getReportRunResultsByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse);
	if (soap_out_ns1__getReportRunResultsByRecordIDResponse(soap, tag?tag:"ns1:getReportRunResultsByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, struct ns1__getReportRunResultsByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReportRunResultsByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getReportRunResultsByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReportRunResultsByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReportRunResultsByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getReportRunResultsByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getReportRunResultsByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getReportRunResultsByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getReportRunResultsByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getReportRunResultsByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReportRunResultsByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getReportRunResultsByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getReportRunResultsByRecordIDResponse*)p = *(struct ns1__getReportRunResultsByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getReportRunResultsByName(struct soap *soap, struct ns1__getReportRunResultsByName *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getReportRunResultsByName(struct soap *soap, const struct ns1__getReportRunResultsByName *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReportRunResultsByName(struct soap *soap, const char *tag, int id, const struct ns1__getReportRunResultsByName *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReportRunResultsByName), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByName * SOAP_FMAC4 soap_in_ns1__getReportRunResultsByName(struct soap *soap, const char *tag, struct ns1__getReportRunResultsByName *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getReportRunResultsByName *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReportRunResultsByName, sizeof(struct ns1__getReportRunResultsByName), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getReportRunResultsByName(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getReportRunResultsByName *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReportRunResultsByName, 0, sizeof(struct ns1__getReportRunResultsByName), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getReportRunResultsByName(struct soap *soap, const struct ns1__getReportRunResultsByName *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getReportRunResultsByName);
	if (soap_out_ns1__getReportRunResultsByName(soap, tag?tag:"ns1:getReportRunResultsByName", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByName * SOAP_FMAC4 soap_get_ns1__getReportRunResultsByName(struct soap *soap, struct ns1__getReportRunResultsByName *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReportRunResultsByName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getReportRunResultsByName * SOAP_FMAC2 soap_instantiate_ns1__getReportRunResultsByName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReportRunResultsByName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReportRunResultsByName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getReportRunResultsByName);
		if (size)
			*size = sizeof(struct ns1__getReportRunResultsByName);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getReportRunResultsByName, n);
		if (size)
			*size = n * sizeof(struct ns1__getReportRunResultsByName);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getReportRunResultsByName*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReportRunResultsByName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getReportRunResultsByName %p -> %p\n", q, p));
	*(struct ns1__getReportRunResultsByName*)p = *(struct ns1__getReportRunResultsByName*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getReportRunResultsByNameResponse(struct soap *soap, struct ns1__getReportRunResultsByNameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->results = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getReportRunResultsByNameResponse(struct soap *soap, const struct ns1__getReportRunResultsByNameResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CReportRunResults(soap, &a->results);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getReportRunResultsByNameResponse(struct soap *soap, const char *tag, int id, const struct ns1__getReportRunResultsByNameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getReportRunResultsByNameResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CReportRunResults(soap, "results", -1, &a->results, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByNameResponse * SOAP_FMAC4 soap_in_ns1__getReportRunResultsByNameResponse(struct soap *soap, const char *tag, struct ns1__getReportRunResultsByNameResponse *a, const char *type)
{
	size_t soap_flag_results = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getReportRunResultsByNameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getReportRunResultsByNameResponse, sizeof(struct ns1__getReportRunResultsByNameResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getReportRunResultsByNameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_results && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CReportRunResults(soap, "results", &a->results, "ns1:CReportRunResults"))
				{	soap_flag_results--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getReportRunResultsByNameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getReportRunResultsByNameResponse, 0, sizeof(struct ns1__getReportRunResultsByNameResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getReportRunResultsByNameResponse(struct soap *soap, const struct ns1__getReportRunResultsByNameResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getReportRunResultsByNameResponse);
	if (soap_out_ns1__getReportRunResultsByNameResponse(soap, tag?tag:"ns1:getReportRunResultsByNameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getReportRunResultsByNameResponse * SOAP_FMAC4 soap_get_ns1__getReportRunResultsByNameResponse(struct soap *soap, struct ns1__getReportRunResultsByNameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getReportRunResultsByNameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getReportRunResultsByNameResponse * SOAP_FMAC2 soap_instantiate_ns1__getReportRunResultsByNameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getReportRunResultsByNameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getReportRunResultsByNameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getReportRunResultsByNameResponse);
		if (size)
			*size = sizeof(struct ns1__getReportRunResultsByNameResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getReportRunResultsByNameResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getReportRunResultsByNameResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getReportRunResultsByNameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getReportRunResultsByNameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getReportRunResultsByNameResponse %p -> %p\n", q, p));
	*(struct ns1__getReportRunResultsByNameResponse*)p = *(struct ns1__getReportRunResultsByNameResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAttachmentTypes(struct soap *soap, struct ns1__getAttachmentTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAttachmentTypes(struct soap *soap, const struct ns1__getAttachmentTypes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAttachmentTypes(struct soap *soap, const char *tag, int id, const struct ns1__getAttachmentTypes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAttachmentTypes), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAttachmentTypes * SOAP_FMAC4 soap_in_ns1__getAttachmentTypes(struct soap *soap, const char *tag, struct ns1__getAttachmentTypes *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAttachmentTypes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAttachmentTypes, sizeof(struct ns1__getAttachmentTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAttachmentTypes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAttachmentTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAttachmentTypes, 0, sizeof(struct ns1__getAttachmentTypes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAttachmentTypes(struct soap *soap, const struct ns1__getAttachmentTypes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAttachmentTypes);
	if (soap_out_ns1__getAttachmentTypes(soap, tag?tag:"ns1:getAttachmentTypes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAttachmentTypes * SOAP_FMAC4 soap_get_ns1__getAttachmentTypes(struct soap *soap, struct ns1__getAttachmentTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAttachmentTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAttachmentTypes * SOAP_FMAC2 soap_instantiate_ns1__getAttachmentTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAttachmentTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAttachmentTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAttachmentTypes);
		if (size)
			*size = sizeof(struct ns1__getAttachmentTypes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAttachmentTypes, n);
		if (size)
			*size = n * sizeof(struct ns1__getAttachmentTypes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAttachmentTypes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAttachmentTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAttachmentTypes %p -> %p\n", q, p));
	*(struct ns1__getAttachmentTypes*)p = *(struct ns1__getAttachmentTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAttachmentTypesResponse(struct soap *soap, struct ns1__getAttachmentTypesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTypeList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAttachmentTypesResponse(struct soap *soap, const struct ns1__getAttachmentTypesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfstring(soap, &a->pTypeList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAttachmentTypesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAttachmentTypesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAttachmentTypesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfstring(soap, "pTypeList", -1, &a->pTypeList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAttachmentTypesResponse * SOAP_FMAC4 soap_in_ns1__getAttachmentTypesResponse(struct soap *soap, const char *tag, struct ns1__getAttachmentTypesResponse *a, const char *type)
{
	size_t soap_flag_pTypeList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAttachmentTypesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAttachmentTypesResponse, sizeof(struct ns1__getAttachmentTypesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAttachmentTypesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTypeList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "pTypeList", &a->pTypeList, "xsd:string"))
				{	soap_flag_pTypeList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAttachmentTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAttachmentTypesResponse, 0, sizeof(struct ns1__getAttachmentTypesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAttachmentTypesResponse(struct soap *soap, const struct ns1__getAttachmentTypesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAttachmentTypesResponse);
	if (soap_out_ns1__getAttachmentTypesResponse(soap, tag?tag:"ns1:getAttachmentTypesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getAttachmentTypesResponse * SOAP_FMAC4 soap_get_ns1__getAttachmentTypesResponse(struct soap *soap, struct ns1__getAttachmentTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAttachmentTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getAttachmentTypesResponse * SOAP_FMAC2 soap_instantiate_ns1__getAttachmentTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAttachmentTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAttachmentTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getAttachmentTypesResponse);
		if (size)
			*size = sizeof(struct ns1__getAttachmentTypesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getAttachmentTypesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getAttachmentTypesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getAttachmentTypesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAttachmentTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAttachmentTypesResponse %p -> %p\n", q, p));
	*(struct ns1__getAttachmentTypesResponse*)p = *(struct ns1__getAttachmentTypesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestConfig(struct soap *soap, struct ns1__cancelSaveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestConfig(struct soap *soap, const struct ns1__cancelSaveTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestConfig * SOAP_FMAC4 soap_in_ns1__cancelSaveTestConfig(struct soap *soap, const char *tag, struct ns1__cancelSaveTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestConfig, sizeof(struct ns1__cancelSaveTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestConfig, 0, sizeof(struct ns1__cancelSaveTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestConfig(struct soap *soap, const struct ns1__cancelSaveTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestConfig);
	if (soap_out_ns1__cancelSaveTestConfig(soap, tag?tag:"ns1:cancelSaveTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestConfig * SOAP_FMAC4 soap_get_ns1__cancelSaveTestConfig(struct soap *soap, struct ns1__cancelSaveTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestConfig * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestConfig);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestConfig %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestConfig*)p = *(struct ns1__cancelSaveTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cancelSaveTestConfigResponse(struct soap *soap, struct ns1__cancelSaveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__cancelSaveTestConfigResponse(struct soap *soap, const struct ns1__cancelSaveTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cancelSaveTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__cancelSaveTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cancelSaveTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__cancelSaveTestConfigResponse * SOAP_FMAC4 soap_in_ns1__cancelSaveTestConfigResponse(struct soap *soap, const char *tag, struct ns1__cancelSaveTestConfigResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__cancelSaveTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cancelSaveTestConfigResponse, sizeof(struct ns1__cancelSaveTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__cancelSaveTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__cancelSaveTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cancelSaveTestConfigResponse, 0, sizeof(struct ns1__cancelSaveTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cancelSaveTestConfigResponse(struct soap *soap, const struct ns1__cancelSaveTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cancelSaveTestConfigResponse);
	if (soap_out_ns1__cancelSaveTestConfigResponse(soap, tag?tag:"ns1:cancelSaveTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__cancelSaveTestConfigResponse * SOAP_FMAC4 soap_get_ns1__cancelSaveTestConfigResponse(struct soap *soap, struct ns1__cancelSaveTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cancelSaveTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__cancelSaveTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__cancelSaveTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cancelSaveTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cancelSaveTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__cancelSaveTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__cancelSaveTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__cancelSaveTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__cancelSaveTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__cancelSaveTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cancelSaveTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__cancelSaveTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__cancelSaveTestConfigResponse*)p = *(struct ns1__cancelSaveTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestConfigByRecordID(struct soap *soap, struct ns1__deleteTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestConfigByRecordID(struct soap *soap, const struct ns1__deleteTestConfigByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestConfigByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestConfigByRecordID * SOAP_FMAC4 soap_in_ns1__deleteTestConfigByRecordID(struct soap *soap, const char *tag, struct ns1__deleteTestConfigByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestConfigByRecordID, sizeof(struct ns1__deleteTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestConfigByRecordID, 0, sizeof(struct ns1__deleteTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestConfigByRecordID(struct soap *soap, const struct ns1__deleteTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestConfigByRecordID);
	if (soap_out_ns1__deleteTestConfigByRecordID(soap, tag?tag:"ns1:deleteTestConfigByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestConfigByRecordID * SOAP_FMAC4 soap_get_ns1__deleteTestConfigByRecordID(struct soap *soap, struct ns1__deleteTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestConfigByRecordID * SOAP_FMAC2 soap_instantiate_ns1__deleteTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestConfigByRecordID);
		if (size)
			*size = sizeof(struct ns1__deleteTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestConfigByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestConfigByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestConfigByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestConfigByRecordID %p -> %p\n", q, p));
	*(struct ns1__deleteTestConfigByRecordID*)p = *(struct ns1__deleteTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, struct ns1__deleteTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestConfigByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestConfigByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__deleteTestConfigByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse, sizeof(struct ns1__deleteTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse, 0, sizeof(struct ns1__deleteTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__deleteTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse);
	if (soap_out_ns1__deleteTestConfigByRecordIDResponse(soap, tag?tag:"ns1:deleteTestConfigByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, struct ns1__deleteTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestConfigByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestConfigByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestConfigByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestConfigByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestConfigByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestConfigByRecordIDResponse*)p = *(struct ns1__deleteTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestConfig(struct soap *soap, struct ns1__deleteTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestConfig(struct soap *soap, const struct ns1__deleteTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestConfig * SOAP_FMAC4 soap_in_ns1__deleteTestConfig(struct soap *soap, const char *tag, struct ns1__deleteTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestConfig, sizeof(struct ns1__deleteTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestConfig, 0, sizeof(struct ns1__deleteTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestConfig(struct soap *soap, const struct ns1__deleteTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestConfig);
	if (soap_out_ns1__deleteTestConfig(soap, tag?tag:"ns1:deleteTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestConfig * SOAP_FMAC4 soap_get_ns1__deleteTestConfig(struct soap *soap, struct ns1__deleteTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestConfig * SOAP_FMAC2 soap_instantiate_ns1__deleteTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestConfig);
		if (size)
			*size = sizeof(struct ns1__deleteTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestConfig %p -> %p\n", q, p));
	*(struct ns1__deleteTestConfig*)p = *(struct ns1__deleteTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__deleteTestConfigResponse(struct soap *soap, struct ns1__deleteTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__deleteTestConfigResponse(struct soap *soap, const struct ns1__deleteTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__deleteTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__deleteTestConfigResponse * SOAP_FMAC4 soap_in_ns1__deleteTestConfigResponse(struct soap *soap, const char *tag, struct ns1__deleteTestConfigResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__deleteTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteTestConfigResponse, sizeof(struct ns1__deleteTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__deleteTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__deleteTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteTestConfigResponse, 0, sizeof(struct ns1__deleteTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__deleteTestConfigResponse(struct soap *soap, const struct ns1__deleteTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__deleteTestConfigResponse);
	if (soap_out_ns1__deleteTestConfigResponse(soap, tag?tag:"ns1:deleteTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__deleteTestConfigResponse * SOAP_FMAC4 soap_get_ns1__deleteTestConfigResponse(struct soap *soap, struct ns1__deleteTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__deleteTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__deleteTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__deleteTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__deleteTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__deleteTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__deleteTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__deleteTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__deleteTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__deleteTestConfigResponse*)p = *(struct ns1__deleteTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestConfig(struct soap *soap, struct ns1__saveTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestConfig(struct soap *soap, const struct ns1__saveTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__saveTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestConfig * SOAP_FMAC4 soap_in_ns1__saveTestConfig(struct soap *soap, const char *tag, struct ns1__saveTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestConfig, sizeof(struct ns1__saveTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestConfig, 0, sizeof(struct ns1__saveTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestConfig(struct soap *soap, const struct ns1__saveTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestConfig);
	if (soap_out_ns1__saveTestConfig(soap, tag?tag:"ns1:saveTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestConfig * SOAP_FMAC4 soap_get_ns1__saveTestConfig(struct soap *soap, struct ns1__saveTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestConfig * SOAP_FMAC2 soap_instantiate_ns1__saveTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestConfig);
		if (size)
			*size = sizeof(struct ns1__saveTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestConfig %p -> %p\n", q, p));
	*(struct ns1__saveTestConfig*)p = *(struct ns1__saveTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveTestConfigResponse(struct soap *soap, struct ns1__saveTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveTestConfigResponse(struct soap *soap, const struct ns1__saveTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveTestConfigResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveTestConfigResponse * SOAP_FMAC4 soap_in_ns1__saveTestConfigResponse(struct soap *soap, const char *tag, struct ns1__saveTestConfigResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveTestConfigResponse, sizeof(struct ns1__saveTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveTestConfigResponse, 0, sizeof(struct ns1__saveTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveTestConfigResponse(struct soap *soap, const struct ns1__saveTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__saveTestConfigResponse);
	if (soap_out_ns1__saveTestConfigResponse(soap, tag?tag:"ns1:saveTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveTestConfigResponse * SOAP_FMAC4 soap_get_ns1__saveTestConfigResponse(struct soap *soap, struct ns1__saveTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__saveTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__saveTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__saveTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__saveTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__saveTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__saveTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__saveTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__saveTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__saveTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__saveTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__saveTestConfigResponse*)p = *(struct ns1__saveTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestConfigByRecordID(struct soap *soap, struct ns1__editTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestConfigByRecordID(struct soap *soap, const struct ns1__editTestConfigByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__editTestConfigByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestConfigByRecordID * SOAP_FMAC4 soap_in_ns1__editTestConfigByRecordID(struct soap *soap, const char *tag, struct ns1__editTestConfigByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestConfigByRecordID, sizeof(struct ns1__editTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestConfigByRecordID, 0, sizeof(struct ns1__editTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestConfigByRecordID(struct soap *soap, const struct ns1__editTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestConfigByRecordID);
	if (soap_out_ns1__editTestConfigByRecordID(soap, tag?tag:"ns1:editTestConfigByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestConfigByRecordID * SOAP_FMAC4 soap_get_ns1__editTestConfigByRecordID(struct soap *soap, struct ns1__editTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestConfigByRecordID * SOAP_FMAC2 soap_instantiate_ns1__editTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestConfigByRecordID);
		if (size)
			*size = sizeof(struct ns1__editTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestConfigByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestConfigByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestConfigByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestConfigByRecordID %p -> %p\n", q, p));
	*(struct ns1__editTestConfigByRecordID*)p = *(struct ns1__editTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestConfigByRecordIDResponse(struct soap *soap, struct ns1__editTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__editTestConfigByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestConfigByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__editTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__editTestConfigByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestConfigByRecordIDResponse, sizeof(struct ns1__editTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestConfigByRecordIDResponse, 0, sizeof(struct ns1__editTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__editTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestConfigByRecordIDResponse);
	if (soap_out_ns1__editTestConfigByRecordIDResponse(soap, tag?tag:"ns1:editTestConfigByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__editTestConfigByRecordIDResponse(struct soap *soap, struct ns1__editTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestConfigByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestConfigByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__editTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestConfigByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestConfigByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestConfigByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__editTestConfigByRecordIDResponse*)p = *(struct ns1__editTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestConfig(struct soap *soap, struct ns1__editTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestConfig(struct soap *soap, const struct ns1__editTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__editTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestConfig * SOAP_FMAC4 soap_in_ns1__editTestConfig(struct soap *soap, const char *tag, struct ns1__editTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestConfig, sizeof(struct ns1__editTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestConfig, 0, sizeof(struct ns1__editTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestConfig(struct soap *soap, const struct ns1__editTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestConfig);
	if (soap_out_ns1__editTestConfig(soap, tag?tag:"ns1:editTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestConfig * SOAP_FMAC4 soap_get_ns1__editTestConfig(struct soap *soap, struct ns1__editTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestConfig * SOAP_FMAC2 soap_instantiate_ns1__editTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestConfig);
		if (size)
			*size = sizeof(struct ns1__editTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestConfig %p -> %p\n", q, p));
	*(struct ns1__editTestConfig*)p = *(struct ns1__editTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__editTestConfigResponse(struct soap *soap, struct ns1__editTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__editTestConfigResponse(struct soap *soap, const struct ns1__editTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__editTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__editTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__editTestConfigResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__editTestConfigResponse * SOAP_FMAC4 soap_in_ns1__editTestConfigResponse(struct soap *soap, const char *tag, struct ns1__editTestConfigResponse *a, const char *type)
{
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__editTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__editTestConfigResponse, sizeof(struct ns1__editTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__editTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__editTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__editTestConfigResponse, 0, sizeof(struct ns1__editTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__editTestConfigResponse(struct soap *soap, const struct ns1__editTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__editTestConfigResponse);
	if (soap_out_ns1__editTestConfigResponse(soap, tag?tag:"ns1:editTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__editTestConfigResponse * SOAP_FMAC4 soap_get_ns1__editTestConfigResponse(struct soap *soap, struct ns1__editTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__editTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__editTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__editTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__editTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__editTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__editTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__editTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__editTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__editTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__editTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__editTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__editTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__editTestConfigResponse*)p = *(struct ns1__editTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTestConfig(struct soap *soap, struct ns1__addTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTestConfig(struct soap *soap, const struct ns1__addTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__addTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTestConfig * SOAP_FMAC4 soap_in_ns1__addTestConfig(struct soap *soap, const char *tag, struct ns1__addTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTestConfig, sizeof(struct ns1__addTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTestConfig, 0, sizeof(struct ns1__addTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTestConfig(struct soap *soap, const struct ns1__addTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTestConfig);
	if (soap_out_ns1__addTestConfig(soap, tag?tag:"ns1:addTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTestConfig * SOAP_FMAC4 soap_get_ns1__addTestConfig(struct soap *soap, struct ns1__addTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTestConfig * SOAP_FMAC2 soap_instantiate_ns1__addTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTestConfig);
		if (size)
			*size = sizeof(struct ns1__addTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__addTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTestConfig %p -> %p\n", q, p));
	*(struct ns1__addTestConfig*)p = *(struct ns1__addTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addTestConfigResponse(struct soap *soap, struct ns1__addTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addTestConfigResponse(struct soap *soap, const struct ns1__addTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__addTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addTestConfigResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addTestConfigResponse * SOAP_FMAC4 soap_in_ns1__addTestConfigResponse(struct soap *soap, const char *tag, struct ns1__addTestConfigResponse *a, const char *type)
{
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addTestConfigResponse, sizeof(struct ns1__addTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addTestConfigResponse, 0, sizeof(struct ns1__addTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addTestConfigResponse(struct soap *soap, const struct ns1__addTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addTestConfigResponse);
	if (soap_out_ns1__addTestConfigResponse(soap, tag?tag:"ns1:addTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addTestConfigResponse * SOAP_FMAC4 soap_get_ns1__addTestConfigResponse(struct soap *soap, struct ns1__addTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__addTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__addTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__addTestConfigResponse*)p = *(struct ns1__addTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestConfigByRecordID(struct soap *soap, struct ns1__getTestConfigByRecordID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_LONG64(soap, &a->recordID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestConfigByRecordID(struct soap *soap, const struct ns1__getTestConfigByRecordID *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->recordID, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestConfigByRecordID(struct soap *soap, const char *tag, int id, const struct ns1__getTestConfigByRecordID *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestConfigByRecordID), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_LONG64(soap, "recordID", -1, &a->recordID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestConfigByRecordID * SOAP_FMAC4 soap_in_ns1__getTestConfigByRecordID(struct soap *soap, const char *tag, struct ns1__getTestConfigByRecordID *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_recordID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestConfigByRecordID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestConfigByRecordID, sizeof(struct ns1__getTestConfigByRecordID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestConfigByRecordID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_recordID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "recordID", &a->recordID, "xsd:long"))
				{	soap_flag_recordID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestConfigByRecordID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestConfigByRecordID, 0, sizeof(struct ns1__getTestConfigByRecordID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_recordID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestConfigByRecordID(struct soap *soap, const struct ns1__getTestConfigByRecordID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestConfigByRecordID);
	if (soap_out_ns1__getTestConfigByRecordID(soap, tag?tag:"ns1:getTestConfigByRecordID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestConfigByRecordID * SOAP_FMAC4 soap_get_ns1__getTestConfigByRecordID(struct soap *soap, struct ns1__getTestConfigByRecordID *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestConfigByRecordID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestConfigByRecordID * SOAP_FMAC2 soap_instantiate_ns1__getTestConfigByRecordID(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestConfigByRecordID(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestConfigByRecordID, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestConfigByRecordID);
		if (size)
			*size = sizeof(struct ns1__getTestConfigByRecordID);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestConfigByRecordID, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestConfigByRecordID);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestConfigByRecordID*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestConfigByRecordID(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestConfigByRecordID %p -> %p\n", q, p));
	*(struct ns1__getTestConfigByRecordID*)p = *(struct ns1__getTestConfigByRecordID*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestConfigByRecordIDResponse(struct soap *soap, struct ns1__getTestConfigByRecordIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__getTestConfigByRecordIDResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestConfigByRecordIDResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestConfigByRecordIDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestConfigByRecordIDResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestConfigByRecordIDResponse * SOAP_FMAC4 soap_in_ns1__getTestConfigByRecordIDResponse(struct soap *soap, const char *tag, struct ns1__getTestConfigByRecordIDResponse *a, const char *type)
{
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestConfigByRecordIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestConfigByRecordIDResponse, sizeof(struct ns1__getTestConfigByRecordIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestConfigByRecordIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestConfigByRecordIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestConfigByRecordIDResponse, 0, sizeof(struct ns1__getTestConfigByRecordIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestConfigByRecordIDResponse(struct soap *soap, const struct ns1__getTestConfigByRecordIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestConfigByRecordIDResponse);
	if (soap_out_ns1__getTestConfigByRecordIDResponse(soap, tag?tag:"ns1:getTestConfigByRecordIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestConfigByRecordIDResponse * SOAP_FMAC4 soap_get_ns1__getTestConfigByRecordIDResponse(struct soap *soap, struct ns1__getTestConfigByRecordIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestConfigByRecordIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestConfigByRecordIDResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestConfigByRecordIDResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestConfigByRecordIDResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestConfigByRecordIDResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestConfigByRecordIDResponse);
		if (size)
			*size = sizeof(struct ns1__getTestConfigByRecordIDResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestConfigByRecordIDResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestConfigByRecordIDResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestConfigByRecordIDResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestConfigByRecordIDResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestConfigByRecordIDResponse %p -> %p\n", q, p));
	*(struct ns1__getTestConfigByRecordIDResponse*)p = *(struct ns1__getTestConfigByRecordIDResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestConfig(struct soap *soap, struct ns1__getTestConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestConfig(struct soap *soap, const struct ns1__getTestConfig *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestConfig(struct soap *soap, const char *tag, int id, const struct ns1__getTestConfig *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestConfig), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &a->name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestConfig * SOAP_FMAC4 soap_in_ns1__getTestConfig(struct soap *soap, const char *tag, struct ns1__getTestConfig *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestConfig, sizeof(struct ns1__getTestConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestConfig, 0, sizeof(struct ns1__getTestConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestConfig(struct soap *soap, const struct ns1__getTestConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestConfig);
	if (soap_out_ns1__getTestConfig(soap, tag?tag:"ns1:getTestConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestConfig * SOAP_FMAC4 soap_get_ns1__getTestConfig(struct soap *soap, struct ns1__getTestConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestConfig * SOAP_FMAC2 soap_instantiate_ns1__getTestConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestConfig);
		if (size)
			*size = sizeof(struct ns1__getTestConfig);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestConfig, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestConfig);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestConfig*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestConfig %p -> %p\n", q, p));
	*(struct ns1__getTestConfig*)p = *(struct ns1__getTestConfig*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTestConfigResponse(struct soap *soap, struct ns1__getTestConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTestConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTestConfigResponse(struct soap *soap, const struct ns1__getTestConfigResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CSystem(soap, &a->pTestConfig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTestConfigResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTestConfigResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTestConfigResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CSystem(soap, "pTestConfig", -1, &a->pTestConfig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTestConfigResponse * SOAP_FMAC4 soap_in_ns1__getTestConfigResponse(struct soap *soap, const char *tag, struct ns1__getTestConfigResponse *a, const char *type)
{
	size_t soap_flag_pTestConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTestConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTestConfigResponse, sizeof(struct ns1__getTestConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTestConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTestConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CSystem(soap, "pTestConfig", &a->pTestConfig, "ns1:CSystem"))
				{	soap_flag_pTestConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTestConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTestConfigResponse, 0, sizeof(struct ns1__getTestConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTestConfigResponse(struct soap *soap, const struct ns1__getTestConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTestConfigResponse);
	if (soap_out_ns1__getTestConfigResponse(soap, tag?tag:"ns1:getTestConfigResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTestConfigResponse * SOAP_FMAC4 soap_get_ns1__getTestConfigResponse(struct soap *soap, struct ns1__getTestConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTestConfigResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTestConfigResponse * SOAP_FMAC2 soap_instantiate_ns1__getTestConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTestConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTestConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTestConfigResponse);
		if (size)
			*size = sizeof(struct ns1__getTestConfigResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTestConfigResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTestConfigResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTestConfigResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTestConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTestConfigResponse %p -> %p\n", q, p));
	*(struct ns1__getTestConfigResponse*)p = *(struct ns1__getTestConfigResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRecordListForTable(struct soap *soap, struct ns1__getRecordListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->filtername);
	a->columnlist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRecordListForTable(struct soap *soap, const struct ns1__getRecordListForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->filtername);
	soap_serialize_PointerToArrayOfCTableColumn(soap, &a->columnlist);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRecordListForTable(struct soap *soap, const char *tag, int id, const struct ns1__getRecordListForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRecordListForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "filtername", -1, &a->filtername, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCTableColumn(soap, "columnlist", -1, &a->columnlist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRecordListForTable * SOAP_FMAC4 soap_in_ns1__getRecordListForTable(struct soap *soap, const char *tag, struct ns1__getRecordListForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_filtername = 1;
	size_t soap_flag_columnlist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRecordListForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRecordListForTable, sizeof(struct ns1__getRecordListForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRecordListForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_filtername && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filtername", &a->filtername, "xsd:string"))
				{	soap_flag_filtername--;
					continue;
				}
			if (soap_flag_columnlist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTableColumn(soap, "columnlist", &a->columnlist, "ns1:CTableColumn"))
				{	soap_flag_columnlist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRecordListForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRecordListForTable, 0, sizeof(struct ns1__getRecordListForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRecordListForTable(struct soap *soap, const struct ns1__getRecordListForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRecordListForTable);
	if (soap_out_ns1__getRecordListForTable(soap, tag?tag:"ns1:getRecordListForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRecordListForTable * SOAP_FMAC4 soap_get_ns1__getRecordListForTable(struct soap *soap, struct ns1__getRecordListForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRecordListForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRecordListForTable * SOAP_FMAC2 soap_instantiate_ns1__getRecordListForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRecordListForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRecordListForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRecordListForTable);
		if (size)
			*size = sizeof(struct ns1__getRecordListForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRecordListForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__getRecordListForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRecordListForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRecordListForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRecordListForTable %p -> %p\n", q, p));
	*(struct ns1__getRecordListForTable*)p = *(struct ns1__getRecordListForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getRecordListForTableResponse(struct soap *soap, struct ns1__getRecordListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->recordlist = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getRecordListForTableResponse(struct soap *soap, const struct ns1__getRecordListForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CRecordListSoap(soap, &a->recordlist);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getRecordListForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__getRecordListForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getRecordListForTableResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__CRecordListSoap(soap, "recordlist", -1, &a->recordlist, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getRecordListForTableResponse * SOAP_FMAC4 soap_in_ns1__getRecordListForTableResponse(struct soap *soap, const char *tag, struct ns1__getRecordListForTableResponse *a, const char *type)
{
	size_t soap_flag_recordlist = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getRecordListForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getRecordListForTableResponse, sizeof(struct ns1__getRecordListForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getRecordListForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_recordlist && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CRecordListSoap(soap, "recordlist", &a->recordlist, "ns1:CRecordListSoap"))
				{	soap_flag_recordlist--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getRecordListForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getRecordListForTableResponse, 0, sizeof(struct ns1__getRecordListForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getRecordListForTableResponse(struct soap *soap, const struct ns1__getRecordListForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getRecordListForTableResponse);
	if (soap_out_ns1__getRecordListForTableResponse(soap, tag?tag:"ns1:getRecordListForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getRecordListForTableResponse * SOAP_FMAC4 soap_get_ns1__getRecordListForTableResponse(struct soap *soap, struct ns1__getRecordListForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getRecordListForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getRecordListForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__getRecordListForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getRecordListForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getRecordListForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getRecordListForTableResponse);
		if (size)
			*size = sizeof(struct ns1__getRecordListForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getRecordListForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getRecordListForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getRecordListForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getRecordListForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getRecordListForTableResponse %p -> %p\n", q, p));
	*(struct ns1__getRecordListForTableResponse*)p = *(struct ns1__getRecordListForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFilterListForTable(struct soap *soap, struct ns1__getFilterListForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFilterListForTable(struct soap *soap, const struct ns1__getFilterListForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFilterListForTable(struct soap *soap, const char *tag, int id, const struct ns1__getFilterListForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFilterListForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFilterListForTable * SOAP_FMAC4 soap_in_ns1__getFilterListForTable(struct soap *soap, const char *tag, struct ns1__getFilterListForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFilterListForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFilterListForTable, sizeof(struct ns1__getFilterListForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFilterListForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFilterListForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFilterListForTable, 0, sizeof(struct ns1__getFilterListForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFilterListForTable(struct soap *soap, const struct ns1__getFilterListForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFilterListForTable);
	if (soap_out_ns1__getFilterListForTable(soap, tag?tag:"ns1:getFilterListForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFilterListForTable * SOAP_FMAC4 soap_get_ns1__getFilterListForTable(struct soap *soap, struct ns1__getFilterListForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFilterListForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFilterListForTable * SOAP_FMAC2 soap_instantiate_ns1__getFilterListForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFilterListForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFilterListForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFilterListForTable);
		if (size)
			*size = sizeof(struct ns1__getFilterListForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFilterListForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__getFilterListForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFilterListForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFilterListForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFilterListForTable %p -> %p\n", q, p));
	*(struct ns1__getFilterListForTable*)p = *(struct ns1__getFilterListForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFilterListForTableResponse(struct soap *soap, struct ns1__getFilterListForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFilterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFilterListForTableResponse(struct soap *soap, const struct ns1__getFilterListForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFilter(soap, &a->pFilterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFilterListForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFilterListForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFilterListForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFilter(soap, "pFilterList", -1, &a->pFilterList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFilterListForTableResponse * SOAP_FMAC4 soap_in_ns1__getFilterListForTableResponse(struct soap *soap, const char *tag, struct ns1__getFilterListForTableResponse *a, const char *type)
{
	size_t soap_flag_pFilterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFilterListForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFilterListForTableResponse, sizeof(struct ns1__getFilterListForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFilterListForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFilterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFilter(soap, "pFilterList", &a->pFilterList, "ns1:CFilter"))
				{	soap_flag_pFilterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFilterListForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFilterListForTableResponse, 0, sizeof(struct ns1__getFilterListForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFilterListForTableResponse(struct soap *soap, const struct ns1__getFilterListForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFilterListForTableResponse);
	if (soap_out_ns1__getFilterListForTableResponse(soap, tag?tag:"ns1:getFilterListForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFilterListForTableResponse * SOAP_FMAC4 soap_get_ns1__getFilterListForTableResponse(struct soap *soap, struct ns1__getFilterListForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFilterListForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFilterListForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__getFilterListForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFilterListForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFilterListForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFilterListForTableResponse);
		if (size)
			*size = sizeof(struct ns1__getFilterListForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFilterListForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFilterListForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFilterListForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFilterListForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFilterListForTableResponse %p -> %p\n", q, p));
	*(struct ns1__getFilterListForTableResponse*)p = *(struct ns1__getFilterListForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFilterList(struct soap *soap, struct ns1__getFilterList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFilterList(struct soap *soap, const struct ns1__getFilterList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFilterList(struct soap *soap, const char *tag, int id, const struct ns1__getFilterList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFilterList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFilterList * SOAP_FMAC4 soap_in_ns1__getFilterList(struct soap *soap, const char *tag, struct ns1__getFilterList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFilterList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFilterList, sizeof(struct ns1__getFilterList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFilterList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFilterList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFilterList, 0, sizeof(struct ns1__getFilterList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFilterList(struct soap *soap, const struct ns1__getFilterList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFilterList);
	if (soap_out_ns1__getFilterList(soap, tag?tag:"ns1:getFilterList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFilterList * SOAP_FMAC4 soap_get_ns1__getFilterList(struct soap *soap, struct ns1__getFilterList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFilterList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFilterList * SOAP_FMAC2 soap_instantiate_ns1__getFilterList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFilterList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFilterList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFilterList);
		if (size)
			*size = sizeof(struct ns1__getFilterList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFilterList, n);
		if (size)
			*size = n * sizeof(struct ns1__getFilterList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFilterList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFilterList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFilterList %p -> %p\n", q, p));
	*(struct ns1__getFilterList*)p = *(struct ns1__getFilterList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFilterListResponse(struct soap *soap, struct ns1__getFilterListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFilterList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFilterListResponse(struct soap *soap, const struct ns1__getFilterListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFilter(soap, &a->pFilterList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFilterListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFilterListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFilterListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFilter(soap, "pFilterList", -1, &a->pFilterList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFilterListResponse * SOAP_FMAC4 soap_in_ns1__getFilterListResponse(struct soap *soap, const char *tag, struct ns1__getFilterListResponse *a, const char *type)
{
	size_t soap_flag_pFilterList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFilterListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFilterListResponse, sizeof(struct ns1__getFilterListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFilterListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFilterList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFilter(soap, "pFilterList", &a->pFilterList, "ns1:CFilter"))
				{	soap_flag_pFilterList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFilterListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFilterListResponse, 0, sizeof(struct ns1__getFilterListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFilterListResponse(struct soap *soap, const struct ns1__getFilterListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getFilterListResponse);
	if (soap_out_ns1__getFilterListResponse(soap, tag?tag:"ns1:getFilterListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFilterListResponse * SOAP_FMAC4 soap_get_ns1__getFilterListResponse(struct soap *soap, struct ns1__getFilterListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFilterListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getFilterListResponse * SOAP_FMAC2 soap_instantiate_ns1__getFilterListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFilterListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getFilterListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getFilterListResponse);
		if (size)
			*size = sizeof(struct ns1__getFilterListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getFilterListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getFilterListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getFilterListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getFilterListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getFilterListResponse %p -> %p\n", q, p));
	*(struct ns1__getFilterListResponse*)p = *(struct ns1__getFilterListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getColumnsForTable(struct soap *soap, struct ns1__getColumnsForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getColumnsForTable(struct soap *soap, const struct ns1__getColumnsForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getColumnsForTable(struct soap *soap, const char *tag, int id, const struct ns1__getColumnsForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getColumnsForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getColumnsForTable * SOAP_FMAC4 soap_in_ns1__getColumnsForTable(struct soap *soap, const char *tag, struct ns1__getColumnsForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getColumnsForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getColumnsForTable, sizeof(struct ns1__getColumnsForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getColumnsForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getColumnsForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getColumnsForTable, 0, sizeof(struct ns1__getColumnsForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getColumnsForTable(struct soap *soap, const struct ns1__getColumnsForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getColumnsForTable);
	if (soap_out_ns1__getColumnsForTable(soap, tag?tag:"ns1:getColumnsForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getColumnsForTable * SOAP_FMAC4 soap_get_ns1__getColumnsForTable(struct soap *soap, struct ns1__getColumnsForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getColumnsForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getColumnsForTable * SOAP_FMAC2 soap_instantiate_ns1__getColumnsForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getColumnsForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getColumnsForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getColumnsForTable);
		if (size)
			*size = sizeof(struct ns1__getColumnsForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getColumnsForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__getColumnsForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getColumnsForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getColumnsForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getColumnsForTable %p -> %p\n", q, p));
	*(struct ns1__getColumnsForTable*)p = *(struct ns1__getColumnsForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getColumnsForTableResponse(struct soap *soap, struct ns1__getColumnsForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pColumnList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getColumnsForTableResponse(struct soap *soap, const struct ns1__getColumnsForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCTableColumn(soap, &a->pColumnList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getColumnsForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__getColumnsForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getColumnsForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCTableColumn(soap, "pColumnList", -1, &a->pColumnList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getColumnsForTableResponse * SOAP_FMAC4 soap_in_ns1__getColumnsForTableResponse(struct soap *soap, const char *tag, struct ns1__getColumnsForTableResponse *a, const char *type)
{
	size_t soap_flag_pColumnList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getColumnsForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getColumnsForTableResponse, sizeof(struct ns1__getColumnsForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getColumnsForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pColumnList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTableColumn(soap, "pColumnList", &a->pColumnList, "ns1:CTableColumn"))
				{	soap_flag_pColumnList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getColumnsForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getColumnsForTableResponse, 0, sizeof(struct ns1__getColumnsForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getColumnsForTableResponse(struct soap *soap, const struct ns1__getColumnsForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getColumnsForTableResponse);
	if (soap_out_ns1__getColumnsForTableResponse(soap, tag?tag:"ns1:getColumnsForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getColumnsForTableResponse * SOAP_FMAC4 soap_get_ns1__getColumnsForTableResponse(struct soap *soap, struct ns1__getColumnsForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getColumnsForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getColumnsForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__getColumnsForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getColumnsForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getColumnsForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getColumnsForTableResponse);
		if (size)
			*size = sizeof(struct ns1__getColumnsForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getColumnsForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getColumnsForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getColumnsForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getColumnsForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getColumnsForTableResponse %p -> %p\n", q, p));
	*(struct ns1__getColumnsForTableResponse*)p = *(struct ns1__getColumnsForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetLinkDefinitionValues(struct soap *soap, struct ns1__GetLinkDefinitionValues *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetLinkDefinitionValues(struct soap *soap, const struct ns1__GetLinkDefinitionValues *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetLinkDefinitionValues(struct soap *soap, const char *tag, int id, const struct ns1__GetLinkDefinitionValues *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetLinkDefinitionValues), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetLinkDefinitionValues * SOAP_FMAC4 soap_in_ns1__GetLinkDefinitionValues(struct soap *soap, const char *tag, struct ns1__GetLinkDefinitionValues *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetLinkDefinitionValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetLinkDefinitionValues, sizeof(struct ns1__GetLinkDefinitionValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetLinkDefinitionValues(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetLinkDefinitionValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetLinkDefinitionValues, 0, sizeof(struct ns1__GetLinkDefinitionValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetLinkDefinitionValues(struct soap *soap, const struct ns1__GetLinkDefinitionValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetLinkDefinitionValues);
	if (soap_out_ns1__GetLinkDefinitionValues(soap, tag?tag:"ns1:GetLinkDefinitionValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetLinkDefinitionValues * SOAP_FMAC4 soap_get_ns1__GetLinkDefinitionValues(struct soap *soap, struct ns1__GetLinkDefinitionValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetLinkDefinitionValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetLinkDefinitionValues * SOAP_FMAC2 soap_instantiate_ns1__GetLinkDefinitionValues(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetLinkDefinitionValues(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetLinkDefinitionValues, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLinkDefinitionValues);
		if (size)
			*size = sizeof(struct ns1__GetLinkDefinitionValues);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__GetLinkDefinitionValues, n);
		if (size)
			*size = n * sizeof(struct ns1__GetLinkDefinitionValues);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__GetLinkDefinitionValues*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetLinkDefinitionValues(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetLinkDefinitionValues %p -> %p\n", q, p));
	*(struct ns1__GetLinkDefinitionValues*)p = *(struct ns1__GetLinkDefinitionValues*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, struct ns1__GetLinkDefinitionValuesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, const struct ns1__GetLinkDefinitionValuesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFieldValue(soap, &a->pValueList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetLinkDefinitionValuesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetLinkDefinitionValuesResponse * SOAP_FMAC4 soap_in_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, const char *tag, struct ns1__GetLinkDefinitionValuesResponse *a, const char *type)
{
	size_t soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetLinkDefinitionValuesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse, sizeof(struct ns1__GetLinkDefinitionValuesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetLinkDefinitionValuesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "ns1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetLinkDefinitionValuesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse, 0, sizeof(struct ns1__GetLinkDefinitionValuesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, const struct ns1__GetLinkDefinitionValuesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse);
	if (soap_out_ns1__GetLinkDefinitionValuesResponse(soap, tag?tag:"ns1:GetLinkDefinitionValuesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetLinkDefinitionValuesResponse * SOAP_FMAC4 soap_get_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, struct ns1__GetLinkDefinitionValuesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetLinkDefinitionValuesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__GetLinkDefinitionValuesResponse * SOAP_FMAC2 soap_instantiate_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetLinkDefinitionValuesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GetLinkDefinitionValuesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__GetLinkDefinitionValuesResponse);
		if (size)
			*size = sizeof(struct ns1__GetLinkDefinitionValuesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__GetLinkDefinitionValuesResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__GetLinkDefinitionValuesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__GetLinkDefinitionValuesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GetLinkDefinitionValuesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__GetLinkDefinitionValuesResponse %p -> %p\n", q, p));
	*(struct ns1__GetLinkDefinitionValuesResponse*)p = *(struct ns1__GetLinkDefinitionValuesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDropdownFieldValuesForTable(struct soap *soap, struct ns1__addDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->fieldname);
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDropdownFieldValuesForTable(struct soap *soap, const struct ns1__addDropdownFieldValuesForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->fieldname);
	soap_serialize_PointerToArrayOfCFieldValue(soap, &a->pValueList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDropdownFieldValuesForTable(struct soap *soap, const char *tag, int id, const struct ns1__addDropdownFieldValuesForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDropdownFieldValuesForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "fieldname", -1, &a->fieldname, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDropdownFieldValuesForTable * SOAP_FMAC4 soap_in_ns1__addDropdownFieldValuesForTable(struct soap *soap, const char *tag, struct ns1__addDropdownFieldValuesForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_fieldname = 1;
	size_t soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDropdownFieldValuesForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDropdownFieldValuesForTable, sizeof(struct ns1__addDropdownFieldValuesForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDropdownFieldValuesForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_fieldname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fieldname", &a->fieldname, "xsd:string"))
				{	soap_flag_fieldname--;
					continue;
				}
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "ns1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDropdownFieldValuesForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDropdownFieldValuesForTable, 0, sizeof(struct ns1__addDropdownFieldValuesForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDropdownFieldValuesForTable(struct soap *soap, const struct ns1__addDropdownFieldValuesForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDropdownFieldValuesForTable);
	if (soap_out_ns1__addDropdownFieldValuesForTable(soap, tag?tag:"ns1:addDropdownFieldValuesForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDropdownFieldValuesForTable * SOAP_FMAC4 soap_get_ns1__addDropdownFieldValuesForTable(struct soap *soap, struct ns1__addDropdownFieldValuesForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDropdownFieldValuesForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDropdownFieldValuesForTable * SOAP_FMAC2 soap_instantiate_ns1__addDropdownFieldValuesForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDropdownFieldValuesForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDropdownFieldValuesForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDropdownFieldValuesForTable);
		if (size)
			*size = sizeof(struct ns1__addDropdownFieldValuesForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDropdownFieldValuesForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__addDropdownFieldValuesForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDropdownFieldValuesForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDropdownFieldValuesForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDropdownFieldValuesForTable %p -> %p\n", q, p));
	*(struct ns1__addDropdownFieldValuesForTable*)p = *(struct ns1__addDropdownFieldValuesForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, struct ns1__addDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, const struct ns1__addDropdownFieldValuesForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__addDropdownFieldValuesForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_in_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, struct ns1__addDropdownFieldValuesForTableResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDropdownFieldValuesForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse, sizeof(struct ns1__addDropdownFieldValuesForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDropdownFieldValuesForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDropdownFieldValuesForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse, 0, sizeof(struct ns1__addDropdownFieldValuesForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, const struct ns1__addDropdownFieldValuesForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse);
	if (soap_out_ns1__addDropdownFieldValuesForTableResponse(soap, tag?tag:"ns1:addDropdownFieldValuesForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_get_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, struct ns1__addDropdownFieldValuesForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDropdownFieldValuesForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__addDropdownFieldValuesForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addDropdownFieldValuesForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addDropdownFieldValuesForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__addDropdownFieldValuesForTableResponse);
		if (size)
			*size = sizeof(struct ns1__addDropdownFieldValuesForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__addDropdownFieldValuesForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__addDropdownFieldValuesForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__addDropdownFieldValuesForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addDropdownFieldValuesForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__addDropdownFieldValuesForTableResponse %p -> %p\n", q, p));
	*(struct ns1__addDropdownFieldValuesForTableResponse*)p = *(struct ns1__addDropdownFieldValuesForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDropdownFieldValuesForTable(struct soap *soap, struct ns1__getDropdownFieldValuesForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
	soap_default_string(soap, &a->fieldname);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDropdownFieldValuesForTable(struct soap *soap, const struct ns1__getDropdownFieldValuesForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
	soap_serialize_string(soap, &a->fieldname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDropdownFieldValuesForTable(struct soap *soap, const char *tag, int id, const struct ns1__getDropdownFieldValuesForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDropdownFieldValuesForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	if (soap_out_string(soap, "fieldname", -1, &a->fieldname, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDropdownFieldValuesForTable * SOAP_FMAC4 soap_in_ns1__getDropdownFieldValuesForTable(struct soap *soap, const char *tag, struct ns1__getDropdownFieldValuesForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	size_t soap_flag_fieldname = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDropdownFieldValuesForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDropdownFieldValuesForTable, sizeof(struct ns1__getDropdownFieldValuesForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDropdownFieldValuesForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap_flag_fieldname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fieldname", &a->fieldname, "xsd:string"))
				{	soap_flag_fieldname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDropdownFieldValuesForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDropdownFieldValuesForTable, 0, sizeof(struct ns1__getDropdownFieldValuesForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDropdownFieldValuesForTable(struct soap *soap, const struct ns1__getDropdownFieldValuesForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDropdownFieldValuesForTable);
	if (soap_out_ns1__getDropdownFieldValuesForTable(soap, tag?tag:"ns1:getDropdownFieldValuesForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDropdownFieldValuesForTable * SOAP_FMAC4 soap_get_ns1__getDropdownFieldValuesForTable(struct soap *soap, struct ns1__getDropdownFieldValuesForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDropdownFieldValuesForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDropdownFieldValuesForTable * SOAP_FMAC2 soap_instantiate_ns1__getDropdownFieldValuesForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDropdownFieldValuesForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDropdownFieldValuesForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDropdownFieldValuesForTable);
		if (size)
			*size = sizeof(struct ns1__getDropdownFieldValuesForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDropdownFieldValuesForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__getDropdownFieldValuesForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDropdownFieldValuesForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDropdownFieldValuesForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDropdownFieldValuesForTable %p -> %p\n", q, p));
	*(struct ns1__getDropdownFieldValuesForTable*)p = *(struct ns1__getDropdownFieldValuesForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, struct ns1__getDropdownFieldValuesForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pValueList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, const struct ns1__getDropdownFieldValuesForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCFieldValue(soap, &a->pValueList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDropdownFieldValuesForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCFieldValue(soap, "pValueList", -1, &a->pValueList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_in_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, const char *tag, struct ns1__getDropdownFieldValuesForTableResponse *a, const char *type)
{
	size_t soap_flag_pValueList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDropdownFieldValuesForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse, sizeof(struct ns1__getDropdownFieldValuesForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDropdownFieldValuesForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pValueList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCFieldValue(soap, "pValueList", &a->pValueList, "ns1:CFieldValue"))
				{	soap_flag_pValueList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDropdownFieldValuesForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse, 0, sizeof(struct ns1__getDropdownFieldValuesForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, const struct ns1__getDropdownFieldValuesForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse);
	if (soap_out_ns1__getDropdownFieldValuesForTableResponse(soap, tag?tag:"ns1:getDropdownFieldValuesForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDropdownFieldValuesForTableResponse * SOAP_FMAC4 soap_get_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, struct ns1__getDropdownFieldValuesForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDropdownFieldValuesForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDropdownFieldValuesForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDropdownFieldValuesForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDropdownFieldValuesForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDropdownFieldValuesForTableResponse);
		if (size)
			*size = sizeof(struct ns1__getDropdownFieldValuesForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDropdownFieldValuesForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDropdownFieldValuesForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDropdownFieldValuesForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDropdownFieldValuesForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDropdownFieldValuesForTableResponse %p -> %p\n", q, p));
	*(struct ns1__getDropdownFieldValuesForTableResponse*)p = *(struct ns1__getDropdownFieldValuesForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDropdownFieldForTable(struct soap *soap, struct ns1__getDropdownFieldForTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_string(soap, &a->tablename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDropdownFieldForTable(struct soap *soap, const struct ns1__getDropdownFieldForTable *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_serialize_string(soap, &a->tablename);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDropdownFieldForTable(struct soap *soap, const char *tag, int id, const struct ns1__getDropdownFieldForTable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDropdownFieldForTable), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_string(soap, "tablename", -1, &a->tablename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDropdownFieldForTable * SOAP_FMAC4 soap_in_ns1__getDropdownFieldForTable(struct soap *soap, const char *tag, struct ns1__getDropdownFieldForTable *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_tablename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDropdownFieldForTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDropdownFieldForTable, sizeof(struct ns1__getDropdownFieldForTable), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDropdownFieldForTable(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_tablename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tablename", &a->tablename, "xsd:string"))
				{	soap_flag_tablename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDropdownFieldForTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDropdownFieldForTable, 0, sizeof(struct ns1__getDropdownFieldForTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDropdownFieldForTable(struct soap *soap, const struct ns1__getDropdownFieldForTable *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDropdownFieldForTable);
	if (soap_out_ns1__getDropdownFieldForTable(soap, tag?tag:"ns1:getDropdownFieldForTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDropdownFieldForTable * SOAP_FMAC4 soap_get_ns1__getDropdownFieldForTable(struct soap *soap, struct ns1__getDropdownFieldForTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDropdownFieldForTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDropdownFieldForTable * SOAP_FMAC2 soap_instantiate_ns1__getDropdownFieldForTable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDropdownFieldForTable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDropdownFieldForTable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDropdownFieldForTable);
		if (size)
			*size = sizeof(struct ns1__getDropdownFieldForTable);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDropdownFieldForTable, n);
		if (size)
			*size = n * sizeof(struct ns1__getDropdownFieldForTable);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDropdownFieldForTable*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDropdownFieldForTable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDropdownFieldForTable %p -> %p\n", q, p));
	*(struct ns1__getDropdownFieldForTable*)p = *(struct ns1__getDropdownFieldForTable*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDropdownFieldForTableResponse(struct soap *soap, struct ns1__getDropdownFieldForTableResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pFieldList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDropdownFieldForTableResponse(struct soap *soap, const struct ns1__getDropdownFieldForTableResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCTableField(soap, &a->pFieldList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDropdownFieldForTableResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDropdownFieldForTableResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDropdownFieldForTableResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCTableField(soap, "pFieldList", -1, &a->pFieldList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDropdownFieldForTableResponse * SOAP_FMAC4 soap_in_ns1__getDropdownFieldForTableResponse(struct soap *soap, const char *tag, struct ns1__getDropdownFieldForTableResponse *a, const char *type)
{
	size_t soap_flag_pFieldList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDropdownFieldForTableResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDropdownFieldForTableResponse, sizeof(struct ns1__getDropdownFieldForTableResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDropdownFieldForTableResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pFieldList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTableField(soap, "pFieldList", &a->pFieldList, "ns1:CTableField"))
				{	soap_flag_pFieldList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDropdownFieldForTableResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDropdownFieldForTableResponse, 0, sizeof(struct ns1__getDropdownFieldForTableResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDropdownFieldForTableResponse(struct soap *soap, const struct ns1__getDropdownFieldForTableResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDropdownFieldForTableResponse);
	if (soap_out_ns1__getDropdownFieldForTableResponse(soap, tag?tag:"ns1:getDropdownFieldForTableResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDropdownFieldForTableResponse * SOAP_FMAC4 soap_get_ns1__getDropdownFieldForTableResponse(struct soap *soap, struct ns1__getDropdownFieldForTableResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDropdownFieldForTableResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDropdownFieldForTableResponse * SOAP_FMAC2 soap_instantiate_ns1__getDropdownFieldForTableResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDropdownFieldForTableResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDropdownFieldForTableResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDropdownFieldForTableResponse);
		if (size)
			*size = sizeof(struct ns1__getDropdownFieldForTableResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDropdownFieldForTableResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDropdownFieldForTableResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDropdownFieldForTableResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDropdownFieldForTableResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDropdownFieldForTableResponse %p -> %p\n", q, p));
	*(struct ns1__getDropdownFieldForTableResponse*)p = *(struct ns1__getDropdownFieldForTableResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTableList(struct soap *soap, struct ns1__getTableList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTableList(struct soap *soap, const struct ns1__getTableList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTableList(struct soap *soap, const char *tag, int id, const struct ns1__getTableList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTableList), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTableList * SOAP_FMAC4 soap_in_ns1__getTableList(struct soap *soap, const char *tag, struct ns1__getTableList *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTableList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTableList, sizeof(struct ns1__getTableList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTableList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTableList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTableList, 0, sizeof(struct ns1__getTableList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTableList(struct soap *soap, const struct ns1__getTableList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTableList);
	if (soap_out_ns1__getTableList(soap, tag?tag:"ns1:getTableList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTableList * SOAP_FMAC4 soap_get_ns1__getTableList(struct soap *soap, struct ns1__getTableList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTableList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTableList * SOAP_FMAC2 soap_instantiate_ns1__getTableList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTableList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTableList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTableList);
		if (size)
			*size = sizeof(struct ns1__getTableList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTableList, n);
		if (size)
			*size = n * sizeof(struct ns1__getTableList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTableList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTableList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTableList %p -> %p\n", q, p));
	*(struct ns1__getTableList*)p = *(struct ns1__getTableList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getTableListResponse(struct soap *soap, struct ns1__getTableListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pTableList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getTableListResponse(struct soap *soap, const struct ns1__getTableListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCDatabaseTable(soap, &a->pTableList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTableListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getTableListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTableListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCDatabaseTable(soap, "pTableList", -1, &a->pTableList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getTableListResponse * SOAP_FMAC4 soap_in_ns1__getTableListResponse(struct soap *soap, const char *tag, struct ns1__getTableListResponse *a, const char *type)
{
	size_t soap_flag_pTableList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getTableListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTableListResponse, sizeof(struct ns1__getTableListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getTableListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pTableList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCDatabaseTable(soap, "pTableList", &a->pTableList, "ns1:CDatabaseTable"))
				{	soap_flag_pTableList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getTableListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTableListResponse, 0, sizeof(struct ns1__getTableListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getTableListResponse(struct soap *soap, const struct ns1__getTableListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getTableListResponse);
	if (soap_out_ns1__getTableListResponse(soap, tag?tag:"ns1:getTableListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getTableListResponse * SOAP_FMAC4 soap_get_ns1__getTableListResponse(struct soap *soap, struct ns1__getTableListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTableListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getTableListResponse * SOAP_FMAC2 soap_instantiate_ns1__getTableListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTableListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTableListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getTableListResponse);
		if (size)
			*size = sizeof(struct ns1__getTableListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getTableListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getTableListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getTableListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTableListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getTableListResponse %p -> %p\n", q, p));
	*(struct ns1__getTableListResponse*)p = *(struct ns1__getTableListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__formattedTextSupport(struct soap *soap, struct ns1__formattedTextSupport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
	soap_default_bool(soap, &a->enableFormattedText);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__formattedTextSupport(struct soap *soap, const struct ns1__formattedTextSupport *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
	soap_embedded(soap, &a->enableFormattedText, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__formattedTextSupport(struct soap *soap, const char *tag, int id, const struct ns1__formattedTextSupport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__formattedTextSupport), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	if (soap_out_bool(soap, "enableFormattedText", -1, &a->enableFormattedText, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__formattedTextSupport * SOAP_FMAC4 soap_in_ns1__formattedTextSupport(struct soap *soap, const char *tag, struct ns1__formattedTextSupport *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	size_t soap_flag_enableFormattedText = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__formattedTextSupport *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__formattedTextSupport, sizeof(struct ns1__formattedTextSupport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__formattedTextSupport(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap_flag_enableFormattedText && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enableFormattedText", &a->enableFormattedText, "xsd:boolean"))
				{	soap_flag_enableFormattedText--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__formattedTextSupport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__formattedTextSupport, 0, sizeof(struct ns1__formattedTextSupport), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0 || soap_flag_enableFormattedText > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__formattedTextSupport(struct soap *soap, const struct ns1__formattedTextSupport *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__formattedTextSupport);
	if (soap_out_ns1__formattedTextSupport(soap, tag?tag:"ns1:formattedTextSupport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__formattedTextSupport * SOAP_FMAC4 soap_get_ns1__formattedTextSupport(struct soap *soap, struct ns1__formattedTextSupport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__formattedTextSupport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__formattedTextSupport * SOAP_FMAC2 soap_instantiate_ns1__formattedTextSupport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__formattedTextSupport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__formattedTextSupport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__formattedTextSupport);
		if (size)
			*size = sizeof(struct ns1__formattedTextSupport);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__formattedTextSupport, n);
		if (size)
			*size = n * sizeof(struct ns1__formattedTextSupport);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__formattedTextSupport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__formattedTextSupport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__formattedTextSupport %p -> %p\n", q, p));
	*(struct ns1__formattedTextSupport*)p = *(struct ns1__formattedTextSupport*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__formattedTextSupportResponse(struct soap *soap, struct ns1__formattedTextSupportResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_bool(soap, &a->formattingEnabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__formattedTextSupportResponse(struct soap *soap, const struct ns1__formattedTextSupportResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->formattingEnabled, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__formattedTextSupportResponse(struct soap *soap, const char *tag, int id, const struct ns1__formattedTextSupportResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__formattedTextSupportResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "formattingEnabled", -1, &a->formattingEnabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__formattedTextSupportResponse * SOAP_FMAC4 soap_in_ns1__formattedTextSupportResponse(struct soap *soap, const char *tag, struct ns1__formattedTextSupportResponse *a, const char *type)
{
	size_t soap_flag_formattingEnabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__formattedTextSupportResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__formattedTextSupportResponse, sizeof(struct ns1__formattedTextSupportResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__formattedTextSupportResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_formattingEnabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "formattingEnabled", &a->formattingEnabled, "xsd:boolean"))
				{	soap_flag_formattingEnabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__formattedTextSupportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__formattedTextSupportResponse, 0, sizeof(struct ns1__formattedTextSupportResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_formattingEnabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__formattedTextSupportResponse(struct soap *soap, const struct ns1__formattedTextSupportResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__formattedTextSupportResponse);
	if (soap_out_ns1__formattedTextSupportResponse(soap, tag?tag:"ns1:formattedTextSupportResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__formattedTextSupportResponse * SOAP_FMAC4 soap_get_ns1__formattedTextSupportResponse(struct soap *soap, struct ns1__formattedTextSupportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__formattedTextSupportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__formattedTextSupportResponse * SOAP_FMAC2 soap_instantiate_ns1__formattedTextSupportResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__formattedTextSupportResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__formattedTextSupportResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__formattedTextSupportResponse);
		if (size)
			*size = sizeof(struct ns1__formattedTextSupportResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__formattedTextSupportResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__formattedTextSupportResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__formattedTextSupportResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__formattedTextSupportResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__formattedTextSupportResponse %p -> %p\n", q, p));
	*(struct ns1__formattedTextSupportResponse*)p = *(struct ns1__formattedTextSupportResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DatabaseLogoff(struct soap *soap, struct ns1__DatabaseLogoff *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DatabaseLogoff(struct soap *soap, const struct ns1__DatabaseLogoff *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DatabaseLogoff(struct soap *soap, const char *tag, int id, const struct ns1__DatabaseLogoff *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DatabaseLogoff), type))
		return soap->error;
	if (soap_out_LONG64(soap, "cookie", -1, &a->cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DatabaseLogoff * SOAP_FMAC4 soap_in_ns1__DatabaseLogoff(struct soap *soap, const char *tag, struct ns1__DatabaseLogoff *a, const char *type)
{
	size_t soap_flag_cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DatabaseLogoff *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DatabaseLogoff, sizeof(struct ns1__DatabaseLogoff), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DatabaseLogoff(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "cookie", &a->cookie, "xsd:long"))
				{	soap_flag_cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DatabaseLogoff *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DatabaseLogoff, 0, sizeof(struct ns1__DatabaseLogoff), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DatabaseLogoff(struct soap *soap, const struct ns1__DatabaseLogoff *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DatabaseLogoff);
	if (soap_out_ns1__DatabaseLogoff(soap, tag?tag:"ns1:DatabaseLogoff", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DatabaseLogoff * SOAP_FMAC4 soap_get_ns1__DatabaseLogoff(struct soap *soap, struct ns1__DatabaseLogoff *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DatabaseLogoff(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DatabaseLogoff * SOAP_FMAC2 soap_instantiate_ns1__DatabaseLogoff(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DatabaseLogoff(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DatabaseLogoff, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DatabaseLogoff);
		if (size)
			*size = sizeof(struct ns1__DatabaseLogoff);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__DatabaseLogoff, n);
		if (size)
			*size = n * sizeof(struct ns1__DatabaseLogoff);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__DatabaseLogoff*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DatabaseLogoff(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DatabaseLogoff %p -> %p\n", q, p));
	*(struct ns1__DatabaseLogoff*)p = *(struct ns1__DatabaseLogoff*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DatabaseLogoffResponse(struct soap *soap, struct ns1__DatabaseLogoffResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DatabaseLogoffResponse(struct soap *soap, const struct ns1__DatabaseLogoffResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DatabaseLogoffResponse(struct soap *soap, const char *tag, int id, const struct ns1__DatabaseLogoffResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DatabaseLogoffResponse), type))
		return soap->error;
	if (soap_out_int(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DatabaseLogoffResponse * SOAP_FMAC4 soap_in_ns1__DatabaseLogoffResponse(struct soap *soap, const char *tag, struct ns1__DatabaseLogoffResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DatabaseLogoffResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DatabaseLogoffResponse, sizeof(struct ns1__DatabaseLogoffResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DatabaseLogoffResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DatabaseLogoffResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DatabaseLogoffResponse, 0, sizeof(struct ns1__DatabaseLogoffResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DatabaseLogoffResponse(struct soap *soap, const struct ns1__DatabaseLogoffResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DatabaseLogoffResponse);
	if (soap_out_ns1__DatabaseLogoffResponse(soap, tag?tag:"ns1:DatabaseLogoffResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DatabaseLogoffResponse * SOAP_FMAC4 soap_get_ns1__DatabaseLogoffResponse(struct soap *soap, struct ns1__DatabaseLogoffResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DatabaseLogoffResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DatabaseLogoffResponse * SOAP_FMAC2 soap_instantiate_ns1__DatabaseLogoffResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DatabaseLogoffResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DatabaseLogoffResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DatabaseLogoffResponse);
		if (size)
			*size = sizeof(struct ns1__DatabaseLogoffResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__DatabaseLogoffResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__DatabaseLogoffResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__DatabaseLogoffResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DatabaseLogoffResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DatabaseLogoffResponse %p -> %p\n", q, p));
	*(struct ns1__DatabaseLogoffResponse*)p = *(struct ns1__DatabaseLogoffResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ProjectLogon(struct soap *soap, struct ns1__ProjectLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProj = NULL;
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ProjectLogon(struct soap *soap, const struct ns1__ProjectLogon *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CProject(soap, &a->pProj);
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProjectLogon(struct soap *soap, const char *tag, int id, const struct ns1__ProjectLogon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProjectLogon), type))
		return soap->error;
	if (soap_out_PointerTons1__CProject(soap, "pProj", -1, &a->pProj, ""))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ProjectLogon * SOAP_FMAC4 soap_in_ns1__ProjectLogon(struct soap *soap, const char *tag, struct ns1__ProjectLogon *a, const char *type)
{
	size_t soap_flag_pProj = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ProjectLogon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProjectLogon, sizeof(struct ns1__ProjectLogon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ProjectLogon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProj && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CProject(soap, "pProj", &a->pProj, "ns1:CProject"))
				{	soap_flag_pProj--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectLogon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProjectLogon, 0, sizeof(struct ns1__ProjectLogon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProjectLogon(struct soap *soap, const struct ns1__ProjectLogon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ProjectLogon);
	if (soap_out_ns1__ProjectLogon(soap, tag?tag:"ns1:ProjectLogon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectLogon * SOAP_FMAC4 soap_get_ns1__ProjectLogon(struct soap *soap, struct ns1__ProjectLogon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProjectLogon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__ProjectLogon * SOAP_FMAC2 soap_instantiate_ns1__ProjectLogon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProjectLogon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProjectLogon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ProjectLogon);
		if (size)
			*size = sizeof(struct ns1__ProjectLogon);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__ProjectLogon, n);
		if (size)
			*size = n * sizeof(struct ns1__ProjectLogon);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__ProjectLogon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProjectLogon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ProjectLogon %p -> %p\n", q, p));
	*(struct ns1__ProjectLogon*)p = *(struct ns1__ProjectLogon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ProjectLogonResponse(struct soap *soap, struct ns1__ProjectLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->Cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ProjectLogonResponse(struct soap *soap, const struct ns1__ProjectLogonResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ProjectLogonResponse(struct soap *soap, const char *tag, int id, const struct ns1__ProjectLogonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ProjectLogonResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "Cookie", -1, &a->Cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ProjectLogonResponse * SOAP_FMAC4 soap_in_ns1__ProjectLogonResponse(struct soap *soap, const char *tag, struct ns1__ProjectLogonResponse *a, const char *type)
{
	size_t soap_flag_Cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ProjectLogonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ProjectLogonResponse, sizeof(struct ns1__ProjectLogonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ProjectLogonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "Cookie", &a->Cookie, "xsd:long"))
				{	soap_flag_Cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ProjectLogonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ProjectLogonResponse, 0, sizeof(struct ns1__ProjectLogonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ProjectLogonResponse(struct soap *soap, const struct ns1__ProjectLogonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ProjectLogonResponse);
	if (soap_out_ns1__ProjectLogonResponse(soap, tag?tag:"ns1:ProjectLogonResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ProjectLogonResponse * SOAP_FMAC4 soap_get_ns1__ProjectLogonResponse(struct soap *soap, struct ns1__ProjectLogonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ProjectLogonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__ProjectLogonResponse * SOAP_FMAC2 soap_instantiate_ns1__ProjectLogonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ProjectLogonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ProjectLogonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__ProjectLogonResponse);
		if (size)
			*size = sizeof(struct ns1__ProjectLogonResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__ProjectLogonResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__ProjectLogonResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__ProjectLogonResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ProjectLogonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__ProjectLogonResponse %p -> %p\n", q, p));
	*(struct ns1__ProjectLogonResponse*)p = *(struct ns1__ProjectLogonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DatabaseLogon(struct soap *soap, struct ns1__DatabaseLogon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->dbname);
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DatabaseLogon(struct soap *soap, const struct ns1__DatabaseLogon *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->dbname);
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DatabaseLogon(struct soap *soap, const char *tag, int id, const struct ns1__DatabaseLogon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DatabaseLogon), type))
		return soap->error;
	if (soap_out_string(soap, "dbname", -1, &a->dbname, ""))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DatabaseLogon * SOAP_FMAC4 soap_in_ns1__DatabaseLogon(struct soap *soap, const char *tag, struct ns1__DatabaseLogon *a, const char *type)
{
	size_t soap_flag_dbname = 1;
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DatabaseLogon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DatabaseLogon, sizeof(struct ns1__DatabaseLogon), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DatabaseLogon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dbname && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dbname", &a->dbname, "xsd:string"))
				{	soap_flag_dbname--;
					continue;
				}
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DatabaseLogon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DatabaseLogon, 0, sizeof(struct ns1__DatabaseLogon), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DatabaseLogon(struct soap *soap, const struct ns1__DatabaseLogon *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DatabaseLogon);
	if (soap_out_ns1__DatabaseLogon(soap, tag?tag:"ns1:DatabaseLogon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DatabaseLogon * SOAP_FMAC4 soap_get_ns1__DatabaseLogon(struct soap *soap, struct ns1__DatabaseLogon *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DatabaseLogon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DatabaseLogon * SOAP_FMAC2 soap_instantiate_ns1__DatabaseLogon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DatabaseLogon(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DatabaseLogon, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DatabaseLogon);
		if (size)
			*size = sizeof(struct ns1__DatabaseLogon);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__DatabaseLogon, n);
		if (size)
			*size = n * sizeof(struct ns1__DatabaseLogon);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__DatabaseLogon*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DatabaseLogon(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DatabaseLogon %p -> %p\n", q, p));
	*(struct ns1__DatabaseLogon*)p = *(struct ns1__DatabaseLogon*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DatabaseLogonResponse(struct soap *soap, struct ns1__DatabaseLogonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_LONG64(soap, &a->Cookie);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DatabaseLogonResponse(struct soap *soap, const struct ns1__DatabaseLogonResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Cookie, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DatabaseLogonResponse(struct soap *soap, const char *tag, int id, const struct ns1__DatabaseLogonResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DatabaseLogonResponse), type))
		return soap->error;
	if (soap_out_LONG64(soap, "Cookie", -1, &a->Cookie, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DatabaseLogonResponse * SOAP_FMAC4 soap_in_ns1__DatabaseLogonResponse(struct soap *soap, const char *tag, struct ns1__DatabaseLogonResponse *a, const char *type)
{
	size_t soap_flag_Cookie = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DatabaseLogonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DatabaseLogonResponse, sizeof(struct ns1__DatabaseLogonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DatabaseLogonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Cookie && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "Cookie", &a->Cookie, "xsd:long"))
				{	soap_flag_Cookie--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DatabaseLogonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DatabaseLogonResponse, 0, sizeof(struct ns1__DatabaseLogonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Cookie > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DatabaseLogonResponse(struct soap *soap, const struct ns1__DatabaseLogonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__DatabaseLogonResponse);
	if (soap_out_ns1__DatabaseLogonResponse(soap, tag?tag:"ns1:DatabaseLogonResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DatabaseLogonResponse * SOAP_FMAC4 soap_get_ns1__DatabaseLogonResponse(struct soap *soap, struct ns1__DatabaseLogonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DatabaseLogonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__DatabaseLogonResponse * SOAP_FMAC2 soap_instantiate_ns1__DatabaseLogonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DatabaseLogonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DatabaseLogonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__DatabaseLogonResponse);
		if (size)
			*size = sizeof(struct ns1__DatabaseLogonResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__DatabaseLogonResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__DatabaseLogonResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__DatabaseLogonResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DatabaseLogonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__DatabaseLogonResponse %p -> %p\n", q, p));
	*(struct ns1__DatabaseLogonResponse*)p = *(struct ns1__DatabaseLogonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProjectDataOptionList(struct soap *soap, struct ns1__getProjectDataOptionList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProjectDataOptionList(struct soap *soap, const struct ns1__getProjectDataOptionList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProjectDataOptionList(struct soap *soap, const char *tag, int id, const struct ns1__getProjectDataOptionList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProjectDataOptionList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProjectDataOptionList * SOAP_FMAC4 soap_in_ns1__getProjectDataOptionList(struct soap *soap, const char *tag, struct ns1__getProjectDataOptionList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProjectDataOptionList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProjectDataOptionList, sizeof(struct ns1__getProjectDataOptionList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getProjectDataOptionList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProjectDataOptionList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProjectDataOptionList, 0, sizeof(struct ns1__getProjectDataOptionList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProjectDataOptionList(struct soap *soap, const struct ns1__getProjectDataOptionList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProjectDataOptionList);
	if (soap_out_ns1__getProjectDataOptionList(soap, tag?tag:"ns1:getProjectDataOptionList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProjectDataOptionList * SOAP_FMAC4 soap_get_ns1__getProjectDataOptionList(struct soap *soap, struct ns1__getProjectDataOptionList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProjectDataOptionList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProjectDataOptionList * SOAP_FMAC2 soap_instantiate_ns1__getProjectDataOptionList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProjectDataOptionList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProjectDataOptionList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProjectDataOptionList);
		if (size)
			*size = sizeof(struct ns1__getProjectDataOptionList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getProjectDataOptionList, n);
		if (size)
			*size = n * sizeof(struct ns1__getProjectDataOptionList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getProjectDataOptionList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProjectDataOptionList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProjectDataOptionList %p -> %p\n", q, p));
	*(struct ns1__getProjectDataOptionList*)p = *(struct ns1__getProjectDataOptionList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProjectDataOptionListResponse(struct soap *soap, struct ns1__getProjectDataOptionListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProjTypes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProjectDataOptionListResponse(struct soap *soap, const struct ns1__getProjectDataOptionListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCProjectDataOption(soap, &a->pProjTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProjectDataOptionListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getProjectDataOptionListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProjectDataOptionListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCProjectDataOption(soap, "pProjTypes", -1, &a->pProjTypes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProjectDataOptionListResponse * SOAP_FMAC4 soap_in_ns1__getProjectDataOptionListResponse(struct soap *soap, const char *tag, struct ns1__getProjectDataOptionListResponse *a, const char *type)
{
	size_t soap_flag_pProjTypes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProjectDataOptionListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProjectDataOptionListResponse, sizeof(struct ns1__getProjectDataOptionListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getProjectDataOptionListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProjTypes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCProjectDataOption(soap, "pProjTypes", &a->pProjTypes, "ns1:CProjectDataOption"))
				{	soap_flag_pProjTypes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProjectDataOptionListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProjectDataOptionListResponse, 0, sizeof(struct ns1__getProjectDataOptionListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProjectDataOptionListResponse(struct soap *soap, const struct ns1__getProjectDataOptionListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProjectDataOptionListResponse);
	if (soap_out_ns1__getProjectDataOptionListResponse(soap, tag?tag:"ns1:getProjectDataOptionListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProjectDataOptionListResponse * SOAP_FMAC4 soap_get_ns1__getProjectDataOptionListResponse(struct soap *soap, struct ns1__getProjectDataOptionListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProjectDataOptionListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProjectDataOptionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getProjectDataOptionListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProjectDataOptionListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProjectDataOptionListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProjectDataOptionListResponse);
		if (size)
			*size = sizeof(struct ns1__getProjectDataOptionListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getProjectDataOptionListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getProjectDataOptionListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getProjectDataOptionListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProjectDataOptionListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProjectDataOptionListResponse %p -> %p\n", q, p));
	*(struct ns1__getProjectDataOptionListResponse*)p = *(struct ns1__getProjectDataOptionListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProjectList(struct soap *soap, struct ns1__getProjectList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->username);
	soap_default_string(soap, &a->password);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProjectList(struct soap *soap, const struct ns1__getProjectList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->username);
	soap_serialize_string(soap, &a->password);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProjectList(struct soap *soap, const char *tag, int id, const struct ns1__getProjectList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProjectList), type))
		return soap->error;
	if (soap_out_string(soap, "username", -1, &a->username, ""))
		return soap->error;
	if (soap_out_string(soap, "password", -1, &a->password, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProjectList * SOAP_FMAC4 soap_in_ns1__getProjectList(struct soap *soap, const char *tag, struct ns1__getProjectList *a, const char *type)
{
	size_t soap_flag_username = 1;
	size_t soap_flag_password = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProjectList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProjectList, sizeof(struct ns1__getProjectList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getProjectList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "username", &a->username, "xsd:string"))
				{	soap_flag_username--;
					continue;
				}
			if (soap_flag_password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "password", &a->password, "xsd:string"))
				{	soap_flag_password--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProjectList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProjectList, 0, sizeof(struct ns1__getProjectList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProjectList(struct soap *soap, const struct ns1__getProjectList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProjectList);
	if (soap_out_ns1__getProjectList(soap, tag?tag:"ns1:getProjectList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProjectList * SOAP_FMAC4 soap_get_ns1__getProjectList(struct soap *soap, struct ns1__getProjectList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProjectList * SOAP_FMAC2 soap_instantiate_ns1__getProjectList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProjectList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProjectList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProjectList);
		if (size)
			*size = sizeof(struct ns1__getProjectList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getProjectList, n);
		if (size)
			*size = n * sizeof(struct ns1__getProjectList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getProjectList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProjectList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProjectList %p -> %p\n", q, p));
	*(struct ns1__getProjectList*)p = *(struct ns1__getProjectList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getProjectListResponse(struct soap *soap, struct ns1__getProjectListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pProjList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getProjectListResponse(struct soap *soap, const struct ns1__getProjectListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCProject(soap, &a->pProjList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getProjectListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getProjectListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getProjectListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCProject(soap, "pProjList", -1, &a->pProjList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getProjectListResponse * SOAP_FMAC4 soap_in_ns1__getProjectListResponse(struct soap *soap, const char *tag, struct ns1__getProjectListResponse *a, const char *type)
{
	size_t soap_flag_pProjList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getProjectListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getProjectListResponse, sizeof(struct ns1__getProjectListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getProjectListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pProjList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCProject(soap, "pProjList", &a->pProjList, "ns1:CProject"))
				{	soap_flag_pProjList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getProjectListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getProjectListResponse, 0, sizeof(struct ns1__getProjectListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getProjectListResponse(struct soap *soap, const struct ns1__getProjectListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getProjectListResponse);
	if (soap_out_ns1__getProjectListResponse(soap, tag?tag:"ns1:getProjectListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getProjectListResponse * SOAP_FMAC4 soap_get_ns1__getProjectListResponse(struct soap *soap, struct ns1__getProjectListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getProjectListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getProjectListResponse * SOAP_FMAC2 soap_instantiate_ns1__getProjectListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getProjectListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getProjectListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getProjectListResponse);
		if (size)
			*size = sizeof(struct ns1__getProjectListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getProjectListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getProjectListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getProjectListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getProjectListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getProjectListResponse %p -> %p\n", q, p));
	*(struct ns1__getProjectListResponse*)p = *(struct ns1__getProjectListResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDatabaseList(struct soap *soap, struct ns1__getDatabaseList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDatabaseList(struct soap *soap, const struct ns1__getDatabaseList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatabaseList(struct soap *soap, const char *tag, int id, const struct ns1__getDatabaseList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatabaseList), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDatabaseList * SOAP_FMAC4 soap_in_ns1__getDatabaseList(struct soap *soap, const char *tag, struct ns1__getDatabaseList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDatabaseList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatabaseList, sizeof(struct ns1__getDatabaseList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDatabaseList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDatabaseList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatabaseList, 0, sizeof(struct ns1__getDatabaseList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDatabaseList(struct soap *soap, const struct ns1__getDatabaseList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDatabaseList);
	if (soap_out_ns1__getDatabaseList(soap, tag?tag:"ns1:getDatabaseList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDatabaseList * SOAP_FMAC4 soap_get_ns1__getDatabaseList(struct soap *soap, struct ns1__getDatabaseList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatabaseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDatabaseList * SOAP_FMAC2 soap_instantiate_ns1__getDatabaseList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatabaseList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatabaseList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDatabaseList);
		if (size)
			*size = sizeof(struct ns1__getDatabaseList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDatabaseList, n);
		if (size)
			*size = n * sizeof(struct ns1__getDatabaseList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDatabaseList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatabaseList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDatabaseList %p -> %p\n", q, p));
	*(struct ns1__getDatabaseList*)p = *(struct ns1__getDatabaseList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDatabaseListResponse(struct soap *soap, struct ns1__getDatabaseListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pDBList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDatabaseListResponse(struct soap *soap, const struct ns1__getDatabaseListResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCDatabase(soap, &a->pDBList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDatabaseListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDatabaseListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDatabaseListResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfCDatabase(soap, "pDBList", -1, &a->pDBList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDatabaseListResponse * SOAP_FMAC4 soap_in_ns1__getDatabaseListResponse(struct soap *soap, const char *tag, struct ns1__getDatabaseListResponse *a, const char *type)
{
	size_t soap_flag_pDBList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDatabaseListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDatabaseListResponse, sizeof(struct ns1__getDatabaseListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDatabaseListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pDBList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCDatabase(soap, "pDBList", &a->pDBList, "ns1:CDatabase"))
				{	soap_flag_pDBList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDatabaseListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDatabaseListResponse, 0, sizeof(struct ns1__getDatabaseListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDatabaseListResponse(struct soap *soap, const struct ns1__getDatabaseListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDatabaseListResponse);
	if (soap_out_ns1__getDatabaseListResponse(soap, tag?tag:"ns1:getDatabaseListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDatabaseListResponse * SOAP_FMAC4 soap_get_ns1__getDatabaseListResponse(struct soap *soap, struct ns1__getDatabaseListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDatabaseListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns1__getDatabaseListResponse * SOAP_FMAC2 soap_instantiate_ns1__getDatabaseListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDatabaseListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDatabaseListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns1__getDatabaseListResponse);
		if (size)
			*size = sizeof(struct ns1__getDatabaseListResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns1__getDatabaseListResponse, n);
		if (size)
			*size = n * sizeof(struct ns1__getDatabaseListResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns1__getDatabaseListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDatabaseListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDatabaseListResponse %p -> %p\n", q, p));
	*(struct ns1__getDatabaseListResponse*)p = *(struct ns1__getDatabaseListResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CItemHyperlinkContainer(struct soap *soap, ns1__CItemHyperlinkContainer *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CItemHyperlinkContainer))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CItemHyperlinkContainer(struct soap *soap, const char *tag, int id, ns1__CItemHyperlinkContainer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CItemHyperlinkContainer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CItemHyperlinkContainer ** SOAP_FMAC4 soap_in_PointerTons1__CItemHyperlinkContainer(struct soap *soap, const char *tag, ns1__CItemHyperlinkContainer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CItemHyperlinkContainer **)soap_malloc(soap, sizeof(ns1__CItemHyperlinkContainer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CItemHyperlinkContainer *)soap_instantiate_ns1__CItemHyperlinkContainer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CItemHyperlinkContainer ** p = (ns1__CItemHyperlinkContainer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CItemHyperlinkContainer, sizeof(ns1__CItemHyperlinkContainer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CItemHyperlinkContainer(struct soap *soap, ns1__CItemHyperlinkContainer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CItemHyperlinkContainer);
	if (soap_out_PointerTons1__CItemHyperlinkContainer(soap, tag?tag:"ns1:CItemHyperlinkContainer", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CItemHyperlinkContainer ** SOAP_FMAC4 soap_get_PointerTons1__CItemHyperlinkContainer(struct soap *soap, ns1__CItemHyperlinkContainer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CItemHyperlinkContainer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CRequirementDocument(struct soap *soap, ns1__CRequirementDocument *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CRequirementDocument))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CRequirementDocument(struct soap *soap, const char *tag, int id, ns1__CRequirementDocument *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CRequirementDocument);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CRequirementDocument ** SOAP_FMAC4 soap_in_PointerTons1__CRequirementDocument(struct soap *soap, const char *tag, ns1__CRequirementDocument **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRequirementDocument **)soap_malloc(soap, sizeof(ns1__CRequirementDocument *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CRequirementDocument *)soap_instantiate_ns1__CRequirementDocument(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CRequirementDocument ** p = (ns1__CRequirementDocument **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CRequirementDocument, sizeof(ns1__CRequirementDocument), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CRequirementDocument(struct soap *soap, ns1__CRequirementDocument *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CRequirementDocument);
	if (soap_out_PointerTons1__CRequirementDocument(soap, tag?tag:"ns1:CRequirementDocument", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRequirementDocument ** SOAP_FMAC4 soap_get_PointerTons1__CRequirementDocument(struct soap *soap, ns1__CRequirementDocument **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CRequirementDocument(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOflong(struct soap *soap, ArrayOflong *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOflong(struct soap *soap, const char *tag, int id, ArrayOflong *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOflong);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOflong ** SOAP_FMAC4 soap_in_PointerToArrayOflong(struct soap *soap, const char *tag, ArrayOflong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOflong **)soap_malloc(soap, sizeof(ArrayOflong *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOflong *)soap_instantiate_ArrayOflong(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOflong ** p = (ArrayOflong **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOflong, sizeof(ArrayOflong), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOflong(struct soap *soap, ArrayOflong *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOflong);
	if (soap_out_PointerToArrayOflong(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOflong ** SOAP_FMAC4 soap_get_PointerToArrayOflong(struct soap *soap, ArrayOflong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOflong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CRequirement(struct soap *soap, ns1__CRequirement *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CRequirement))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CRequirement(struct soap *soap, const char *tag, int id, ns1__CRequirement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CRequirement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CRequirement ** SOAP_FMAC4 soap_in_PointerTons1__CRequirement(struct soap *soap, const char *tag, ns1__CRequirement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRequirement **)soap_malloc(soap, sizeof(ns1__CRequirement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CRequirement *)soap_instantiate_ns1__CRequirement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CRequirement ** p = (ns1__CRequirement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CRequirement, sizeof(ns1__CRequirement), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CRequirement(struct soap *soap, ns1__CRequirement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CRequirement);
	if (soap_out_PointerTons1__CRequirement(soap, tag?tag:"ns1:CRequirement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRequirement ** SOAP_FMAC4 soap_get_PointerTons1__CRequirement(struct soap *soap, ns1__CRequirement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CRequirement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFolder(struct soap *soap, ArrayOfCFolder *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFolder(struct soap *soap, const char *tag, int id, ArrayOfCFolder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFolder ** SOAP_FMAC4 soap_in_PointerToArrayOfCFolder(struct soap *soap, const char *tag, ArrayOfCFolder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFolder **)soap_malloc(soap, sizeof(ArrayOfCFolder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFolder *)soap_instantiate_ArrayOfCFolder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFolder ** p = (ArrayOfCFolder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFolder, sizeof(ArrayOfCFolder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFolder(struct soap *soap, ArrayOfCFolder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFolder);
	if (soap_out_PointerToArrayOfCFolder(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFolder ** SOAP_FMAC4 soap_get_PointerToArrayOfCFolder(struct soap *soap, ArrayOfCFolder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFolderItem(struct soap *soap, ArrayOfCFolderItem *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFolderItem(struct soap *soap, const char *tag, int id, ArrayOfCFolderItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolderItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFolderItem ** SOAP_FMAC4 soap_in_PointerToArrayOfCFolderItem(struct soap *soap, const char *tag, ArrayOfCFolderItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFolderItem **)soap_malloc(soap, sizeof(ArrayOfCFolderItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFolderItem *)soap_instantiate_ArrayOfCFolderItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFolderItem ** p = (ArrayOfCFolderItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFolderItem, sizeof(ArrayOfCFolderItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFolderItem(struct soap *soap, ArrayOfCFolderItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFolderItem);
	if (soap_out_PointerToArrayOfCFolderItem(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFolderItem ** SOAP_FMAC4 soap_get_PointerToArrayOfCFolderItem(struct soap *soap, ArrayOfCFolderItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFolderType(struct soap *soap, ArrayOfCFolderType *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFolderType(struct soap *soap, const char *tag, int id, ArrayOfCFolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFolderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFolderType ** SOAP_FMAC4 soap_in_PointerToArrayOfCFolderType(struct soap *soap, const char *tag, ArrayOfCFolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFolderType **)soap_malloc(soap, sizeof(ArrayOfCFolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFolderType *)soap_instantiate_ArrayOfCFolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFolderType ** p = (ArrayOfCFolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFolderType, sizeof(ArrayOfCFolderType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFolderType(struct soap *soap, ArrayOfCFolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFolderType);
	if (soap_out_PointerToArrayOfCFolderType(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFolderType ** SOAP_FMAC4 soap_get_PointerToArrayOfCFolderType(struct soap *soap, ArrayOfCFolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTestRunVariantField(struct soap *soap, ArrayOfCTestRunVariantField *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTestRunVariantField(struct soap *soap, const char *tag, int id, ArrayOfCTestRunVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTestRunVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTestRunVariantField ** SOAP_FMAC4 soap_in_PointerToArrayOfCTestRunVariantField(struct soap *soap, const char *tag, ArrayOfCTestRunVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTestRunVariantField **)soap_malloc(soap, sizeof(ArrayOfCTestRunVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTestRunVariantField *)soap_instantiate_ArrayOfCTestRunVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCTestRunVariantField ** p = (ArrayOfCTestRunVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTestRunVariantField, sizeof(ArrayOfCTestRunVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTestRunVariantField(struct soap *soap, ArrayOfCTestRunVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTestRunVariantField);
	if (soap_out_PointerToArrayOfCTestRunVariantField(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCTestRunVariantField ** SOAP_FMAC4 soap_get_PointerToArrayOfCTestRunVariantField(struct soap *soap, ArrayOfCTestRunVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCItemToTrack(struct soap *soap, ArrayOfCItemToTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCItemToTrack(struct soap *soap, const char *tag, int id, ArrayOfCItemToTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCItemToTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCItemToTrack ** SOAP_FMAC4 soap_in_PointerToArrayOfCItemToTrack(struct soap *soap, const char *tag, ArrayOfCItemToTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCItemToTrack **)soap_malloc(soap, sizeof(ArrayOfCItemToTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCItemToTrack *)soap_instantiate_ArrayOfCItemToTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCItemToTrack ** p = (ArrayOfCItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCItemToTrack, sizeof(ArrayOfCItemToTrack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCItemToTrack(struct soap *soap, ArrayOfCItemToTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCItemToTrack);
	if (soap_out_PointerToArrayOfCItemToTrack(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCItemToTrack ** SOAP_FMAC4 soap_get_PointerToArrayOfCItemToTrack(struct soap *soap, ArrayOfCItemToTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTestRun(struct soap *soap, ns1__CTestRun *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTestRun))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTestRun(struct soap *soap, const char *tag, int id, ns1__CTestRun *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTestRun);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTestRun ** SOAP_FMAC4 soap_in_PointerTons1__CTestRun(struct soap *soap, const char *tag, ns1__CTestRun **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestRun **)soap_malloc(soap, sizeof(ns1__CTestRun *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTestRun *)soap_instantiate_ns1__CTestRun(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTestRun ** p = (ns1__CTestRun **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTestRun, sizeof(ns1__CTestRun), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTestRun(struct soap *soap, ns1__CTestRun *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTestRun);
	if (soap_out_PointerTons1__CTestRun(soap, tag?tag:"ns1:CTestRun", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestRun ** SOAP_FMAC4 soap_get_PointerTons1__CTestRun(struct soap *soap, ns1__CTestRun **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTestRun(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTestCase(struct soap *soap, ns1__CTestCase *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTestCase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTestCase(struct soap *soap, const char *tag, int id, ns1__CTestCase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTestCase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTestCase ** SOAP_FMAC4 soap_in_PointerTons1__CTestCase(struct soap *soap, const char *tag, ns1__CTestCase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestCase **)soap_malloc(soap, sizeof(ns1__CTestCase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTestCase *)soap_instantiate_ns1__CTestCase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTestCase ** p = (ns1__CTestCase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTestCase, sizeof(ns1__CTestCase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTestCase(struct soap *soap, ns1__CTestCase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTestCase);
	if (soap_out_PointerTons1__CTestCase(soap, tag?tag:"ns1:CTestCase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestCase ** SOAP_FMAC4 soap_get_PointerTons1__CTestCase(struct soap *soap, ns1__CTestCase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTestCase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCLink(struct soap *soap, ArrayOfCLink *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCLink(struct soap *soap, const char *tag, int id, ArrayOfCLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCLink ** SOAP_FMAC4 soap_in_PointerToArrayOfCLink(struct soap *soap, const char *tag, ArrayOfCLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCLink **)soap_malloc(soap, sizeof(ArrayOfCLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCLink *)soap_instantiate_ArrayOfCLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCLink ** p = (ArrayOfCLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCLink, sizeof(ArrayOfCLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCLink(struct soap *soap, ArrayOfCLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCLink);
	if (soap_out_PointerToArrayOfCLink(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCLink ** SOAP_FMAC4 soap_get_PointerToArrayOfCLink(struct soap *soap, ArrayOfCLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CUser(struct soap *soap, ns1__CUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CUser(struct soap *soap, const char *tag, int id, ns1__CUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CUser ** SOAP_FMAC4 soap_in_PointerTons1__CUser(struct soap *soap, const char *tag, ns1__CUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CUser **)soap_malloc(soap, sizeof(ns1__CUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CUser *)soap_instantiate_ns1__CUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CUser ** p = (ns1__CUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CUser, sizeof(ns1__CUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CUser(struct soap *soap, ns1__CUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CUser);
	if (soap_out_PointerTons1__CUser(soap, tag?tag:"ns1:CUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CUser ** SOAP_FMAC4 soap_get_PointerTons1__CUser(struct soap *soap, ns1__CUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCUserLicense(struct soap *soap, ArrayOfCUserLicense *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCUserLicense(struct soap *soap, const char *tag, int id, ArrayOfCUserLicense *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCUserLicense);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCUserLicense ** SOAP_FMAC4 soap_in_PointerToArrayOfCUserLicense(struct soap *soap, const char *tag, ArrayOfCUserLicense **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCUserLicense **)soap_malloc(soap, sizeof(ArrayOfCUserLicense *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCUserLicense *)soap_instantiate_ArrayOfCUserLicense(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCUserLicense ** p = (ArrayOfCUserLicense **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCUserLicense, sizeof(ArrayOfCUserLicense), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCUserLicense(struct soap *soap, ArrayOfCUserLicense *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCUserLicense);
	if (soap_out_PointerToArrayOfCUserLicense(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCUserLicense ** SOAP_FMAC4 soap_get_PointerToArrayOfCUserLicense(struct soap *soap, ArrayOfCUserLicense **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCGlobalUser(struct soap *soap, ArrayOfCGlobalUser *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCGlobalUser(struct soap *soap, const char *tag, int id, ArrayOfCGlobalUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCGlobalUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCGlobalUser ** SOAP_FMAC4 soap_in_PointerToArrayOfCGlobalUser(struct soap *soap, const char *tag, ArrayOfCGlobalUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCGlobalUser **)soap_malloc(soap, sizeof(ArrayOfCGlobalUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCGlobalUser *)soap_instantiate_ArrayOfCGlobalUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCGlobalUser ** p = (ArrayOfCGlobalUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCGlobalUser, sizeof(ArrayOfCGlobalUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCGlobalUser(struct soap *soap, ArrayOfCGlobalUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCGlobalUser);
	if (soap_out_PointerToArrayOfCGlobalUser(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCGlobalUser ** SOAP_FMAC4 soap_get_PointerToArrayOfCGlobalUser(struct soap *soap, ArrayOfCGlobalUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTask(struct soap *soap, ns1__CTask *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTask))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTask(struct soap *soap, const char *tag, int id, ns1__CTask *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTask);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTask ** SOAP_FMAC4 soap_in_PointerTons1__CTask(struct soap *soap, const char *tag, ns1__CTask **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTask **)soap_malloc(soap, sizeof(ns1__CTask *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTask *)soap_instantiate_ns1__CTask(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTask ** p = (ns1__CTask **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTask, sizeof(ns1__CTask), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTask(struct soap *soap, ns1__CTask *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTask);
	if (soap_out_PointerTons1__CTask(soap, tag?tag:"ns1:CTask", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTask ** SOAP_FMAC4 soap_get_PointerTons1__CTask(struct soap *soap, ns1__CTask **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CDefect(struct soap *soap, ns1__CDefect *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CDefect))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CDefect(struct soap *soap, const char *tag, int id, ns1__CDefect *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CDefect);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CDefect ** SOAP_FMAC4 soap_in_PointerTons1__CDefect(struct soap *soap, const char *tag, ns1__CDefect **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDefect **)soap_malloc(soap, sizeof(ns1__CDefect *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CDefect *)soap_instantiate_ns1__CDefect(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CDefect ** p = (ns1__CDefect **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CDefect, sizeof(ns1__CDefect), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CDefect(struct soap *soap, ns1__CDefect *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CDefect);
	if (soap_out_PointerTons1__CDefect(soap, tag?tag:"ns1:CDefect", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDefect ** SOAP_FMAC4 soap_get_PointerTons1__CDefect(struct soap *soap, ns1__CDefect **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CDefect(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCDefectEventDefinition(struct soap *soap, ArrayOfCDefectEventDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, int id, ArrayOfCDefectEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCDefectEventDefinition ** SOAP_FMAC4 soap_in_PointerToArrayOfCDefectEventDefinition(struct soap *soap, const char *tag, ArrayOfCDefectEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCDefectEventDefinition **)soap_malloc(soap, sizeof(ArrayOfCDefectEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCDefectEventDefinition *)soap_instantiate_ArrayOfCDefectEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCDefectEventDefinition ** p = (ArrayOfCDefectEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCDefectEventDefinition, sizeof(ArrayOfCDefectEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCDefectEventDefinition(struct soap *soap, ArrayOfCDefectEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCDefectEventDefinition);
	if (soap_out_PointerToArrayOfCDefectEventDefinition(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCDefectEventDefinition ** SOAP_FMAC4 soap_get_PointerToArrayOfCDefectEventDefinition(struct soap *soap, ArrayOfCDefectEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCEventDefinition(struct soap *soap, ArrayOfCEventDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCEventDefinition(struct soap *soap, const char *tag, int id, ArrayOfCEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCEventDefinition ** SOAP_FMAC4 soap_in_PointerToArrayOfCEventDefinition(struct soap *soap, const char *tag, ArrayOfCEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCEventDefinition **)soap_malloc(soap, sizeof(ArrayOfCEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCEventDefinition *)soap_instantiate_ArrayOfCEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCEventDefinition ** p = (ArrayOfCEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCEventDefinition, sizeof(ArrayOfCEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCEventDefinition(struct soap *soap, ArrayOfCEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCEventDefinition);
	if (soap_out_PointerToArrayOfCEventDefinition(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCEventDefinition ** SOAP_FMAC4 soap_get_PointerToArrayOfCEventDefinition(struct soap *soap, ArrayOfCEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CReportRunResults(struct soap *soap, ns1__CReportRunResults *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CReportRunResults))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CReportRunResults(struct soap *soap, const char *tag, int id, ns1__CReportRunResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CReportRunResults);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CReportRunResults ** SOAP_FMAC4 soap_in_PointerTons1__CReportRunResults(struct soap *soap, const char *tag, ns1__CReportRunResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CReportRunResults **)soap_malloc(soap, sizeof(ns1__CReportRunResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CReportRunResults *)soap_instantiate_ns1__CReportRunResults(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CReportRunResults ** p = (ns1__CReportRunResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CReportRunResults, sizeof(ns1__CReportRunResults), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CReportRunResults(struct soap *soap, ns1__CReportRunResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CReportRunResults);
	if (soap_out_PointerTons1__CReportRunResults(soap, tag?tag:"ns1:CReportRunResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CReportRunResults ** SOAP_FMAC4 soap_get_PointerTons1__CReportRunResults(struct soap *soap, ns1__CReportRunResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CReportRunResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CRecordListSoap(struct soap *soap, ns1__CRecordListSoap *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CRecordListSoap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CRecordListSoap(struct soap *soap, const char *tag, int id, ns1__CRecordListSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CRecordListSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CRecordListSoap ** SOAP_FMAC4 soap_in_PointerTons1__CRecordListSoap(struct soap *soap, const char *tag, ns1__CRecordListSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRecordListSoap **)soap_malloc(soap, sizeof(ns1__CRecordListSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CRecordListSoap *)soap_instantiate_ns1__CRecordListSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CRecordListSoap ** p = (ns1__CRecordListSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CRecordListSoap, sizeof(ns1__CRecordListSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CRecordListSoap(struct soap *soap, ns1__CRecordListSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CRecordListSoap);
	if (soap_out_PointerTons1__CRecordListSoap(soap, tag?tag:"ns1:CRecordListSoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRecordListSoap ** SOAP_FMAC4 soap_get_PointerTons1__CRecordListSoap(struct soap *soap, ns1__CRecordListSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CRecordListSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFilter(struct soap *soap, ArrayOfCFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFilter(struct soap *soap, const char *tag, int id, ArrayOfCFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFilter ** SOAP_FMAC4 soap_in_PointerToArrayOfCFilter(struct soap *soap, const char *tag, ArrayOfCFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFilter **)soap_malloc(soap, sizeof(ArrayOfCFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFilter *)soap_instantiate_ArrayOfCFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFilter ** p = (ArrayOfCFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFilter, sizeof(ArrayOfCFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFilter(struct soap *soap, ArrayOfCFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFilter);
	if (soap_out_PointerToArrayOfCFilter(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFilter ** SOAP_FMAC4 soap_get_PointerToArrayOfCFilter(struct soap *soap, ArrayOfCFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTableField(struct soap *soap, ArrayOfCTableField *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTableField(struct soap *soap, const char *tag, int id, ArrayOfCTableField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTableField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTableField ** SOAP_FMAC4 soap_in_PointerToArrayOfCTableField(struct soap *soap, const char *tag, ArrayOfCTableField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTableField **)soap_malloc(soap, sizeof(ArrayOfCTableField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTableField *)soap_instantiate_ArrayOfCTableField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCTableField ** p = (ArrayOfCTableField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTableField, sizeof(ArrayOfCTableField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTableField(struct soap *soap, ArrayOfCTableField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTableField);
	if (soap_out_PointerToArrayOfCTableField(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCTableField ** SOAP_FMAC4 soap_get_PointerToArrayOfCTableField(struct soap *soap, ArrayOfCTableField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCDatabaseTable(struct soap *soap, ArrayOfCDatabaseTable *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCDatabaseTable(struct soap *soap, const char *tag, int id, ArrayOfCDatabaseTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDatabaseTable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCDatabaseTable ** SOAP_FMAC4 soap_in_PointerToArrayOfCDatabaseTable(struct soap *soap, const char *tag, ArrayOfCDatabaseTable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCDatabaseTable **)soap_malloc(soap, sizeof(ArrayOfCDatabaseTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCDatabaseTable *)soap_instantiate_ArrayOfCDatabaseTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCDatabaseTable ** p = (ArrayOfCDatabaseTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCDatabaseTable, sizeof(ArrayOfCDatabaseTable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCDatabaseTable(struct soap *soap, ArrayOfCDatabaseTable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCDatabaseTable);
	if (soap_out_PointerToArrayOfCDatabaseTable(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCDatabaseTable ** SOAP_FMAC4 soap_get_PointerToArrayOfCDatabaseTable(struct soap *soap, ArrayOfCDatabaseTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCProject(struct soap *soap, ArrayOfCProject *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCProject(struct soap *soap, const char *tag, int id, ArrayOfCProject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCProject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCProject ** SOAP_FMAC4 soap_in_PointerToArrayOfCProject(struct soap *soap, const char *tag, ArrayOfCProject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCProject **)soap_malloc(soap, sizeof(ArrayOfCProject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCProject *)soap_instantiate_ArrayOfCProject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCProject ** p = (ArrayOfCProject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCProject, sizeof(ArrayOfCProject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCProject(struct soap *soap, ArrayOfCProject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCProject);
	if (soap_out_PointerToArrayOfCProject(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCProject ** SOAP_FMAC4 soap_get_PointerToArrayOfCProject(struct soap *soap, ArrayOfCProject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCDatabase(struct soap *soap, ArrayOfCDatabase *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCDatabase(struct soap *soap, const char *tag, int id, ArrayOfCDatabase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCDatabase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCDatabase ** SOAP_FMAC4 soap_in_PointerToArrayOfCDatabase(struct soap *soap, const char *tag, ArrayOfCDatabase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCDatabase **)soap_malloc(soap, sizeof(ArrayOfCDatabase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCDatabase *)soap_instantiate_ArrayOfCDatabase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCDatabase ** p = (ArrayOfCDatabase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCDatabase, sizeof(ArrayOfCDatabase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCDatabase(struct soap *soap, ArrayOfCDatabase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCDatabase);
	if (soap_out_PointerToArrayOfCDatabase(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCDatabase ** SOAP_FMAC4 soap_get_PointerToArrayOfCDatabase(struct soap *soap, ArrayOfCDatabase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCSnapshotInfo(struct soap *soap, ArrayOfCSnapshotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCSnapshotInfo(struct soap *soap, const char *tag, int id, ArrayOfCSnapshotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCSnapshotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCSnapshotInfo ** SOAP_FMAC4 soap_in_PointerToArrayOfCSnapshotInfo(struct soap *soap, const char *tag, ArrayOfCSnapshotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCSnapshotInfo **)soap_malloc(soap, sizeof(ArrayOfCSnapshotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCSnapshotInfo *)soap_instantiate_ArrayOfCSnapshotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCSnapshotInfo ** p = (ArrayOfCSnapshotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCSnapshotInfo, sizeof(ArrayOfCSnapshotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCSnapshotInfo(struct soap *soap, ArrayOfCSnapshotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCSnapshotInfo);
	if (soap_out_PointerToArrayOfCSnapshotInfo(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCSnapshotInfo ** SOAP_FMAC4 soap_get_PointerToArrayOfCSnapshotInfo(struct soap *soap, ArrayOfCSnapshotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCSnapshotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCVersionInfo(struct soap *soap, ArrayOfCVersionInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCVersionInfo(struct soap *soap, const char *tag, int id, ArrayOfCVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCVersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCVersionInfo ** SOAP_FMAC4 soap_in_PointerToArrayOfCVersionInfo(struct soap *soap, const char *tag, ArrayOfCVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCVersionInfo **)soap_malloc(soap, sizeof(ArrayOfCVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCVersionInfo *)soap_instantiate_ArrayOfCVersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCVersionInfo ** p = (ArrayOfCVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCVersionInfo, sizeof(ArrayOfCVersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCVersionInfo(struct soap *soap, ArrayOfCVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCVersionInfo);
	if (soap_out_PointerToArrayOfCVersionInfo(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCVersionInfo ** SOAP_FMAC4 soap_get_PointerToArrayOfCVersionInfo(struct soap *soap, ArrayOfCVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CScheduleInfo(struct soap *soap, ns1__CScheduleInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CScheduleInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CScheduleInfo(struct soap *soap, const char *tag, int id, ns1__CScheduleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CScheduleInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CScheduleInfo ** SOAP_FMAC4 soap_in_PointerTons1__CScheduleInfo(struct soap *soap, const char *tag, ns1__CScheduleInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CScheduleInfo **)soap_malloc(soap, sizeof(ns1__CScheduleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CScheduleInfo *)soap_instantiate_ns1__CScheduleInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CScheduleInfo ** p = (ns1__CScheduleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CScheduleInfo, sizeof(ns1__CScheduleInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CScheduleInfo(struct soap *soap, ns1__CScheduleInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CScheduleInfo);
	if (soap_out_PointerTons1__CScheduleInfo(soap, tag?tag:"ns1:CScheduleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CScheduleInfo ** SOAP_FMAC4 soap_get_PointerTons1__CScheduleInfo(struct soap *soap, ns1__CScheduleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CScheduleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTestCaseVariantField(struct soap *soap, ArrayOfCTestCaseVariantField *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, int id, ArrayOfCTestCaseVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTestCaseVariantField ** SOAP_FMAC4 soap_in_PointerToArrayOfCTestCaseVariantField(struct soap *soap, const char *tag, ArrayOfCTestCaseVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTestCaseVariantField **)soap_malloc(soap, sizeof(ArrayOfCTestCaseVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTestCaseVariantField *)soap_instantiate_ArrayOfCTestCaseVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCTestCaseVariantField ** p = (ArrayOfCTestCaseVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTestCaseVariantField, sizeof(ArrayOfCTestCaseVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTestCaseVariantField(struct soap *soap, ArrayOfCTestCaseVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTestCaseVariantField);
	if (soap_out_PointerToArrayOfCTestCaseVariantField(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCTestCaseVariantField ** SOAP_FMAC4 soap_get_PointerToArrayOfCTestCaseVariantField(struct soap *soap, ArrayOfCTestCaseVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCLinkHistoryItem(struct soap *soap, ArrayOfCLinkHistoryItem *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, int id, ArrayOfCLinkHistoryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCLinkHistoryItem ** SOAP_FMAC4 soap_in_PointerToArrayOfCLinkHistoryItem(struct soap *soap, const char *tag, ArrayOfCLinkHistoryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCLinkHistoryItem **)soap_malloc(soap, sizeof(ArrayOfCLinkHistoryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCLinkHistoryItem *)soap_instantiate_ArrayOfCLinkHistoryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCLinkHistoryItem ** p = (ArrayOfCLinkHistoryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCLinkHistoryItem, sizeof(ArrayOfCLinkHistoryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCLinkHistoryItem(struct soap *soap, ArrayOfCLinkHistoryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCLinkHistoryItem);
	if (soap_out_PointerToArrayOfCLinkHistoryItem(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCLinkHistoryItem ** SOAP_FMAC4 soap_get_PointerToArrayOfCLinkHistoryItem(struct soap *soap, ArrayOfCLinkHistoryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCLinkedItem(struct soap *soap, ArrayOfCLinkedItem *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCLinkedItem(struct soap *soap, const char *tag, int id, ArrayOfCLinkedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCLinkedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCLinkedItem ** SOAP_FMAC4 soap_in_PointerToArrayOfCLinkedItem(struct soap *soap, const char *tag, ArrayOfCLinkedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCLinkedItem **)soap_malloc(soap, sizeof(ArrayOfCLinkedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCLinkedItem *)soap_instantiate_ArrayOfCLinkedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCLinkedItem ** p = (ArrayOfCLinkedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCLinkedItem, sizeof(ArrayOfCLinkedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCLinkedItem(struct soap *soap, ArrayOfCLinkedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCLinkedItem);
	if (soap_out_PointerToArrayOfCLinkedItem(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCLinkedItem ** SOAP_FMAC4 soap_get_PointerToArrayOfCLinkedItem(struct soap *soap, ArrayOfCLinkedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PhoneNumber(struct soap *soap, ns1__PhoneNumber *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PhoneNumber))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PhoneNumber(struct soap *soap, const char *tag, int id, ns1__PhoneNumber *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PhoneNumber);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PhoneNumber ** SOAP_FMAC4 soap_in_PointerTons1__PhoneNumber(struct soap *soap, const char *tag, ns1__PhoneNumber **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PhoneNumber **)soap_malloc(soap, sizeof(ns1__PhoneNumber *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PhoneNumber *)soap_instantiate_ns1__PhoneNumber(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__PhoneNumber ** p = (ns1__PhoneNumber **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PhoneNumber, sizeof(ns1__PhoneNumber), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PhoneNumber(struct soap *soap, ns1__PhoneNumber *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PhoneNumber);
	if (soap_out_PointerTons1__PhoneNumber(soap, tag?tag:"ns1:PhoneNumber", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__PhoneNumber ** SOAP_FMAC4 soap_get_PointerTons1__PhoneNumber(struct soap *soap, ns1__PhoneNumber **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PhoneNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCSCCFileRecord(struct soap *soap, ArrayOfCSCCFileRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCSCCFileRecord(struct soap *soap, const char *tag, int id, ArrayOfCSCCFileRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCSCCFileRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCSCCFileRecord ** SOAP_FMAC4 soap_in_PointerToArrayOfCSCCFileRecord(struct soap *soap, const char *tag, ArrayOfCSCCFileRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCSCCFileRecord **)soap_malloc(soap, sizeof(ArrayOfCSCCFileRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCSCCFileRecord *)soap_instantiate_ArrayOfCSCCFileRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCSCCFileRecord ** p = (ArrayOfCSCCFileRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCSCCFileRecord, sizeof(ArrayOfCSCCFileRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCSCCFileRecord(struct soap *soap, ArrayOfCSCCFileRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCSCCFileRecord);
	if (soap_out_PointerToArrayOfCSCCFileRecord(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCSCCFileRecord ** SOAP_FMAC4 soap_get_PointerToArrayOfCSCCFileRecord(struct soap *soap, ArrayOfCSCCFileRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCEvent(struct soap *soap, ArrayOfCEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCEvent(struct soap *soap, const char *tag, int id, ArrayOfCEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCEvent ** SOAP_FMAC4 soap_in_PointerToArrayOfCEvent(struct soap *soap, const char *tag, ArrayOfCEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCEvent **)soap_malloc(soap, sizeof(ArrayOfCEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCEvent *)soap_instantiate_ArrayOfCEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCEvent ** p = (ArrayOfCEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCEvent, sizeof(ArrayOfCEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCEvent(struct soap *soap, ArrayOfCEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCEvent);
	if (soap_out_PointerToArrayOfCEvent(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCEvent ** SOAP_FMAC4 soap_get_PointerToArrayOfCEvent(struct soap *soap, ArrayOfCEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCReportedByRecord(struct soap *soap, ArrayOfCReportedByRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCReportedByRecord(struct soap *soap, const char *tag, int id, ArrayOfCReportedByRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCReportedByRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCReportedByRecord ** SOAP_FMAC4 soap_in_PointerToArrayOfCReportedByRecord(struct soap *soap, const char *tag, ArrayOfCReportedByRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCReportedByRecord **)soap_malloc(soap, sizeof(ArrayOfCReportedByRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCReportedByRecord *)soap_instantiate_ArrayOfCReportedByRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCReportedByRecord ** p = (ArrayOfCReportedByRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCReportedByRecord, sizeof(ArrayOfCReportedByRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCReportedByRecord(struct soap *soap, ArrayOfCReportedByRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCReportedByRecord);
	if (soap_out_PointerToArrayOfCReportedByRecord(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCReportedByRecord ** SOAP_FMAC4 soap_get_PointerToArrayOfCReportedByRecord(struct soap *soap, ArrayOfCReportedByRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTreeNodeSoap))
		soap_serialize_PointerTons1__CTreeNodeSoap(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTreeNodeSoap(struct soap *soap, const char *tag, int id, ns1__CTreeNodeSoap **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTreeNodeSoap);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTreeNodeSoap(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTreeNodeSoap *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTreeNodeSoap(struct soap *soap, const char *tag, ns1__CTreeNodeSoap ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTreeNodeSoap ***)soap_malloc(soap, sizeof(ns1__CTreeNodeSoap **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTreeNodeSoap(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTreeNodeSoap ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTreeNodeSoap, sizeof(ns1__CTreeNodeSoap *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTreeNodeSoap);
	if (soap_out_PointerToPointerTons1__CTreeNodeSoap(soap, tag?tag:"ns1:CTreeNodeSoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTreeNodeSoap *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTreeNodeSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTreeNodeSoap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTreeNodeSoap(struct soap *soap, const char *tag, int id, ns1__CTreeNodeSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTreeNodeSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTreeNodeSoap ** SOAP_FMAC4 soap_in_PointerTons1__CTreeNodeSoap(struct soap *soap, const char *tag, ns1__CTreeNodeSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTreeNodeSoap **)soap_malloc(soap, sizeof(ns1__CTreeNodeSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTreeNodeSoap *)soap_instantiate_ns1__CTreeNodeSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTreeNodeSoap ** p = (ns1__CTreeNodeSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTreeNodeSoap, sizeof(ns1__CTreeNodeSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTreeNodeSoap);
	if (soap_out_PointerTons1__CTreeNodeSoap(soap, tag?tag:"ns1:CTreeNodeSoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTreeNodeSoap ** SOAP_FMAC4 soap_get_PointerTons1__CTreeNodeSoap(struct soap *soap, ns1__CTreeNodeSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTreeNodeSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CSnapshotInfo))
		soap_serialize_PointerTons1__CSnapshotInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CSnapshotInfo(struct soap *soap, const char *tag, int id, ns1__CSnapshotInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CSnapshotInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CSnapshotInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CSnapshotInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CSnapshotInfo(struct soap *soap, const char *tag, ns1__CSnapshotInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CSnapshotInfo ***)soap_malloc(soap, sizeof(ns1__CSnapshotInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CSnapshotInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CSnapshotInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CSnapshotInfo, sizeof(ns1__CSnapshotInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CSnapshotInfo);
	if (soap_out_PointerToPointerTons1__CSnapshotInfo(soap, tag?tag:"ns1:CSnapshotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CSnapshotInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CSnapshotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CSnapshotInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CSnapshotInfo(struct soap *soap, const char *tag, int id, ns1__CSnapshotInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CSnapshotInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CSnapshotInfo ** SOAP_FMAC4 soap_in_PointerTons1__CSnapshotInfo(struct soap *soap, const char *tag, ns1__CSnapshotInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CSnapshotInfo **)soap_malloc(soap, sizeof(ns1__CSnapshotInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CSnapshotInfo *)soap_instantiate_ns1__CSnapshotInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CSnapshotInfo ** p = (ns1__CSnapshotInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CSnapshotInfo, sizeof(ns1__CSnapshotInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CSnapshotInfo);
	if (soap_out_PointerTons1__CSnapshotInfo(soap, tag?tag:"ns1:CSnapshotInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CSnapshotInfo ** SOAP_FMAC4 soap_get_PointerTons1__CSnapshotInfo(struct soap *soap, ns1__CSnapshotInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CSnapshotInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CVersionInfo))
		soap_serialize_PointerTons1__CVersionInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CVersionInfo(struct soap *soap, const char *tag, int id, ns1__CVersionInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CVersionInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CVersionInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CVersionInfo *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CVersionInfo(struct soap *soap, const char *tag, ns1__CVersionInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CVersionInfo ***)soap_malloc(soap, sizeof(ns1__CVersionInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CVersionInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CVersionInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CVersionInfo, sizeof(ns1__CVersionInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CVersionInfo);
	if (soap_out_PointerToPointerTons1__CVersionInfo(soap, tag?tag:"ns1:CVersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CVersionInfo *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CVersionInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CVersionInfo(struct soap *soap, const char *tag, int id, ns1__CVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CVersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CVersionInfo ** SOAP_FMAC4 soap_in_PointerTons1__CVersionInfo(struct soap *soap, const char *tag, ns1__CVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CVersionInfo **)soap_malloc(soap, sizeof(ns1__CVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CVersionInfo *)soap_instantiate_ns1__CVersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CVersionInfo ** p = (ns1__CVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CVersionInfo, sizeof(ns1__CVersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CVersionInfo);
	if (soap_out_PointerTons1__CVersionInfo(soap, tag?tag:"ns1:CVersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CVersionInfo ** SOAP_FMAC4 soap_get_PointerTons1__CVersionInfo(struct soap *soap, ns1__CVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFolderItem))
		soap_serialize_PointerTons1__CFolderItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFolderItem(struct soap *soap, const char *tag, int id, ns1__CFolderItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFolderItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFolderItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFolderItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFolderItem(struct soap *soap, const char *tag, ns1__CFolderItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolderItem ***)soap_malloc(soap, sizeof(ns1__CFolderItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFolderItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFolderItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFolderItem, sizeof(ns1__CFolderItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFolderItem);
	if (soap_out_PointerToPointerTons1__CFolderItem(soap, tag?tag:"ns1:CFolderItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolderItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFolderItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFolderItem(struct soap *soap, const char *tag, int id, ns1__CFolderItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFolderItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFolderItem ** SOAP_FMAC4 soap_in_PointerTons1__CFolderItem(struct soap *soap, const char *tag, ns1__CFolderItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolderItem **)soap_malloc(soap, sizeof(ns1__CFolderItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFolderItem *)soap_instantiate_ns1__CFolderItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFolderItem ** p = (ns1__CFolderItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFolderItem, sizeof(ns1__CFolderItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFolderItem);
	if (soap_out_PointerTons1__CFolderItem(soap, tag?tag:"ns1:CFolderItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolderItem ** SOAP_FMAC4 soap_get_PointerTons1__CFolderItem(struct soap *soap, ns1__CFolderItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFolderItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFolder(struct soap *soap, ns1__CFolder **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFolder))
		soap_serialize_PointerTons1__CFolder(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFolder(struct soap *soap, const char *tag, int id, ns1__CFolder **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFolder);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFolder(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFolder *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFolder(struct soap *soap, const char *tag, ns1__CFolder ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolder ***)soap_malloc(soap, sizeof(ns1__CFolder **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFolder(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFolder ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFolder, sizeof(ns1__CFolder *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFolder(struct soap *soap, ns1__CFolder **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFolder);
	if (soap_out_PointerToPointerTons1__CFolder(soap, tag?tag:"ns1:CFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolder *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFolder(struct soap *soap, ns1__CFolder ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFolder(struct soap *soap, ns1__CFolder *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFolder))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFolder(struct soap *soap, const char *tag, int id, ns1__CFolder *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFolder);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFolder ** SOAP_FMAC4 soap_in_PointerTons1__CFolder(struct soap *soap, const char *tag, ns1__CFolder **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolder **)soap_malloc(soap, sizeof(ns1__CFolder *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFolder *)soap_instantiate_ns1__CFolder(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFolder ** p = (ns1__CFolder **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFolder, sizeof(ns1__CFolder), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFolder(struct soap *soap, ns1__CFolder *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFolder);
	if (soap_out_PointerTons1__CFolder(soap, tag?tag:"ns1:CFolder", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolder ** SOAP_FMAC4 soap_get_PointerTons1__CFolder(struct soap *soap, ns1__CFolder **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFolderType(struct soap *soap, ns1__CFolderType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFolderType))
		soap_serialize_PointerTons1__CFolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFolderType(struct soap *soap, const char *tag, int id, ns1__CFolderType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFolderType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFolderType *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFolderType(struct soap *soap, const char *tag, ns1__CFolderType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolderType ***)soap_malloc(soap, sizeof(ns1__CFolderType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFolderType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFolderType, sizeof(ns1__CFolderType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFolderType(struct soap *soap, ns1__CFolderType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFolderType);
	if (soap_out_PointerToPointerTons1__CFolderType(soap, tag?tag:"ns1:CFolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolderType *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFolderType(struct soap *soap, ns1__CFolderType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFolderType(struct soap *soap, ns1__CFolderType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFolderType(struct soap *soap, const char *tag, int id, ns1__CFolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFolderType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFolderType ** SOAP_FMAC4 soap_in_PointerTons1__CFolderType(struct soap *soap, const char *tag, ns1__CFolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFolderType **)soap_malloc(soap, sizeof(ns1__CFolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFolderType *)soap_instantiate_ns1__CFolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFolderType ** p = (ns1__CFolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFolderType, sizeof(ns1__CFolderType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFolderType(struct soap *soap, ns1__CFolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFolderType);
	if (soap_out_PointerTons1__CFolderType(soap, tag?tag:"ns1:CFolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFolderType ** SOAP_FMAC4 soap_get_PointerTons1__CFolderType(struct soap *soap, ns1__CFolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CItemToTrack))
		soap_serialize_PointerTons1__CItemToTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CItemToTrack(struct soap *soap, const char *tag, int id, ns1__CItemToTrack **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CItemToTrack);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CItemToTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CItemToTrack *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CItemToTrack(struct soap *soap, const char *tag, ns1__CItemToTrack ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CItemToTrack ***)soap_malloc(soap, sizeof(ns1__CItemToTrack **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CItemToTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CItemToTrack ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CItemToTrack, sizeof(ns1__CItemToTrack *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CItemToTrack);
	if (soap_out_PointerToPointerTons1__CItemToTrack(soap, tag?tag:"ns1:CItemToTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CItemToTrack *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CItemToTrack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CItemToTrack(struct soap *soap, const char *tag, int id, ns1__CItemToTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CItemToTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CItemToTrack ** SOAP_FMAC4 soap_in_PointerTons1__CItemToTrack(struct soap *soap, const char *tag, ns1__CItemToTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CItemToTrack **)soap_malloc(soap, sizeof(ns1__CItemToTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CItemToTrack *)soap_instantiate_ns1__CItemToTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CItemToTrack ** p = (ns1__CItemToTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CItemToTrack, sizeof(ns1__CItemToTrack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CItemToTrack);
	if (soap_out_PointerTons1__CItemToTrack(soap, tag?tag:"ns1:CItemToTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CItemToTrack ** SOAP_FMAC4 soap_get_PointerTons1__CItemToTrack(struct soap *soap, ns1__CItemToTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CItemToTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CLink(struct soap *soap, ns1__CLink **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CLink))
		soap_serialize_PointerTons1__CLink(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CLink(struct soap *soap, const char *tag, int id, ns1__CLink **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CLink);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CLink *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CLink(struct soap *soap, const char *tag, ns1__CLink ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLink ***)soap_malloc(soap, sizeof(ns1__CLink **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CLink ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CLink, sizeof(ns1__CLink *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CLink(struct soap *soap, ns1__CLink **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CLink);
	if (soap_out_PointerToPointerTons1__CLink(soap, tag?tag:"ns1:CLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLink *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CLink(struct soap *soap, ns1__CLink ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CLink(struct soap *soap, ns1__CLink *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CLink(struct soap *soap, const char *tag, int id, ns1__CLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CLink ** SOAP_FMAC4 soap_in_PointerTons1__CLink(struct soap *soap, const char *tag, ns1__CLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLink **)soap_malloc(soap, sizeof(ns1__CLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CLink *)soap_instantiate_ns1__CLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CLink ** p = (ns1__CLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CLink, sizeof(ns1__CLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CLink(struct soap *soap, ns1__CLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CLink);
	if (soap_out_PointerTons1__CLink(soap, tag?tag:"ns1:CLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLink ** SOAP_FMAC4 soap_get_PointerTons1__CLink(struct soap *soap, ns1__CLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CLinkHistoryItem))
		soap_serialize_PointerTons1__CLinkHistoryItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, ns1__CLinkHistoryItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CLinkHistoryItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CLinkHistoryItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CLinkHistoryItem(struct soap *soap, const char *tag, ns1__CLinkHistoryItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLinkHistoryItem ***)soap_malloc(soap, sizeof(ns1__CLinkHistoryItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CLinkHistoryItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CLinkHistoryItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CLinkHistoryItem, sizeof(ns1__CLinkHistoryItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CLinkHistoryItem);
	if (soap_out_PointerToPointerTons1__CLinkHistoryItem(soap, tag?tag:"ns1:CLinkHistoryItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLinkHistoryItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CLinkHistoryItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CLinkHistoryItem(struct soap *soap, const char *tag, int id, ns1__CLinkHistoryItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CLinkHistoryItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CLinkHistoryItem ** SOAP_FMAC4 soap_in_PointerTons1__CLinkHistoryItem(struct soap *soap, const char *tag, ns1__CLinkHistoryItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLinkHistoryItem **)soap_malloc(soap, sizeof(ns1__CLinkHistoryItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CLinkHistoryItem *)soap_instantiate_ns1__CLinkHistoryItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CLinkHistoryItem ** p = (ns1__CLinkHistoryItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CLinkHistoryItem, sizeof(ns1__CLinkHistoryItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CLinkHistoryItem);
	if (soap_out_PointerTons1__CLinkHistoryItem(soap, tag?tag:"ns1:CLinkHistoryItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLinkHistoryItem ** SOAP_FMAC4 soap_get_PointerTons1__CLinkHistoryItem(struct soap *soap, ns1__CLinkHistoryItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CLinkHistoryItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CLinkedItem))
		soap_serialize_PointerTons1__CLinkedItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CLinkedItem(struct soap *soap, const char *tag, int id, ns1__CLinkedItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CLinkedItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CLinkedItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CLinkedItem *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CLinkedItem(struct soap *soap, const char *tag, ns1__CLinkedItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLinkedItem ***)soap_malloc(soap, sizeof(ns1__CLinkedItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CLinkedItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CLinkedItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CLinkedItem, sizeof(ns1__CLinkedItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CLinkedItem);
	if (soap_out_PointerToPointerTons1__CLinkedItem(soap, tag?tag:"ns1:CLinkedItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLinkedItem *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CLinkedItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CLinkedItem(struct soap *soap, const char *tag, int id, ns1__CLinkedItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CLinkedItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CLinkedItem ** SOAP_FMAC4 soap_in_PointerTons1__CLinkedItem(struct soap *soap, const char *tag, ns1__CLinkedItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CLinkedItem **)soap_malloc(soap, sizeof(ns1__CLinkedItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CLinkedItem *)soap_instantiate_ns1__CLinkedItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CLinkedItem ** p = (ns1__CLinkedItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CLinkedItem, sizeof(ns1__CLinkedItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CLinkedItem);
	if (soap_out_PointerTons1__CLinkedItem(soap, tag?tag:"ns1:CLinkedItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CLinkedItem ** SOAP_FMAC4 soap_get_PointerTons1__CLinkedItem(struct soap *soap, ns1__CLinkedItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CLinkedItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CUserLicense))
		soap_serialize_PointerTons1__CUserLicense(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CUserLicense(struct soap *soap, const char *tag, int id, ns1__CUserLicense **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CUserLicense);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CUserLicense(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CUserLicense *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CUserLicense(struct soap *soap, const char *tag, ns1__CUserLicense ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CUserLicense ***)soap_malloc(soap, sizeof(ns1__CUserLicense **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CUserLicense(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CUserLicense ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CUserLicense, sizeof(ns1__CUserLicense *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CUserLicense);
	if (soap_out_PointerToPointerTons1__CUserLicense(soap, tag?tag:"ns1:CUserLicense", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CUserLicense *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CUserLicense))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CUserLicense(struct soap *soap, const char *tag, int id, ns1__CUserLicense *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CUserLicense);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CUserLicense ** SOAP_FMAC4 soap_in_PointerTons1__CUserLicense(struct soap *soap, const char *tag, ns1__CUserLicense **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CUserLicense **)soap_malloc(soap, sizeof(ns1__CUserLicense *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CUserLicense *)soap_instantiate_ns1__CUserLicense(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CUserLicense ** p = (ns1__CUserLicense **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CUserLicense, sizeof(ns1__CUserLicense), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CUserLicense);
	if (soap_out_PointerTons1__CUserLicense(soap, tag?tag:"ns1:CUserLicense", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CUserLicense ** SOAP_FMAC4 soap_get_PointerTons1__CUserLicense(struct soap *soap, ns1__CUserLicense **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CUserLicense(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CGlobalUser))
		soap_serialize_PointerTons1__CGlobalUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CGlobalUser(struct soap *soap, const char *tag, int id, ns1__CGlobalUser **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CGlobalUser);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CGlobalUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CGlobalUser *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CGlobalUser(struct soap *soap, const char *tag, ns1__CGlobalUser ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CGlobalUser ***)soap_malloc(soap, sizeof(ns1__CGlobalUser **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CGlobalUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CGlobalUser ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CGlobalUser, sizeof(ns1__CGlobalUser *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CGlobalUser);
	if (soap_out_PointerToPointerTons1__CGlobalUser(soap, tag?tag:"ns1:CGlobalUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CGlobalUser *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CGlobalUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CGlobalUser(struct soap *soap, const char *tag, int id, ns1__CGlobalUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CGlobalUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CGlobalUser ** SOAP_FMAC4 soap_in_PointerTons1__CGlobalUser(struct soap *soap, const char *tag, ns1__CGlobalUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CGlobalUser **)soap_malloc(soap, sizeof(ns1__CGlobalUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CGlobalUser *)soap_instantiate_ns1__CGlobalUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CGlobalUser ** p = (ns1__CGlobalUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CGlobalUser, sizeof(ns1__CGlobalUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CGlobalUser);
	if (soap_out_PointerTons1__CGlobalUser(soap, tag?tag:"ns1:CGlobalUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CGlobalUser ** SOAP_FMAC4 soap_get_PointerTons1__CGlobalUser(struct soap *soap, ns1__CGlobalUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CGlobalUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CDefectEventDefinition))
		soap_serialize_PointerTons1__CDefectEventDefinition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, ns1__CDefectEventDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CDefectEventDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CDefectEventDefinition *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CDefectEventDefinition(struct soap *soap, const char *tag, ns1__CDefectEventDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDefectEventDefinition ***)soap_malloc(soap, sizeof(ns1__CDefectEventDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CDefectEventDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CDefectEventDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CDefectEventDefinition, sizeof(ns1__CDefectEventDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CDefectEventDefinition);
	if (soap_out_PointerToPointerTons1__CDefectEventDefinition(soap, tag?tag:"ns1:CDefectEventDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDefectEventDefinition *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CDefectEventDefinition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CDefectEventDefinition(struct soap *soap, const char *tag, int id, ns1__CDefectEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CDefectEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CDefectEventDefinition ** SOAP_FMAC4 soap_in_PointerTons1__CDefectEventDefinition(struct soap *soap, const char *tag, ns1__CDefectEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDefectEventDefinition **)soap_malloc(soap, sizeof(ns1__CDefectEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CDefectEventDefinition *)soap_instantiate_ns1__CDefectEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CDefectEventDefinition ** p = (ns1__CDefectEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CDefectEventDefinition, sizeof(ns1__CDefectEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CDefectEventDefinition);
	if (soap_out_PointerTons1__CDefectEventDefinition(soap, tag?tag:"ns1:CDefectEventDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDefectEventDefinition ** SOAP_FMAC4 soap_get_PointerTons1__CDefectEventDefinition(struct soap *soap, ns1__CDefectEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CDefectEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CEventDefinition))
		soap_serialize_PointerTons1__CEventDefinition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CEventDefinition(struct soap *soap, const char *tag, int id, ns1__CEventDefinition **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CEventDefinition);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CEventDefinition(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CEventDefinition *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CEventDefinition(struct soap *soap, const char *tag, ns1__CEventDefinition ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CEventDefinition ***)soap_malloc(soap, sizeof(ns1__CEventDefinition **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CEventDefinition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CEventDefinition ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CEventDefinition, sizeof(ns1__CEventDefinition *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CEventDefinition);
	if (soap_out_PointerToPointerTons1__CEventDefinition(soap, tag?tag:"ns1:CEventDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CEventDefinition *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CEventDefinition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CEventDefinition(struct soap *soap, const char *tag, int id, ns1__CEventDefinition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CEventDefinition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CEventDefinition ** SOAP_FMAC4 soap_in_PointerTons1__CEventDefinition(struct soap *soap, const char *tag, ns1__CEventDefinition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CEventDefinition **)soap_malloc(soap, sizeof(ns1__CEventDefinition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CEventDefinition *)soap_instantiate_ns1__CEventDefinition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CEventDefinition ** p = (ns1__CEventDefinition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CEventDefinition, sizeof(ns1__CEventDefinition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CEventDefinition);
	if (soap_out_PointerTons1__CEventDefinition(soap, tag?tag:"ns1:CEventDefinition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CEventDefinition ** SOAP_FMAC4 soap_get_PointerTons1__CEventDefinition(struct soap *soap, ns1__CEventDefinition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CEventDefinition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CDefectEvent))
		soap_serialize_PointerTons1__CDefectEvent(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CDefectEvent(struct soap *soap, const char *tag, int id, ns1__CDefectEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CDefectEvent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CDefectEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CDefectEvent *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CDefectEvent(struct soap *soap, const char *tag, ns1__CDefectEvent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDefectEvent ***)soap_malloc(soap, sizeof(ns1__CDefectEvent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CDefectEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CDefectEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CDefectEvent, sizeof(ns1__CDefectEvent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CDefectEvent);
	if (soap_out_PointerToPointerTons1__CDefectEvent(soap, tag?tag:"ns1:CDefectEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDefectEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CDefectEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CDefectEvent(struct soap *soap, const char *tag, int id, ns1__CDefectEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CDefectEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CDefectEvent ** SOAP_FMAC4 soap_in_PointerTons1__CDefectEvent(struct soap *soap, const char *tag, ns1__CDefectEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDefectEvent **)soap_malloc(soap, sizeof(ns1__CDefectEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CDefectEvent *)soap_instantiate_ns1__CDefectEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CDefectEvent ** p = (ns1__CDefectEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CDefectEvent, sizeof(ns1__CDefectEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CDefectEvent);
	if (soap_out_PointerTons1__CDefectEvent(soap, tag?tag:"ns1:CDefectEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDefectEvent ** SOAP_FMAC4 soap_get_PointerTons1__CDefectEvent(struct soap *soap, ns1__CDefectEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CDefectEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CEvent(struct soap *soap, ns1__CEvent **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CEvent))
		soap_serialize_PointerTons1__CEvent(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CEvent(struct soap *soap, const char *tag, int id, ns1__CEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CEvent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CEvent *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CEvent(struct soap *soap, const char *tag, ns1__CEvent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CEvent ***)soap_malloc(soap, sizeof(ns1__CEvent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CEvent, sizeof(ns1__CEvent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CEvent(struct soap *soap, ns1__CEvent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CEvent);
	if (soap_out_PointerToPointerTons1__CEvent(soap, tag?tag:"ns1:CEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CEvent(struct soap *soap, ns1__CEvent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CEvent(struct soap *soap, ns1__CEvent *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CEvent))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CEvent(struct soap *soap, const char *tag, int id, ns1__CEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CEvent ** SOAP_FMAC4 soap_in_PointerTons1__CEvent(struct soap *soap, const char *tag, ns1__CEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CEvent **)soap_malloc(soap, sizeof(ns1__CEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CEvent *)soap_instantiate_ns1__CEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CEvent ** p = (ns1__CEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CEvent, sizeof(ns1__CEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CEvent(struct soap *soap, ns1__CEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CEvent);
	if (soap_out_PointerTons1__CEvent(soap, tag?tag:"ns1:CEvent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CEvent ** SOAP_FMAC4 soap_get_PointerTons1__CEvent(struct soap *soap, ns1__CEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfstring(struct soap *soap, const char *tag, int id, ArrayOfstring *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfstring);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfstring ** SOAP_FMAC4 soap_in_PointerToArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfstring **)soap_malloc(soap, sizeof(ArrayOfstring *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfstring *)soap_instantiate_ArrayOfstring(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfstring ** p = (ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfstring);
	if (soap_out_PointerToArrayOfstring(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfstring ** SOAP_FMAC4 soap_get_PointerToArrayOfstring(struct soap *soap, ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfstring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTestCaseVariantField))
		soap_serialize_PointerTons1__CTestCaseVariantField(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, ns1__CTestCaseVariantField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTestCaseVariantField(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTestCaseVariantField *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTestCaseVariantField(struct soap *soap, const char *tag, ns1__CTestCaseVariantField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestCaseVariantField ***)soap_malloc(soap, sizeof(ns1__CTestCaseVariantField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTestCaseVariantField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTestCaseVariantField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTestCaseVariantField, sizeof(ns1__CTestCaseVariantField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTestCaseVariantField);
	if (soap_out_PointerToPointerTons1__CTestCaseVariantField(soap, tag?tag:"ns1:CTestCaseVariantField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestCaseVariantField *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTestCaseVariantField))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTestCaseVariantField(struct soap *soap, const char *tag, int id, ns1__CTestCaseVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTestCaseVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTestCaseVariantField ** SOAP_FMAC4 soap_in_PointerTons1__CTestCaseVariantField(struct soap *soap, const char *tag, ns1__CTestCaseVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestCaseVariantField **)soap_malloc(soap, sizeof(ns1__CTestCaseVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTestCaseVariantField *)soap_instantiate_ns1__CTestCaseVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTestCaseVariantField ** p = (ns1__CTestCaseVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTestCaseVariantField, sizeof(ns1__CTestCaseVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTestCaseVariantField);
	if (soap_out_PointerTons1__CTestCaseVariantField(soap, tag?tag:"ns1:CTestCaseVariantField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestCaseVariantField ** SOAP_FMAC4 soap_get_PointerTons1__CTestCaseVariantField(struct soap *soap, ns1__CTestCaseVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTestCaseVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTestRunVariantField))
		soap_serialize_PointerTons1__CTestRunVariantField(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTestRunVariantField(struct soap *soap, const char *tag, int id, ns1__CTestRunVariantField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTestRunVariantField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTestRunVariantField(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTestRunVariantField *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTestRunVariantField(struct soap *soap, const char *tag, ns1__CTestRunVariantField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestRunVariantField ***)soap_malloc(soap, sizeof(ns1__CTestRunVariantField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTestRunVariantField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTestRunVariantField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTestRunVariantField, sizeof(ns1__CTestRunVariantField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTestRunVariantField);
	if (soap_out_PointerToPointerTons1__CTestRunVariantField(soap, tag?tag:"ns1:CTestRunVariantField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestRunVariantField *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTestRunVariantField))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTestRunVariantField(struct soap *soap, const char *tag, int id, ns1__CTestRunVariantField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTestRunVariantField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTestRunVariantField ** SOAP_FMAC4 soap_in_PointerTons1__CTestRunVariantField(struct soap *soap, const char *tag, ns1__CTestRunVariantField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTestRunVariantField **)soap_malloc(soap, sizeof(ns1__CTestRunVariantField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTestRunVariantField *)soap_instantiate_ns1__CTestRunVariantField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTestRunVariantField ** p = (ns1__CTestRunVariantField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTestRunVariantField, sizeof(ns1__CTestRunVariantField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTestRunVariantField);
	if (soap_out_PointerTons1__CTestRunVariantField(soap, tag?tag:"ns1:CTestRunVariantField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTestRunVariantField ** SOAP_FMAC4 soap_get_PointerTons1__CTestRunVariantField(struct soap *soap, ns1__CTestRunVariantField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTestRunVariantField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CField(struct soap *soap, ns1__CField **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CField))
		soap_serialize_PointerTons1__CField(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CField(struct soap *soap, const char *tag, int id, ns1__CField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CField(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CField *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CField(struct soap *soap, const char *tag, ns1__CField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CField ***)soap_malloc(soap, sizeof(ns1__CField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CField, sizeof(ns1__CField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CField(struct soap *soap, ns1__CField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CField);
	if (soap_out_PointerToPointerTons1__CField(soap, tag?tag:"ns1:CField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CField *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CField(struct soap *soap, ns1__CField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CField(struct soap *soap, ns1__CField *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CField))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CField(struct soap *soap, const char *tag, int id, ns1__CField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CField ** SOAP_FMAC4 soap_in_PointerTons1__CField(struct soap *soap, const char *tag, ns1__CField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CField **)soap_malloc(soap, sizeof(ns1__CField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CField *)soap_instantiate_ns1__CField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CField ** p = (ns1__CField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CField, sizeof(ns1__CField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CField(struct soap *soap, ns1__CField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CField);
	if (soap_out_PointerTons1__CField(soap, tag?tag:"ns1:CField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CField ** SOAP_FMAC4 soap_get_PointerTons1__CField(struct soap *soap, ns1__CField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CReportedByRecord))
		soap_serialize_PointerTons1__CReportedByRecord(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CReportedByRecord(struct soap *soap, const char *tag, int id, ns1__CReportedByRecord **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CReportedByRecord);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CReportedByRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CReportedByRecord *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CReportedByRecord(struct soap *soap, const char *tag, ns1__CReportedByRecord ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CReportedByRecord ***)soap_malloc(soap, sizeof(ns1__CReportedByRecord **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CReportedByRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CReportedByRecord ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CReportedByRecord, sizeof(ns1__CReportedByRecord *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CReportedByRecord);
	if (soap_out_PointerToPointerTons1__CReportedByRecord(soap, tag?tag:"ns1:CReportedByRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CReportedByRecord *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CReportedByRecord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CReportedByRecord(struct soap *soap, const char *tag, int id, ns1__CReportedByRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CReportedByRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CReportedByRecord ** SOAP_FMAC4 soap_in_PointerTons1__CReportedByRecord(struct soap *soap, const char *tag, ns1__CReportedByRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CReportedByRecord **)soap_malloc(soap, sizeof(ns1__CReportedByRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CReportedByRecord *)soap_instantiate_ns1__CReportedByRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CReportedByRecord ** p = (ns1__CReportedByRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CReportedByRecord, sizeof(ns1__CReportedByRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CReportedByRecord);
	if (soap_out_PointerTons1__CReportedByRecord(soap, tag?tag:"ns1:CReportedByRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CReportedByRecord ** SOAP_FMAC4 soap_get_PointerTons1__CReportedByRecord(struct soap *soap, ns1__CReportedByRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CReportedByRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToshort(struct soap *soap, short *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_short);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToshort(struct soap *soap, const char *tag, int id, short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_short);
	if (id < 0)
		return soap->error;
	return soap_out_short(soap, tag, id, *a, type);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_in_PointerToshort(struct soap *soap, const char *tag, short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (short **)soap_malloc(soap, sizeof(short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_short(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_short, sizeof(short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToshort(struct soap *soap, short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToshort);
	if (soap_out_PointerToshort(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_get_PointerToshort(struct soap *soap, short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToshort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CSystem(struct soap *soap, ns1__CSystem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CSystem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CSystem(struct soap *soap, const char *tag, int id, ns1__CSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CSystem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CSystem ** SOAP_FMAC4 soap_in_PointerTons1__CSystem(struct soap *soap, const char *tag, ns1__CSystem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CSystem **)soap_malloc(soap, sizeof(ns1__CSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CSystem *)soap_instantiate_ns1__CSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CSystem ** p = (ns1__CSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CSystem, sizeof(ns1__CSystem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CSystem(struct soap *soap, ns1__CSystem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CSystem);
	if (soap_out_PointerTons1__CSystem(soap, tag?tag:"ns1:CSystem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CSystem ** SOAP_FMAC4 soap_get_PointerTons1__CSystem(struct soap *soap, ns1__CSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFileAttachment(struct soap *soap, ArrayOfCFileAttachment *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFileAttachment(struct soap *soap, const char *tag, int id, ArrayOfCFileAttachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFileAttachment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFileAttachment ** SOAP_FMAC4 soap_in_PointerToArrayOfCFileAttachment(struct soap *soap, const char *tag, ArrayOfCFileAttachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFileAttachment **)soap_malloc(soap, sizeof(ArrayOfCFileAttachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFileAttachment *)soap_instantiate_ArrayOfCFileAttachment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFileAttachment ** p = (ArrayOfCFileAttachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFileAttachment, sizeof(ArrayOfCFileAttachment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFileAttachment(struct soap *soap, ArrayOfCFileAttachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFileAttachment);
	if (soap_out_PointerToArrayOfCFileAttachment(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFileAttachment ** SOAP_FMAC4 soap_get_PointerToArrayOfCFileAttachment(struct soap *soap, ArrayOfCFileAttachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFileAttachment))
		soap_serialize_PointerTons1__CFileAttachment(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFileAttachment(struct soap *soap, const char *tag, int id, ns1__CFileAttachment **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFileAttachment);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFileAttachment(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFileAttachment *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFileAttachment(struct soap *soap, const char *tag, ns1__CFileAttachment ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFileAttachment ***)soap_malloc(soap, sizeof(ns1__CFileAttachment **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFileAttachment(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFileAttachment ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFileAttachment, sizeof(ns1__CFileAttachment *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFileAttachment);
	if (soap_out_PointerToPointerTons1__CFileAttachment(soap, tag?tag:"ns1:CFileAttachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFileAttachment *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFileAttachment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFileAttachment(struct soap *soap, const char *tag, int id, ns1__CFileAttachment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFileAttachment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFileAttachment ** SOAP_FMAC4 soap_in_PointerTons1__CFileAttachment(struct soap *soap, const char *tag, ns1__CFileAttachment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFileAttachment **)soap_malloc(soap, sizeof(ns1__CFileAttachment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFileAttachment *)soap_instantiate_ns1__CFileAttachment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFileAttachment ** p = (ns1__CFileAttachment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFileAttachment, sizeof(ns1__CFileAttachment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFileAttachment);
	if (soap_out_PointerTons1__CFileAttachment(soap, tag?tag:"ns1:CFileAttachment", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFileAttachment ** SOAP_FMAC4 soap_get_PointerTons1__CFileAttachment(struct soap *soap, ns1__CFileAttachment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFileAttachment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFile(struct soap *soap, ns1__CFile **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFile))
		soap_serialize_PointerTons1__CFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFile(struct soap *soap, const char *tag, int id, ns1__CFile **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFile);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFile *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFile(struct soap *soap, const char *tag, ns1__CFile ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFile ***)soap_malloc(soap, sizeof(ns1__CFile **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFile ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFile, sizeof(ns1__CFile *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFile(struct soap *soap, ns1__CFile **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFile);
	if (soap_out_PointerToPointerTons1__CFile(soap, tag?tag:"ns1:CFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFile *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFile(struct soap *soap, ns1__CFile ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFile(struct soap *soap, ns1__CFile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFile(struct soap *soap, const char *tag, int id, ns1__CFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFile ** SOAP_FMAC4 soap_in_PointerTons1__CFile(struct soap *soap, const char *tag, ns1__CFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFile **)soap_malloc(soap, sizeof(ns1__CFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFile *)soap_instantiate_ns1__CFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFile ** p = (ns1__CFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFile, sizeof(ns1__CFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFile(struct soap *soap, ns1__CFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFile);
	if (soap_out_PointerTons1__CFile(soap, tag?tag:"ns1:CFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFile ** SOAP_FMAC4 soap_get_PointerTons1__CFile(struct soap *soap, ns1__CFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CSCCFileRecord))
		soap_serialize_PointerTons1__CSCCFileRecord(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CSCCFileRecord(struct soap *soap, const char *tag, int id, ns1__CSCCFileRecord **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CSCCFileRecord);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CSCCFileRecord(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CSCCFileRecord *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CSCCFileRecord(struct soap *soap, const char *tag, ns1__CSCCFileRecord ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CSCCFileRecord ***)soap_malloc(soap, sizeof(ns1__CSCCFileRecord **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CSCCFileRecord(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CSCCFileRecord ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CSCCFileRecord, sizeof(ns1__CSCCFileRecord *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CSCCFileRecord);
	if (soap_out_PointerToPointerTons1__CSCCFileRecord(soap, tag?tag:"ns1:CSCCFileRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CSCCFileRecord *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CSCCFileRecord))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CSCCFileRecord(struct soap *soap, const char *tag, int id, ns1__CSCCFileRecord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CSCCFileRecord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CSCCFileRecord ** SOAP_FMAC4 soap_in_PointerTons1__CSCCFileRecord(struct soap *soap, const char *tag, ns1__CSCCFileRecord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CSCCFileRecord **)soap_malloc(soap, sizeof(ns1__CSCCFileRecord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CSCCFileRecord *)soap_instantiate_ns1__CSCCFileRecord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CSCCFileRecord ** p = (ns1__CSCCFileRecord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CSCCFileRecord, sizeof(ns1__CSCCFileRecord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CSCCFileRecord);
	if (soap_out_PointerTons1__CSCCFileRecord(soap, tag?tag:"ns1:CSCCFileRecord", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CSCCFileRecord ** SOAP_FMAC4 soap_get_PointerTons1__CSCCFileRecord(struct soap *soap, ns1__CSCCFileRecord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CSCCFileRecord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CRecordRowSoap))
		soap_serialize_PointerTons1__CRecordRowSoap(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CRecordRowSoap(struct soap *soap, const char *tag, int id, ns1__CRecordRowSoap **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CRecordRowSoap);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CRecordRowSoap(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CRecordRowSoap *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CRecordRowSoap(struct soap *soap, const char *tag, ns1__CRecordRowSoap ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRecordRowSoap ***)soap_malloc(soap, sizeof(ns1__CRecordRowSoap **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CRecordRowSoap(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CRecordRowSoap ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CRecordRowSoap, sizeof(ns1__CRecordRowSoap *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CRecordRowSoap);
	if (soap_out_PointerToPointerTons1__CRecordRowSoap(soap, tag?tag:"ns1:CRecordRowSoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRecordRowSoap *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CRecordRowSoap))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CRecordRowSoap(struct soap *soap, const char *tag, int id, ns1__CRecordRowSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CRecordRowSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CRecordRowSoap ** SOAP_FMAC4 soap_in_PointerTons1__CRecordRowSoap(struct soap *soap, const char *tag, ns1__CRecordRowSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRecordRowSoap **)soap_malloc(soap, sizeof(ns1__CRecordRowSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CRecordRowSoap *)soap_instantiate_ns1__CRecordRowSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CRecordRowSoap ** p = (ns1__CRecordRowSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CRecordRowSoap, sizeof(ns1__CRecordRowSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CRecordRowSoap);
	if (soap_out_PointerTons1__CRecordRowSoap(soap, tag?tag:"ns1:CRecordRowSoap", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRecordRowSoap ** SOAP_FMAC4 soap_get_PointerTons1__CRecordRowSoap(struct soap *soap, ns1__CRecordRowSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CRecordData(struct soap *soap, ns1__CRecordData **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CRecordData))
		soap_serialize_PointerTons1__CRecordData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CRecordData(struct soap *soap, const char *tag, int id, ns1__CRecordData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CRecordData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CRecordData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CRecordData *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CRecordData(struct soap *soap, const char *tag, ns1__CRecordData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRecordData ***)soap_malloc(soap, sizeof(ns1__CRecordData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CRecordData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CRecordData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CRecordData, sizeof(ns1__CRecordData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CRecordData(struct soap *soap, ns1__CRecordData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CRecordData);
	if (soap_out_PointerToPointerTons1__CRecordData(soap, tag?tag:"ns1:CRecordData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRecordData *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CRecordData(struct soap *soap, ns1__CRecordData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CRecordData(struct soap *soap, ns1__CRecordData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CRecordData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CRecordData(struct soap *soap, const char *tag, int id, ns1__CRecordData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CRecordData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CRecordData ** SOAP_FMAC4 soap_in_PointerTons1__CRecordData(struct soap *soap, const char *tag, ns1__CRecordData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CRecordData **)soap_malloc(soap, sizeof(ns1__CRecordData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CRecordData *)soap_instantiate_ns1__CRecordData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CRecordData ** p = (ns1__CRecordData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CRecordData, sizeof(ns1__CRecordData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CRecordData(struct soap *soap, ns1__CRecordData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CRecordData);
	if (soap_out_PointerTons1__CRecordData(soap, tag?tag:"ns1:CRecordData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CRecordData ** SOAP_FMAC4 soap_get_PointerTons1__CRecordData(struct soap *soap, ns1__CRecordData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFilter(struct soap *soap, ns1__CFilter **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFilter))
		soap_serialize_PointerTons1__CFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFilter(struct soap *soap, const char *tag, int id, ns1__CFilter **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFilter);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFilter *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFilter(struct soap *soap, const char *tag, ns1__CFilter ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFilter ***)soap_malloc(soap, sizeof(ns1__CFilter **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFilter ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFilter, sizeof(ns1__CFilter *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFilter(struct soap *soap, ns1__CFilter **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFilter);
	if (soap_out_PointerToPointerTons1__CFilter(soap, tag?tag:"ns1:CFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFilter *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFilter(struct soap *soap, ns1__CFilter ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFilter(struct soap *soap, ns1__CFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFilter(struct soap *soap, const char *tag, int id, ns1__CFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFilter ** SOAP_FMAC4 soap_in_PointerTons1__CFilter(struct soap *soap, const char *tag, ns1__CFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFilter **)soap_malloc(soap, sizeof(ns1__CFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFilter *)soap_instantiate_ns1__CFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFilter ** p = (ns1__CFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFilter, sizeof(ns1__CFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFilter(struct soap *soap, ns1__CFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFilter);
	if (soap_out_PointerTons1__CFilter(soap, tag?tag:"ns1:CFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFilter ** SOAP_FMAC4 soap_get_PointerTons1__CFilter(struct soap *soap, ns1__CFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTableColumn))
		soap_serialize_PointerTons1__CTableColumn(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTableColumn(struct soap *soap, const char *tag, int id, ns1__CTableColumn **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTableColumn);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTableColumn(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTableColumn *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTableColumn(struct soap *soap, const char *tag, ns1__CTableColumn ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTableColumn ***)soap_malloc(soap, sizeof(ns1__CTableColumn **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTableColumn(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTableColumn ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTableColumn, sizeof(ns1__CTableColumn *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTableColumn);
	if (soap_out_PointerToPointerTons1__CTableColumn(soap, tag?tag:"ns1:CTableColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTableColumn *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTableColumn))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTableColumn(struct soap *soap, const char *tag, int id, ns1__CTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTableColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTableColumn ** SOAP_FMAC4 soap_in_PointerTons1__CTableColumn(struct soap *soap, const char *tag, ns1__CTableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTableColumn **)soap_malloc(soap, sizeof(ns1__CTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTableColumn *)soap_instantiate_ns1__CTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTableColumn ** p = (ns1__CTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTableColumn, sizeof(ns1__CTableColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTableColumn);
	if (soap_out_PointerTons1__CTableColumn(soap, tag?tag:"ns1:CTableColumn", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTableColumn ** SOAP_FMAC4 soap_get_PointerTons1__CTableColumn(struct soap *soap, ns1__CTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CFieldValue))
		soap_serialize_PointerTons1__CFieldValue(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CFieldValue(struct soap *soap, const char *tag, int id, ns1__CFieldValue **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CFieldValue);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CFieldValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CFieldValue *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CFieldValue(struct soap *soap, const char *tag, ns1__CFieldValue ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFieldValue ***)soap_malloc(soap, sizeof(ns1__CFieldValue **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CFieldValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CFieldValue ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CFieldValue, sizeof(ns1__CFieldValue *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CFieldValue);
	if (soap_out_PointerToPointerTons1__CFieldValue(soap, tag?tag:"ns1:CFieldValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFieldValue *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CFieldValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CFieldValue(struct soap *soap, const char *tag, int id, ns1__CFieldValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CFieldValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CFieldValue ** SOAP_FMAC4 soap_in_PointerTons1__CFieldValue(struct soap *soap, const char *tag, ns1__CFieldValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CFieldValue **)soap_malloc(soap, sizeof(ns1__CFieldValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CFieldValue *)soap_instantiate_ns1__CFieldValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CFieldValue ** p = (ns1__CFieldValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CFieldValue, sizeof(ns1__CFieldValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CFieldValue);
	if (soap_out_PointerTons1__CFieldValue(soap, tag?tag:"ns1:CFieldValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CFieldValue ** SOAP_FMAC4 soap_get_PointerTons1__CFieldValue(struct soap *soap, ns1__CFieldValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTableField(struct soap *soap, ns1__CTableField **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTableField))
		soap_serialize_PointerTons1__CTableField(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTableField(struct soap *soap, const char *tag, int id, ns1__CTableField **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTableField);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTableField(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTableField *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTableField(struct soap *soap, const char *tag, ns1__CTableField ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTableField ***)soap_malloc(soap, sizeof(ns1__CTableField **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTableField(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTableField ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTableField, sizeof(ns1__CTableField *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTableField(struct soap *soap, ns1__CTableField **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTableField);
	if (soap_out_PointerToPointerTons1__CTableField(soap, tag?tag:"ns1:CTableField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTableField *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTableField(struct soap *soap, ns1__CTableField ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTableField(struct soap *soap, ns1__CTableField *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTableField))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTableField(struct soap *soap, const char *tag, int id, ns1__CTableField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTableField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTableField ** SOAP_FMAC4 soap_in_PointerTons1__CTableField(struct soap *soap, const char *tag, ns1__CTableField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTableField **)soap_malloc(soap, sizeof(ns1__CTableField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTableField *)soap_instantiate_ns1__CTableField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CTableField ** p = (ns1__CTableField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTableField, sizeof(ns1__CTableField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTableField(struct soap *soap, ns1__CTableField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTableField);
	if (soap_out_PointerTons1__CTableField(soap, tag?tag:"ns1:CTableField", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CTableField ** SOAP_FMAC4 soap_get_PointerTons1__CTableField(struct soap *soap, ns1__CTableField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTableField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CDatabaseTable))
		soap_serialize_PointerTons1__CDatabaseTable(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CDatabaseTable(struct soap *soap, const char *tag, int id, ns1__CDatabaseTable **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CDatabaseTable);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CDatabaseTable(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CDatabaseTable *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CDatabaseTable(struct soap *soap, const char *tag, ns1__CDatabaseTable ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDatabaseTable ***)soap_malloc(soap, sizeof(ns1__CDatabaseTable **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CDatabaseTable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CDatabaseTable ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CDatabaseTable, sizeof(ns1__CDatabaseTable *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CDatabaseTable);
	if (soap_out_PointerToPointerTons1__CDatabaseTable(soap, tag?tag:"ns1:CDatabaseTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDatabaseTable *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CDatabaseTable))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CDatabaseTable(struct soap *soap, const char *tag, int id, ns1__CDatabaseTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CDatabaseTable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CDatabaseTable ** SOAP_FMAC4 soap_in_PointerTons1__CDatabaseTable(struct soap *soap, const char *tag, ns1__CDatabaseTable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDatabaseTable **)soap_malloc(soap, sizeof(ns1__CDatabaseTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CDatabaseTable *)soap_instantiate_ns1__CDatabaseTable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CDatabaseTable ** p = (ns1__CDatabaseTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CDatabaseTable, sizeof(ns1__CDatabaseTable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CDatabaseTable);
	if (soap_out_PointerTons1__CDatabaseTable(soap, tag?tag:"ns1:CDatabaseTable", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDatabaseTable ** SOAP_FMAC4 soap_get_PointerTons1__CDatabaseTable(struct soap *soap, ns1__CDatabaseTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CDatabaseTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CProject(struct soap *soap, ns1__CProject **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CProject))
		soap_serialize_PointerTons1__CProject(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CProject(struct soap *soap, const char *tag, int id, ns1__CProject **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CProject);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CProject(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CProject *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CProject(struct soap *soap, const char *tag, ns1__CProject ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CProject ***)soap_malloc(soap, sizeof(ns1__CProject **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CProject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CProject ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CProject, sizeof(ns1__CProject *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CProject(struct soap *soap, ns1__CProject **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CProject);
	if (soap_out_PointerToPointerTons1__CProject(soap, tag?tag:"ns1:CProject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CProject *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CProject(struct soap *soap, ns1__CProject ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CProject(struct soap *soap, ns1__CProject *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CProject))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CProject(struct soap *soap, const char *tag, int id, ns1__CProject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CProject);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CProject ** SOAP_FMAC4 soap_in_PointerTons1__CProject(struct soap *soap, const char *tag, ns1__CProject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CProject **)soap_malloc(soap, sizeof(ns1__CProject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CProject *)soap_instantiate_ns1__CProject(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CProject ** p = (ns1__CProject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CProject, sizeof(ns1__CProject), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CProject(struct soap *soap, ns1__CProject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CProject);
	if (soap_out_PointerTons1__CProject(soap, tag?tag:"ns1:CProject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CProject ** SOAP_FMAC4 soap_get_PointerTons1__CProject(struct soap *soap, ns1__CProject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CProjectDataOption))
		soap_serialize_PointerTons1__CProjectDataOption(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CProjectDataOption(struct soap *soap, const char *tag, int id, ns1__CProjectDataOption **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CProjectDataOption);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CProjectDataOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CProjectDataOption *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CProjectDataOption(struct soap *soap, const char *tag, ns1__CProjectDataOption ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CProjectDataOption ***)soap_malloc(soap, sizeof(ns1__CProjectDataOption **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CProjectDataOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CProjectDataOption ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CProjectDataOption, sizeof(ns1__CProjectDataOption *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CProjectDataOption);
	if (soap_out_PointerToPointerTons1__CProjectDataOption(soap, tag?tag:"ns1:CProjectDataOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CProjectDataOption *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CProjectDataOption))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CProjectDataOption(struct soap *soap, const char *tag, int id, ns1__CProjectDataOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CProjectDataOption);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CProjectDataOption ** SOAP_FMAC4 soap_in_PointerTons1__CProjectDataOption(struct soap *soap, const char *tag, ns1__CProjectDataOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CProjectDataOption **)soap_malloc(soap, sizeof(ns1__CProjectDataOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CProjectDataOption *)soap_instantiate_ns1__CProjectDataOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CProjectDataOption ** p = (ns1__CProjectDataOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CProjectDataOption, sizeof(ns1__CProjectDataOption), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CProjectDataOption);
	if (soap_out_PointerTons1__CProjectDataOption(soap, tag?tag:"ns1:CProjectDataOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CProjectDataOption ** SOAP_FMAC4 soap_get_PointerTons1__CProjectDataOption(struct soap *soap, ns1__CProjectDataOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CDatabase(struct soap *soap, ns1__CDatabase **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CDatabase))
		soap_serialize_PointerTons1__CDatabase(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CDatabase(struct soap *soap, const char *tag, int id, ns1__CDatabase **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CDatabase);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CDatabase(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CDatabase *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CDatabase(struct soap *soap, const char *tag, ns1__CDatabase ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDatabase ***)soap_malloc(soap, sizeof(ns1__CDatabase **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CDatabase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CDatabase ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CDatabase, sizeof(ns1__CDatabase *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CDatabase(struct soap *soap, ns1__CDatabase **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CDatabase);
	if (soap_out_PointerToPointerTons1__CDatabase(soap, tag?tag:"ns1:CDatabase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDatabase *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CDatabase(struct soap *soap, ns1__CDatabase ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTreeNodeSoap(struct soap *soap, ArrayOfCTreeNodeSoap *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTreeNodeSoap(struct soap *soap, const char *tag, int id, ArrayOfCTreeNodeSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTreeNodeSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTreeNodeSoap ** SOAP_FMAC4 soap_in_PointerToArrayOfCTreeNodeSoap(struct soap *soap, const char *tag, ArrayOfCTreeNodeSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTreeNodeSoap **)soap_malloc(soap, sizeof(ArrayOfCTreeNodeSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTreeNodeSoap *)soap_instantiate_ArrayOfCTreeNodeSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCTreeNodeSoap ** p = (ArrayOfCTreeNodeSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTreeNodeSoap, sizeof(ArrayOfCTreeNodeSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTreeNodeSoap(struct soap *soap, ArrayOfCTreeNodeSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTreeNodeSoap);
	if (soap_out_PointerToArrayOfCTreeNodeSoap(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCTreeNodeSoap ** SOAP_FMAC4 soap_get_PointerToArrayOfCTreeNodeSoap(struct soap *soap, ArrayOfCTreeNodeSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTreeNodeSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToLONG64(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_LONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToLONG64(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_LONG64);
	if (id < 0)
		return soap->error;
	return soap_out_LONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToLONG64(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_LONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_LONG64, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToLONG64(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToLONG64);
	if (soap_out_PointerToLONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToLONG64(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCField(struct soap *soap, ArrayOfCField *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCField(struct soap *soap, const char *tag, int id, ArrayOfCField *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCField);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCField ** SOAP_FMAC4 soap_in_PointerToArrayOfCField(struct soap *soap, const char *tag, ArrayOfCField **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCField **)soap_malloc(soap, sizeof(ArrayOfCField *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCField *)soap_instantiate_ArrayOfCField(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCField ** p = (ArrayOfCField **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCField, sizeof(ArrayOfCField), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCField(struct soap *soap, ArrayOfCField *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCField);
	if (soap_out_PointerToArrayOfCField(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCField ** SOAP_FMAC4 soap_get_PointerToArrayOfCField(struct soap *soap, ArrayOfCField **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCField(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFieldValue(struct soap *soap, ArrayOfCFieldValue *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFieldValue(struct soap *soap, const char *tag, int id, ArrayOfCFieldValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFieldValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFieldValue ** SOAP_FMAC4 soap_in_PointerToArrayOfCFieldValue(struct soap *soap, const char *tag, ArrayOfCFieldValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFieldValue **)soap_malloc(soap, sizeof(ArrayOfCFieldValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFieldValue *)soap_instantiate_ArrayOfCFieldValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFieldValue ** p = (ArrayOfCFieldValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFieldValue, sizeof(ArrayOfCFieldValue), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFieldValue(struct soap *soap, ArrayOfCFieldValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFieldValue);
	if (soap_out_PointerToArrayOfCFieldValue(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFieldValue ** SOAP_FMAC4 soap_get_PointerToArrayOfCFieldValue(struct soap *soap, ArrayOfCFieldValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFieldValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCFile(struct soap *soap, ArrayOfCFile *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCFile(struct soap *soap, const char *tag, int id, ArrayOfCFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCFile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCFile ** SOAP_FMAC4 soap_in_PointerToArrayOfCFile(struct soap *soap, const char *tag, ArrayOfCFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCFile **)soap_malloc(soap, sizeof(ArrayOfCFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCFile *)soap_instantiate_ArrayOfCFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCFile ** p = (ArrayOfCFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCFile, sizeof(ArrayOfCFile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCFile(struct soap *soap, ArrayOfCFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCFile);
	if (soap_out_PointerToArrayOfCFile(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCFile ** SOAP_FMAC4 soap_get_PointerToArrayOfCFile(struct soap *soap, ArrayOfCFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__base64Binary **)soap_malloc(soap, sizeof(xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__base64Binary *)soap_instantiate_xsd__base64Binary(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__base64Binary ** p = (xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCRecordRowSoap(struct soap *soap, ArrayOfCRecordRowSoap *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCRecordRowSoap(struct soap *soap, const char *tag, int id, ArrayOfCRecordRowSoap *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCRecordRowSoap);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCRecordRowSoap ** SOAP_FMAC4 soap_in_PointerToArrayOfCRecordRowSoap(struct soap *soap, const char *tag, ArrayOfCRecordRowSoap **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCRecordRowSoap **)soap_malloc(soap, sizeof(ArrayOfCRecordRowSoap *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCRecordRowSoap *)soap_instantiate_ArrayOfCRecordRowSoap(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCRecordRowSoap ** p = (ArrayOfCRecordRowSoap **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCRecordRowSoap, sizeof(ArrayOfCRecordRowSoap), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCRecordRowSoap(struct soap *soap, ArrayOfCRecordRowSoap *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCRecordRowSoap);
	if (soap_out_PointerToArrayOfCRecordRowSoap(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCRecordRowSoap ** SOAP_FMAC4 soap_get_PointerToArrayOfCRecordRowSoap(struct soap *soap, ArrayOfCRecordRowSoap **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCRecordRowSoap(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTableColumn(struct soap *soap, ArrayOfCTableColumn *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTableColumn(struct soap *soap, const char *tag, int id, ArrayOfCTableColumn *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCTableColumn);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTableColumn ** SOAP_FMAC4 soap_in_PointerToArrayOfCTableColumn(struct soap *soap, const char *tag, ArrayOfCTableColumn **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTableColumn **)soap_malloc(soap, sizeof(ArrayOfCTableColumn *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTableColumn *)soap_instantiate_ArrayOfCTableColumn(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCTableColumn ** p = (ArrayOfCTableColumn **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTableColumn, sizeof(ArrayOfCTableColumn), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTableColumn(struct soap *soap, ArrayOfCTableColumn *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTableColumn);
	if (soap_out_PointerToArrayOfCTableColumn(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCTableColumn ** SOAP_FMAC4 soap_get_PointerToArrayOfCTableColumn(struct soap *soap, ArrayOfCTableColumn **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTableColumn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCRecordData(struct soap *soap, ArrayOfCRecordData *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCRecordData(struct soap *soap, const char *tag, int id, ArrayOfCRecordData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCRecordData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCRecordData ** SOAP_FMAC4 soap_in_PointerToArrayOfCRecordData(struct soap *soap, const char *tag, ArrayOfCRecordData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCRecordData **)soap_malloc(soap, sizeof(ArrayOfCRecordData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCRecordData *)soap_instantiate_ArrayOfCRecordData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCRecordData ** p = (ArrayOfCRecordData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCRecordData, sizeof(ArrayOfCRecordData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCRecordData(struct soap *soap, ArrayOfCRecordData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCRecordData);
	if (soap_out_PointerToArrayOfCRecordData(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCRecordData ** SOAP_FMAC4 soap_get_PointerToArrayOfCRecordData(struct soap *soap, ArrayOfCRecordData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCRecordData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCProjectDataOption(struct soap *soap, ArrayOfCProjectDataOption *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCProjectDataOption(struct soap *soap, const char *tag, int id, ArrayOfCProjectDataOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptritem, 1, type, SOAP_TYPE_ArrayOfCProjectDataOption);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCProjectDataOption ** SOAP_FMAC4 soap_in_PointerToArrayOfCProjectDataOption(struct soap *soap, const char *tag, ArrayOfCProjectDataOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCProjectDataOption **)soap_malloc(soap, sizeof(ArrayOfCProjectDataOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCProjectDataOption *)soap_instantiate_ArrayOfCProjectDataOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfCProjectDataOption ** p = (ArrayOfCProjectDataOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCProjectDataOption, sizeof(ArrayOfCProjectDataOption), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCProjectDataOption(struct soap *soap, ArrayOfCProjectDataOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCProjectDataOption);
	if (soap_out_PointerToArrayOfCProjectDataOption(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfCProjectDataOption ** SOAP_FMAC4 soap_get_PointerToArrayOfCProjectDataOption(struct soap *soap, ArrayOfCProjectDataOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCProjectDataOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CDatabase(struct soap *soap, ns1__CDatabase *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CDatabase))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CDatabase(struct soap *soap, const char *tag, int id, ns1__CDatabase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CDatabase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CDatabase ** SOAP_FMAC4 soap_in_PointerTons1__CDatabase(struct soap *soap, const char *tag, ns1__CDatabase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CDatabase **)soap_malloc(soap, sizeof(ns1__CDatabase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CDatabase *)soap_instantiate_ns1__CDatabase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__CDatabase ** p = (ns1__CDatabase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CDatabase, sizeof(ns1__CDatabase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CDatabase(struct soap *soap, ns1__CDatabase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CDatabase);
	if (soap_out_PointerTons1__CDatabase(soap, tag?tag:"ns1:CDatabase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__CDatabase ** SOAP_FMAC4 soap_get_PointerTons1__CDatabase(struct soap *soap, ns1__CDatabase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CDatabase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__date(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__date(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__date);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__date(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__date, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__date(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__date);
	if (soap_out_xsd__date(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__date(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */

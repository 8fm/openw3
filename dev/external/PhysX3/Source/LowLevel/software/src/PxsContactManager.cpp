// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2013 NVIDIA Corporation. All rights reserved.
// Copyright (c) 2004-2008 AGEIA Technologies, Inc. All rights reserved.
// Copyright (c) 2001-2004 NovodeX AG. All rights reserved.  


#include "PxsContactManager.h"
#include "PxsRigidBody.h"
#include "PxcContactMethodImpl.h"
#include "PxsThreadContext.h"
#include "PxcSolverConstraintTypes.h"
#include "PxcSolverContact.h"
#include "PxcSolverContactPF.h"
#include "PxsSolverConstraintDesc.h"
#include "PxsDynamics.h"

using namespace physx;

PxsContactManager::PxsContactManager(PxsContext*, PxU32 index) :
	//mBodyShape0 (0), 
	//mBodyShape1 (0),
	mUserData	(NULL)
{
	mFlags = 0;

	mNpUnit.index				= index;
	mNpUnit.rigidCore0			= 0;
	mNpUnit.rigidCore1			= 0;
	//mNpUnit.dynamicFriction		= 0;
	//mNpUnit.staticFriction		= 0;
	//mNpUnit.restitution			= 0;
	mNpUnit.restDistance		= 0;
	mNpUnit.dominance0			= 1.0f;
	mNpUnit.dominance1			= 1.0f;
	//mNpUnit.contactPoints		= NULL;
	mNpUnit.frictionDataPtr		= NULL;
	mNpUnit.frictionPatchCount	= 0;
}

PxsContactManager::~PxsContactManager()
{
}

void PxsContactManager::init(const PxvManagerDescRigidRigid& desc, const PxsMaterialManager* materialManager)
{
	//mBodyShape0					= desc.bodyShape0;
	//mBodyShape1					= desc.bodyShape1;

	mRigidBody0					= desc.rigidBody0;
	mRigidBody1					= desc.rigidBody1;

	mNpUnit.shapeCore0			= desc.shapeCore0;
	mNpUnit.shapeCore1			= desc.shapeCore1;

	PX_ASSERT(mNpUnit.shapeCore0->transform.isValid() && mNpUnit.shapeCore1->transform.isValid());

	mNpUnit.rigidCore0			= desc.rigidCore0;
	mNpUnit.rigidCore1			= desc.rigidCore1;

	//mNpUnit.dynamicFriction		= desc.dynamicFriction;
	//mNpUnit.staticFriction		= desc.staticFriction;
	//mNpUnit.restitution			= desc.restitution;
	mNpUnit.restDistance		= desc.restDistance;
	mNpUnit.dominance0			= desc.dominance0;
	mNpUnit.dominance1			= desc.dominance1;
	mNpUnit.geomType0			= PxU8(mNpUnit.shapeCore0->geometry.getType());
	mNpUnit.geomType1			= PxU8(mNpUnit.shapeCore1->geometry.getType());
	mNpUnit.materialManager     = materialManager;
	mNpUnit.mTransformCache0	= desc.transformCache0;
	mNpUnit.mTransformCache1	= desc.transformCache1;

	PxcNpWorkUnitClearContactState(mNpUnit);
	PxcNpWorkUnitClearCachedState(mNpUnit);
	
	PxU16 wuflags = 0;

	if(desc.hasArticulations & 1)
		wuflags |= PxcNpWorkUnitFlag::eARTICULATION_BODY0;

	if(desc.hasArticulations & 2)
		wuflags |= PxcNpWorkUnitFlag::eARTICULATION_BODY1;

	if(desc.hasDynamics & 1)
		wuflags |= PxcNpWorkUnitFlag::eDYNAMIC_BODY0;

	if(desc.hasDynamics & 2)
		wuflags |= PxcNpWorkUnitFlag::eDYNAMIC_BODY1;

	if(!desc.disableResponse && !desc.contactChangeable)
		wuflags |= PxcNpWorkUnitFlag::eOUTPUT_CONSTRAINTS;

	mNpUnit.disableResponse = desc.disableResponse != 0;

	mNpUnit.disableCCDResponse = desc.disableCCDResponse != 0;

	// this is just the user req: contact reports can also be generated by body thresholding
	if(desc.reportContactInfo || desc.contactChangeable)
		wuflags |= PxcNpWorkUnitFlag::eOUTPUT_CONTACTS;

	if(desc.hasForceThreshold)
		wuflags |= PxcNpWorkUnitFlag::eFORCE_THRESHOLD;

	if(desc.contactChangeable)
		wuflags |= PxcNpWorkUnitFlag::eMODIFIABLE_CONTACT;

	mNpUnit.flags = wuflags;

	mFlags	=  desc.contactChangeable ? PXS_CM_CHANGEABLE : 0;

	mUserData				= desc.userData;

	PxcNpWorkUnitClearContactState(mNpUnit);
}


void PxsContactManager::setCCD(bool enable)
{
	PxU32 flags = mFlags & (~PXS_CM_CCD_CONTACT);
	if (enable)
		flags |= PXS_CM_CCD_LINEAR;
	else
		flags &= ~PXS_CM_CCD_LINEAR;

	mFlags = flags;
}



void PxsContactManager::resetCachedState()
{ 
	// happens when the body transform or shape relative transform changes.

	PxcNpWorkUnitClearCachedState(mNpUnit);
}


// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2013 NVIDIA Corporation. All rights reserved.

// This file was generated by NxParameterized/scripts/GenParameterized.pl
// Created: 2013.10.01 14:57:20

#include "ExplosionEnvParameters.h"
#include <string.h>
#include <stdlib.h>

using namespace NxParameterized;

namespace physx
{
namespace apex
{
namespace explosion
{

using namespace ExplosionEnvParametersNS;

const char* const ExplosionEnvParametersFactory::vptr =
    NxParameterized::getVptr<ExplosionEnvParameters, ExplosionEnvParameters::ClassAlignment>();

const physx::PxU32 NumParamDefs = 11;
static NxParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 3, 5, 7, 9, 10, 2, 4, 6, 8,
};

#define TENUM(type) physx::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NxParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 6 },
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->fluidInteraction), CHILDREN(6), 1 }, // fluidInteraction
	{ TYPE_ENUM, false, (size_t)(&((forceFieldType_Type*)0)->interaction), NULL, 0 }, // fluidInteraction.interaction
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->clothInteraction), CHILDREN(7), 1 }, // clothInteraction
	{ TYPE_ENUM, false, (size_t)(&((forceFieldType_Type*)0)->interaction), NULL, 0 }, // clothInteraction.interaction
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->softBodyInteraction), CHILDREN(8), 1 }, // softBodyInteraction
	{ TYPE_ENUM, false, (size_t)(&((forceFieldType_Type*)0)->interaction), NULL, 0 }, // softBodyInteraction.interaction
	{ TYPE_STRUCT, false, (size_t)(&((ParametersStruct*)0)->rigidBodyInteraction), CHILDREN(9), 1 }, // rigidBodyInteraction
	{ TYPE_ENUM, false, (size_t)(&((forceFieldType_Type*)0)->interaction), NULL, 0 }, // rigidBodyInteraction.interaction
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionGroupName), NULL, 0 }, // collisionGroupName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionGroupsMask128Name), NULL, 0 }, // collisionGroupsMask128Name
};


bool ExplosionEnvParameters::mBuiltFlag = false;
NxParameterized::MutexType ExplosionEnvParameters::mBuiltFlagMutex;

ExplosionEnvParameters::ExplosionEnvParameters(NxParameterized::Traits* traits, void* buf, PxI32* refCount) :
	NxParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &ExplosionEnvParametersFactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

ExplosionEnvParameters::~ExplosionEnvParameters()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void ExplosionEnvParameters::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NxParameterized::Traits* traits = mParameterizedTraits;
	physx::PxI32* refCount = mRefCount;
	void* buf = mBuffer;

	this->~ExplosionEnvParameters();

	NxParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NxParameterized::DefinitionImpl* ExplosionEnvParameters::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NxParameterized::DefinitionImpl* ExplosionEnvParameters::getParameterDefinitionTree(void) const
{
	ExplosionEnvParameters* tmpParam = const_cast<ExplosionEnvParameters*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NxParameterized::ErrorType ExplosionEnvParameters::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NxParameterized::ErrorType ExplosionEnvParameters::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void ExplosionEnvParameters::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<ExplosionEnvParameters::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void ExplosionEnvParameters::freeParameterDefinitionTable(NxParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void ExplosionEnvParameters::buildTree(void)
{

	physx::PxU32 allocSize = sizeof(NxParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NxParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		NX_PARAM_PLACEMENT_NEW(ParamDefTable + i, NxParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);






	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="fluidInteraction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("fluidInteraction", TYPE_STRUCT, "forceFieldType", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Fluid feature interaction type", true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="fluidInteraction.interaction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("interaction", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", "other", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", "other", true);
		HintTable[1].init("longDescription", "other - does not scale the value from the force field\ngravitational - scales the force by the mass of the particle or body\nnone - used to disable force field interaction with a specific feature\n", true);
		HintTable[2].init("shortDescription", "Forcefield interaction type", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "other", "gravitational", "none" };
		ParamDefTable[2].setEnumVals((const char**)EnumVals, 3);




	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="clothInteraction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("clothInteraction", TYPE_STRUCT, "forceFieldType", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Cloth feature interaction type", true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="clothInteraction.interaction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("interaction", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", "other", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", "other", true);
		HintTable[1].init("longDescription", "other - does not scale the value from the force field\ngravitational - scales the force by the mass of the particle or body\nnone - used to disable force field interaction with a specific feature\n", true);
		HintTable[2].init("shortDescription", "Forcefield interaction type", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "other", "gravitational", "none" };
		ParamDefTable[4].setEnumVals((const char**)EnumVals, 3);




	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="softBodyInteraction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("softBodyInteraction", TYPE_STRUCT, "forceFieldType", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Softbody feature interaction type", true);
		ParamDefTable[5].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="softBodyInteraction.interaction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("interaction", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", "other", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", "other", true);
		HintTable[1].init("longDescription", "other - does not scale the value from the force field\ngravitational - scales the force by the mass of the particle or body\nnone - used to disable force field interaction with a specific feature\n", true);
		HintTable[2].init("shortDescription", "Forcefield interaction type", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "other", "gravitational", "none" };
		ParamDefTable[6].setEnumVals((const char**)EnumVals, 3);




	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="rigidBodyInteraction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("rigidBodyInteraction", TYPE_STRUCT, "forceFieldType", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "Rigid body feature interaction type", true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="rigidBodyInteraction.interaction"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("interaction", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", "other", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", "other", true);
		HintTable[1].init("longDescription", "other - does not scale the value from the force field\ngravitational - scales the force by the mass of the particle or body\nnone - used to disable force field interaction with a specific feature\n", true);
		HintTable[2].init("shortDescription", "Forcefield interaction type", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "other", "gravitational", "none" };
		ParamDefTable[8].setEnumVals((const char**)EnumVals, 3);




	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="collisionGroupName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("collisionGroupName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This name resolves to an NxCollisionGroup.  It is resolved by a call to the named resource \nprovider using the 'NSCollisionGroup' namespace.  If none is provided, the forcefield actor \nwill be created in collision group 0. \nThis avoids storing fragile enums in asset files.  \n", true);
		HintTable[1].init("shortDescription", "Explosion Collision Group Name", true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="collisionGroupsMask128Name"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("collisionGroupsMask128Name", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "This name resolves to a 128-bit NxGroupsMask used for collision filtering with the explosion\nactor.  It is resolved by a call to the named resource provider using the 'NSCollisionGroup128' \n", true);
		HintTable[1].init("shortDescription", "Explosion 128-bit Collision Groups Mask", true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[6];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(3);
		Children[2] = PDEF_PTR(5);
		Children[3] = PDEF_PTR(7);
		Children[4] = PDEF_PTR(9);
		Children[5] = PDEF_PTR(10);

		ParamDefTable[0].setChildren(Children, 6);
	}

	// SetChildren for: nodeIndex=1, longName="fluidInteraction"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(2);

		ParamDefTable[1].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=3, longName="clothInteraction"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(4);

		ParamDefTable[3].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=5, longName="softBodyInteraction"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(6);

		ParamDefTable[5].setChildren(Children, 1);
	}

	// SetChildren for: nodeIndex=7, longName="rigidBodyInteraction"
	{
		static Definition* Children[1];
		Children[0] = PDEF_PTR(8);

		ParamDefTable[7].setChildren(Children, 1);
	}

	mBuiltFlag = true;

}
void ExplosionEnvParameters::initStrings(void)
{
	collisionGroupName.isAllocated = true;
	collisionGroupName.buf = NULL;
	collisionGroupsMask128Name.isAllocated = true;
	collisionGroupsMask128Name.buf = NULL;
}

void ExplosionEnvParameters::initDynamicArrays(void)
{
}

void ExplosionEnvParameters::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	fluidInteraction.interaction = (const char*)"other";
	clothInteraction.interaction = (const char*)"other";
	softBodyInteraction.interaction = (const char*)"other";
	rigidBodyInteraction.interaction = (const char*)"other";

	initDynamicArrays();
	initStrings();
	initReferences();
}

void ExplosionEnvParameters::initReferences(void)
{
}

void ExplosionEnvParameters::freeDynamicArrays(void)
{
}

void ExplosionEnvParameters::freeStrings(void)
{

	if (collisionGroupName.isAllocated && collisionGroupName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionGroupName.buf);
	}

	if (collisionGroupsMask128Name.isAllocated && collisionGroupsMask128Name.buf)
	{
		mParameterizedTraits->strfree((char*)collisionGroupsMask128Name.buf);
	}
}

void ExplosionEnvParameters::freeReferences(void)
{
}

} // namespace explosion
} // namespace apex
} // namespace physx

// This code contains NVIDIA Confidential Information and is disclosed to you
// under a form of NVIDIA software license agreement provided separately to you.
//
// Notice
// NVIDIA Corporation and its licensors retain all intellectual property and
// proprietary rights in and to this software and related documentation and
// any modifications thereto. Any use, reproduction, disclosure, or
// distribution of this software and related documentation without an express
// license agreement from NVIDIA Corporation is strictly prohibited.
//
// ALL NVIDIA DESIGN SPECIFICATIONS, CODE ARE PROVIDED "AS IS.". NVIDIA MAKES
// NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT,
// MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE.
//
// Information and code furnished is believed to be accurate and reliable.
// However, NVIDIA Corporation assumes no responsibility for the consequences of use of such
// information or for any infringement of patents or other rights of third parties that may
// result from its use. No license is granted by implication or otherwise under any patent
// or patent rights of NVIDIA Corporation. Details are subject to change without notice.
// This code supersedes and replaces all information previously supplied.
// NVIDIA Corporation products are not authorized for use as critical
// components in life support devices or systems without express written approval of
// NVIDIA Corporation.
//
// Copyright (c) 2008-2013 NVIDIA Corporation. All rights reserved.

// This file was generated by NxParameterized/scripts/GenParameterized.pl
// Created: 2013.10.01 14:57:23

#include "NxFluidIosParameters.h"
#include <string.h>
#include <stdlib.h>

using namespace NxParameterized;

namespace physx
{
namespace apex
{
namespace nxfluidios
{

using namespace NxFluidIosParametersNS;

const char* const NxFluidIosParametersFactory::vptr =
    NxParameterized::getVptr<NxFluidIosParameters, NxFluidIosParameters::ClassAlignment>();

const physx::PxU32 NumParamDefs = 36;
static NxParameterized::DefinitionImpl* ParamDefTable; // now allocated in buildTree [NumParamDefs];


static const size_t ParamLookupChildrenTable[] =
{
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
};

#define TENUM(type) physx::##type
#define CHILDREN(index) &ParamLookupChildrenTable[index]
static const NxParameterized::ParamLookupNode ParamLookupTable[NumParamDefs] =
{
	{ TYPE_STRUCT, false, 0, CHILDREN(0), 35 },
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->maxParticleCount), NULL, 0 }, // maxParticleCount
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->particleRadius), NULL, 0 }, // particleRadius
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->reserveParticleCount), NULL, 0 }, // reserveParticleCount
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->restDensity), NULL, 0 }, // restDensity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->kernelRadiusMultiplier), NULL, 0 }, // kernelRadiusMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->motionLimitMultiplier), NULL, 0 }, // motionLimitMultiplier
	{ TYPE_U32, false, (size_t)(&((ParametersStruct*)0)->packetSizeMultiplier), NULL, 0 }, // packetSizeMultiplier
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->stiffness), NULL, 0 }, // stiffness
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->viscosity), NULL, 0 }, // viscosity
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->damping), NULL, 0 }, // damping
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->fadeInTime), NULL, 0 }, // fadeInTime
	{ TYPE_VEC3, false, (size_t)(&((ParametersStruct*)0)->externalAcceleration), NULL, 0 }, // externalAcceleration
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->collisionResponseCoefficient), NULL, 0 }, // collisionResponseCoefficient
	{ TYPE_ENUM, false, (size_t)(&((ParametersStruct*)0)->simulationMethod), NULL, 0 }, // simulationMethod
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->staticCollision), NULL, 0 }, // staticCollision
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->dynamicCollision), NULL, 0 }, // dynamicCollision
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->visualization), NULL, 0 }, // visualization
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->disableGravity), NULL, 0 }, // disableGravity
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->twoWayCollision), NULL, 0 }, // twoWayCollision
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->simulationEnabled), NULL, 0 }, // simulationEnabled
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->useGPU), NULL, 0 }, // useGPU
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->priorityMode), NULL, 0 }, // priorityMode
	{ TYPE_BOOL, false, (size_t)(&((ParametersStruct*)0)->projectedToPlane), NULL, 0 }, // projectedToPlane
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->staticFrictionForStaticShapes), NULL, 0 }, // staticFrictionForStaticShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->staticFrictionForDynamicShapes), NULL, 0 }, // staticFrictionForDynamicShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->restitutionForStaticShapes), NULL, 0 }, // restitutionForStaticShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dynamicFrictionForStaticShapes), NULL, 0 }, // dynamicFrictionForStaticShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->attractionForStaticShapes), NULL, 0 }, // attractionForStaticShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->restitutionForDynamicShapes), NULL, 0 }, // restitutionForDynamicShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->dynamicFrictionForDynamicShapes), NULL, 0 }, // dynamicFrictionForDynamicShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->attractionForDynamicShapes), NULL, 0 }, // attractionForDynamicShapes
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->surfaceTension), NULL, 0 }, // surfaceTension
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->collisionGroupName), NULL, 0 }, // collisionGroupName
	{ TYPE_STRING, false, (size_t)(&((ParametersStruct*)0)->forcefieldMaterialName), NULL, 0 }, // forcefieldMaterialName
	{ TYPE_F32, false, (size_t)(&((ParametersStruct*)0)->collisionDistanceMultiplier), NULL, 0 }, // collisionDistanceMultiplier
};


bool NxFluidIosParameters::mBuiltFlag = false;
NxParameterized::MutexType NxFluidIosParameters::mBuiltFlagMutex;

NxFluidIosParameters::NxFluidIosParameters(NxParameterized::Traits* traits, void* buf, PxI32* refCount) :
	NxParameters(traits, buf, refCount)
{
	//mParameterizedTraits->registerFactory(className(), &NxFluidIosParametersFactoryInst);

	if (!buf) //Do not init data if it is inplace-deserialized
	{
		initDynamicArrays();
		initStrings();
		initReferences();
		initDefaults();
	}
}

NxFluidIosParameters::~NxFluidIosParameters()
{
	freeStrings();
	freeReferences();
	freeDynamicArrays();
}

void NxFluidIosParameters::destroy()
{
	// We cache these fields here to avoid overwrite in destructor
	bool doDeallocateSelf = mDoDeallocateSelf;
	NxParameterized::Traits* traits = mParameterizedTraits;
	physx::PxI32* refCount = mRefCount;
	void* buf = mBuffer;

	this->~NxFluidIosParameters();

	NxParameters::destroy(this, traits, doDeallocateSelf, refCount, buf);
}

const NxParameterized::DefinitionImpl* NxFluidIosParameters::getParameterDefinitionTree(void)
{
	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

const NxParameterized::DefinitionImpl* NxFluidIosParameters::getParameterDefinitionTree(void) const
{
	NxFluidIosParameters* tmpParam = const_cast<NxFluidIosParameters*>(this);

	if (!mBuiltFlag) // Double-checked lock
	{
		NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);
		if (!mBuiltFlag)
		{
			tmpParam->buildTree();
		}
	}

	return(&ParamDefTable[0]);
}

NxParameterized::ErrorType NxFluidIosParameters::getParameterHandle(const char* long_name, Handle& handle) const
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

NxParameterized::ErrorType NxFluidIosParameters::getParameterHandle(const char* long_name, Handle& handle)
{
	ErrorType Ret = NxParameters::getParameterHandle(long_name, handle);
	if (Ret != ERROR_NONE)
	{
		return(Ret);
	}

	size_t offset;
	void* ptr;

	getVarPtr(handle, ptr, offset);

	if (ptr == NULL)
	{
		return(ERROR_INDEX_OUT_OF_RANGE);
	}

	return(ERROR_NONE);
}

void NxFluidIosParameters::getVarPtr(const Handle& handle, void*& ptr, size_t& offset) const
{
	ptr = getVarPtrHelper(&ParamLookupTable[0], const_cast<NxFluidIosParameters::ParametersStruct*>(&parameters()), handle, offset);
}


/* Dynamic Handle Indices */

void NxFluidIosParameters::freeParameterDefinitionTable(NxParameterized::Traits* traits)
{
	if (!traits)
	{
		return;
	}

	if (!mBuiltFlag) // Double-checked lock
	{
		return;
	}

	NxParameterized::MutexType::ScopedLock lock(mBuiltFlagMutex);

	if (!mBuiltFlag)
	{
		return;
	}

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		ParamDefTable[i].~DefinitionImpl();
	}

	traits->free(ParamDefTable);

	mBuiltFlag = false;
}

#define PDEF_PTR(index) (&ParamDefTable[index])

void NxFluidIosParameters::buildTree(void)
{

	physx::PxU32 allocSize = sizeof(NxParameterized::DefinitionImpl) * NumParamDefs;
	ParamDefTable = (NxParameterized::DefinitionImpl*)(mParameterizedTraits->alloc(allocSize));
	memset(ParamDefTable, 0, allocSize);

	for (physx::PxU32 i = 0; i < NumParamDefs; ++i)
	{
		NX_PARAM_PLACEMENT_NEW(ParamDefTable + i, NxParameterized::DefinitionImpl)(*mParameterizedTraits);
	}

	// Initialize DefinitionImpl node: nodeIndex=0, longName=""
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[0];
		ParamDef->init("", TYPE_STRUCT, "STRUCT", true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("shortDescription", "This class is parameter storage for the NxFluidIosAsset.  For the most part they mirror the NxFluidDescBase class.", true);
		ParamDefTable[0].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=1, longName="maxParticleCount"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[1];
		ParamDef->init("maxParticleCount", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("READONLY", physx::PxU64(1), true);
		HintTable[1].init("max", physx::PxU64(65535), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("READONLY", physx::PxU64(1), true);
		HintTable[1].init("max", physx::PxU64(65535), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Maximum particle count", true);
		ParamDefTable[1].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=2, longName="particleRadius"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[2];
		ParamDef->init("particleRadius", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("longDescription", "The particle radius is used to calculate the restParticlesPerMeter NxFluid parameter (RPPM = 1/(2*radius)).", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Particle radius", true);
		ParamDefTable[2].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=3, longName="reserveParticleCount"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[3];
		ParamDef->init("reserveParticleCount", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If NxFluidDesc.flags.NX_FF_PRIORITY_MODE is set the oldest particles are removed until \nthere are no more than (maxParticles - numReserveParticles) particles left. This removal\nis carried out for each simulation step, on particles which have a finite life time \n(i.e. > 0.0). The deletion guarantees a reserve of numReserveParticles particles which \ncan be added for each simulaiton step. Note that particles which have equal lifetime can \nget deleted at the same time. In order to avoid this, the particle lifetimes \ncan be varied randomly.\n\nThis parameter must be smaller than NxFluidDesc.maxParticles.\n", true);
		HintTable[1].init("shortDescription", "Defines the number of particles which are reserved for creation at runtime.", true);
		ParamDefTable[3].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=4, longName="restDensity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[4];
		ParamDef->init("restDensity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1000), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(1000), true);
		HintTable[1].init("longDescription", "Even if the particle system is simulated without particle interactions, this parameter defines indirectly in combination with restParticlesPerMeter the mass of one particle ( mass = restDensity/(restParticlesPerMeter^3) ).\nThe particle mass has an impact on the repulsion effect on emitters and actors.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Target density for the fluid (water is about 1000).", true);
		ParamDefTable[4].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=5, longName="kernelRadiusMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[5];
		ParamDef->init("kernelRadiusMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(1.2), true);
		HintTable[1].init("max", physx::PxF64(2.5), true);
		HintTable[2].init("min", physx::PxU64(1), true);
		ParamDefTable[5].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxF64(1.2), true);
		HintTable[1].init("longDescription", "This parameter is relative to the rest spacing of the particles, which is defined by the parameter restParticlesPerMeter\n( radius = kernelRadiusMultiplier/restParticlesPerMeter ).\nThis parameter should be set around 2.0 and definitely below 2.5 for optimal performance and simulation quality.\n", true);
		HintTable[2].init("max", physx::PxF64(2.5), true);
		HintTable[3].init("min", physx::PxU64(1), true);
		HintTable[4].init("shortDescription", "Radius of sphere of influence for particle interaction.", true);
		ParamDefTable[5].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=6, longName="motionLimitMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[6];
		ParamDef->init("motionLimitMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxF64(3.6), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxF64(3.6), true);
		HintTable[1].init("longDescription", "This parameter is relative to the rest spacing of the particles, which is defined by the parameter restParticlesPerMeter:\n( maximal travel distance = motionLimitMultiplier/restParticlesPerMeter ).\nDefault value is 3.6 (i.e., 3.0 * kernelRadiusMultiplier).\nThe value must not be higher than the product of packetSizeMultiplier and kernelRadiusMultiplier.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Maximal distance a particle is allowed to travel within one timestep.", true);
		ParamDefTable[6].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=7, longName="packetSizeMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[7];
		ParamDef->init("packetSizeMultiplier", TYPE_U32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(16), true);
		HintTable[1].init("min", physx::PxU64(4), true);
		HintTable[2].init("powerOf", physx::PxU64(2), true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxU64(16), true);
		HintTable[1].init("longDescription", "The spatial domain is divided into so called packets, equal sized cubes, aligned in a grid.\nThe parameter given defines the edge length of such a packet. This parameter is relative to the interaction \nradius of the particles, given as kernelRadiusMultiplier/restParticlesPerMeter.\nIt has to be a power of two, no less than 4.\n", true);
		HintTable[2].init("min", physx::PxU64(4), true);
		HintTable[3].init("powerOf", physx::PxU64(2), true);
		HintTable[4].init("shortDescription", "This parameter controls the parallelization of the fluid.", true);
		ParamDefTable[7].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=8, longName="stiffness"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[8];
		ParamDef->init("stiffness", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(16), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(16), true);
		HintTable[1].init("longDescription", "This factor linearly scales the force which acts on particles which are closer to each other than \nthe rest spacing.\n\nSetting	this parameter appropriately is crucial for the simulation.  The right value depends on many factors\nsuch as viscosity, damping, and kernelRadiusMultiplier.  Values which are too high will result in an\nunstable simulation, whereas too low values will make the fluid appear springy (the fluid\nacts more compressible).\n\nMust be positive.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "The stiffness of the particle interaction related to the pressure.", true);
		ParamDefTable[8].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=9, longName="viscosity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[9];
		ParamDef->init("viscosity", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(6), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(6), true);
		HintTable[1].init("longDescription", "Higher values will result in a honey-like behavior.  Viscosity is an effect which depends on the \nrelative velocity of neighboring particles; it reduces the magnitude of the relative velocity.\n	\nMust be positive.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "The viscosity of the fluid defines its viscous behavior.", true);
		ParamDefTable[9].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=10, longName="damping"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[10];
		ParamDef->init("damping", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "It generally reduces the velocity of the particles. Setting the damping to 0 will leave the particles unaffected.\n\nMust be nonnegative.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Velocity damping constant, which is globally applied to each particle.", true);
		ParamDefTable[10].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=11, longName="fadeInTime"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[11];
		ParamDef->init("fadeInTime", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[11].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "This feature is experimental. When a particle is created it has no influence on the simulation. \nIt takes fadeInTime until the particle has full influence. If set to zero, the particle has full influence on the simulation from start.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines a timespan for the particle fade-in.", true);
		ParamDefTable[11].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=12, longName="externalAcceleration"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[12];
		ParamDef->init("externalAcceleration", TYPE_VEC3, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("gameScale", "true", true);
		ParamDefTable[12].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("longDescription", "Useful to simulate smoke or fire.\nThis acceleration is additive to the scene gravity. The scene gravity can be turned off for the fluid, using the flag NX_FF_DISABLE_GRAVITY.\n", true);
		HintTable[2].init("shortDescription", "Acceleration (m/s^2) applied to all particles at all time steps.", true);
		ParamDefTable[12].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=13, longName="collisionResponseCoefficient"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[13];
		ParamDef->init("collisionResponseCoefficient", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxF64(0.2), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[13].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxF64(0.2), true);
		HintTable[1].init("longDescription", "Only has an effect if NX_FF_COLLISION_TWOWAY is set.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines a factor for the impulse transfer from fluid to colliding rigid bodies.", true);
		ParamDefTable[13].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=14, longName="simulationMethod"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[14];
		ParamDef->init("simulationMethod", TYPE_ENUM, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", "SPH", true);
		ParamDefTable[14].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", "SPH", true);
		HintTable[1].init("shortDescription", "NxFluidSimulationMethod flags. Defines whether or not particle interactions are considered in the simulation.", true);
		ParamDefTable[14].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */

		static const char* const EnumVals[] = { "SPH", "noInteraction", "mixedMode" };
		ParamDefTable[14].setEnumVals((const char**)EnumVals, 3);




	}

	// Initialize DefinitionImpl node: nodeIndex=15, longName="staticCollision"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[15];
		ParamDef->init("staticCollision", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		ParamDefTable[15].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Enables collision with static shapes", true);
		ParamDefTable[15].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=16, longName="dynamicCollision"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[16];
		ParamDef->init("dynamicCollision", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		ParamDefTable[16].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Enables collision with dynamic shapes", true);
		ParamDefTable[16].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=17, longName="visualization"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[17];
		ParamDef->init("visualization", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		ParamDefTable[17].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Enables debug visualization for the NxFluid", true);
		ParamDefTable[17].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=18, longName="disableGravity"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[18];
		ParamDef->init("disableGravity", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("shortDescription", "Disables scene gravity for the NxFluid", true);
		ParamDefTable[18].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=19, longName="twoWayCollision"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[19];
		ParamDef->init("twoWayCollision", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "In either case, fluid is influenced by colliding rigid bodies.\nIf NX_FF_COLLISION_TWOWAY is not set, rigid bodies are not influenced by \ncolliding pieces of fluid. Use NxFluidDesc.collisionResponseCoefficient to\ncontrol the strength of the feedback force on rigid bodies.\n", true);
		HintTable[2].init("shortDescription", "Enable/disable two way collision of fluid with the rigid body scene", true);
		ParamDefTable[19].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=20, longName="simulationEnabled"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[20];
		ParamDef->init("simulationEnabled", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Enable/disable execution of fluid simulation", true);
		ParamDefTable[20].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=21, longName="useGPU"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[21];
		ParamDef->init("useGPU", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(1), true);
		HintTable[1].init("shortDescription", "Defines whether this fluid is simulated on the GPU", true);
		ParamDefTable[21].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=22, longName="priorityMode"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[22];
		ParamDef->init("priorityMode", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "If enabled, the oldest particles are deleted to keep a certain budget for \nnew particles. Note that particles which have equal lifetime can get deleted \nat the same time. In order to avoid this, the particle lifetimes \ncan be varied randomly.\n", true);
		HintTable[2].init("shortDescription", "Enable/disable particle priority mode", true);
		ParamDefTable[22].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=23, longName="projectedToPlane"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[23];
		ParamDef->init("projectedToPlane", TYPE_BOOL, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[1];
		static Hint* HintPtrTable[1] = { &HintTable[0], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 1);

#else

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "This can be used to build 2D fluid applications, for instance. The projection\nplane is defined by the parameter NxFluidDesc.projectionPlane.\n", true);
		HintTable[2].init("shortDescription", "Defines whether the particles of this fluid should be projected to a plane", true);
		ParamDefTable[23].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=24, longName="staticFrictionForStaticShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[24];
		ParamDef->init("staticFrictionForStaticShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines the static friction of the fluid regarding the surface of a static shape.", true);
		ParamDefTable[24].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=25, longName="staticFrictionForDynamicShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[25];
		ParamDef->init("staticFrictionForDynamicShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[25].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines the static friction of the fluid regarding the surface of a dynamic shape.", true);
		ParamDefTable[25].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=26, longName="restitutionForStaticShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[26];
		ParamDef->init("restitutionForStaticShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[26].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("longDescription", "Must be between 0 and 1.\n\nA value of 0 causes the colliding particle to get a zero velocity component in the\ndirection of the surface normal of the static shape at the collision location; i.e.\nit will not bounce.\n\nA value of 1 causes a particle's velocity component in the direction of the surface normal to invert;\ni.e. the particle bounces off the surface with the same velocity magnitude as it had before collision. \n(Caution: values near 1 may have a negative impact on stability)\n", true);
		HintTable[2].init("max", physx::PxU64(1), true);
		HintTable[3].init("min", physx::PxU64(0), true);
		HintTable[4].init("shortDescription", "Defines the restitution coefficient used for collisions of the fluid particles with static shapes.", true);
		ParamDefTable[26].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=27, longName="dynamicFrictionForStaticShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[27];
		ParamDef->init("dynamicFrictionForStaticShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[27].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("longDescription", "Must be between 0 and 1.\n\nA value of 1 will cause the particle to lose its velocity tangential to\nthe surface normal of the shape at the collision location; i.e. it will not slide\nalong the surface.\n\nA value of 0 will preserve the particle's velocity in the tangential surface\ndirection; i.e. it will slide without resistance on the surface.\n", true);
		HintTable[2].init("max", physx::PxU64(1), true);
		HintTable[3].init("min", physx::PxU64(0), true);
		HintTable[4].init("shortDescription", "Defines the dynamic friction of the fluid regarding the surface of a static shape.", true);
		ParamDefTable[27].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=28, longName="attractionForStaticShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[28];
		ParamDef->init("attractionForStaticShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("hidden", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[28].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("hidden", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines the restitution coefficient used for collisions of the fluid particles with dynamic shapes.", true);
		ParamDefTable[28].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=29, longName="restitutionForDynamicShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[29];
		ParamDef->init("restitutionForDynamicShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[29].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxF64(0.5), true);
		HintTable[1].init("longDescription", "Must be between 0 and 1.\n", true);
		HintTable[2].init("max", physx::PxU64(1), true);
		HintTable[3].init("min", physx::PxU64(0), true);
		HintTable[4].init("shortDescription", "Defines the restitution coefficient used for collisions of the fluid particles with dynamic shapes.", true);
		ParamDefTable[29].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=30, longName="dynamicFrictionForDynamicShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[30];
		ParamDef->init("dynamicFrictionForDynamicShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("max", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[30].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[5];
		static Hint* HintPtrTable[5] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], &HintTable[4], };
		HintTable[0].init("defaultValue", physx::PxF64(0.05), true);
		HintTable[1].init("longDescription", "Must be between 0 and 1.\n", true);
		HintTable[2].init("max", physx::PxU64(1), true);
		HintTable[3].init("min", physx::PxU64(0), true);
		HintTable[4].init("shortDescription", "Defines the dynamic friction of the fluid regarding the surface of a dynamic shape.", true);
		ParamDefTable[30].setHints((const NxParameterized::Hint**)HintPtrTable, 5);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=31, longName="attractionForDynamicShapes"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[31];
		ParamDef->init("attractionForDynamicShapes", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[3];
		static Hint* HintPtrTable[3] = { &HintTable[0], &HintTable[1], &HintTable[2], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("hidden", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		ParamDefTable[31].setHints((const NxParameterized::Hint**)HintPtrTable, 3);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("hidden", physx::PxU64(1), true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "Defines the strength of attraction between the particles and the dynamic rigid bodies on collision.", true);
		ParamDefTable[31].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=32, longName="surfaceTension"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[32];
		ParamDef->init("surfaceTension", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("min", physx::PxU64(0), true);
		ParamDefTable[32].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("defaultValue", physx::PxU64(0), true);
		HintTable[1].init("longDescription", "Higher values will result in smoother surfaces.\nMust be nonnegative.\n", true);
		HintTable[2].init("min", physx::PxU64(0), true);
		HintTable[3].init("shortDescription", "The surfaceTension of the fluid defines an attractive force between particles.", true);
		ParamDefTable[32].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=33, longName="collisionGroupName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[33];
		ParamDef->init("collisionGroupName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If specified, this name will be dereferenced at runtime through the named resource provider to resolve a collision \ngroup ID using both the NSCollisionGroup and NSCollisionGroup128 namespaces.  If the application only wants to use\nNxGroupIDs then it may ignore the callback for the NSCollisionGroup128 namespace.\n", true);
		HintTable[1].init("shortDescription", "Name of NxFluid collision group.", true);
		ParamDefTable[33].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=34, longName="forcefieldMaterialName"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[34];
		ParamDef->init("forcefieldMaterialName", TYPE_STRING, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

#else

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("longDescription", "If specified, this name will be dereferenced at runtime through the named resource provider to resolve an actual forcefield material for the name.\n", true);
		HintTable[1].init("shortDescription", "Name of NxFluid forcefield material.", true);
		ParamDefTable[34].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// Initialize DefinitionImpl node: nodeIndex=35, longName="collisionDistanceMultiplier"
	{
		NxParameterized::DefinitionImpl* ParamDef = &ParamDefTable[35];
		ParamDef->init("collisionDistanceMultiplier", TYPE_F32, NULL, true);

#ifdef NX_PARAMETERIZED_HIDE_DESCRIPTIONS

		static HintImpl HintTable[2];
		static Hint* HintPtrTable[2] = { &HintTable[0], &HintTable[1], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("min", physx::PxF64(1e-006), true);
		ParamDefTable[35].setHints((const NxParameterized::Hint**)HintPtrTable, 2);

#else

		static HintImpl HintTable[4];
		static Hint* HintPtrTable[4] = { &HintTable[0], &HintTable[1], &HintTable[2], &HintTable[3], };
		HintTable[0].init("gameScale", "true", true);
		HintTable[1].init("longDescription", "For the actual distance, this parameter is divided by the rest spacing of the particles, which is defined by the parameter\nrestParticlesPerMeter: ( distance = collisionDistanceMultiplier/restParticlesPerMeter ).\n\nIt has to be positive and not higher than packetSizeMultiplier*kernelRadiusMultiplier.\nDefault value is 0.12 (i.e., 0.1 * kernelRadiusMultiplier).\n", true);
		HintTable[2].init("min", physx::PxF64(1e-006), true);
		HintTable[3].init("shortDescription", "Defines the distance between particles and collision geometry, which is maintained during simulation.", true);
		ParamDefTable[35].setHints((const NxParameterized::Hint**)HintPtrTable, 4);

#endif /* NX_PARAMETERIZED_HIDE_DESCRIPTIONS */





	}

	// SetChildren for: nodeIndex=0, longName=""
	{
		static Definition* Children[35];
		Children[0] = PDEF_PTR(1);
		Children[1] = PDEF_PTR(2);
		Children[2] = PDEF_PTR(3);
		Children[3] = PDEF_PTR(4);
		Children[4] = PDEF_PTR(5);
		Children[5] = PDEF_PTR(6);
		Children[6] = PDEF_PTR(7);
		Children[7] = PDEF_PTR(8);
		Children[8] = PDEF_PTR(9);
		Children[9] = PDEF_PTR(10);
		Children[10] = PDEF_PTR(11);
		Children[11] = PDEF_PTR(12);
		Children[12] = PDEF_PTR(13);
		Children[13] = PDEF_PTR(14);
		Children[14] = PDEF_PTR(15);
		Children[15] = PDEF_PTR(16);
		Children[16] = PDEF_PTR(17);
		Children[17] = PDEF_PTR(18);
		Children[18] = PDEF_PTR(19);
		Children[19] = PDEF_PTR(20);
		Children[20] = PDEF_PTR(21);
		Children[21] = PDEF_PTR(22);
		Children[22] = PDEF_PTR(23);
		Children[23] = PDEF_PTR(24);
		Children[24] = PDEF_PTR(25);
		Children[25] = PDEF_PTR(26);
		Children[26] = PDEF_PTR(27);
		Children[27] = PDEF_PTR(28);
		Children[28] = PDEF_PTR(29);
		Children[29] = PDEF_PTR(30);
		Children[30] = PDEF_PTR(31);
		Children[31] = PDEF_PTR(32);
		Children[32] = PDEF_PTR(33);
		Children[33] = PDEF_PTR(34);
		Children[34] = PDEF_PTR(35);

		ParamDefTable[0].setChildren(Children, 35);
	}

	mBuiltFlag = true;

}
void NxFluidIosParameters::initStrings(void)
{
	collisionGroupName.isAllocated = true;
	collisionGroupName.buf = NULL;
	forcefieldMaterialName.isAllocated = true;
	forcefieldMaterialName.buf = NULL;
}

void NxFluidIosParameters::initDynamicArrays(void)
{
}

void NxFluidIosParameters::initDefaults(void)
{

	freeStrings();
	freeReferences();
	freeDynamicArrays();
	maxParticleCount = physx::PxU32(4096);
	particleRadius = physx::PxF32(1.0f);
	reserveParticleCount = physx::PxU32(0);
	restDensity = physx::PxF32(1000.0f);
	kernelRadiusMultiplier = physx::PxF32(1.2f);
	motionLimitMultiplier = physx::PxF32(3.6f);
	packetSizeMultiplier = physx::PxU32(16);
	stiffness = physx::PxF32(16.0f);
	viscosity = physx::PxF32(6.0f);
	damping = physx::PxF32(0.0f);
	fadeInTime = physx::PxF32(0.0f);
	externalAcceleration = physx::PxVec3(init(0, 0, 0));
	collisionResponseCoefficient = physx::PxF32(0.2f);
	simulationMethod = (const char*)"SPH";
	staticCollision = bool(1);
	dynamicCollision = bool(1);
	visualization = bool(1);
	disableGravity = bool(0);
	twoWayCollision = bool(0);
	simulationEnabled = bool(1);
	useGPU = bool(1);
	priorityMode = bool(0);
	projectedToPlane = bool(0);
	staticFrictionForStaticShapes = physx::PxF32(0.05f);
	staticFrictionForDynamicShapes = physx::PxF32(0.5f);
	restitutionForStaticShapes = physx::PxF32(0.5f);
	dynamicFrictionForStaticShapes = physx::PxF32(0.05f);
	attractionForStaticShapes = physx::PxF32(0.0f);
	restitutionForDynamicShapes = physx::PxF32(0.5f);
	dynamicFrictionForDynamicShapes = physx::PxF32(0.05f);
	attractionForDynamicShapes = physx::PxF32(0.0f);
	surfaceTension = physx::PxF32(0.0f);
	collisionDistanceMultiplier = physx::PxF32(0.5f);

	initDynamicArrays();
	initStrings();
	initReferences();
}

void NxFluidIosParameters::initReferences(void)
{
}

void NxFluidIosParameters::freeDynamicArrays(void)
{
}

void NxFluidIosParameters::freeStrings(void)
{

	if (collisionGroupName.isAllocated && collisionGroupName.buf)
	{
		mParameterizedTraits->strfree((char*)collisionGroupName.buf);
	}

	if (forcefieldMaterialName.isAllocated && forcefieldMaterialName.buf)
	{
		mParameterizedTraits->strfree((char*)forcefieldMaterialName.buf);
	}
}

void NxFluidIosParameters::freeReferences(void)
{
}

} // namespace nxfluidios
} // namespace apex
} // namespace physx

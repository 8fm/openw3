/**************************************************************************

Filename    :   GFxKoreanIME.cpp
Content     :   Core implementation of Korean IME
Created     :   Feb 27, 2008
Authors     :   A. Mohan, Artem Bolgar

Copyright   :   Copyright 2014 Autodesk, Inc. All Rights reserved.

Use of this software is subject to the terms of the Autodesk license
agreement provided at the time of installation or download, or which
otherwise accompanies this software in either electronic or hard copy form.

**************************************************************************/
#ifndef UNICODE
// Unicode version must be used if an app uses PeekMessageW function 
// for main message loop.
// Non-Unicode version might be used if an app uses PeekMessageA function.
// However, the proper system locale should be set (Korean), either 
// through Control Panel or using AppLocale application.
// The default implementation is Unicode-base.
#define UNICODE
#else
//#undef UNICODE
#endif //UNICODE
#include "Kernel/SF_Types.h"

#if defined(SF_OS_WIN32) && defined(GFX_ENABLE_BUILTIN_KOREAN_IME) && !defined(SF_NO_IME_SUPPORT)
#include "GFx/GFx_PlayerImpl.h"
# pragma warning(disable : 4005)
#define ReplaceText ReplaceTextA
#include "GFx/GFx_TextField.h"
# pragma warning(default : 4005)
#include "GFxIMEImm32Dll.h"

namespace Scaleform { namespace GFx {

unsigned MovieImpl::HandleKoreanIME(const IMEEvent& imeEvent)
{
    // check if Imm32.dll is available.
    if (!Imm32Dll.IsAvailable())
    {
        UInt32 errorCode;
        if ((errorCode = Imm32Dll.GetErrorCode()) != 0)
        {
            Log* plog = GetLog();
            if (plog)
                plog->LogError("IMM32.DLL is not available, error code = 0x%X", errorCode);
            Imm32Dll.ResetErrorCode(); 
        }
		return MovieImpl::HE_NotHandled; // no Imm32 is available, aborting....
    }

    const IMEWin32Event& winEvt = static_cast<const IMEWin32Event&>(imeEvent);
    if (winEvt.IMEEvtType != IMEEvent::IME_PreProcessKeyboard)
    {
        HWND hWND = (HWND)winEvt.hWND;
        union {
            HKL     hkl;
            UPInt   langId;
        } un;
        un.hkl = GetKeyboardLayout(0); 
        if ((un.langId & 0xFFFF) == MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN)) //korean
        {
            //printf("!!! %X\n", un.langId);
            switch(winEvt.Message)
            {
            case WM_IME_STARTCOMPOSITION:
                {
                    Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
                        if (ptextFld->IsIMEEnabled())
                        {
                            // first of all, if we have an active selection - remove it

							ptextFld->ReplaceText(L"", ptextFld->GetBeginIndex(), 
                                ptextFld->GetEndIndex());

                            ptextFld->CreateCompositionString();
                            //ptextFld->SetCompositionStringHighlighting(true);
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }

            case WM_IME_COMPOSITION:
                {
					Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
						if (ptextFld->IsIMEEnabled())
						{
                            UPInt keyCode = winEvt.WParam, info = winEvt.LParam;
                            //int options = winEvt.Options;
                            if (info & GCS_RESULTSTR) 
                            {
                                HIMC hIMC = Imm32Dll.ImmGetContext(hWND);
                                // Get the size of the result string.
                                DWORD dwSize = Imm32Dll.ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);

                                wchar_t lpstr[20]; // very unlikely, Korean composition string is longer than 20 chars 
                                                   // (or even, longer than 2 chars). Anyway we have an ASSERT to 
                                                   // catch any weird situations.
#ifdef UNICODE
                                SF_ASSERT(sizeof(lpstr) >= (dwSize+sizeof(wchar_t)));

                                // Get the result string that is generated by IME into lpstr.
                                LONG res = Imm32Dll.ImmGetCompositionStringW(hIMC, GCS_RESULTSTR, lpstr, dwSize);
                                if (res != IMM_ERROR_NODATA && res != IMM_ERROR_GENERAL)
                                {
                                    lpstr[dwSize/2] = 0; //dwSize is in bytes
                                    ptextFld->SetWideCursor(false);
                                }
#else
                                char mbstr[40];
                                SF_ASSERT(sizeof(mbstr) >= (dwSize+sizeof(mbstr[0])));

                                // Get the result string that is generated by IME into lpstr.
                                LONG res = Imm32Dll.ImmGetCompositionStringA(hIMC, GCS_RESULTSTR, mbstr, dwSize);
                                if (res != IMM_ERROR_NODATA && res != IMM_ERROR_GENERAL)
                                {
                                    mbstr[dwSize] = 0;
                                    ptextFld->SetWideCursor(false);

                                    int cn = MultiByteToWideChar(CP_ACP, 0, mbstr, dwSize, lpstr, sizeof(lpstr));
                                    SF_ASSERT(sizeof(lpstr) >= cn);
                                    lpstr[cn] = 0;
                                }
#endif

                                Imm32Dll.ImmReleaseContext(hWND, hIMC);
                                ptextFld->CommitCompositionString(lpstr, SF_MAX_UPINT);
                                //ptextFld->SetCompositionStringHighlighting(true, SF_MAX_UPINT);
                            }
                            if ((info & CS_INSERTCHAR) && (info & CS_NOMOVECARET) )
                            {
                                // This is for Korean- a character can change shape depending upon what is typed next, 
                                // so don't advance caret position. Move Caret when the character is finalized.
                                // The "replace" flag is used to indicate whether we should replace the current character 
                                // or not-In case of korean, when the user begins to type, the character should be 
                                // inserted at the current location, but subsequent modifications to the same character 
                                // should replace the existing character.
                                wchar_t lpstr[2];
                                lpstr[0] = (wchar_t)keyCode; lpstr[1] = 0;

                                ptextFld->SetWideCursor(true);

                                UPInt pos = ptextFld->GetCaretIndex();
                                ptextFld->SetCompositionStringPosition(pos);
                                ptextFld->SetCompositionStringText(lpstr, 1);
                                ptextFld->SetCursorInCompositionString(0);
                            }
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }

            case WM_IME_ENDCOMPOSITION:
                {
					Ptr<InteractiveObject> pfocusedCh = GetFocusedCharacter(0);
					if (pfocusedCh && pfocusedCh->GetType() == TextFieldDef::TextField)
					{
						Ptr<TextField> ptextFld = static_cast<TextField*>(pfocusedCh.GetPtr());
						if (ptextFld->IsIMEEnabled())
						{
                            ptextFld->SetWideCursor(false);
                            ptextFld->ClearCompositionString();
                        }
                    }
                    return MovieImpl::HE_NoDefaultAction;
                }
            case WM_IME_CHAR:
                // This message should not be passed down to DefWinProc otherwise it will
                // generate WM_CHAR messages which will cause text duplication.
                return MovieImpl::HE_NoDefaultAction;
            }
        }
    }
    return MovieImpl::HE_NotHandled;
}
}}

#endif // SF_NO_BUILTIN_KOREAN_IME

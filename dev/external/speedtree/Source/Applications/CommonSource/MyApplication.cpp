///////////////////////////////////////////////////////////////////////
//
//	All source files prefixed with "My" indicate an example implementation,
//	meant to detail what an application might (and, in most cases, should)
//	do when interfacing with the SpeedTree SDK.  These files constitute
//	the bulk of the SpeedTree Reference Application and are not part
//	of the official SDK, but merely example or "reference" implementations.
//
//	*** INTERACTIVE DATA VISUALIZATION (IDV) CONFIDENTIAL AND PROPRIETARY INFORMATION ***
//
//	This software is supplied under the terms of a license agreement or
//	nondisclosure agreement with Interactive Data Visualization, Inc. and
//  may not be copied, disclosed, or exploited except in accordance with
//  the terms of that agreement.
//
//      Copyright (c) 2003-2014 IDV, Inc.
//      All rights reserved in all media.
//
//      IDV, Inc.
//      http://www.idvinc.com


///////////////////////////////////////////////////////////////////////
//  Preprocessor

// specify the entire scene's coordinate system (comment all out for default right-handed, z-up)
#define SPEEDTREE_COORD_SYS_RHCS_ZUP // default (same as not #defining any coord sys)
//#define SPEEDTREE_COORD_SYS_RHCS_YUP
//#define SPEEDTREE_COORD_SYS_LHCS_ZUP
//#define SPEEDTREE_COORD_SYS_LHCS_YUP

// used in diagnostics to ensure that not floating point exceptions are being generated by the SpeedTree SDK
//#if defined(_WIN32) && !defined(NDEBUG)
//	#define SPEEDTREE_FLOATING_POINT_EXCEPTIONS	(EM_OVERFLOW | EM_ZERODIVIDE | EM_DENORMAL/* | EM_INVALID | EM_UNDERFLOW*/)
//#endif

#include "MyApplication.h"
#include "MyConfigFile.h"
#include "Core/Random.h"
#include "Utilities/Utility.h"
#include "MyPopulate.h"
#include "Core/Timer.h"
#include <time.h>
#ifdef SPEEDTREE_OPENGL
	#include "Utilities/glfw/include/GL/glfw.h"
#endif
#include "Testing.h"
#ifdef SPEEDTREE_INTEL_GPA
	#pragma comment(lib, "gpasdk_sr_2008.lib")
#endif
using namespace SpeedTree;


///////////////////////////////////////////////////////////////////////
//  Constants

const CFixedString c_strSavedCameraFilename = "SavedCameras.txt";
const st_float32 c_fWindPrerollTime = 10.0f;


///////////////////////////////////////////////////////////////////////
//  CMyApplication::CMyApplication

CMyApplication::CMyApplication( ) :
	  m_bExplicitMsaaResolveEnabled(false)
	, m_bCameraChanged(true)
	#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
		, m_bIgnoreNextMouseMove(false)
	#endif
	, m_pCurrentNavigation(NULL)
	, m_bFollowTerrain(true)
	, m_fCurrentTime(0.0f)
	, m_fFrameTime(0.0f)
	, m_fTimeMarker(0.0f)
	, m_nFrameIndex(0)
	, m_bRenderTrees(true)
	, m_bRenderBillboards(true)
	, m_bRenderGrass(true)
	, m_bRenderOverlays(true)
	, m_eTransparentTextureRenderMode(TRANS_TEXTURE_ALPHA_TESTING)
	, m_bRenderTransparentMultiPass(false)
	, m_bHandleCollision(true)
	, m_bDepthBlur(true)
	, m_nBloomDisplayMode(BLOOM_DISPLAY_MODE_FULL)
	, m_sLightAdjuster(CMyParamAdjuster::DIRECTION)
	, m_sWindAdjuster(CMyParamAdjuster::DIRECTION)
	, m_sLodAdjuster(CMyParamAdjuster::FLOAT)
	, m_bReadyToRender(false)
	, m_fAspectRatio(16.0f / 9.0f)
	#ifdef _WIN32
		, m_hWindow(NULL)
	#endif
{
	#ifdef SPEEDTREE_FLOATING_POINT_EXCEPTIONS
		_clearfp( );
		DWORD FPOld = _controlfp(0, 0);
		DWORD FPNew = FPOld & ~(SPEEDTREE_FLOATING_POINT_EXCEPTIONS);
		_controlfp(FPNew, MCW_EM);
	#endif

	#ifdef SPEEDTREE_COORD_SYS_RHCS_YUP
		CCoordSys::SetCoordSys(CCoordSys::COORD_SYS_RIGHT_HANDED_Y_UP);
	#elif defined(SPEEDTREE_COORD_SYS_LHCS_ZUP)
		CCoordSys::SetCoordSys(CCoordSys::COORD_SYS_LEFT_HANDED_Z_UP);
	#elif defined(SPEEDTREE_COORD_SYS_LHCS_YUP)
		CCoordSys::SetCoordSys(CCoordSys::COORD_SYS_LEFT_HANDED_Y_UP);
	#else
		// SPEEDTREE_COORD_SYS_RHCS_ZUP
	#endif

	st_assert(CCoordSys::ConvertToStd(CCoordSys::ConvertFromStd(1.0f, 2.0f, 3.0f)) == Vec3(1.0f, 2.0f, 3.0f), "Run-time coordinate conversion sanity test failed");

	UpdateLightDir( );

	#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
		m_pCurrentNavigation = &m_cMyMouseNavigation;
		m_anMousePos[0] = m_anMousePos[1] = 0;
	#else
		m_pCurrentNavigation = &m_cOtherNavigation;
	#endif

	m_aGrassLayers.SetHeapDescription("CMyApplication::m_aGrassLayers");
	m_aRandomGrassInstancesBuffer.SetHeapDescription("CMyApplication::m_aRandomGrassInstancesBuffer");

	m_aAllBaseTreesAndGrass.SetHeapDescription("CMyApplication::m_aAllBaseTreesAndGrass");
	m_aAllBaseTrees.SetHeapDescription("CMyApplication::m_aAllBaseTrees");
	m_aAllBaseGrasses.SetHeapDescription("CMyApplication::m_aAllBaseGrasses");

	srand(static_cast<unsigned int>(time(NULL)));
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::~CMyApplication

CMyApplication::~CMyApplication( )
{
	// delete base trees
	const TTreePtrArray& aBaseTrees = m_cAllTreeInstances.GetBaseTrees( );
	for (size_t i = 0; i < aBaseTrees.size( ); ++i)
	{
		CTreeRender* pTree = (CTreeRender*) aBaseTrees[i];
		st_delete<CTreeRender>(pTree);
	}

	#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
		// save cameras
		m_cMyMouseNavigation.SaveCameraFile(m_cConfigFile.m_sNavigation.m_strCameraFilename);
	#endif

	SetGamma(1.0f);
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::ParseCmdLine

st_bool CMyApplication::ParseCmdLine(st_int32 argc, char* argv[])
{
	if (!CMyCmdLineParser::Parse(argc, argv, m_sCmdLine))
		Warning("Command-line option malformed or not set - using default values to fill in the gaps\n");

	return true;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::Init

st_bool CMyApplication::Init(void)
{
	st_bool bSuccess = false;

	// call to Authorize() to activate an evaluation or lease license
	//#error Please enter your evaluation key. When building a full version, this section may be commented out.
	CCore::Authorize("E477B72631CD3929");

	// check for authorized SDK before proceeding (failure is fatal)
	if (!CCore::IsAuthorized( ))
	{
		Error("The SpeedTree SDK has not been authorized; enter your company's key in the call to CCore::Authorize() in app source");
		return false;
	}

	if (m_cConfigFile.Load(m_sCmdLine.m_strSfcFilename, &m_sCmdLine))
	{
		SForestRenderInfo sRenderInfo;

		// app-level
		sRenderInfo.m_sAppState.m_bMultisampling = (m_sCmdLine.m_nNumSamples > 1);
		sRenderInfo.m_sAppState.m_bAlphaToCoverage = (m_sCmdLine.m_nNumSamples > 1);
		sRenderInfo.m_sAppState.m_bDepthPrepass = m_cConfigFile.m_sForwardRender.m_bDepthOnlyPrepass;
		sRenderInfo.m_sAppState.m_bDeferred = m_cConfigFile.m_sDeferredRender.m_bEnabled;
		if (m_cConfigFile.m_sShadows.m_bEnabled)
			sRenderInfo.m_sAppState.m_eShadowConfig = SRenderState::EShadowConfig(SRenderState::SHADOW_CONFIG_OFF + m_cConfigFile.m_sShadows.m_nNumMaps);
		else
			sRenderInfo.m_sAppState.m_eShadowConfig = SRenderState::SHADOW_CONFIG_OFF;
		// general rendering
		sRenderInfo.m_nMaxAnisotropy = m_sCmdLine.m_nMaxAnisotropy;
		sRenderInfo.m_bDepthOnlyPrepass = m_cConfigFile.m_sForwardRender.m_bDepthOnlyPrepass;
		sRenderInfo.m_fNearClip = m_cConfigFile.m_sWorld.m_fNearClip;
		sRenderInfo.m_fFarClip = m_cConfigFile.m_sWorld.m_fFarClip;
		// lighting
		SSimpleMaterial sLightMaterial;
		sLightMaterial.m_vAmbient = m_cConfigFile.m_sLighting.m_vAmbient;
		sLightMaterial.m_vDiffuse = m_cConfigFile.m_sLighting.m_vDiffuse;
		sLightMaterial.m_vSpecular = m_cConfigFile.m_sLighting.m_vSpecular;
		sLightMaterial.m_vTransmission = m_cConfigFile.m_sLighting.m_vTransmission;
		sRenderInfo.m_sLightMaterial = sLightMaterial;
		// other lighting
		sRenderInfo.m_strImageBasedAmbientLightingFilename = m_cConfigFile.m_sLighting.m_sImageBasedAmbientLighting.m_strFilename;
		// texture/alpha
		sRenderInfo.m_bTexturingEnabled = true;
		sRenderInfo.m_fTextureAlphaScalar3d = m_cConfigFile.m_sWorld.m_fAlphaTestScalar3d;
		sRenderInfo.m_fTextureAlphaScalarGrass = m_cConfigFile.m_sWorld.m_fAlphaTestScalarGrass;
		sRenderInfo.m_fTextureAlphaScalarBillboards = m_cConfigFile.m_sWorld.m_fAlphaTestScalarBillboards;
		// fog
		sRenderInfo.m_vFogColor = m_cConfigFile.m_sFog.m_vColor;
		sRenderInfo.m_fFogStartDistance = m_cConfigFile.m_sFog.m_afLinear[0];
		sRenderInfo.m_fFogEndDistance = m_cConfigFile.m_sFog.m_afLinear[1];
		// sky
		sRenderInfo.m_vSkyColor = m_cConfigFile.m_sSky.m_vColor;
		sRenderInfo.m_fSkyFogMin = m_cConfigFile.m_sSky.m_afFogRange[0];
		sRenderInfo.m_fSkyFogMax = m_cConfigFile.m_sSky.m_afFogRange[1];
		// sun
		sRenderInfo.m_vSunColor = m_cConfigFile.m_sSky.m_vSunColor;
		sRenderInfo.m_fSunSize = m_cConfigFile.m_sSky.m_fSunSize;
		sRenderInfo.m_fSunSpreadExponent = m_cConfigFile.m_sSky.m_fSunSpreadExponent;
		// shadows
		sRenderInfo.m_bShadowsEnabled = m_cConfigFile.m_sShadows.m_bEnabled;
		sRenderInfo.m_nShadowsNumMaps = m_cConfigFile.m_sShadows.m_nNumMaps;
		sRenderInfo.m_nShadowsResolution = m_cConfigFile.m_sShadows.m_nResolution;
		memcpy(sRenderInfo.m_afShadowMapRanges, m_cConfigFile.m_sShadows.m_afMapRanges, sizeof(m_cConfigFile.m_sShadows.m_afMapRanges));
		sRenderInfo.m_fShadowFadePercent = m_cConfigFile.m_sShadows.m_fFadePercent;
		m_cForest.SetRenderInfo(sRenderInfo);

		#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
			// cameras
			m_cMyMouseNavigation.LoadCameraFile(m_cConfigFile.m_sNavigation.m_strCameraFilename);
		#endif

		// set transparent texture render mode based on multisampling
		if (m_sCmdLine.m_nNumSamples > 1)
			m_eTransparentTextureRenderMode = TRANS_TEXTURE_ALPHA_TO_COVERAGE;
		else
			m_eTransparentTextureRenderMode = TRANS_TEXTURE_ALPHA_TESTING;

		// lighting
		m_cForest.SetLightDir(m_cConfigFile.m_sLighting.m_vDirection);

		// parameters controlled via mouse
		m_sLightAdjuster.SetInitDir(m_cConfigFile.m_sLighting.m_vDirection);
		m_sWindAdjuster.SetInitDir(m_cConfigFile.m_sWind.m_vDirection);
		m_sLodAdjuster.SetInitFloat(1.0f, 0.1f, 3.0f);
		
		// params are: (init, min_clamp, max_clamp)
		m_asHandTuneAdjuster[0].SetInitFloat(1.0f, -990.0f, 990.0f);//, 0.0000125f);
		m_asHandTuneAdjuster[1].SetInitFloat(0.0f, -990.0f, 990.0f, 0.01f);//, 0.00000125f);
		m_asHandTuneAdjuster[2].SetInitFloat(0.00003f, -99.0f, 99.0f, 0.00000125f);
		m_asHandTuneAdjuster[3].SetInitFloat(1.0f, -99.0f, 99.0f);

		const Vec3 c_vStartingCameraPos(m_cConfigFile.m_sNavigation.m_afStartingPosition[0], m_cConfigFile.m_sNavigation.m_afStartingPosition[1], 0.0f);
		m_pCurrentNavigation->SetCameraPos(CCoordSys::ConvertFromStd(c_vStartingCameraPos));
		m_pCurrentNavigation->AdjustAzimuth(m_cConfigFile.m_sNavigation.m_afStartingAzimuthAndPitch[0]);
		m_pCurrentNavigation->AdjustPitch(m_cConfigFile.m_sNavigation.m_afStartingAzimuthAndPitch[1]);

		UpdateLightDir( );

		bSuccess = true;

		PrintSpeedTreeErrors("CMyApplication::Init");
	}
	else
	{
		CString strErrorReport = CString::Format("Error parsing SFC file [%s]:\n\n", m_sCmdLine.m_strSfcFilename.c_str( ));
		for (size_t i = 0; i < m_cConfigFile.GetErrors( ).size( ); ++i)
			strErrorReport += CString("    ") + CString(m_cConfigFile.GetErrors( )[i].c_str( )) + "\n";
		Error(strErrorReport.c_str( ));
	}

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::ReadyToRender

st_bool CMyApplication::ReadyToRender(void) const
{
	return m_bReadyToRender;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::InitGfx

st_bool CMyApplication::InitGfx(void)
{
	m_bReadyToRender = false;

	// forest gfx initialization is minimal, most of the substantive gfx init is in the tree models
	if (!m_cForest.InitGfx( ))
	{
		PrintSpeedTreeErrors( );
		Error("The SpeedTree Render Interface failed to initialize; check the console for an error report");
	}
	else
	{
		m_bReadyToRender = true;

		if (m_cConfigFile.m_sDeferredRender.m_bEnabled)
			m_bReadyToRender &= InitDeferredSupportGfx( );
		else
			m_bReadyToRender &= InitForwardSupportGfx( );

		m_bReadyToRender &= InitPostEffectsGfx( );

		m_bReadyToRender &= m_cShadowSystem.Init(m_cConfigFile);
	}

	// set terrain heap reserves (needed before forest can be populated -- dependent on terrain load)
	SHeapReserves sTerrainHeapReserves;
	m_cAllTreeInstances.ComputeHeapReserveGuess(sTerrainHeapReserves, m_cConfigFile, m_fAspectRatio);
	m_cTerrain.SetHeapReserves(sTerrainHeapReserves);
	m_sTerrainCullResults.SetHeapReserves(sTerrainHeapReserves);

	// init supporting systems (terrain & sky, not part of SpeedTree, just support)
	m_bReadyToRender &= m_cTerrain.Init(m_cConfigFile, m_sCmdLine);
	m_bReadyToRender &= m_cSky.Init(m_cConfigFile);

	// overlays
	m_bReadyToRender &= m_cOverlays.InitGfx(m_sCmdLine, m_cConfigFile);

	// set clip space range (important for frustum/culling computations in the Forest library)
	#ifdef SPEEDTREE_OPENGL
		CCore::SetClipSpaceDepthRange(-1.0f, 1.0f);
	#else
		CCore::SetClipSpaceDepthRange(0.0f, 1.0f);
	#endif

	if (m_bReadyToRender && PopulateForest( ))
	{
		// reserves
		SetCullCellSizes( );
		SetHeapReserves( );

		// compile arrays of trees, grass, and then trees+grasses
		m_aAllBaseTrees.reserve(m_cAllTreeInstances.GetBaseTrees( ).size( ));
		m_aAllBaseGrasses.reserve(m_aGrassLayers.size( ));
		m_aAllBaseTreesAndGrass.reserve(m_cAllTreeInstances.GetBaseTrees( ).size( ) + m_aGrassLayers.size( ));

		// add trees
		for (size_t i = 0; i < m_cAllTreeInstances.GetBaseTrees( ).size( ); ++i)
		{
			m_aAllBaseTrees.push_back((CTreeRender*) m_cAllTreeInstances.GetBaseTrees( )[i]);
			m_aAllBaseTreesAndGrass.push_back(m_cAllTreeInstances.GetBaseTrees( )[i]);
		}

		// add grasses
		for (st_int32 i = 0; i < st_int32(m_aGrassLayers.size( )); ++i)
		{
			m_aAllBaseGrasses.push_back((CTreeRender*) m_aGrassLayers[i].GetBaseGrass( ));
			m_aAllBaseTreesAndGrass.push_back(m_aGrassLayers[i].GetBaseGrass( ));
		}

		// cull results containers
		m_cVisibleTreesFromCamera.InitGfx(m_aAllBaseTrees);
		if (m_cConfigFile.m_sShadows.m_bEnabled)
			m_cShadowSystem.InitGfx(m_cConfigFile, m_aAllBaseTrees);

		// wind
		m_cForest.WindEnable(m_cConfigFile.m_sWind.m_bEnabled);
		m_cForest.WindEnableGusting(m_aAllBaseTreesAndGrass, m_cConfigFile.m_sWind.m_bGusting);
		m_cForest.WindSetStrength(m_aAllBaseTreesAndGrass, m_cConfigFile.m_sWind.m_fStrength);
		m_cForest.WindSetInitDirection(m_aAllBaseTreesAndGrass, m_cConfigFile.m_sWind.m_vDirection);
		m_cForest.WindSetDirection(m_aAllBaseTreesAndGrass, m_cConfigFile.m_sWind.m_vDirection);

		// bypass startup wind effects through preroll
		m_cForest.WindPreroll(m_aAllBaseTreesAndGrass, c_fWindPrerollTime); 

		// must be called after m_cAllTreeInstances is populated
		m_cTerrain.ComputeAmbientOcclusion(m_cConfigFile, m_cAllTreeInstances);

		#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
			m_pCurrentNavigation->SetSpeedScalars(0.2f * m_cConfigFile.m_sNavigation.m_fSpeedScalar);
		#endif

		#ifdef SPEEDTREE_WINDOWS
			m_hWindow = GetActiveWindow( );
			st_assert(m_hWindow != NULL, "We expect GetActiveWindow() to always return non-NULL but it didn't");
		#endif
	}
	else
		m_bReadyToRender = false;

	// delete temporary heap blocks used for initialization; if all blocks are cleared here,
	// it may result it a couple of heap allocations during the first few frame renders, so we
	// leave a few smaller blocks ready to use
	(void) CCore::TmpHeapBlockDeleteAll(1024 * 512); // delete any blocks larger than 512 KB

	// start real-time main clock (used for frame rate & wind computations)
	m_cWallClock.Start( );

	if (m_bReadyToRender)
	{
		SetGamma(m_sCmdLine.m_fGamma);
		#ifdef HAND_TUNED_SYSTEM_ACTIVE
			UpdateHandTune( );
		#endif
	}

	// report any errors that may have occurred during initialization
	PrintSpeedTreeErrors("End of CMyApplication::InitGfx");

	return m_bReadyToRender;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::InitForwardSupportGfx

st_bool CMyApplication::InitForwardSupportGfx(void)
{
	st_bool bSuccess = false;

	#ifdef _DURANGO
		m_bExplicitMsaaResolveEnabled = (m_sCmdLine.m_nNumSamples > 1) && (!m_cConfigFile.m_sDeferredRender.m_bEnabled);
	#endif

	if (m_bExplicitMsaaResolveEnabled)
	{
		// set up app state (user settings, configurable on cmd-line)
		SAppState sAppState;
		sAppState.m_bMultisampling = false;
		sAppState.m_bAlphaToCoverage = false;
		sAppState.m_bDepthPrepass = false;
		sAppState.m_bDeferred = false;
		sAppState.m_eOverrideDepthTest = SAppState::OVERRIDE_DEPTH_TEST_DISABLE;

		// set up render state (should be as simple as possible)
		m_cExplicitMsaaResolveState.m_eFaceCulling = CULLTYPE_NONE;

		// set search paths
		CStaticArray<CFixedString> aSearchPaths(2, "CMyApplication::InitForwardSupportGfx");
		aSearchPaths[0] = m_cConfigFile.m_sForwardRender.m_strPostEffectsShaderPath + c_szFolderSeparator + CShaderTechnique::GetCompiledShaderFolder( );
		aSearchPaths[1] = m_cConfigFile.m_sForwardRender.m_strPostEffectsShaderPath;

		if (m_cExplicitMsaaResolveState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "ForwardResolveMSAA_ps.fx", NULL))
		{
			// set up simple geometry for rendering fullscreen quads
			if (m_cExplicitMsaaResolveQuad.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_cExplicitMsaaResolveState.GetTechnique( )))
				bSuccess = m_cExplicitMsaaResolveTarget.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_sCmdLine.m_nNumSamples);
		}
		else
			CCore::SetError("Failed to load explicit resolve shaders");
	}
	else
		bSuccess = true;

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::InitDeferredSupportGfx

st_bool CMyApplication::InitDeferredSupportGfx(void)
{
	st_bool bSuccess = true;

	// set up render targets
	const st_bool bA2C = (m_sCmdLine.m_nNumSamples > 1);
	bSuccess &= m_cDeferredTarget.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_sCmdLine.m_nNumSamples, bA2C);

	if (m_cConfigFile.m_sDeferredRender.m_bDistanceBlur)
		bSuccess &= m_cDepthBlurTarget.InitGfx(RENDER_TARGET_TYPE_COLOR, m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_sCmdLine.m_nNumSamples);

	if (bSuccess)
	{
		// load shaders
		{
			// set up app state (user settings, configurable on cmd-line)
			SAppState sAppState;
			sAppState.m_bMultisampling = (m_sCmdLine.m_nNumSamples > 1);;
			sAppState.m_bAlphaToCoverage = (m_sCmdLine.m_nNumSamples > 1);;
			sAppState.m_bDepthPrepass = false;
			sAppState.m_bDeferred = m_cConfigFile.m_sDeferredRender.m_bEnabled;

			#ifndef __CELLOS_LV2__
				// PS3 has a weird optimizer error in draw order if we flip this on and off. Just suffer the depth test in fullscreen render
				sAppState.m_eOverrideDepthTest = SAppState::OVERRIDE_DEPTH_TEST_DISABLE;
			#endif

			// set up render state (should be as simple as possible)
			m_cDeferredState.m_eLightingModel = LIGHTING_MODEL_DEFERRED;
			m_cDeferredState.m_eFaceCulling = CULLTYPE_NONE;

			// set search paths
			CStaticArray<CFixedString> aSearchPaths(2, "CMyApplication::InitDeferredRenderingGfx");
			aSearchPaths[0] = m_cConfigFile.m_sDeferredRender.m_strPostEffectsShaderPath + c_szFolderSeparator + CShaderTechnique::GetCompiledShaderFolder( );
			aSearchPaths[1] = m_cConfigFile.m_sDeferredRender.m_strPostEffectsShaderPath;

			if (!m_cDeferredState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "DeferredLighting", NULL))
			{
				CCore::SetError("Failed to load deferred lighting shaders");
				bSuccess = false;
			}

			// distance blur
			if (m_cConfigFile.m_sDeferredRender.m_bDistanceBlur)
			{
				if (!m_cDepthBlurState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "DepthBlur", NULL))
				{
					CCore::SetError("Failed to load blurring shaders");
					bSuccess = false;
				}
			}
		}

		// set up simple geometry for rendering fullscreen quads
		if (bSuccess && m_cDeferredRenderResolveQuad.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_cDeferredState.GetTechnique( )))
		{
			if (m_cConfigFile.m_sDeferredRender.m_bDistanceBlur)
				bSuccess = m_cDepthBlurQuad.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_cDepthBlurState.GetTechnique( ));
		}
	}

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::InitPostEffectsGfx

st_bool CMyApplication::InitPostEffectsGfx(void)
{
	st_bool bSuccess = true;

	// set shader search paths
	CStaticArray<CFixedString> aSearchPaths(2, "CMyApplication::InitPostEffectsGfx");
	aSearchPaths[0] = m_cConfigFile.m_sDeferredRender.m_strPostEffectsShaderPath + c_szFolderSeparator + CShaderTechnique::GetCompiledShaderFolder( );
	aSearchPaths[1] = m_cConfigFile.m_sDeferredRender.m_strPostEffectsShaderPath;

	// bloom effect (temporarily forward render path only)
	if (m_cConfigFile.m_sLighting.m_sBloom.m_bEnabled)
	{
		// set up app state (user settings, configurable on cmd-line)
		SAppState sAppState;
		sAppState.m_bMultisampling = false;
		sAppState.m_bAlphaToCoverage = false;
		sAppState.m_bDepthPrepass = false;
		sAppState.m_bDeferred = false;
		sAppState.m_eOverrideDepthTest = SAppState::OVERRIDE_DEPTH_TEST_DISABLE;

		// two render targets, one quarter the area of the window
		bSuccess &= m_cBloomForwardTarget.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_sCmdLine.m_nNumSamples);
		bSuccess &= m_cBloomAuxTargetA.InitGfx(RENDER_TARGET_TYPE_COLOR, 
											   m_sCmdLine.m_nWindowWidth / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											   m_sCmdLine.m_nWindowHeight / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 1);
		bSuccess &= m_cBloomAuxTargetB.InitGfx(RENDER_TARGET_TYPE_COLOR, 
											   m_sCmdLine.m_nWindowWidth / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											   m_sCmdLine.m_nWindowHeight / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 1);

		// render states / shaders
		m_cBloomBlurState.m_eFaceCulling = CULLTYPE_NONE;
		if (!m_cBloomBlurState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "BloomBlur", NULL))
		{
			Error("Failed to find bloom blur shaders, Fullscreen_vs and/or BloomBlur_ps");
			bSuccess = false;
		}
		bSuccess &= m_cBloomBlurQuad.InitGfx(m_sCmdLine.m_nWindowWidth / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											 m_sCmdLine.m_nWindowHeight / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											 m_cBloomBlurState.GetTechnique( ));

		m_cBloomHiPassState.m_eFaceCulling = CULLTYPE_NONE;
		if (!m_cBloomHiPassState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "BloomHiPass", NULL))
		{
			Error("Failed to find bloom high pass shaders, Fullscreen_vs and/or BloomHiPass_ps");
			bSuccess = false;
		}
		bSuccess &= m_cBloomHiPassQuad.InitGfx(m_sCmdLine.m_nWindowWidth / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											   m_sCmdLine.m_nWindowHeight / m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample, 
											   m_cBloomHiPassState.GetTechnique( ));

		m_cBloomFinalState.m_eFaceCulling = CULLTYPE_NONE;
		if (!m_cBloomFinalState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "BloomFinal", NULL))
		{
			Error("Failed to find bloom final pass shaders, Fullscreen_vs and/or BloomFinal_ps");
			bSuccess = false;
		}
		bSuccess &= m_cBloomFinalQuad.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_cBloomFinalState.GetTechnique( ));

		m_cFullscreenAlpaState.m_eFaceCulling = CULLTYPE_NONE;
		m_cFullscreenAlpaState.m_eRenderPass = RENDER_PASS_SHADOW_CAST;
		m_cFullscreenAlpaState.m_bBlending = false;
		sAppState.m_bDepthPrepass = true;
		if (!m_cFullscreenAlpaState.InitGfx(sAppState, aSearchPaths, 0, 1.0f, "Fullscreen", "SetAlpha", NULL))
		{
			Error("Failed to find bloom final pass shaders, Fullscreen_vs and/or SetAlpha_ps");
			bSuccess = false;
		}
		bSuccess &= m_cFullscreenAlpaQuad.InitGfx(m_sCmdLine.m_nWindowWidth, m_sCmdLine.m_nWindowHeight, m_cFullscreenAlpaState.GetTechnique( ));

		// constant buffer
		if (m_cBloomConstantBuffer.Init(&m_sBloomConstantBufferLayout, sizeof(m_sBloomConstantBufferLayout), CONST_BUF_REGISTER_BLOOM))
		{
			m_sBloomConstantBufferLayout.m_fBrightPass = m_cConfigFile.m_sLighting.m_sBloom.m_fBrightPass;
			m_sBloomConstantBufferLayout.m_fDownsample = st_float32(m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample);
			m_sBloomConstantBufferLayout.m_fDownsampleLoopStart = -st_float32(st_int32(m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample / 2.0f));
			m_sBloomConstantBufferLayout.m_fDownsampleLoopEnd = st_float32(st_int32(m_cConfigFile.m_sLighting.m_sBloom.m_nDownsample / 2.0f));
			m_sBloomConstantBufferLayout.m_fBlurKernelSize = st_float32(m_cConfigFile.m_sLighting.m_sBloom.m_nBlur);
			m_sBloomConstantBufferLayout.m_fBlurKernelStep = 2.0f / (m_cConfigFile.m_sLighting.m_sBloom.m_nBlur - 1);
			m_sBloomConstantBufferLayout.m_fBlurPixelOffset = (m_cConfigFile.m_sLighting.m_sBloom.m_nBlur - 1) / 2.0f;
			m_sBloomConstantBufferLayout.m_fBloomEffectScalar = m_cConfigFile.m_sLighting.m_sBloom.m_fBloomEffectScalar;
			m_sBloomConstantBufferLayout.m_fHighPassFloor = m_cConfigFile.m_sLighting.m_sBloom.m_fBrightFloor;
			m_sBloomConstantBufferLayout.m_fSkyBleed = m_cConfigFile.m_sLighting.m_sBloom.m_fSkyBleed;
			m_sBloomConstantBufferLayout.m_fFinalMainScalar = m_cConfigFile.m_sLighting.m_sBloom.m_fMainEffectScalar;

			bSuccess &= m_cBloomConstantBuffer.Update( ) && m_cBloomConstantBuffer.Bind( );
		}
		else
			bSuccess = false;
	}

	// depth blur effect (temporarily deferred render path only)

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::ReleaseGfxResources

void CMyApplication::ReleaseGfxResources(void)
{
	if (m_cConfigFile.m_sDeferredRender.m_bEnabled)
	{
		m_cDeferredTarget.ReleaseGfxResources( );
		m_cDeferredState.ReleaseGfxResources( );
		m_cDeferredRenderResolveQuad.ReleaseGfxResources( );

		if (m_cConfigFile.m_sDeferredRender.m_bDistanceBlur)
		{
			m_cDepthBlurTarget.ReleaseGfxResources( );
			m_cDepthBlurState.ReleaseGfxResources( );
			m_cDepthBlurQuad.ReleaseGfxResources( );
		}
	}

	if (m_cConfigFile.m_sLighting.m_sBloom.m_bEnabled)
	{
		m_cBloomForwardTarget.ReleaseGfxResources( );
		m_cBloomAuxTargetA.ReleaseGfxResources( );
		m_cBloomAuxTargetB.ReleaseGfxResources( );
		m_cBloomHiPassState.ReleaseGfxResources( );
		m_cBloomHiPassQuad.ReleaseGfxResources( );
		m_cBloomBlurState.ReleaseGfxResources( );
		m_cBloomBlurQuad.ReleaseGfxResources( );
		m_cBloomFinalState.ReleaseGfxResources( );
		m_cBloomFinalQuad.ReleaseGfxResources( );
		m_cFullscreenAlpaState.ReleaseGfxResources( );
		m_cFullscreenAlpaQuad.ReleaseGfxResources( );
		m_cBloomConstantBuffer.ReleaseGfxResources( );
	}

	m_cForest.ReleaseGfxResources( );
	m_cShadowSystem.ReleaseGfxResources( );
	m_cTerrain.ReleaseGfxResources( );
	m_cSky.ReleaseGfxResources( );
	m_cOverlays.ReleaseGfxResources( );
	m_cVisibleTreesFromCamera.ReleaseGfxResources( );

	if (m_bExplicitMsaaResolveEnabled)
	{
		m_cExplicitMsaaResolveQuad.ReleaseGfxResources( );
		m_cExplicitMsaaResolveState.ReleaseGfxResources( );
		m_cExplicitMsaaResolveTarget.ReleaseGfxResources( );
	}

	for (size_t i = 0; i < m_aGrassLayers.size( ); ++i)
		m_aGrassLayers[i].ReleaseGfxResources( );

	for (size_t i = 0; i < m_aAllBaseTreesAndGrass.size( ); ++i)
	{
		CTreeRender* pTree = (CTreeRender*) m_aAllBaseTreesAndGrass[i];
		pTree->ReleaseGfxResources( );
	}

	CShaderConstant::ReleaseGfxResources( );
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::Advance

void CMyApplication::Advance(void)
{
	#if defined(_WIN32) && !defined(_XBOX) && !defined(_DURANGO)
		// shift/ctrl to speed or slow
		st_bool bShiftKeyDown = GetKeyState(VK_SHIFT) < 0;
		m_pCurrentNavigation->SetShiftKeyState(bShiftKeyDown);

		st_bool bControlKeyDown = GetKeyState(VK_CONTROL) < 0;
		m_pCurrentNavigation->SetControlKeyState(bControlKeyDown);
	#elif defined(__APPLE__)
		m_pCurrentNavigation->SetShiftKeyState(glfwGetKey(GLFW_KEY_LSHIFT) == GLFW_PRESS || glfwGetKey(GLFW_KEY_RSHIFT) == GLFW_PRESS);
		m_pCurrentNavigation->SetControlKeyState(glfwGetKey(GLFW_KEY_LCTRL) == GLFW_PRESS || glfwGetKey(GLFW_KEY_RCTRL) == GLFW_PRESS);
	#endif

	// update timer data
	m_cWallClock.Stop( );
	m_fCurrentTime = m_cWallClock.GetSec( );
	m_fFrameTime = m_fCurrentTime - m_fTimeMarker;
	m_fTimeMarker = m_fCurrentTime;

	// advance navigation
	st_assert(m_pCurrentNavigation, "m_pCurrentNavigation should already have been allocated at this point");
	(void) m_pCurrentNavigation->Advance(m_fFrameTime);

	// handle terrain following
	Vec3 vStdCameraPos = CCoordSys::ConvertToStd(m_pCurrentNavigation->GetCameraPos( ));

	// clamp to tiles
	if (m_cConfigFile.m_sTerrain.m_nTiles > 0)
	{
		if (vStdCameraPos.x < 0.0f)
			vStdCameraPos.x = 0.0f;
		if (vStdCameraPos.y < 0.0f)
			vStdCameraPos.y = 0.0f;
		if (vStdCameraPos.x > m_cConfigFile.m_sTerrain.m_vHeightMapSize.x * st_float32(m_cConfigFile.m_sTerrain.m_nTiles))
			vStdCameraPos.x = m_cConfigFile.m_sTerrain.m_vHeightMapSize.x * st_float32(m_cConfigFile.m_sTerrain.m_nTiles);
		if (vStdCameraPos.y > m_cConfigFile.m_sTerrain.m_vHeightMapSize.y * st_float32(m_cConfigFile.m_sTerrain.m_nTiles))
			vStdCameraPos.y = m_cConfigFile.m_sTerrain.m_vHeightMapSize.y * st_float32(m_cConfigFile.m_sTerrain.m_nTiles);
	}

	const st_float32 c_fSmoothingDistance = 3.0f;
	st_float32 fTerrainHeight = m_cTerrain.GetSmoothHeightFromXY(vStdCameraPos.x, vStdCameraPos.y, c_fSmoothingDistance * m_cConfigFile.m_sNavigation.m_fFollowHeight) + m_cConfigFile.m_sNavigation.m_fFollowHeight;
	if (m_bFollowTerrain)
		vStdCameraPos.Set(vStdCameraPos.x, vStdCameraPos.y, fTerrainHeight);
	else if (m_bHandleCollision)
		vStdCameraPos.z = st_max(vStdCameraPos.z, fTerrainHeight);
	m_pCurrentNavigation->SetCameraPos(CCoordSys::ConvertFromStd(vStdCameraPos));

	HandleCollision( );

	// wind
	m_cForest.WindAdvance(m_aAllBaseTreesAndGrass, m_fCurrentTime + c_fWindPrerollTime);

	// todo: put this somewhere more formal
	for (size_t i = 0;i < m_aAllBaseTrees.size( ); ++i)
		m_aAllBaseTrees[i]->UpdateWindConstantBuffer( );
	for (size_t i = 0;i < m_aAllBaseGrasses.size( ); ++i)
		m_aAllBaseGrasses[i]->UpdateWindConstantBuffer( );

	// demo mode
	#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
		if (m_cMyMouseNavigation.IsDemoMode( ))
		{
			// todo
			/*const st_float32 c_fSunSpeed = m_cConfigFile.m_sDemo.m_fSunSpeed;

			m_sLightAdjuster.m_fVertAngle = (sin(m_fCurrentTime * c_fSunSpeed) + 1.0f) * 0.5f;
			m_sLightAdjuster.m_fHorzAngle += m_fFrameTime * c_fSunSpeed * m_sLightAdjuster.m_fVertAngle;
			m_sLightAdjuster.m_fVertAngle *= c_fPi * 0.4f;

			if (m_sLightAdjuster.m_fHorzAngle > 2.0f * c_fPi)
				m_sLightAdjuster.m_fHorzAngle -= 2.0f * c_fPi;

			m_sLightAdjuster.ComputeDirection( );*/

			m_sLightAdjuster.SetInitDir(m_cMyMouseNavigation.GetCurrentCameraLightDir( ));
			UpdateLightDir( );
		}
	#endif

	// updating the view is an important step because the forest population or positions
	// may have changed (normally happens if the SDK is embedded in a world-building app)
	UpdateView( );
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::Cull

void CMyApplication::Cull(void)
{
	ScopeTrace("MyApp::Cull");

	const st_bool c_bCullForShadowMaps = m_bCameraChanged || m_cForest.LightDirChanged( );
	const st_bool c_bCullForMainCamera = m_bCameraChanged || m_cForest.LightDirChanged( );

	CTimer cOverallCullAndUpdateTimer(true);

	// shadow maps
	if (m_cConfigFile.m_sShadows.m_bEnabled && c_bCullForShadowMaps)
	{
		CTimer cShadowMapTimer(true);
		{
			// the shadow maps update at different intervals, but some events, like the camera
			// moving, should override the interval timing and update immediately
			const st_bool c_bForceUpdate = false;

			m_cShadowSystem.UpdateView(m_cConfigFile,
									   m_cView,
									   m_sLightAdjuster.m_vDir,
									   m_cTerrain,
									   m_aGrassLayers,
									   m_aRandomGrassInstancesBuffer,
									   m_cForest.GetFrameIndex( ),
									   c_bForceUpdate,
									   m_cAllTreeInstances);
		}
		m_cForest.GetRenderStats( ).m_fSpeedTreeCullAndUpdateTime += cShadowMapTimer.Stop( );
	}

	// main camera
	if (c_bCullForMainCamera)
	{
		// measure SpeedTree cull and update time
		CTimer cSpeedTreeTimer(true);
		{
			// 3d trees
			if (m_bRenderTrees || m_bRenderBillboards)
			{
				CMyPopulate::StreamTrees(m_cAllTreeInstances,
										 m_cView,
										 m_cVisibleTreesFromCamera,
										 m_cForest.GetFrameIndex( ),
										 m_bRenderTrees,
										 m_bRenderBillboards,
										 false); // false for no shadow pass
			}

			// grass
			if (m_bRenderGrass)
			{
				CMyPopulate::StreamGrass(m_aGrassLayers,
										 m_cView,
										 m_cTerrain,
										 m_cForest.GetFrameIndex( ),
										 m_aRandomGrassInstancesBuffer);
			}
		}
		m_cForest.GetRenderStats( ).m_fSpeedTreeCullAndUpdateTime += cSpeedTreeTimer.Stop( );

		// terrain
		if (m_cTerrain.IsActive( ))
		{
			CTimer cTerrainTimer(true);
			{
				m_cTerrain.CullAndPopulate(m_cView, m_cForest.GetFrameIndex( ), m_sTerrainCullResults);
				m_cTerrain.FrameEnd(m_cForest.GetFrameIndex( ), m_sTerrainCullResults);
			}
			m_cForest.GetRenderStats( ).m_fOtherCullAndUpdateTime += cTerrainTimer.Stop( );
		}
	}

	if (c_bCullForShadowMaps || c_bCullForMainCamera)
		m_cForest.GetRenderStats( ).m_fOverallCullAndUpdateTime += cOverallCullAndUpdateTimer.Stop( );
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::HandleCollision

void CMyApplication::HandleCollision(void)
{
	if (m_bHandleCollision)
	{
		Vec3 vCameraPos = m_pCurrentNavigation->GetCameraPos( );

		const st_int32 c_nMaxNumTestTrees = 5;
		if (m_cForest.CollisionAdjust(vCameraPos, m_cVisibleTreesFromCamera, c_nMaxNumTestTrees))
			m_pCurrentNavigation->SetCameraPos(vCameraPos);
	}
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::ReportStats

void CMyApplication::ReportStats(void)
{
	#ifdef SPEEDTREE_RENDER_STATS
		if (m_cStatsReporter.Update(m_fCurrentTime))
		{
			(void) m_cStatsReporter.Report(m_cForest.GetRenderStats( ));
			Report("%s", m_cStatsReporter.LastReport( ));
		}

		m_cForest.GetRenderStats( ).Reset( );
	#endif
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::ReportResourceUsage

void CMyApplication::ReportResourceUsage(void)
{
	const CCore::SResourceSummary& sSummary = CCore::GetSdkResourceUsage( );

	Report("\t     Resource  Usage (KB) Peak (KB)  Qty   Peak\n");
	Report("\t---------------------------------------------------\n");
	Report("\t          heap %8.1f  (%8.1f)  %d (%d)\n",
		sSummary.m_sHeap.m_siCurrentUsage / 1024.0f, sSummary.m_sHeap.m_siPeakUsage / 1024.0f,
		st_uint32(sSummary.m_sHeap.m_siCurrentQuantity), st_uint32(sSummary.m_sHeap.m_siPeakQuantity));

	const char* c_pGfxNames[GFX_RESOURCE_COUNT] =
	{
		"vertex buffers",
		"index buffers",
		"vertex shaders",
		"pixel shaders",
		"textures",
		"other"
	};

	for (st_int32 i = GFX_RESOURCE_VERTEX_BUFFER; i < GFX_RESOURCE_COUNT; ++i)
	{
		// for now, skip vertex & pixel shaders since we don't have a good way to measure their 
		// footprint across all platforms
		if (i != GFX_RESOURCE_VERTEX_SHADER && i != GFX_RESOURCE_PIXEL_SHADER)
		{
			Report("\t%14s %8.1f  (%8.1f)  %4d (%4d)",
					c_pGfxNames[i],
					sSummary.m_asGfxResources[i].m_siCurrentUsage / 1024.0f, sSummary.m_asGfxResources[i].m_siPeakUsage / 1024.0f,
					st_uint32(sSummary.m_asGfxResources[i].m_siCurrentQuantity), st_uint32(sSummary.m_asGfxResources[i].m_siPeakQuantity));
		}
	}
	Report("\n");
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::SetGamma

void CMyApplication::SetGamma(st_float32 fGamma)
{
	#ifdef SPEEDTREE_WINDOWS
		WORD awRamp[256 * 3];
		for (st_int32 i = 0; i < 256; ++i)
			awRamp[i + 0] = awRamp[i + 256] = awRamp[i + 512] = st_min(WORD(65535), st_max(WORD(0), WORD(powf((st_float32(i) + 1.0f) / 256.0f, fGamma) * 65535.0f + 0.5f)));

		(void) SetDeviceGammaRamp(::GetDC(NULL), awRamp);
	#else
		ST_UNREF_PARAM(fGamma);
	#endif
}


#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD

	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::KeyDown

	void CMyApplication::KeyDown(st_uchar chKey, st_int32 x, st_int32 y)
	{
		ST_UNREF_PARAM(x);
		ST_UNREF_PARAM(y);

		const char c_chControlW = 23;
		const char c_chControlA = 1;
		const char c_chControlS = 19;
		const char c_chControlD = 4;

		const st_bool c_bControlPressed = m_pCurrentNavigation->IsControlDown( );

		// hand-tuning system
		#ifdef HAND_TUNED_SYSTEM_ACTIVE
			if (c_bControlPressed && chKey >= '1' && chKey <= '4')
				m_asHandTuneAdjuster[chKey - '1'].Start(m_anMousePos[0], m_anMousePos[1]);
		#endif

		#ifdef _WIN32
			#define HANDLE_PRESET_CAMERA(a, b) \
				case (a + 48): if (!c_bControlPressed) { if (!m_cConfigFile.m_sDemo.m_bKeyboardLock && GetKeyState(VK_SHIFT) < 0) m_cMyMouseNavigation.SaveCamera(a, m_sLightAdjuster.m_vDir); else { m_cMyMouseNavigation.LoadCamera(a); m_bCameraChanged = true; } } break; \
				case (b): m_cMyMouseNavigation.SaveCamera(a, m_sLightAdjuster.m_vDir); break;
		#endif

		if (!m_cConfigFile.m_sDemo.m_bKeyboardLock || (m_cConfigFile.m_sDemo.m_bKeyboardLock && c_bControlPressed))
		{
			switch (chKey)
			{
			// toggle terrain following
			case ' ': // spacebar
				ToggleTerrainFollowing( );
				break;
			// toggle billboard tree visibility (3D trees stay on)
			case 'b': case 'B':
				ToggleBillboards( );
				NotifyOfPopulationChange( );
				break;
			// toggle collision
			case 'c': case 'C':
				m_bHandleCollision = !m_bHandleCollision;
				break;
			// 'demo' mode (automatic camera paths)
			#ifdef SPEEDTREE_MOUSE_AND_KEYBOARD
				case 'r': case 'R':
					if (c_bControlPressed)
						m_cMyMouseNavigation.DemoModeToggle(m_cConfigFile.m_sDemo.m_afCameraTime, m_cConfigFile.m_sDemo.m_afCameraSpeed);
					break;
			#endif
			// toggle overlay visibility
			case 'e': case 'E':	
				ToggleOverlays( );
				break;
			// wind adjust (via mouse)
			case 'f': case 'F':
				m_sWindAdjuster.Start(m_anMousePos[0], m_anMousePos[1]);
				printf("wind dir: (%g, %g, %g)\n", m_sWindAdjuster.m_vDir.x, m_sWindAdjuster.m_vDir.y, m_sWindAdjuster.m_vDir.z);
				break;
			// toggle grass visibility
			case 'g': case 'G':
				ToggleGrass( );
				NotifyOfPopulationChange( );
				break;
			// toggle depth blur
			case 'j': case 'J':
				m_bDepthBlur = !m_bDepthBlur;
				break;
			// toggle terrain visibility
			case 'l': case 'L':
				ToggleTerrain( );
				break;
			// rotate bloom display mode
			case 'o': case 'O':
				if (++m_nBloomDisplayMode == st_int32(BLOOM_DISPLAY_MODE_COUNT))
					m_nBloomDisplayMode = BLOOM_DISPLAY_MODE_FULL;
				break;
			// print resource stats to console if active
			case 'q': case 'Q': 
				ReportResourceUsage( );
				break;
			// toggle 3D tree visibility (billboards stay on)
			case 't': case 'T':
				ToggleTrees( );
				NotifyOfPopulationChange( );
				break;
			// toggle texturing
			case 'u': case 'U': 
				{
					// set for forest
					SForestRenderInfo sForestRenderInfo = m_cForest.GetRenderInfo( );
					sForestRenderInfo.m_bTexturingEnabled = !sForestRenderInfo.m_bTexturingEnabled;
					m_cForest.SetRenderInfo(sForestRenderInfo);
					// set for terrain
					STerrainRenderInfo sTerrainRenderInfo = m_cTerrain.GetRenderInfo( );
					sTerrainRenderInfo.m_bTexturingEnabled = !sTerrainRenderInfo.m_bTexturingEnabled;
					m_cTerrain.SetRenderInfo(sTerrainRenderInfo);
					break;
				}
			// light adjust (via mouse)
			case 'v': case 'V': 
				m_sLightAdjuster.Start(m_anMousePos[0], m_anMousePos[1]);
				break;
			// print frame CPU profile to console if active
			case 'x': case 'X':
				{
				#if !defined(SPEEDTREE_FALLBACK_TIMING) && !defined(SPEEDTREE_INTEL_GPA)
					Report("#define SPEEDTREE_FALLBACK_TIMING or SPEEDTREE_INTEL_GPA in ScopeTrace.h to activate built-in profiling");
				#else
					CString strReport;
					CScopeTrace::Report(CScopeTrace::FORMAT_PRINT, strReport);
					printf("%s\n", strReport.c_str( ));
				#endif
				}
				break;
			// toggle sky visibility
			case 'y': case 'Y':
				m_cSky.SetActive(!m_cSky.IsActive( ));
				break;
			// LOD adjust (via mouse)
			case 'z': case 'Z': 
				m_sLodAdjuster.Start(m_anMousePos[0], m_anMousePos[1]);
				break;
			// loading or saving camera position (shift + key = save, key = load)
			#ifdef HANDLE_PRESET_CAMERA
				HANDLE_PRESET_CAMERA(1, '!');
				HANDLE_PRESET_CAMERA(2, '@');
				HANDLE_PRESET_CAMERA(3, '#');
				HANDLE_PRESET_CAMERA(4, '$');
				HANDLE_PRESET_CAMERA(5, '%');
				HANDLE_PRESET_CAMERA(6, '^');
				HANDLE_PRESET_CAMERA(7, '&');
				HANDLE_PRESET_CAMERA(8, '*');
				HANDLE_PRESET_CAMERA(9, '(');
				HANDLE_PRESET_CAMERA(0, ')');
				#undef HANDLE_PRESET_CAMERA
			#endif
			// keys that control internal dynamic population diagnostics; safe to ignore
			//case '/':
			//{
			//	st_float32 afArea[6] = { -300.0f, -300.0f, 0.0f, 300.0f, 300.0f, 0.0f };
			//	CExtents cArea(afArea);
			//	m_cAllTreeInstances.AnimateFigure(m_fCurrentTime, cArea, 29.0f, m_cTerrain);
			//	NotifyOfPopulationChange( );
			//}
			//	break;
			//case ',': // less than, half population
			//	m_cAllTreeInstances.HalvePopulation( );
			//	NotifyOfPopulationChange( );
			//	break;
			//case '.': // greater than, double population
			//	m_cAllTreeInstances.DoublePopulation(m_cConfigFile, m_cTerrain);
			//	NotifyOfPopulationChange( );
			//	break;

			// todo
			case 'h': case 'H':
				m_cAllTreeInstances.Clear( );
				NotifyOfPopulationChange( );
				break;
			default:
				break;
			}
		}

		// WASD navigation support
		switch (chKey)
		{
		case 'w': case 'W': case c_chControlW:
			m_pCurrentNavigation->SustainForwardMotion(true);
			break;
		case 'a': case 'A': case c_chControlA:
			m_pCurrentNavigation->SustainLeftMotion(true);
			break;
		case 's': case 'S': case c_chControlS:
			m_pCurrentNavigation->SustainBackwardMotion(true);
			break;
		case 'd': case 'D': case c_chControlD:
			m_pCurrentNavigation->SustainRightMotion(true);
			break;
		}
	}


	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::KeyUp

	void CMyApplication::KeyUp(st_uchar chKey, st_int32 x, st_int32 y)
	{
		ST_UNREF_PARAM(x);
		ST_UNREF_PARAM(y);

		// standard WASH navigation (unaffected by keyboard lock)
		switch (chKey)
		{
			// WASD navigation support
		case 'w': case 'W':
			m_pCurrentNavigation->SustainForwardMotion(false);
			break;
		case 'a': case 'A':
			m_pCurrentNavigation->SustainLeftMotion(false);
			break;
		case 's': case 'S':
			m_pCurrentNavigation->SustainBackwardMotion(false);
			break;
		case 'd': case 'D':
			m_pCurrentNavigation->SustainRightMotion(false);
			break;
		}

		// when keyboard lock mode is on, all keys have to be Ctrl+<key>
		const st_bool c_bControlPressed = m_pCurrentNavigation->IsControlDown( );
		if (!m_cConfigFile.m_sDemo.m_bKeyboardLock || (m_cConfigFile.m_sDemo.m_bKeyboardLock && c_bControlPressed))
		{
			// listed alphabetically by key
			switch (chKey)
			{
			#ifdef HAND_TUNED_SYSTEM_ACTIVE			
				case '1': case '2': case '3': case '4':
					m_asHandTuneAdjuster[chKey - '1'].End( );
					// force mouse up to prevent navigation jump
					m_pCurrentNavigation->MouseButton(CMyNavigationBase::BUTTON_LEFT, false, 0, 0);
					break;
			#endif
			// wind direction adjust (via mouse)
			case 'f': case 'F': 
				m_sWindAdjuster.End( );
				// force mouse up to prevent navigation jump
				m_pCurrentNavigation->MouseButton(CMyNavigationBase::BUTTON_LEFT, false, 0, 0);
				break;
			// light adjust (via mouse)
			case 'v': case 'V': 
				m_sLightAdjuster.End( );
				// force mouse up to prevent navigation jump
				m_pCurrentNavigation->MouseButton(CMyNavigationBase::BUTTON_LEFT, false, 0, 0);
				break;
			// LOD adjust (via mouse)
			case 'z': case 'Z':
				m_sLodAdjuster.End( );
				// force mouse up to prevent navigation jump
				m_pCurrentNavigation->MouseButton(CMyNavigationBase::BUTTON_LEFT, false, 0, 0);
				break;
			default:
				break;
			}
		}
	}


	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::MouseClick

	void CMyApplication::MouseClick(CMyNavigationBase::EMouseButton eButton, st_bool bPressed, int x, int y)
	{
		#if defined(SPEEDTREE_OPENGL)
			// handle cursor hiding
			if (eButton == CMyMouseNavigation::BUTTON_MIDDLE || eButton == CMyMouseNavigation::BUTTON_RIGHT)
			{
				if (bPressed)
					glfwDisable(GLFW_MOUSE_CURSOR);
				else
					glfwEnable(GLFW_MOUSE_CURSOR);

				m_bIgnoreNextMouseMove = true;
			}
		#elif defined(_WIN32)
			// handle mouse centering and cursor hiding
			if (eButton == CMyMouseNavigation::BUTTON_MIDDLE || eButton == CMyMouseNavigation::BUTTON_RIGHT)
			{
				if (!bPressed)
					ShowCursor(TRUE);
				else
				{
					m_bIgnoreNextMouseMove = true;
					ShowCursor(FALSE);
				}
			}
		#endif

		m_pCurrentNavigation->MouseButton(eButton, bPressed, x, y);
	}


	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::MouseMotion

	void CMyApplication::MouseMotion(st_int32 x, st_int32 y)
	{
		// check for light adjustment mode
		if (m_sLightAdjuster.IsActive( ))
		{
			m_sLightAdjuster.Move(x, y);
			UpdateLightDir( );
		}
		else if (m_sWindAdjuster.IsActive( ))
		{
			m_sWindAdjuster.Move(x, y);
			m_cForest.WindSetDirection(m_aAllBaseTreesAndGrass, m_sWindAdjuster.m_vDir);
		}
		else if (m_sLodAdjuster.IsActive( ))
		{
			m_sLodAdjuster.Move(x, y);
			UpdateGlobalLod( );
		}
		else if (m_asHandTuneAdjuster[0].IsActive( ))
		{
			m_asHandTuneAdjuster[0].Move(x, y);
			UpdateHandTune( );
		}
		else if (m_asHandTuneAdjuster[1].IsActive( ))
		{
			m_asHandTuneAdjuster[1].Move(x, y);
			UpdateHandTune( );
		}
		else if (m_asHandTuneAdjuster[2].IsActive( ))
		{
			m_asHandTuneAdjuster[2].Move(x, y);
			UpdateHandTune( );
		}
		else if (m_asHandTuneAdjuster[3].IsActive( ))
		{
			m_asHandTuneAdjuster[3].Move(x, y);
			UpdateHandTune( );
		}
		else
		{
			if (m_pCurrentNavigation->IsButtonDown(CMyNavigationBase::BUTTON_LEFT))
			{
				// WASD adjustments
				if (x > 3000)
					x = x - 65535;
				if (y > 3000)
					y = y - 65535;
				m_pCurrentNavigation->MouseMotion(x, y);
			}
			else if (m_pCurrentNavigation->IsButtonDown(CMyNavigationBase::BUTTON_MIDDLE) ||
					m_pCurrentNavigation->IsButtonDown(CMyNavigationBase::BUTTON_RIGHT))
			{

				int nXDelta = x - m_anMousePos[0];
				int nYDelta = y - m_anMousePos[1];
				if (!m_bIgnoreNextMouseMove)
				{
					bool bButtonDown = true;

					#ifdef SPEEDTREE_OPENGL
						bButtonDown = false;
						for (int nButton = GLFW_MOUSE_BUTTON_2; !bButtonDown && nButton < GLFW_MOUSE_BUTTON_LAST; ++nButton)
							bButtonDown = (glfwGetMouseButton(nButton) == GLFW_PRESS);
					#endif

					if (bButtonDown)
						m_pCurrentNavigation->MouseMotion(nXDelta, nYDelta);
				}
				m_bIgnoreNextMouseMove = false;

				// keep the cursor centered
				#if defined(_WIN32)
					POINT ptCursor;
					GetCursorPos(&ptCursor);
					RECT rectWindow;
					GetWindowRect(m_hWindow, &rectWindow);
					POINT ptCenter;
					ptCenter.x = (rectWindow.left + rectWindow.right) / 2;
					ptCenter.y = (rectWindow.bottom + rectWindow.top) / 2;

					if (ptCursor.x != ptCenter.x || ptCursor.y != ptCenter.y)
					{
						SetCursorPos(ptCenter.x, ptCenter.y);
						m_bIgnoreNextMouseMove = true;
					}
				#endif
			}
		}

		m_anMousePos[0] = x;
		m_anMousePos[1] = y;
	}


	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::PrintKeys

	void CMyApplication::PrintKeys(void)
	{
		Report("\n\t** Reference Application Key Bindings **\n");
		Report("\t  W,A,S,D          Navigation (along with mouse)");
		Report("\t  + SHIFT          Increase navigation speed");
		Report("\t  + CTRL           Decrease navigation speed");
		Report("\t  T                Toggle 3D trees");
		Report("\t  B                Toggle billboards");
		Report("\t  G                Toggle grass");
		Report("\t  L                Toggle terrain ('L'and)");
		Report("\t  SPACE            Toggle terrain following");
		Report("\t  Y                Toggle sky");
		Report("\t  U                Toggle textures");
		Report("\t  V (hold + mouse) Move light");
		Report("\t  Z (hold + mouse) Adjust global LOD");
		Report("\t  F (hold + mouse) Adjust wind direction");
		Report("\t  C                Toggle collision");
		Report("\t  Shift + 1-9      Save camera position");
		Report("\t  1-9              Goto camera position");
		Report("\t  ESC              Quit\n");
	}


	///////////////////////////////////////////////////////////////////////
	//  CMyApplication::WindowReshape

	void CMyApplication::WindowReshape(int nWindowWidth, int nWindowHeight)
	{
		m_fAspectRatio = nWindowWidth / st_float32(nWindowHeight);
	}

#endif // SPEEDTREE_MOUSE_AND_KEYBOARD


///////////////////////////////////////////////////////////////////////
//  CMyApplication::PrintId

void CMyApplication::PrintId(void)
{
	Report("\n\t%s", CCore::Version( ));
	Report("\tReference Application\n");
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::OnResetDevice

void CMyApplication::OnResetDevice(void)
{
	m_cShadowSystem.OnResetDevice(m_cConfigFile);
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::OnLostDevice

void CMyApplication::OnLostDevice(void)
{
	m_cShadowSystem.OnLostDevice(m_cConfigFile);
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::PopulateForest
//
//	The main reason this function is not as straightforward as it could be
//	is that it attempts to minimize the number of heap allocations it makes
//	by avoiding numerous push_back() calls.  To avoid these calls, some
//	extra work is necessary to determine allocation quantities early on.

st_bool CMyApplication::PopulateForest(void)
{
	st_bool bSuccess = true;
	
	// compile an array of base trees from multiple possible sources, avoid
	// loading the same SRT file twice
	CArray<CMyPopulate::SMyPerBasePopulation> aPopulationByBaseTree; // one entry per base tree
	aPopulationByBaseTree.SetHeapDescription("App-side base tree population params");
	aPopulationByBaseTree.reserve(100);

	// gather base trees
	{
		// pre-scan STF files (gets list of base trees & instance quantities for each)
		for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aStfTreePopulations.size( )); ++i)
			bSuccess &= CMyPopulate::PreScanStfFile(m_cConfigFile.m_aStfTreePopulations[i], aPopulationByBaseTree);

		// pre-scan SWA files (gets list of base trees & instance quantities for each)
		for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aSwaTreePopulations.size( )); ++i)
			bSuccess &= CMyPopulate::PreScanSwaFile(m_cConfigFile.m_aSwaTreePopulations[i], aPopulationByBaseTree);

		// pre-scan SpeedForest files (gets list of base trees & instance quantities for each)
		for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aSpeedForestPopulations.size( )); ++i)
			bSuccess &= CMyPopulate::PreScanSpeedForestFile(m_cConfigFile.m_aSpeedForestPopulations[i], aPopulationByBaseTree);

		// gather manual population base trees
		for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aManualTreePopulations.size( )); ++i)
		{
			const CMyConfigFile::SManualTreePopulationParams& sParams = m_cConfigFile.m_aManualTreePopulations[i];

			CMyPopulate::SMyPerBasePopulation sBaseTree;
			sBaseTree.m_strSrtFilename = sParams.m_strSrtFilename;
			sBaseTree.m_fLodScalar = sParams.m_fLodScalar;
			sBaseTree.m_fAmbientImageScalar = sParams.m_fAmbientImageScalar;
			sBaseTree.m_sHueVariationParams = sParams.m_sHueVariationParams;

			aPopulationByBaseTree.insert_sorted_unique(sBaseTree);
		}

		// gather random population base trees
		for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aRandomTreePopulations.size( )); ++i)
		{
			const CMyConfigFile::SRandomTreePopulationParams& sParams = m_cConfigFile.m_aRandomTreePopulations[i];

			CMyPopulate::SMyPerBasePopulation sBaseTree;
			sBaseTree.m_strSrtFilename = sParams.m_strSrtFilename;
			sBaseTree.m_fLodScalar = sParams.m_fLodScalar;
			sBaseTree.m_fAmbientImageScalar = sParams.m_fAmbientImageScalar;
			sBaseTree.m_sHueVariationParams = sParams.m_sHueVariationParams;

			aPopulationByBaseTree.insert_sorted_unique(sBaseTree);
		}
	}

	// all of the SRT filenames have been gathered from all sources; load & initialize them
	for (st_int32 i = 0; i < st_int32(aPopulationByBaseTree.size( )); ++i)
	{
		// pull SRT from disk (or memory)
		bSuccess &= CMyPopulate::LoadBaseTree(aPopulationByBaseTree[i], m_cConfigFile.m_sDeferredRender.m_bEnabled);

		// scale LOD profile based on SFC file
		SLodProfile sScaledLodProfile = aPopulationByBaseTree[i].m_pBaseTree->GetLodProfile( );
		sScaledLodProfile.Scale(aPopulationByBaseTree[i].m_fLodScalar * m_cConfigFile.m_sWorld.m_fGlobalTreeLodScalar);
		aPopulationByBaseTree[i].m_pBaseTree->SetLodProfile(sScaledLodProfile);

		// load SRT gfx (textures, VBs/IBs, shaders, constant buffers, etc)
		if (bSuccess)
			bSuccess &= CMyPopulate::InitBaseTreeGraphics(aPopulationByBaseTree[i].m_pBaseTree, m_cForest);
	}

	if (bSuccess)
	{
		// gather instances
		{
			// load STF instances
			for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aStfTreePopulations.size( )); ++i)
				bSuccess &= CMyPopulate::GetStfFileInstances(m_cConfigFile.m_aStfTreePopulations[i], aPopulationByBaseTree, m_cTerrain);

			// load SWA instances
			for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aSwaTreePopulations.size( )); ++i)
				bSuccess &= CMyPopulate::GetSwaFileInstances(m_cConfigFile.m_aSwaTreePopulations[i], aPopulationByBaseTree, m_cTerrain);

			// load SpeedForest instances
			for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aSpeedForestPopulations.size( )); ++i)
				bSuccess &= CMyPopulate::GetSpeedForestFileInstances(m_cConfigFile.m_aSpeedForestPopulations[i], aPopulationByBaseTree, m_cTerrain);

			// load manual instances
			for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aManualTreePopulations.size( )); ++i)
				bSuccess &= CMyPopulate::GetManualInstances(m_cConfigFile.m_aManualTreePopulations[i], aPopulationByBaseTree, m_cTerrain);

			// load random instances
			for (st_int32 i = 0; i < st_int32(m_cConfigFile.m_aRandomTreePopulations.size( )); ++i)
				bSuccess &= CMyPopulate::GenerateRandom3dTreeInstances(aPopulationByBaseTree,
																	   m_cConfigFile.m_aRandomTreePopulations[i],
																	   m_cConfigFile.m_sWorld.m_fTreeSurfaceAdhesion,
																	   m_cTerrain);
		}

		// copy instances into the app's instance data structure, which needs the data organized into cells
		m_cAllTreeInstances.SetMaxNumBaseTrees(st_int32(aPopulationByBaseTree.size( )));
		for (st_int32 i = 0; i < st_int32(aPopulationByBaseTree.size( )); ++i)
		{
			st_assert(aPopulationByBaseTree[i].m_pBaseTree, "Shouldn't be trying to SetInstances() for a NULL base tree");
			printf("adding [%d] instances of [%s]\n", 
				st_int32(aPopulationByBaseTree[i].m_aInstances.size( )), 
				CFixedString(aPopulationByBaseTree[i].m_pBaseTree->GetFilename( )).NoPath( ).c_str( ));
			m_cAllTreeInstances.SetInstances(aPopulationByBaseTree[i].m_pBaseTree, aPopulationByBaseTree[i].m_aInstances);
			aPopulationByBaseTree[i].m_aInstances.clear( );
		}
		m_cAllTreeInstances.SplitIntoCells(m_cConfigFile.m_sWorld.m_f3dTreeCellSize);

		bSuccess &= SetUpGrassLayers( );
	}
	else
		bSuccess = false;

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::SetUpGrassLayers

st_bool CMyApplication::SetUpGrassLayers(void)
{
	st_bool bSuccess = false;

	if (m_cConfigFile.m_aGrassPopulations.empty( ))
	{
		bSuccess = true;
	}
	else
	{
		// gather grass base trees
		CStaticArray<CMyPopulate::SMyPerBasePopulation> aBaseGrasses(m_cConfigFile.m_aGrassPopulations.size( ), "CMyApplication::SetUpGrassLayers");
		for (size_t i = 0; i < m_cConfigFile.m_aGrassPopulations.size( ); ++i)
		{
			const CMyConfigFile::SGrassPopulationParams& sParams = m_cConfigFile.m_aGrassPopulations[i];

			aBaseGrasses[i].m_strSrtFilename = sParams.m_strSrtFilename;
			aBaseGrasses[i].m_bGrassModel = true;
			aBaseGrasses[i].m_fAmbientImageScalar = sParams.m_fAmbientImageScalar;
			aBaseGrasses[i].m_sHueVariationParams = sParams.m_sHueVariationParams;
		}

		// load & init all grass models
		bSuccess = true;
		for (size_t i = 0; i < aBaseGrasses.size( ); ++i)
		{
			// lod SRT & init associate graphics
			bSuccess &= CMyPopulate::LoadBaseTree(aBaseGrasses[i], m_cConfigFile.m_sDeferredRender.m_bEnabled);

			// determine LOD profile based on SFC file
			if (bSuccess &&
				m_cConfigFile.m_aGrassPopulations[i].m_afLodRange[0] > -1.0f &&
				m_cConfigFile.m_aGrassPopulations[i].m_afLodRange[1] > -1.0f)
			{
				SLodProfile sLodProfile = aBaseGrasses[i].m_pBaseTree->GetLodProfile( );
				sLodProfile.m_fHighDetail3dDistance = m_cConfigFile.m_aGrassPopulations[i].m_afLodRange[0];
				sLodProfile.m_fLowDetail3dDistance = m_cConfigFile.m_aGrassPopulations[i].m_afLodRange[1];
				aBaseGrasses[i].m_pBaseTree->SetLodProfile(sLodProfile);
			}

			// set per-base tree parameters based on SFC file
			if (aBaseGrasses[i].m_pBaseTree)
				aBaseGrasses[i].m_pBaseTree->SetHueVariationParams(aBaseGrasses[i].m_sHueVariationParams);

			if (bSuccess)
				bSuccess &= CMyPopulate::InitBaseTreeGraphics(aBaseGrasses[i].m_pBaseTree, m_cForest);
		}

		if (bSuccess)
		{
			bSuccess = true;

			if (!aBaseGrasses.empty( ))
			{
				st_int32 nIndex = 0;

				m_aGrassLayers.resize(aBaseGrasses.size( ));
				for (size_t i = 0; i < aBaseGrasses.size( ); ++i)
				{
					const CMyPopulate::SMyPerBasePopulation& sBaseTreeData = aBaseGrasses[i];
					if (sBaseTreeData.m_bGrassModel)
					{
						CMyGrassLayer& cLayer = m_aGrassLayers[nIndex];

						// population
						cLayer.SetPopulationParams(m_cConfigFile.m_aGrassPopulations[nIndex]);

						// geometry & render
						st_assert(sBaseTreeData.m_pBaseTree, "A grass model's SRT file should always be successfully loaded at this point");
						cLayer.m_pBaseGrass = sBaseTreeData.m_pBaseTree;
						cLayer.m_fCullRadius = sBaseTreeData.m_pBaseTree->GetExtents( ).ComputeRadiusFromCenter3D( );

						++nIndex;
					}
				}
			}
		}
	}

	return bSuccess;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::SetCullCellSizes

void CMyApplication::SetCullCellSizes(void)
{
	// trees
	m_cVisibleTreesFromCamera.SetCellSize(m_cConfigFile.m_sWorld.m_f3dTreeCellSize);

	// grass
	for (size_t i = 0; i < m_aGrassLayers.size( ); ++i)
	{
		m_aGrassLayers[i].GetVisibleFromMainCamera( ).SetCellSize(m_cConfigFile.m_aGrassPopulations[i].m_fCellSize);

		for (st_int32 j = 0; j < m_cConfigFile.m_sShadows.m_nNumMaps; ++j)
			m_aGrassLayers[i].GetVisibleFromShadowMap(j).SetCellSize(m_cConfigFile.m_aGrassPopulations[i].m_fCellSize);
	}

	// shadows
	if (m_cConfigFile.m_sShadows.m_bEnabled)
		m_cShadowSystem.SetCullCellSize(m_cConfigFile.m_sWorld.m_f3dTreeCellSize);
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::SetHeapReserves

void CMyApplication::SetHeapReserves(void)
{
	CScopeTrace::Start( );

	// call this example utility function that makes decent guesses at good reserve values
	// based on population & view parameters
	m_cAllTreeInstances.ComputeHeapReserveGuess(m_sHeapReserves, m_cConfigFile, m_fAspectRatio);

	// passing values to various sub-systems
	{
		// trees
		m_cVisibleTreesFromCamera.SetHeapReserves(m_sHeapReserves);

		// grass
		for (size_t i = 0; i < m_aGrassLayers.size( ); ++i)
		{
			m_aGrassLayers[i].GetVisibleFromMainCamera( ).SetHeapReserves(m_sHeapReserves);

			for (st_int32 j = 0; j < m_cConfigFile.m_sShadows.m_nNumMaps; ++j)
				m_aGrassLayers[i].GetVisibleFromShadowMap(j).SetHeapReserves(m_sHeapReserves);
		}
		m_aRandomGrassInstancesBuffer.reserve(m_sHeapReserves.m_nMaxPerBaseGrassInstancesInAnyCell);

		// shadows
		if (m_cConfigFile.m_sShadows.m_bEnabled)
			m_cShadowSystem.SetHeapReserves(m_sHeapReserves);
	}
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::NotifyOfPopulationChange

void CMyApplication::NotifyOfPopulationChange(void)
{
	// clear any cached population states from main view
	m_cVisibleTreesFromCamera.NotifyOfPopulationChange( );

	// clear grass population caches
	for (size_t i = 0; i < m_aGrassLayers.size( ); ++i)
		m_aGrassLayers[i].NotifyOfPopulationChanged( );

	// perform same clear for shadow views
	m_cShadowSystem.NotifyOfPopulationChange( );

	// force example app to stream new population into the SDK
	CMyPopulate::StreamTrees(m_cAllTreeInstances,
							 m_cView,
							 m_cVisibleTreesFromCamera,
							 m_cForest.GetFrameIndex( ),
							 m_bRenderTrees,
							 m_bRenderBillboards,
							 false); // false for no shadow pass

	m_bCameraChanged = true;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::UpdateView

void CMyApplication::UpdateView(void)
{
	// setup projection matrix
	Mat4x4 mProjectionMatrix;
	mProjectionMatrix.Perspective(DegToRad(m_cConfigFile.m_sWorld.m_fFieldOfView), m_fAspectRatio, m_cConfigFile.m_sWorld.m_fNearClip, m_cConfigFile.m_sWorld.m_fFarClip);
	if (CCoordSys::IsLeftHanded( ))
		mProjectionMatrix.Scale(1.0f, 1.0f, -1.0f);

	// setup the modelview matrix
	Mat4x4 mModelviewMatrix;
	mModelviewMatrix.Set(m_pCurrentNavigation->GetCameraTransform( ).m_afSingle);
	st_bool bViewChanged = m_cView.Set(m_pCurrentNavigation->GetCameraPos( ), mProjectionMatrix, mModelviewMatrix, m_cConfigFile.m_sWorld.m_fNearClip, m_cConfigFile.m_sWorld.m_fFarClip);

	m_bCameraChanged |= bViewChanged;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::UpdateTimeOfDay

void CMyApplication::UpdateTimeOfDay(void)
{
	st_float32 fSunHeight = -CCoordSys::UpComponent(m_cForest.GetLightDir( ));
	fSunHeight = st_min(1.0f, st_max(0.0f, fSunHeight));
	fSunHeight = st_min(1.0f, fSunHeight * 4.0f);

	// update the forest
	SForestRenderInfo sForestRenderInfo = m_cForest.GetRenderInfo( );

	// fog, horizon color
	sForestRenderInfo.m_vFogColor = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vHorizonColor, m_cConfigFile.m_sFog.m_vColor, fSunHeight);
	sForestRenderInfo.m_vSkyColor = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_vColor, m_cConfigFile.m_sSky.m_vColor, fSunHeight);

	// diffuse light
	sForestRenderInfo.m_sLightMaterial.m_vDiffuse.x = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vDiffuse.x, m_cConfigFile.m_sLighting.m_vDiffuse.x, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vDiffuse.y = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vDiffuse.y, m_cConfigFile.m_sLighting.m_vDiffuse.y, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vDiffuse.z = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vDiffuse.z, m_cConfigFile.m_sLighting.m_vDiffuse.z, fSunHeight);

	// ambient light
	sForestRenderInfo.m_sLightMaterial.m_vAmbient.x = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vAmbient.x, m_cConfigFile.m_sLighting.m_vAmbient.x, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vAmbient.y = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vAmbient.y, m_cConfigFile.m_sLighting.m_vAmbient.y, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vAmbient.z = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vAmbient.z, m_cConfigFile.m_sLighting.m_vAmbient.z, fSunHeight);

	// specular light
	sForestRenderInfo.m_sLightMaterial.m_vSpecular.x = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vSpecular.x, m_cConfigFile.m_sLighting.m_vSpecular.x, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vSpecular.y = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vSpecular.y, m_cConfigFile.m_sLighting.m_vSpecular.y, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vSpecular.z = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vSpecular.z, m_cConfigFile.m_sLighting.m_vSpecular.z, fSunHeight);

	// transmission light
	sForestRenderInfo.m_sLightMaterial.m_vTransmission.x = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vTransmission.x, m_cConfigFile.m_sLighting.m_vTransmission.x, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vTransmission.y = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vTransmission.y, m_cConfigFile.m_sLighting.m_vTransmission.y, fSunHeight);
	sForestRenderInfo.m_sLightMaterial.m_vTransmission.z = Interpolate(m_cConfigFile.m_sLighting.m_sTwilight.m_vTransmission.z, m_cConfigFile.m_sLighting.m_vTransmission.z, fSunHeight);

	SFrameCBLayout& sFrameConstantBufferContents = m_cForest.GetFrameConstantBufferContents( );
	sFrameConstantBufferContents.m_sDirLight.m_vDiffuse = sForestRenderInfo.m_sLightMaterial.m_vDiffuse;
	sFrameConstantBufferContents.m_sDirLight.m_vAmbient = sForestRenderInfo.m_sLightMaterial.m_vAmbient;
	sFrameConstantBufferContents.m_sDirLight.m_vSpecular = sForestRenderInfo.m_sLightMaterial.m_vSpecular;
	sFrameConstantBufferContents.m_sDirLight.m_vTransmission = sForestRenderInfo.m_sLightMaterial.m_vTransmission;
	sFrameConstantBufferContents.m_sDirLight.m_vDir = -m_cForest.GetLightDir( );
	m_cForest.GetFrameConstantBuffer( ).Update( );

	// pass in struct
	m_cForest.SetRenderInfo(sForestRenderInfo);

	// update terrain
	STerrainRenderInfo cTerrainRenderInfo = m_cTerrain.GetRenderInfo( );
	m_cTerrain.SetRenderInfo(cTerrainRenderInfo);

	// update sky
	SSkyRenderInfo sSkyRenderInfo = m_cSky.GetRenderInfo( );
	sSkyRenderInfo.m_vFogColor = sForestRenderInfo.m_vFogColor;
	sSkyRenderInfo.m_vSkyColor = sForestRenderInfo.m_vSkyColor;

	sSkyRenderInfo.m_fSunSize = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_fSunSize, m_cConfigFile.m_sSky.m_fSunSize, fSunHeight);
	sSkyRenderInfo.m_fSunSpreadExponent = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_fSunSpreadExponent, m_cConfigFile.m_sSky.m_fSunSpreadExponent, fSunHeight);

	sSkyRenderInfo.m_vSunColor.x = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_vSunColor.x, m_cConfigFile.m_sSky.m_vSunColor.x, fSunHeight);
	sSkyRenderInfo.m_vSunColor.y = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_vSunColor.y, m_cConfigFile.m_sSky.m_vSunColor.y, fSunHeight);
	sSkyRenderInfo.m_vSunColor.z = Interpolate(m_cConfigFile.m_sSky.m_sTwilight.m_vSunColor.z, m_cConfigFile.m_sSky.m_vSunColor.z, fSunHeight);

	m_cSky.SetRenderInfo(sSkyRenderInfo);
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::UpdateLightDir

void CMyApplication::UpdateLightDir(void)
{
	m_cForest.SetLightDir(m_sLightAdjuster.m_vDir);
	m_bCameraChanged = true;
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::UpdateGlobalLod

void CMyApplication::UpdateGlobalLod(void)
{
	const st_float32 c_fLodScalar = m_sLodAdjuster.m_fFloatValue;
	Report("LOD scalar: %g (1.0 is default)\n", c_fLodScalar);

	// update tree models
	for (size_t i = 0; i < m_aAllBaseTreesAndGrass.size( ); ++i)
	{
		CTree* pTree = m_aAllBaseTreesAndGrass[i];
		//if (!pTree->IsGrassModel( ))
		{
			// if tree isn't already in map, add it
			TOrigLodMap::iterator iFind = m_mOrigLodsMap.find(pTree);
			if (iFind == m_mOrigLodsMap.end( ))
			{
				m_mOrigLodsMap[pTree] = pTree->GetLodProfile( );
			}
			else
			{
				const SLodProfile& sBaseLodProfile = iFind->second;

				// set up temporary scaled LOD profile
				SLodProfile sScaledProfile = sBaseLodProfile;
				sScaledProfile.Scale(c_fLodScalar);

				// activate it
				pTree->SetLodProfile(sScaledProfile);
			}
		}
	}

	// force scene update
	NotifyOfPopulationChange( );
}


///////////////////////////////////////////////////////////////////////
//  CMyApplication::UpdateHandTune

void CMyApplication::UpdateHandTune(void)
{
#ifdef OLD_WAY
	printf("g_vHandTuned = (%g, %g, %g, %g)\n", 
		m_asHandTuneAdjuster[0].m_fFloatValue,
		m_asHandTuneAdjuster[1].m_fFloatValue,
		m_asHandTuneAdjuster[2].m_fFloatValue,
		m_asHandTuneAdjuster[3].m_fFloatValue);

	(void) CShaderConstant::Set4f(g_vHandTuned, m_asHandTuneAdjuster[0].m_fFloatValue, m_asHandTuneAdjuster[1].m_fFloatValue, m_asHandTuneAdjuster[2].m_fFloatValue, m_asHandTuneAdjuster[3].m_fFloatValue);
#endif
}

#include "umbraClipPolygon.hpp"
#include "umbraMath.hpp"

using namespace Umbra;

namespace // anonymous
{
    static inline float getClipVal(const Vector3& a, const Vector4& p)
    {
        return -(a.x*p.x+a.y*p.y+a.z*p.z+p.w);
    }

    UMBRA_FORCE_INLINE Vector3 cliplerp(const Vector3& A, const Vector3& B, float lv)
    {
        Vector3 V = (1.f-lv)*A + lv*B;
        if (A.x == B.x) V.x = A.x;
        if (A.y == B.y) V.y = A.y;
        if (A.z == B.z) V.z = A.z;
        return V;
    }
}   // anonymous namespace

static UMBRA_FORCE_INLINE int clipInner (
    Vector3*        clipped,
    const Vector3&  iA,
    const Vector3&  iB,
    const Vector4&  plEq)
{
    int     cn          = 0;
    Vector3 A           = iA;
    Vector3 B           = iB;
    float   clipValA    = getClipVal(A,plEq);
    float   clipValB    = getClipVal(B,plEq);

    if (clipValA <= 0.0f)                               // if edge is going from inside->outside
    {
        clipped[cn++] = A;                              // insert the vertex
        if (clipValB <= 0.0f)                           // edge completely inside -> we're done
            return cn;
    }

    if (clipValA >= 0.0f && clipValB >= 0.0f)           // edge completely clipped away -> skip
        return cn;

    if (clipValA <= 0.0f)
    {
        swap(A,B);
        swap(clipValA,clipValB);
    }

    UMBRA_ASSERT(clipValA > 0.0);
    UMBRA_ASSERT(clipValB < 0.0);

    float dv = clipValA/(clipValA-clipValB);
    clipped[cn] = cliplerp(A,B,dv);

    //--------------------------------------------------------------------
    // Fixer code
    //--------------------------------------------------------------------

    {
        if (getClipVal(clipped[cn],plEq) > 0.0f)                    // this drops 0.5 -> 0.08
        {
            dv = Math::incrementFloat(dv);
            clipped[cn] = cliplerp(A,B,dv);
        }

        int steps = 0;

        if (getClipVal(clipped[cn],plEq) > 0.0f)
        {
            float   mn  = dv;
            float   mx  = mn+(1e-7f);

            if (mx > 1.0f || getClipVal(cliplerp(A,B,mx),plEq) > 0.0f)
            {
                mx = 1.0f;
            }

            // \todo [Hannu] these asserts cannot be guaranteed due to precision problems
#if 0
            UMBRA_ASSERT(getClipVal(cliplerp(A,B,mx),plEq) <= 0.0f);
            UMBRA_ASSERT(getClipVal(cliplerp(A,B,mn),plEq) >  0.0f);
#endif

            for (;;)
            {
                steps++;

                float mid = (mn+mx)*0.5f;

                if (Math::incrementFloat(mid) >= mx)
                    break;

                if (getClipVal(cliplerp(A,B,mid),plEq) <= 0.0f)
                    mx = mid;
                else
                    mn = mid;

#if 0
                UMBRA_ASSERT(getClipVal(cliplerp(A,B,mx),plEq) <= 0.0f);
#endif
                UMBRA_ASSERT(mx >= mn);
            }

            clipped[cn] = cliplerp(A,B, mx);
#if 0
            UMBRA_ASSERT(getClipVal(clipped[cn],plEq) <= 0.0f);
#endif
        }
    }

    cn++;
    return cn;

}
/*----------------------------------------------------------------------*//*!
 * \internal
 * \brief   clips polygon with a plane.
 * \param
 * \return
 * \todo [wili] assertions: make sure that clipVal[cs] != clipVal[cd] in the
 *       floating point division
 * \todo [wili] Maybe we should refactor the function so that the clip vals
 *       are computed in the loop; this way we could avoid the stack
 *       allocation and the artificial limit?
 *//*----------------------------------------------------------------------*/

int Umbra::clipPolygonPlane (Vector3* clipped, const Vector3* polygon, const Vector4& plEq, int N)
{
    UMBRA_ASSERT(clipped && polygon && N>=0);

    //---------------------------------------------------------------------
    // Clip all edges and output them into 'clipped'
    //---------------------------------------------------------------------

    int cn = 0;                                                             // output vertex count
    for (int i = 0; i < N; i++)
    {
        int j = (i == (N-1)) ? 0 : i+1;                                     // next vertex
        cn += clipInner(clipped+cn, polygon[i], polygon[j], plEq);
    }

    //---------------------------------------------------------------------
    // Remove duplicate vertices generated by the clipper (these may
    // occur due to limitations of floating point precision).
    //---------------------------------------------------------------------

    if (cn < 3)
        return 0;

    N = 1;
    for (int i = 1; i < cn; i++)
    {
        if (clipped[i] == clipped[N-1] ||
            clipped[i] == clipped[0])
            continue;
        clipped[N++] = clipped[i];
    }
    if (N < 3)
        return 0;
    return N;
}

/*----------------------------------------------------------------------*//*!
 * \internal
 * \brief   Gets the normalized plane equation.
 * \param
 * \return
 * \todo [wili] why is the last component -0.0f?
 * \todo [jan] float consistency issues?
 *//*----------------------------------------------------------------------*/

Vector4 Umbra::getNormalizedPlaneEquation (const Vector3& a, const Vector3& b, const Vector3& c)
{
    float   x1 = b.x - a.x;
    float   y1 = b.y - a.y;
    float   z1 = b.z - a.z;
    float   x2 = c.x - a.x;
    float   y2 = c.y - a.y;
    float   z2 = c.z - a.z;
    float   nx = (y1*z2)-(z1*y2);
    float   ny = (z1*x2)-(x1*z2);
    float   nz = (x1*y2)-(y1*x2);

    float   d = nx*nx+ny*ny+nz*nz;

    if (d == 0.f)                               // can't take reciprocal sqrt
        return Vector4(0.0f,0.0f,0.0f,-0.0f);

    d = Math::reciprocalSqrt(d);

    nx *= d;
    ny *= d;
    nz *= d;

    return Vector4(nx,ny,nz,-(a.x*nx+a.y*ny+a.z*nz));
}


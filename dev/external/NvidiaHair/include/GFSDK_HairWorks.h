// This code contains NVIDIA Confidential Information and is disclosed 
// under the Mutual Non-Disclosure Agreement. 
// 
// Notice 
// ALL NVIDIA DESIGN SPECIFICATIONS AND CODE ("MATERIALS") ARE PROVIDED "AS IS" NVIDIA MAKES 
// NO REPRESENTATIONS, WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE WITH RESPECT TO 
// THE MATERIALS, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES OF NONINFRINGEMENT, 
// MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. 
// 
// NVIDIA Corporation assumes no responsibility for the consequences of use of such 
// information or for any infringement of patents or other rights of third parties that may 
// result from its use. No license is granted by implication or otherwise under any patent 
// or patent rights of NVIDIA Corporation. No third party distribution is allowed unless 
// expressly authorized by NVIDIA.  Details are subject to change without notice. 
// This code supersedes and replaces all information previously supplied. 
// NVIDIA Corporation products are not authorized for use as critical 
// components in life support devices or systems without express written approval of 
// NVIDIA Corporation. 
// 
// Copyright (c) 2013 NVIDIA Corporation. All rights reserved.
//
// NVIDIA Corporation and its licensors retain all intellectual property and proprietary
// rights in and to this software and related documentation and any modifications thereto.
// Any use, reproduction, disclosure or distribution of this software and related
// documentation without an express license agreement from NVIDIA Corporation is
// strictly prohibited.
//

/*

-----------------------------------------------------------------------------
                                   HairWorks                                 
-----------------------------------------------------------------------------

NVIDIA HairWorks enables users to simulate and render fur/hair to provide a 
truly interactive game experience. The technology originates from multiple 
simulation and rendering technologies that NVIDIA has developed in the past. 
This combines rendering technologies for human hair (GDC 2008) as well as 
various simulation technologies shown in multiple events (Fur Demo - GDC2012).

To make the hair/fur technologies a product, NVIDIA engineers have put
together these existing technologies and added new techniques to ensure a 
smooth pipeline for a variety of characters.

-----------------------------------------------------------------------------
                             INTEGRATION EXAMPLE                             
-----------------------------------------------------------------------------

This is an overview of the integration. Please refer to the API documentation
in the header file and the sample code for details.

(1.) LOAD THE LIBRARY

	#include "GFSDK_HairWorks.h" // hairworks main header file

	GFSDK_HairSDK* g_pHairSDK = GFSDK_LoadHairSDK("GFSDK_HairWorks.win64.dll",
	                                              GFSDK_HAIRWORKS_VERSION);

(2.) INITIALIZE

Initialize D3D Device.

	g_pHairSDK->InitRenderResources(pd3dDevice);

Create the hair asset manually from your asset data

	GFSDK_HairAssetDescriptor hairAssetDescriptor;
	hairAssetDescriptor.m_NumGuideHairs = 4;
	hairAssetDescriptor.m_NumVertices = 20;
	hairAssetDescriptor.m_pVertices = vertices;
	hairAssetDescriptor.m_pEndIndices = endIndices;
	hairAssetDescriptor.m_pBindPoses = bindPoses;
	hairAssetDescriptor.m_pBoneParents = boneParents;
	...
	g_pHairSDK->CreateHairAsset(g_hairAssetDescriptor, &g_hairAssetID);

Or load it from the .apx file (generated by DCC tool or FurViewer) using the API.
	
	g_pHairSDK->LoadHairAssetFromFile("test.apx", &g_hairAssetID);

Create a hair instance from the hair asset.

	g_pHairSDK->CreateHairInstance(g_hairAssetID, &hairInstanceID);

(3.) UPDATE/RENDER

Set render context for HairWorks.

	g_pHairSDK->SetCurrentContext(pd3dContext);

Run simulation for all hairs.

	g_pHairSDK->StepSimulation(fElapsedTime);

Update/render the hair instance.

	GFSDK_HairInstanceDescriptor hairInstanceDescriptor;
	hairInstanceDescriptor.m_width = 0.2;
	hairInstanceDescriptor.m_density = 1.0;
	hairInstanceDescriptor.m_lengthNoise = 0.0f;
	hairInstanceDescriptor.m_simulate = true;
	...
	g_pHairSDK->UpdateInstanceDescriptor(hairInstanceID, hairInstanceDescriptor);

Set view matrix and projection matrix.

	D3DXMATRIX projection = *g_Camera.GetProjMatrix();
	D3DXMATRIX view = *g_Camera.GetViewMatrix();
	g_pHairSDK->SetViewProjection((const gfsdk_float4x4*)&view,(const gfsdk_float4x4*)&projection);

Set your hair pixel shader before rendering hairs.

	pd3dContext->PSSetShader(g_customHairWorksShader, NULL, 0);

Render the hair instance.

	g_pHairSDK->RenderHairs(hairInstanceID);

(4.) RELEASE

	g_pHairSDK->FreeHairInstance(hairInstanceID);
	g_pHairSDK->FreeHairAsset(hairAssetID);
	g_pHairSDK->FreeRenderResources();
	g_pHairSDK->Release();

*/

#ifndef __GFSDK_HAIRWORKS_H__
#define __GFSDK_HAIRWORKS_H__

#include "GFSDK_HairWorks_Common.h"
#include <d3d11.h>

#define GFSDK_HAIRWORKS_VERSION 200


/**
	\brief Dual Quaternion data used for dual quaternion skinning option
	\details Defines a dual quaternion structure with 2 pairs of gfsdk_float4.  
				First gfsdk_float4 is interpreted as normal quaternion and the second gfsdk_float4 is interpreted as dual quteranion.
*/
struct gfsdk_dualquaternion
{
	gfsdk_float4 q0; // first quaternion
	gfsdk_float4 q1; // second (dual) quaternion

	gfsdk_dualquaternion() {}

	gfsdk_dualquaternion(const gfsdk_float4 iq0, const gfsdk_float4 iq1) : q0(iq0), q1(iq1)
	{
		q0.x = iq0.x; q0.y = iq0.y; q0.z = iq0.z; q0.w = iq0.w; 
		q1.x = iq1.x; q1.y = iq1.y; q1.z = iq1.z; q1.w = iq1.w; 
	}

	gfsdk_dualquaternion(gfsdk_F32 qx, gfsdk_F32 qy, gfsdk_F32 qz, gfsdk_F32 qw, gfsdk_F32 dqx, gfsdk_F32 dqy, gfsdk_F32 dqz, gfsdk_F32 dqw)
	{
		q0.x = qx; q0.y = qy; q0.z = qz; q0.w = qw;
		q1.x = dqx, q1.y = dqy; q1.z = dqz; q1.w = dqw;
	}

	gfsdk_F32& operator[](gfsdk_S32 i)
	{
		return *((gfsdk_F32*)this + i);
	}

	operator gfsdk_F32*()
	{
		return (gfsdk_F32*) this;
	}
};

/**
	\brief Identifier for hair asset data.
	\details The asset id is assigned by HairWorks SDK, and corresponds to a unique asset type.
	\see HairSDK.LoadHairAsset()
*/
enum GFSDK_HairAssetID
{
	GFSDK_HairAssetID_NULL = 0xFFFF	//!< invalid hair asset ID
};

/**
	\brief Identifier for a hair instance
	\details Multiple hair instances can be created from a single asset type.  
	\see HairSDK.CreateHairInstance() and HairSDK.FreeHairInstance()
*/
enum GFSDK_HairInstanceID
{
	GFSDK_HairInstanceID_NULL = 0xFFFF //!< invalid hair instance ID
};

/**
	\brief Error code for all HairSDK functions.
	\details Every function under GFSDK_HairSDK returns this error code, based on results.
	GFSDK_RETURN_OK is returned when the function proceeeds successfully, 
	and GFSDK_RETURN_FAIL is returned when there is an error.
*/
typedef gfsdk_U32 GFSDK_HAIR_RETURNCODES;


/**
	\brief Log types to filter log messages
	\details Log messages can be filtered by its log type.
	\see GFSDK_HAIR_LogHandler
*/
enum GFSDK_HAIR_LOG_TYPES
{
	GFSDK_HAIR_LOG_ERROR   = 0, //!< error messages
	GFSDK_HAIR_LOG_WARNING = 1, //!< warning messages
	GFSDK_HAIR_LOG_INFO    = 2, //!< information messages
	GFSDK_HAIR_LOG_DEBUG   = 3, //!< used only in debug version of dll
	GFSDK_HAIR_LOG_ALL     = -1, //!< all log types
};

/**
	\brief Base class for custom log handler
	\details To get the log/error messages, inherit this class and implement the virtual method Log().
	         You can print the message to a file or to an output window, or you can just ignore.
	\see GFSDK_HAIR_LOG_TYPES
*/
class GFSDK_HAIR_LogHandler
{
public:
	virtual ~GFSDK_HAIR_LogHandler() {}

	/**
		\brief Derived class should implement this method to handle the log message.
		\param [in] logType The log type for the message
		\param [in] message The message string
		\param [in] file The filename that outputs the message
		\param [in] line The line number of the file that outputs the message
	*/
	virtual void Log(GFSDK_HAIR_LOG_TYPES logType, const char* message, const char* file, int line) = 0;
};

///maximum allowed size for name string
#define GFSDK_HAIR_MAX_STRING	128 
///maximum allowed size for GFSDK_HairWorksInfo member variable's string
#define GFSDK_HAIR_MAX_INFO_STRING	1024

/**
	\brief Coordinate system setting for file import and camera view projection
	\details Handedness of coordinate system may affect internal HairWorks computation depedent on camera such as culling and shading.
*/
enum GFSDK_HAIR_HANDEDNESS_HINT
{
	GFSDK_HAIR_HANDEDNESS_UNKNOWN, //!< don't know the handedness, use best guess.
	GFSDK_HAIR_RIGHT_HANDED, //!< uses a right handed system (Z is pointing toward the viewer)
	GFSDK_HAIR_LEFT_HANDED,  //!< uses a left handed system ( Z is pointing away from the viewer)
};

/**
	\brief Up axis setting of the asset
	\details When up axis is different between original DCC tool and HairWorks runtime, provide this info to the file loading APIs.
	\see GFSDK_HairImportSettings
*/
enum GFSDK_HAIR_UP_AXIS_HINT
{
	GFSDK_HAIR_UP_AXIS_UNKNOWN, //!< don't know the up axis, use best guess.
	GFSDK_HAIR_Y_UP,  //!< camera is y-up
	GFSDK_HAIR_Z_UP,  //!< camera is z-up
};
/**
	\brief HairWorks file header

	\details Contains info about this file.

	\note If the version is matched, GFSDK_HairSDK.LoadHairAsset() fails.
*/
struct GFSDK_HairWorksInfo
{
	gfsdk_char		m_fileVersion[GFSDK_HAIR_MAX_INFO_STRING];	//!< file format version
	gfsdk_char		m_toolVersion[GFSDK_HAIR_MAX_INFO_STRING];	//!< tool version
	gfsdk_char		m_sourcePath[GFSDK_HAIR_MAX_INFO_STRING];	//!< source asset path
	gfsdk_char		m_authorName[GFSDK_HAIR_MAX_INFO_STRING];	//!< author name
	gfsdk_char		m_lastModified[GFSDK_HAIR_MAX_INFO_STRING]; //!< last modified date and time in format "YYYY-MM-DD HH:MM:SS"

	GFSDK_HairWorksInfo()
	{
		m_fileVersion[0] = '\0';
		m_toolVersion[0] = '\0';
		m_sourcePath[0] = '\0';
		m_authorName[0] = '\0';
		m_lastModified[0] = '\0';
	}
};

/**
	\brief Describes each collision sphere attached to a bone
	\details To enable collision handling between sphere and/or capsule and hair curves, we define a 'boneSphere',
		a sphere whose center is attached to one of the bones used for skinning hairs.
		One can assign radius as well as initial offset with regard to the bind pose of the attached bone.
*/
struct gfsdk_boneSphere
{
	gfsdk_U32		m_BoneSphereIndex;		//!< index for the bone where the collision sphere is attached to
	gfsdk_F32		m_BoneSphereRadius;		//!< radius for the collision sphere
	gfsdk_float3	m_BoneSphereLocalPos;	//!< offset value with regard to bind position of the bone
};

/**
	\brief Descriptor to specify hair asset (hair curves, growth mesh, skinning weights, bone info...)

	\details Hair assets are defined in memory with this data structure, and comrises important part of the hair asset data (.apx) file format.
	This structure defines a minimal static data needed to create hairs in HairWorks.
	A minimal hair assets consists of guide curve data typically exported from DCC tools, and growth mesh face index/uv data.
	Note that vertices of the growth mesh are required to match the root positions of hair guide curves, 
	so it is automatically derived from the curve data without being explicitly stored in the data structure.
	The skinning informations (bone index, weight) are derived from that of the growth mesh, and we use skinning info
	to compute target (skinned) positions for each guide hair.  Same bone index/weights are used for CVs of each guide hair.

	\note When the data is invalid, GFSDK_HairSDK.LoadHairAsset() rejects the hair asset.
	\see All dynamic parameters per hair instance are defined in GFSDK_HairInstanceDescriptor.
*/
struct GFSDK_HairAssetDescriptor
{
	gfsdk_U32		m_NumGuideHairs;//!< number of hair guide hair curves
	gfsdk_U32		m_NumVertices;	//!< number of total # of cvs in guide curves
	gfsdk_float3*	m_pVertices;	//!< all the cv positions of guide curves
	gfsdk_U32*		m_pEndIndices;	//!< index of last vertex for each hair curve pointing to the m_pVertices array
									//!< size of this array should be 'm_NumGuideHairs'	
	gfsdk_U32		m_NumFaces;		//!< number of hair triangles, we grow hairs for each mesh triangles
	gfsdk_U32*		m_pFaceIndices; //!< triangle indices for hair faces, size must be 3 * m_NumFaces
	gfsdk_float2*	m_pFaceUVs;		//!< uv values for hair faces, size must be 3 * m_NumFaces

	gfsdk_U32		m_NumBones;		//!< number of bones used to skin hair curves, the asset should have at least one bone
	gfsdk_float4*	m_pBoneIndices; //!< size should be 'm_NumGuideHairs'. each mesh vertex (hair root) can have up to 4 bone indices.
	gfsdk_float4*	m_pBoneWeights; //!< size should be 'm_NumGuideHairs'. each mesh vertex (hair root) can have up to 4 bone weights.

	gfsdk_char*		m_pBoneNames;	//!<[OPTIONAL] names for each bone used to check if bone names match. buffer size should be at least GFSDK_HAIR_MAX_STRING * 'm_NumBones'.
	gfsdk_float4x4*	m_pBindPoses;	//!<[OPTIONAL] bind pose matrices for each bone. buffer size should be at least sizeof(gfsdk_float4x4) * m_NumBones.
	gfsdk_S32*		m_pBoneParents; //!<[OPTIONAL] parent index for each bone.  if this is a root bone, the index will be -1. buffer size should be at least sizoef(gfsdk_S32) * m_NumBones.

	gfsdk_U32		m_NumBoneSpheres; //!< [OPTIONAL] collision spheres used for collision handling between body and hair 
	gfsdk_boneSphere* m_pBoneSpheres; //!< [OPTIONAL] collision sphere data, each sphere is attached to a bone.
											 //!< The size of this array should be m_NumBoneSpheres
	gfsdk_U32		m_NumBoneCapsules; //!< [OPTIONAL] capsules are defined by connecting a pair of collision spheres
	gfsdk_U32*		m_pBoneCapsuleIndices; //!< [OPTIONAL] index to the bone spheres, size of this array must be 2 * m_NumBoneCapsules;

	gfsdk_U32		m_NumPinConstraints; //!< [OPTIONAL] spheres used to apply soft constraint to pin hairs around the spheres.
	gfsdk_boneSphere* m_pPinConstraints; //!< [OPTIONAL] constraint sphere data, each sphere is attached to a bone. The size of this array should be m_NumPinConstraints.

	gfsdk_char*		m_pTextureNames; //!< [OPTIONAL] placeholder to load hair texture file names from apx file. The size must be GFSDK_HAIR_MAX_STRING * GFSDK_HAIR_NUM_TEXTURES

	gfsdk_F32		m_sceneUnit; //!< scene unit scale in centimeters
	gfsdk_U32		m_handedness; //!< handedness of coordniate system this asset used at time of creation/conversion.  See GFSDK_HAIR_HANDEDNESS_HINT.
	gfsdk_U32		m_upAxis;	  //!< up axis of coordniate system this asset used at time of creation/conversion.  See GFSDK_HAIR_UP_AXIS_HINT.
	

	GFSDK_HairAssetDescriptor::GFSDK_HairAssetDescriptor() :
		m_NumGuideHairs(0),
		m_NumVertices(0),		
		m_pVertices(0),
		m_pEndIndices(0),

		m_NumFaces(0),
		m_pFaceIndices(0),
		m_pFaceUVs(0),

		m_NumBones(0),
		m_pBoneIndices(0),
		m_pBoneWeights(0),
		m_pBoneNames(0),
		m_pBindPoses(0),
		m_pBoneParents(0),

		m_NumBoneSpheres(0),
		m_pBoneSpheres(0),
		m_NumBoneCapsules(0),
		m_pBoneCapsuleIndices(0),

		m_NumPinConstraints(0),
		m_pPinConstraints(0),

		m_pTextureNames(0),

		m_sceneUnit(1.0f),
	
		m_handedness(0), // unknown
		m_upAxis(0)  // unknown
	{
	}
};

struct GFSDK_HairAssetCopySettings
{
	bool m_copyGroom;
	bool m_copyCollision;
	bool m_copyTextures;
	bool m_copyConstraints;
	bool m_copyAll;
public:
	GFSDK_HairAssetCopySettings() :
		m_copyAll(true),
		m_copyGroom(true),
		m_copyCollision(true),
		m_copyTextures(true),
		m_copyConstraints(true)
		{
		}
};

/**
	\brief Texture types used for hair control textures
	\details Some parameters for hair shape/shading/simulation can be controlled with more detail by textures.
			Most of these textures are sampled based on (U,V) values derived from the growth mesh.
			It is OK to share same texture resource for multiple texture type.
			Most of textures have a corresponding constant value, and its value gets used as a multiplier to sampled texture values.
	\see HairSDK.SetTextureSRV()
*/
enum GFSDK_HAIR_TEXTURE_TYPE
{
	GFSDK_HAIR_TEXTURE_DENSITY, //<! hair density map [ shape control ]
	GFSDK_HAIR_TEXTURE_ROOT_COLOR, //<! color at the hair root [ shading ]
	GFSDK_HAIR_TEXTURE_TIP_COLOR, //<! color at the hair tip [ shading ]
	GFSDK_HAIR_TEXTURE_ROOT_WIDTH,  //<! width at the hair root [ shape control ]
	GFSDK_HAIR_TEXTURE_TIP_WIDTH, //<! width at the hair tip [ shape control ]
	GFSDK_HAIR_TEXTURE_STIFFNESS,  //<! stiffness control [ simulation ]
	GFSDK_HAIR_TEXTURE_ROOT_STIFFNESS, //<! stiffness control for root stiffness [simulation]
	GFSDK_HAIR_TEXTURE_CLUMP_SCALE,  //<! clumpiness control [ shape control]
	GFSDK_HAIR_TEXTURE_CLUMP_ROUNDNESS,  //<! clumpiness control [ shape control]
	GFSDK_HAIR_TEXTURE_CLUMP_NOISE, //<! clumping noise [ shape control]
	GFSDK_HAIR_TEXTURE_WAVE_SCALE, //<! waviness scale [ shape control ]
	GFSDK_HAIR_TEXTURE_WAVE_FREQ, //<! waviness frequency [ shape control ]
	GFSDK_HAIR_TEXTURE_STRAND, //<! texture along hair strand [ shading ]
	GFSDK_HAIR_TEXTURE_LENGTH, //<! length control [shape control] 
	GFSDK_HAIR_TEXTURE_SPECULAR, //<! specularity control [shading ] 

	GFSDK_HAIR_NUM_TEXTURES
};

/**
	\brief Texture channel for each control textures
	\details For a single-channel control textures, one can pack multiple control textures into a single texture resource.
		When such packing is used, assign channel for each control texture type.
*/
enum GFSDK_HAIR_TEXTURE_CHANNEL
{
	GFSDK_HAIR_TEXTURE_CHANNEL_RED,
	GFSDK_HAIR_TEXTURE_CHANNEL_GREEN,
	GFSDK_HAIR_TEXTURE_CHANNEL_BLUE,
	GFSDK_HAIR_TEXTURE_CHANNEL_ALPHA
};

/**
	\brief resource type that can be read from hairworks internal resources
	\details One can use GetShaderSRV() to retrieve internal attributes that may be needed for pixel shader.
*/
enum GFSDK_HAIR_SHADER_RESOURCE_TYPE
{
	GFSDK_HAIR_SHADER_RESOUCE_HAIR_INDICES,
	GFSDK_HAIR_SHADER_RESOUCE_TANGENTS,
	GFSDK_HAIR_SHADER_RESOUCE_NORMALS,

	GFSDK_HAIR_NUM_SHADER_RESOUCES
};

/**
	\brief Blend mode for strand texture.
	\details When the strand texture is used, the blend mode determines how colors should combine between the 
			strand texture and other color textures (root, tip, etc.)
*/
enum GFSDK_HAIR_STRAND_BLEND_MODE
{
	GFSDK_HAIR_STRAND_BLEND_OVERWRITE, //!< overwrite with strand texture
	GFSDK_HAIR_STRAND_BLEND_MULTIPLY, //!< multiply strand texture to base color (root/tip)
	GFSDK_HAIR_STRAND_BLEND_ADD,	//!< add strand color on top of base color
	GFSDK_HAIR_STRAND_BLEND_MODULATE, //!< add/subtract strand color to/from base color

	GFSDK_HAIR_STRAND_BLEMD_MODE_END,
};

/**
	\brief Colorize option for hair
	\details Different options for colorizing hairs for visualization.
*/
enum GFSDK_HAIR_COLORIZE_MODE
{
	GFSDK_HAIR_COLORIZE_MODE_NONE,
	GFSDK_HAIR_COLORIZE_MODE_LOD, //!< colorize lod factors
	GFSDK_HAIR_COLORIZE_MODE_TANGENTS, //!< colorize hair tangents
	GFSDK_HAIR_COLORIZE_MODE_NORMAL, //!< colorize hair normal
	GFSDK_HAIR_COLORIZE_MODE_RED, //!< just constant red color for debugging

	GFSDK_HAIR_COLORIZE_MODE_END,
};

/**
	\brief Teleport mode
	\details Options for teleport control in UpdateSkinningMatrices.
*/
enum GFSDK_HAIR_TELEPORT_MODE
{
	GFSDK_HAIR_TELEPORT_MODE_NONE,  //!< no teleport (keep simulating)
	GFSDK_HAIR_TELEPORT_MODE_TELEPORT_WITH_SKINNED_POSITION, //!< teleport and set simulation state to skinned position
	GFSDK_HAIR_TELEPORT_MODE_TELEPORT_WITH_CURRENT_STATE, //!< telerpot while preserving current simulation state
};

/**
	\brief Descriptor to control all aspects of hair (can be updated and animated per fame)
	\details HairWorks provides a unified parameter control for shape, simulation and rendering through GFSDK_HairInstanceDescriptor.
		These parameters can be updated using HairSDK.UpdateInstanceDescriptor() between function calls to render or simulations.
	\note Some parameters are length/scale dependent, and all our default values are optimized for CENTIMETERS.
		If the hair scene uses different unit, all unit dependent paramters can be automatically scaled when GFSDK_HairInstanceDescriptor.m_unitInCentimeters is set correspondingly.
*/
struct GFSDK_HairInstanceDescriptor
{
	// general options
	gfsdk_bool		m_enable;

	/// hair geometry (density/width/length/clump) controls
	gfsdk_F32		m_width;					//!< [In Millimeters] hair width (thickness)
	gfsdk_F32		m_widthNoise;				//!< [0 - 1.0] noise factor for hair width noise 
	gfsdk_F32		m_widthRootScale;			//!< [0 - 1.0] scale factor for top side of the strand
	gfsdk_F32		m_widthTipScale;			//!< [0 - 1.0] scale factor for bottom side of the strand

	gfsdk_U32		m_clumpNumSubclumps;		//!< [0 - 8] number of clumps per triangle
	gfsdk_F32		m_clumpNoise;				//!< [0 - 1.0] probability of each hair gets clumped (0 = all hairs get clumped, 1 = clump scale is randomly distributed from 0 to 1)
	gfsdk_F32		m_clumpRoundness;			//!< [0 - 2.0] exponential factor to control roundness of clump shape (0 = linear cone, clump scale *= power(t, roundness), where t is normalized distance from the root)
	gfsdk_F32		m_clumpScale;				//!< [0 - 1.0] how clumped each hair face is
	gfsdk_bool		m_clumpPerVertex;			//!< [true/false] use per vertex clumping or per face clumping

	gfsdk_F32		m_density;					//!< [0 -    ] hair density per face (1.0 = 64 hairs per face)
	gfsdk_bool		m_usePixelDensity;			//!< [true/false] whether to use per-pixel sampling or per-vertex sampling for density map

	gfsdk_F32		m_lengthNoise;				//!< [0 - 1.0] length variation noise
	gfsdk_F32		m_lengthScale;				//!< [0 - 1.0] length control for growing hair effect

	gfsdk_F32		m_volumeSpread;				//!< [0 - 1.0] add noise to positions of the interpolated hairs

	gfsdk_F32		m_waveScale;				//!< [In Centimeters] size of waves for hair waviness 
	gfsdk_F32		m_waveScaleNoise;			//!< [0 - 1.0] noise factor for the wave scale
	gfsdk_F32		m_waveRootStraighten;		//!< [0 - 1.0] For some distance from the root, we atteunate waviness so that root itself does not move [0-1]
	gfsdk_F32		m_waveFreq;					//!< [0 -    ] wave frequency (1.0 = one sine wave along hair length)
	gfsdk_F32		m_waveFreqNoise;			//!< [0 - 1.0] noise factor for the wave frequency 
	gfsdk_F32		m_waveClump;				//!< [0 - 1.0] waviness at clump level
	gfsdk_F32		m_waveStrand;				//!< [0 - 1.0] waviness at strand level

	/// shading controls
	gfsdk_F32		m_ambientEnvScale;			//!< [0 - 1.0] scaling factor for env ambient

	gfsdk_F32		m_diffuseBlend;				//!< [0 - 1.0] blend factor between Kajiya hair lighting vs normal skin lighting.
	gfsdk_F32		m_diffuseScale;				//!< [0 - 1.0] scale factor for diffuse shading term
	gfsdk_F32		m_diffuseHairNormalWeight;	//!< [0 - 1.0] blend factor between mesh normal vs hair normal. Use higher value for longer (surface like) hair.
	gfsdk_U32		m_diffuseBoneIndex;			//!< [0 - number of bones] index for the bone which we use as model center for diffuse shading purpose
	gfsdk_float3	m_diffuseBoneLocalPos;		//!< [0 - ] offset value with regard to bind position of the diffuse shading bone

	gfsdk_F32		m_diffuseNoiseFreqU;		//!< [0 - 1.0] luminance noise along u direction
	gfsdk_F32		m_diffuseNoiseFreqV;		//!< [0 - 1.0] luminance noise along v direction
	gfsdk_F32		m_diffuseNoiseScale;		//!< [0 - 1.0] amount of noise scale
	gfsdk_F32		m_diffuseNoiseGain;			//!< [0 - 1.0] amount of noise gain

	gfsdk_F32		m_textureBrightness;		//!< [0 - 1.0] scale factor to texture brightness

	gfsdk_F32		m_glintStrength;			//!< [0 - 1.0] strength of the glint noise
	gfsdk_F32		m_glintCount;				//!< [0 - 1024] number of glint sparklets along each hair
	gfsdk_F32		m_glintExponent;			//!< [0 - ] glint power exponent

	gfsdk_float4	m_specularColor;			//!< [0 - 1.0] specular color
	gfsdk_F32		m_specularNoiseScale;		//!< [0 - 1.0] amount of specular noise
	gfsdk_F32		m_specularEnvScale;			//!< [0 - 1.0] amount of specular scale from env probe
	gfsdk_F32		m_specularPrimary;			//!< [0 - 1.0] primary specular factor
	gfsdk_F32		m_specularPowerPrimary;		//!< [0 - ] primary specular power exponent
	gfsdk_F32		m_specularPrimaryBreakup;	//!< [0 - 1.0] shift factor to make specular highlight move with noise
	gfsdk_F32		m_specularSecondary;		//!< [0 - 1.0] secondary specular factor
	gfsdk_F32		m_specularSecondaryOffset;	//!< [0 - 1.0] secondary highlight shift offset along tangents
	gfsdk_F32		m_specularPowerSecondary;	//!< [0 - ] secondary specular power exponent		

	gfsdk_bool		m_useTextures;				//!< [true/false] use textures 
	gfsdk_F32		m_rootAlphaFalloff;			//!< [0 - 1.0] falloff factor for alpha transition from root 
	gfsdk_float4	m_rootColor;				//!< [0 - 1.0] color of hair root (when hair textures are not used)
	gfsdk_float4	m_tipColor;					//!< [0 - 1.0] color of hair tip (when hair textures are not used)
	gfsdk_F32		m_rootTipColorWeight;		//!< [0 - 1.0] blend factor between root and tip color in addition to hair length
	gfsdk_F32		m_rootTipColorFalloff;		//!< [0 - 1.0] falloff factor for root/tip color interpolation

	gfsdk_bool		m_castShadows;				//!< [true/false] this hair cast shadows onto the scene
	gfsdk_bool		m_receiveShadows;			//!< [true/false] this hair receives shadows from the scene
	gfsdk_F32		m_shadowSigma;				//!< [In Centimeters] distance through hair volume beyond which hairs get completely shadowed.

	gfsdk_U32		m_strandBlendMode;			//!< [GFSDK_HAIR_STRAND_BLEND_MODE] blend mode when strand texture is used. Supported mode are defined in GFSDK_HAIR_STRAND_BLEND_MODE.
	gfsdk_F32		m_strandBlendScale;			//!< [0 - 1.0] scale strand texture before blend

	// simulation control
	gfsdk_F32		m_backStopRadius;			//!< [0 - 1.0] radius of backstop collision (normalized along hair length)
	gfsdk_F32		m_bendStiffness;			//!< [0 - 1.0] stiffness for bending, useful for long hair
	gfsdk_F32		m_damping;					//!< [0 - ] damping to slow down hair motion
	gfsdk_float3	m_gravityDir;				//!< [0 - 1.0] gravity force direction (unit vector)
	gfsdk_F32		m_friction;					//!< [0 - 1.0] friction when capsule collision is used
	gfsdk_F32		m_massScale;				//!< [In Meters] mass scale for this hair
	gfsdk_F32		m_inertiaScale;				//!< [0 - 1.0] inertia control. (0: no inertia, 1: full intertia)
	gfsdk_F32		m_inertiaLimit;				//!< [In Meters] speed limit where everything gets locked (for teleport etc.)
	gfsdk_F32		m_interactionStiffness;		//!< [0 - 1.0] how strong the hair interaction force is
	gfsdk_F32		m_rootStiffness;			//!< [0 - 1.0] attenuation of stiffness away from the root (stiffer at root, weaker toward tip)
	gfsdk_F32		m_pinStiffness;				//!< [0 - 1.0] stiffness for pin constraints
	gfsdk_bool		m_simulate;					//!< [true/false] whether to turn on/off simulation
	gfsdk_F32		m_stiffness;				//!< [0 - 1.0] how close hairs try to stay within skinned position
	gfsdk_F32		m_stiffnessStrength;		//!< [0 - 1.0] how strongly hairs move toward the stiffness target
	gfsdk_F32		m_stiffnessDamping;			//!< [0 - 1.0] how fast hair stiffness gerneated motion decays over time
	gfsdk_F32		m_tipStiffness;				//!< [0 - 1.0] attenuation of stiffness away from the tip (stiffer at tip, weaker toward root)
	gfsdk_bool		m_useCollision;				//!< [true/false] whether to use the sphere/capsule collision or not for hair/body collision
	gfsdk_bool		m_useDynamicPin;			//!< [true/false] If true, pin constraint transformation is computed by simulation.  If false, it follows the bone.
	gfsdk_float3	m_wind;						//!< [In Meters] vector force for main wind direction
	gfsdk_F32		m_windNoise;				//!< [0 - 1.0] strength of wind noise

	gfsdk_bool		m_stiffnessBoneEnable;		//!< [true/false] If true, bone based scaling is used for stiffness
	gfsdk_U32		m_stiffnessBoneIndex;		//!< [0 - number of bones] index for the bone which we use as reference position for setting min/max distance
	gfsdk_U32		m_stiffnessBoneAxis;		//!< [0 - 2] which axis (X,Y,Z) to use for min/max. Default is 2 (Z-axis).
	gfsdk_F32		m_stiffnessStartDistance;	//!< [In Meters] signed distance from the bone center that specifies start of stiffness scaling
	gfsdk_F32		m_stiffnessEndDistance;		//!< [In Meters] signed distance from the bone center that specifies end of stiffness scaling
	gfsdk_float4	m_stiffnessBoneCurve;		//! [0 - 1.0] curve values for bone based stiffness control

	gfsdk_float4	m_stiffnessCurve;			//! [0 - 1.0] curve values for stiffness 
	gfsdk_float4	m_stiffnessStrengthCurve;	//! [0 - 1.0] curve values for stiffness strength
	gfsdk_float4	m_stiffnessDampingCurve;	//! [0 - 1.0] curve values for stiffness damping
	gfsdk_float4	m_bendStiffnessCurve;		//! [0 - 1.0] curve values for bend stiffness
	gfsdk_float4	m_interactionStiffnessCurve;//! [0 - 1.0] curve values for interaction stiffness

	/// lod controls
	gfsdk_bool		m_enableLOD;				//!< [true/false] whether to enable/disable entire lod scheme

	gfsdk_bool		m_enableDistanceLOD;		//!< [true/false] whether to enable lod for far away object (distance LOD)
	gfsdk_F32		m_distanceLODStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start fading out (by reducing density)
	gfsdk_F32		m_distanceLODEnd;			//!< [In Meters] distance (in scene unit) to camera where fur will completely disappear (and stop simulating)
	gfsdk_F32		m_distanceLODFadeStart;		//!< [In Meters] distance (in scene unit) to camera where fur will fade with alpha from 1 (this distance) to 0 (DistanceLODEnd)
	gfsdk_F32		m_distanceLODDensity;		//!< [0 - ] density when distance LOD is in action.  hairDensity gets scaled based on LOD factor.
	gfsdk_F32		m_distanceLODWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	gfsdk_bool		m_enableDetailLOD;			//!< [true/false] whether to enable lod for close object (detail LOD)
	gfsdk_F32		m_detailLODStart;			//!< [In Meters] distance (in scene unit) to camera where fur will start getting denser toward closeup density
	gfsdk_F32		m_detailLODEnd;				//!< [In Meters] distance (in scene unit) to camera where fur will get full closeup density value
	gfsdk_F32		m_detailLODDensity;			//!< [0 - ] density scale when closeup LOD is in action.  hairDensity gets scaled based on LOD factor.
	gfsdk_F32		m_detailLODWidth;			//!< [In Millimeters] hair width that can change when close up density is triggered by closeup lod mechanism

	gfsdk_F32		m_shadowDensityScale;		//!< [0 - 1] density scale factor to reduce hair density for shadow map rendering

	gfsdk_bool		m_useViewfrustrumCulling;	//!< [true/false] when this is on, density for hairs outside view are set to 0. Use this option when fur is in a closeup.
	gfsdk_bool		m_useBackfaceCulling;		//!< [true/false] when this is on, density for hairs growing from backfacing faces will be set to 0
	gfsdk_F32		m_backfaceCullingThreshold; //!< [-1 - 1.0] threshold to determine backface, note that this value should be slightly smaller 0 to avoid hairs at the silhouette from disappearing

	gfsdk_bool		m_useCullSphere;			//!< [true/false] when this is on, hairs get culled when their root points are inside the sphere
	gfsdk_float4x4	m_cullSphereInvTransform;	//!< inverse of general affine transform (scale, rotation, translation..) applied to a unit sphere centered at origin

	gfsdk_U32		m_splineMultiplier;			//!< [1 - 4] spline multiplier for guide hair spline interpolation

	// drawing option
	gfsdk_bool		m_drawRenderHairs;			//!< [true/false] draw render hair
	gfsdk_bool		m_visualizeBones;			//!< [true/false] visualize skinning bones
	gfsdk_bool		m_visualizeBoundingBox;		//!< [true/false] draw bounding box of hairs
	gfsdk_bool		m_visualizeCapsules;		//!< [true/false] visualize collision capsules
	gfsdk_bool		m_visualizeControlVertices; //!< [true/false] draw control vertices of guide hairs
	gfsdk_bool		m_visualizeCullSphere;		//!< [true/false] draw cull sphere
	gfsdk_bool		m_visualizeDiffuseBone;		//!< [true/false] visualize diffuse bone
	gfsdk_bool		m_visualizeFrames;			//!< [true/false] visualize coordinate frames
	gfsdk_bool		m_visualizeGrowthMesh;		//!< [true/false] draw growth mesh
	gfsdk_bool		m_visualizeGuideHairs;		//!< [true/false] draw guide hairs
	gfsdk_bool		m_visualizeHairInteractions;//!< [true/false] draw hair interaction lines
	gfsdk_U32		m_visualizeHairSkips;		//!< [0 - ] for per hair visualization, how many hairs to skip?
	gfsdk_bool		m_visualizeLocalPos;		//!< [true/false] visualize target pose for bending
	gfsdk_bool		m_visualizePinConstraints;	//!< [true/false] whether to visualize pin constraint spheres
	gfsdk_bool		m_visualizeShadingNormals;	//!< [true/false] visualize normals used for hair shading
	gfsdk_bool		m_visualizeSkinnedGuideHairs; //!< [true/false] draw skinned positions for guide hairs
	gfsdk_bool		m_visualizeStiffnessBone;	//!< [true/false] visualize stiffness bone

	gfsdk_U32		m_colorizeMode;				//!< [GFSDK_HAIR_COLORIZE_MODE] colorize hair based on various terms. See GFSDK_HAIR_COLORIZE_MODE.
	
	// texture control
	GFSDK_HAIR_TEXTURE_CHANNEL m_textureChannels[GFSDK_HAIR_NUM_TEXTURES]; //!< texture chanel for each control textures.  
	
	// model to world transform
	gfsdk_float4x4	m_modelToWorld;				// render time transformation to offset hair from its simulated position

	// default values
	GFSDK_HairInstanceDescriptor() :

		// general options
		m_enable(true),

		// default geometry parameters
		m_width(1.0f),
		m_widthNoise(0.0f),
		m_widthRootScale(1.0f),
		m_widthTipScale(0.1f),

		m_clumpNoise(0.0f),
		m_clumpRoundness(1.0f),
		m_clumpScale(0.0f),
		m_clumpNumSubclumps(0),
		m_clumpPerVertex(false),
		
		m_density(1.0f), 
		m_lengthNoise(1.0f),
		m_lengthScale(1.0f),
			
		m_usePixelDensity(false),
		m_volumeSpread(0.0f),
		m_waveScale(0.0f),
		m_waveScaleNoise(0.5f),
		m_waveFreq(3.0f),
		m_waveFreqNoise(0.5f),
		m_waveRootStraighten(0.0f),
		m_waveClump(1.0f),
		m_waveStrand(0.0f),

		// default shading parameters
		m_ambientEnvScale(1.0f),

		m_diffuseBlend(0.5f),
		m_diffuseScale(1.0f),
		m_diffuseHairNormalWeight(0.0f),
		m_diffuseBoneIndex(gfsdk_U32(-1)),

		m_diffuseNoiseFreqU(64.0f),
		m_diffuseNoiseFreqV(64.0f),
		m_diffuseNoiseScale(0.0f),
		m_diffuseNoiseGain(0.0f),

		m_textureBrightness(1.0f),

		m_glintStrength(0.0f),
		m_glintCount(256.0f),
		m_glintExponent(2.0f),
		m_rootTipColorWeight(0.5f),
		m_rootTipColorFalloff(1.0f),

		m_specularNoiseScale(0.0f),
		m_specularEnvScale(0.25f),
		m_specularPrimary(0.1f),
		m_specularPrimaryBreakup(0.0f),
		m_specularSecondary(0.05f),
		m_specularSecondaryOffset(0.1f),
		m_specularPowerPrimary(100.0f),
		m_specularPowerSecondary(20.0f),

		m_rootAlphaFalloff(0.0f),

		m_useTextures(true),

		m_shadowSigma(0.2f),
		m_castShadows(true),
		m_receiveShadows(true),

		m_strandBlendMode(GFSDK_HAIR_STRAND_BLEND_OVERWRITE),
		m_strandBlendScale(1.0f),

		// default simulation parameters
		m_simulate(true),
		m_backStopRadius(0.0f),
		m_bendStiffness(0.0f),
		m_damping(0.0f),
		m_friction(0.0f),
		m_inertiaScale(1.0f),
		m_inertiaLimit(1000.0f),
		m_interactionStiffness(0.0f),
		m_massScale(10.0f),
		m_windNoise(0.0f),
		m_stiffness(0.5f),
		m_stiffnessStrength(1.0f),
		m_stiffnessDamping(0.0f),
		m_rootStiffness(0.5f),
		m_pinStiffness(1.0f),
		m_tipStiffness(0.0f),
		m_useCollision(false),
		m_useDynamicPin(false),

		m_stiffnessBoneEnable(false),
		m_stiffnessBoneIndex(1000),
		m_stiffnessBoneAxis(2),
		m_stiffnessStartDistance(0.0f),
		m_stiffnessEndDistance(0.0f),
		
		// default LOD parameters
		m_enableLOD(false),

		m_enableDistanceLOD(true),
		m_distanceLODStart(5.0f), 
		m_distanceLODEnd(10.0f), 
		m_distanceLODFadeStart(1000.0f),
		m_distanceLODDensity(0.0f),
		m_distanceLODWidth(1.0f),

		m_enableDetailLOD(true),
		m_detailLODStart(2.0f), 
		m_detailLODEnd(1.0f), 
		m_detailLODDensity(1.0f),
		m_detailLODWidth(1.0f),

		m_shadowDensityScale(1.0f),

		m_useViewfrustrumCulling(true),
		m_useBackfaceCulling(false),
		m_backfaceCullingThreshold(-0.2f),
		m_useCullSphere(false),

		m_splineMultiplier(4),

		// visualization options
		m_drawRenderHairs(true),		
		m_visualizeBones(false),
		m_visualizePinConstraints(false),
		m_visualizeCapsules(false),
		m_visualizeGrowthMesh(false),	
		m_visualizeGuideHairs(false),	
		m_visualizeControlVertices(false),
		m_visualizeBoundingBox(false),
		m_visualizeCullSphere(false),
		m_visualizeDiffuseBone(false),
		m_visualizeHairInteractions(false),
		m_visualizeSkinnedGuideHairs(false),	
		m_visualizeFrames(false),
		m_visualizeLocalPos(false),
		m_visualizeShadingNormals(false),
		m_visualizeHairSkips(0),
		m_visualizeStiffnessBone(false),

		m_colorizeMode(GFSDK_HAIR_COLORIZE_MODE_NONE)

		{
			m_gravityDir.x = 0.0f; 
			m_gravityDir.y = 0.0f; 
			m_gravityDir.z = -1.0f;

			m_wind.x = 0.0f; 
			m_wind.y = 0.0f; 
			m_wind.z = 0.0f;

			m_rootColor.x = 1.0f; m_rootColor.y = 1.0f; m_rootColor.z = 1.0f; m_rootColor.w = 1.0f;
			m_tipColor.x = 1.0f; m_tipColor.y = 1.0f; m_tipColor.z = 1.0f; m_tipColor.w = 1.0f;
			m_specularColor.x = 1.0f; m_specularColor.y = 1.0f; m_specularColor.z = 1.0f; m_specularColor.w = 1.0f;

#define MAKE_IDENTITY(M) M._11 = 1.0f; M._12 = 0.0f; M._13 = 0.0f; M._14 = 0.0f; \
			M._21 = 0.0f; M._22 = 1.0f; M._23 = 0.0f; M._24 = 0.0f; \
			M._31 = 0.0f; M._32 = 0.0f; M._33 = 1.0f; M._34 = 0.0f; \
			M._41 = 0.0f; M._42 = 0.0f; M._43 = 0.0f; M._44 = 1.0f;

			MAKE_IDENTITY(m_modelToWorld);

			MAKE_IDENTITY(m_cullSphereInvTransform);

			m_diffuseBoneLocalPos.x = 0.0f;	m_diffuseBoneLocalPos.y = 0.0f;	m_diffuseBoneLocalPos.z = 0.0f;

#define SETX(X, V) X.x = V; X.y = V; X.z = V; X.w = V;

			SETX(m_stiffnessCurve, 1.0f);
			SETX(m_stiffnessStrengthCurve, 1.0f);
			SETX(m_stiffnessDampingCurve, 1.0f);
			SETX(m_bendStiffnessCurve, 1.0f);
			SETX(m_interactionStiffnessCurve, 1.0f);
			SETX(m_stiffnessBoneCurve, 1.0f);

#undef MAKE_IDENTITY
#undef SETX

			for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
				m_textureChannels[i] = GFSDK_HAIR_TEXTURE_CHANNEL_RED;
		}
};

/**
	\brief statistics for optimization and profiling
	\details For statistics or profiling purpose, one can query the HairSDK how much resources are currently consumed.
	\see Use HairSDK.ComputeStats() to retrieve this data.
*/
struct GFSDK_HairStats
{
	gfsdk_S32	m_numHairs;					//!< total hair counts for the hair instances
	gfsdk_S32	m_numFaces;					//!< total face counts for the hair instance
	gfsdk_F32	m_averageCV;				//!< average CV per hair
	gfsdk_F32	m_averageDensity;			//!< average density, accouting for density maps, etc.
	gfsdk_F32	m_averageHairsPerFace;		//!< average hairs per face

	gfsdk_F32	m_distanceLODFactor;		//!< distance LOD factor
	gfsdk_F32	m_detailLODFactor;			//!< closeup LOD factor
	gfsdk_F32	m_camDistance;				//!< distance to camera

public:
	GFSDK_HairStats() :
		m_numHairs(0),
		m_numFaces(0),

		m_averageCV(0.0f),
		m_averageDensity(0.0f),
		m_averageHairsPerFace(0.0f),

		m_distanceLODFactor(0.0f),
		m_detailLODFactor(0.0f),
		m_camDistance(0.0f)

		{}
};

/**
	\brief descriptor structure to customize HairWorks rendering
	\details Users can customize HairWorks runtime by providing their render settings.
*/
#define GFSDK_HAIR_SHADER_EMIT_NONE 0x0000		// emit no attributes
#define GFSDK_HAIR_SHADER_EMIT_TANGENT 0x0001	// emit tangent vector
#define GFSDK_HAIR_SHADER_EMIT_NORMAL  0x0002		// emit normal vector of the growth mesh
#define GFSDK_HAIR_SHADER_EMIT_TEXCOORD 0x0004	// emit (u,v) texcoord of hair root (growth mesh)
#define GFSDK_HAIR_SHADER_EMIT_HAIRTEX  0x0008	// emit texcoord along hair length
#define GFSDK_HAIR_SHADER_EMIT_ALL	0xffff

struct GFSDK_HairShaderSettings
{
	gfsdk_bool	m_useCustomShaderResources;	//!< If true, HairWorks will not bind shader resoruces for textures
	gfsdk_bool	m_useCustomConstantBuffer;	//!< If true, HairWorks will not bind constant bufer
	gfsdk_U32	m_shaderAttributeMask;		//!< GS-PS pipe will only emit attribute whose mask is 1
	gfsdk_bool	m_shadowPass;				//!< If true, density and width will be adjusted based on m_shadowDensityScale of GFSDK_HairInstanceDescriptor
	gfsdk_bool	m_depthFuncLess;			//!< If true, we assume depth comparison function is less.  If false, we assume depth comparison is greater.
	gfsdk_bool	m_optimizeShader;			//!< If true, runtime shader optimization is enabled
	gfsdk_bool	m_usePixelShaderInterpolation; //!< If true, shader attributes are interpolated at pixel shader (enabled only when m_optimizeShader is true)

public:
	GFSDK_HairShaderSettings(
		gfsdk_bool	useCustomShaderResources =  true,
		gfsdk_bool	useCustomConstantBuffer = true,
		gfsdk_U32	shaderAttributeMask = GFSDK_HAIR_SHADER_EMIT_ALL,
		gfsdk_bool	shadowPass = false,
		gfsdk_bool	depthFuncLess = true,
		gfsdk_bool	optimizeShader = true,
		gfsdk_bool	usePixelShaderInterpolation = true
		) 
	{
		m_useCustomShaderResources	= useCustomShaderResources;
		m_useCustomConstantBuffer	= useCustomConstantBuffer;
		m_shaderAttributeMask		= shaderAttributeMask;
		m_shadowPass				= shadowPass;
		m_depthFuncLess				= depthFuncLess;
		m_optimizeShader			= optimizeShader;
		m_usePixelShaderInterpolation = usePixelShaderInterpolation;
	}
};

/**
	\brief shader cache settings that causes different shader code to be created.
	HairWorks optimize shader by storing different shader code based on asset parameter variations.
	For unused options, we remove related code blocks from the compiled shader, so shaders run faster.
	Note that once an option is disabled in shader cache, the feature will not work even if it is enabled in instance descriptor in runtime.
*/
struct GFSDK_HairShaderCacheSettings
{
	bool		useCullSphere;		//!< if cull sphere is used (GFSDK_HairInstanceDescriptor.m_useCullSphere == true)
	bool		useClumping;		//!< if clumping is used (GFSDK_HairInstanceDescriptor.m_clumpScale > 0)
	bool		useWaveStrand;		//!< if strand waviness is used (GFSDK_HairInstanceDescriptor.m_waveScale > 0 && GFSDK_HairInstanceDescriptor.m_waveStrand > 0)
	bool		useWaveClump;		//!< if strand waviness is used (GFSDK_HairInstanceDescriptor.m_waveScale > 0 && GFSDK_HairInstanceDescriptor.m_waveClump > 0)
	bool		usePixelDensity;	//!< if per-pixel density option is used (GFSDK_HairInstanceDescriptor.m_usePixelDeisnty = true)
	bool		isTextureUsed[GFSDK_HAIR_NUM_TEXTURES]; //!< flag to tell if control texture is used.  
									// Currently, only the following textures need to be checked. (Pixel Shader textures are not used for shader cache).
									// GFSDK_HAIR_TEXTURE_DENSITY,
									// GFSDK_HAIR_TEXTURE_LENGTH,
									// GFSDK_HAIR_TEXTURE_ROOT_WIDTH,
									// GFSDK_HAIR_TEXTURE_TIP_WIDTH,
									// GFSDK_HAIR_TEXTURE_WAVE_SCALE,
									// GFSDK_HAIR_TEXTURE_WAVE_FREQ,
									// GFSDK_HAIR_TEXTURE_CLUMP_SCALE,
									// GFSDK_HAIR_TEXTURE_CLUMP_NOISE,
									// GFSDK_HAIR_TEXTURE_CLUMP_ROUNDNESS,
	GFSDK_HAIR_TEXTURE_CHANNEL	textureChannel[GFSDK_HAIR_NUM_TEXTURES]; //!< texture channels 

	// default option is to turn on all the options
	GFSDK_HairShaderCacheSettings()
	{
		useCullSphere				=	true;
		useClumping					=	true;
		useWaveStrand				=	true;
		useWaveClump				=	true;
		usePixelDensity				=	true;

		for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
		{
			isTextureUsed[i] = true;
			textureChannel[i] = GFSDK_HAIR_TEXTURE_CHANNEL_RED; 
		}
	}

	// set feature sets from instance descriptor.
	// Note that texture references are not part of instance descriptor, so still need to be set after this function.
	void SetFromInstanceDescriptor(const GFSDK_HairInstanceDescriptor &desc)
	{
		usePixelDensity = desc.m_usePixelDensity;
		useCullSphere	= desc.m_useCullSphere;

		useClumping	= desc.m_clumpScale > 0.0f;
		useWaveStrand = (desc.m_waveScale > 0.0f) && (desc.m_waveStrand > 0.0f);
		useWaveClump = (desc.m_waveScale > 0.0f) && (desc.m_waveClump > 0.0f);

		for (int i = 0; i < GFSDK_HAIR_NUM_TEXTURES; i++)
			textureChannel[i] = desc.m_textureChannels[i]; //!< texture chanel for each control textures.  
	}
};

/**
	\brief Constant buffer structure to map hair shading data to DX constant buffer
	\see Use GFSDK_HairSDK.PrepareShaderConstantBuffer() to get this data structure properly mapped for shader use.
*/

struct GFSDK_HairShaderConstantBuffer
{
	#define GFSDK_HAIR_CONSTANT_BUFFER_SIZE 1280 // = 1024 + 256 constant buffer size used by HairWorks pixel shader.
	float m_data[GFSDK_HAIR_CONSTANT_BUFFER_SIZE]; 
};

/**
	\brief Settings to apply coorindate/unit conversion for hair asset loading.
	\details When hair asset is exported from various DCC tools, needs may arise to properly convert unit and coordinate system settings to match
		different setups in game engines. Use the following data structure to provide information about how HairWorks should convert those.
	\note The axis conversion uses data stored in GFSDK_HairAssetDescriptor (m_upAxis, m_handedness).
		If any of the data is set to unknown (0), or if any of target hint is unknown, we do not perform any default conversion.
	\note If m_pConversionMatrix is set to non-null, this overrides standard conversion and we multiply this matrix as follows
		For all position data (hair vertices, etc.)
			p_converted = p_old * m_pConversionMatrix
		For all matrix data (bind pose matrix, etc.)
			M_converted = M_old * m_pConversionMatrix.
*/
struct GFSDK_HairConversionSettings
{
	GFSDK_HAIR_UP_AXIS_HINT			m_targetUpAxisHint;			//!< up axis used by the game engine that will use this asset in runtime
	GFSDK_HAIR_HANDEDNESS_HINT		m_targetHandednessHint;		//!< handedness of original tools that generated this asset
	gfsdk_float4x4*					m_pConversionMatrix;		//!< If not null, we use this conversion matrix instead
	gfsdk_F32						m_targetSceneUnit;			//!< scene unit (in centimeters) for game engine.  0 means unknown (use source unit)
																// Centimeter (default): 1.0.
																// Meter: 100.0 
																// Inch: 2.54
																// Decimeter: 10.0
public:
	GFSDK_HairConversionSettings() :
		m_targetUpAxisHint(GFSDK_HAIR_UP_AXIS_UNKNOWN),
		m_targetHandednessHint(GFSDK_HAIR_HANDEDNESS_UNKNOWN),
		m_pConversionMatrix(0),
		m_targetSceneUnit(0.0f)
	{
	}
};
/**
	\brief This abstract class provides all the API for HairWorks runtime
*/
class GFSDK_HairSDK
{
public:
	/*=============================================================================================
		OVERVIEW

		To use HairWorks runtime, we first need to load the HairWorks dll and create this HairSDK object.
		See LoadHairSDK(gfsdk_cstr dllPath, gfsdk_U32 version = GFSDK_HAIRWORKS_VERSION) at the end of this header.
		Once SDK's DLL is loaded, we can use the HairSDK object to access all the APIs below.
		When HairSDK is not needed (typically at the shutdown stage of a game), call Release().
	=============================================================================================*/

	/*
		\brief Deletes this SDK object.
		\return GFSDK_RETURN_OK is returned when the SDK object was sucessfully destroyed.
	*/
	virtual GFSDK_HAIR_RETURNCODES Release(void) = 0;

	/*=============================================================================================
		HAIR ASSET PREPARATION AND MANAGEMENT

		The first step is to get hair asset created and loaded, and get hair asset ID.
		The hair assets can be either created manually or loaded from a file (.apx/.apb).
		
		See functions below.
	=============================================================================================*/

	/**
		\brief loads hair asset data from descriptor. 
		\param [in] assetDesc The hair asset descriptor created from apx file, etc.
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value.
		\return GFSDK_RETURN_OK is returned when hair asset is loaded successfully.
	*/
	virtual GFSDK_HAIR_RETURNCODES CreateHairAsset(const GFSDK_HairAssetDescriptor& assetDesc, GFSDK_HairAssetID *assetID) = 0;

	/**
		\brief destory/release hair asset data
		\param [in] assetID hair asset ID to delete
		\return GFSDK_RETURN_OK is returned when hair asset was successfully destroyed.
	*/
	virtual GFSDK_HAIR_RETURNCODES FreeHairAsset( const GFSDK_HairAssetID assetID ) = 0;

	/**
		\brief load hair asset data from an (.apx/.apb) file
		\param [in] filename File name for a valid .apx or .apb file that stores hair asset descirptor and instance descriptor, texture file references
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value. assetID must be not NULL.
		\param [out] info If the info is not null, the info is filled upon success.
		\param [in] pSettings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See GFSDK_HairConversionSettings.
	
		\return GFSDK_RETURN_OK is returned if file read was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadHairAssetFromFile(
		gfsdk_cstr							filename, 
		GFSDK_HairAssetID*					assetID, 
		GFSDK_HairWorksInfo*				info = 0, 
		const GFSDK_HairConversionSettings*	pSettings = 0) = 0;

	/**
		\brief load hair asset data from a memory buffer that contains (.apx/.apb) file content
		\param [in] pMemoryBuffer Pointer to the memory buffer that contains a valid .apx or .apb file content.
		\param [in] memoryBufferSizeBytes Size of the memory buffer in bytes.
		\param [out] assetID Upon success, assetID is filled by a valid GFSDK_HairAssetID value.
		\param [out] info If the info is not null, the info is filled upon success.
		\param [in] pSettings Conversion settings regarding scene unit, up vector, coordinate handedness, etc. See GFSDK_HairConversionSettings.
	
		\return GFSDK_RETURN_OK is returned if file read was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadHairAssetFromMemory(
		const void*							pMemoryBuffer, 
		gfsdk_U32							memoryBufferSizeBytes, 
		GFSDK_HairAssetID*					assetID, 
		GFSDK_HairWorksInfo*				info = 0, 
		const GFSDK_HairConversionSettings* pSettings = 0) = 0;

	/**
		\brief save hair asset data to an (.apx/.apb) file
		\param [in] filename File name for a .apx or .apb file to store hair asset descriptor and instance descriptor, texture files.
		\param [in] assetID hair asset ID to store.
		\param [in] pInstanceDescriptor Instance descriptor to save in apx file.  If this is NULL, default instance descriptor for the asset will be saved.
		\param [in] pInfo file header info to be stored. info can be NULL.
		\param [in] pTextureNames Set texture file names if different from the names in the original asset. If NULL, texture file names loaded from original asset will be saved.
		\return GFSDK_RETURN_OK is returned if file write was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveHairAssetToFile(
		gfsdk_cstr							filename, 
		const GFSDK_HairAssetID				assetID, 
		const GFSDK_HairInstanceDescriptor* pInstanceDescriptor = 0, 
		const GFSDK_HairWorksInfo*			pInfo = 0,
		const gfsdk_cstr*					pTextureNames = 0) = 0;

	/**
		\brief save hair instance data to an (.apx/.apb) file
		\param [in] filename File name for a .apx or .apb file to store hair asset descriptor and instance descriptor, texture files.
		\param [in] instnaceID hair instance ID to save.
		\param [in] pInfo file header info to be stored. info can be NULL.
		\param [in] pTextureNames Set texture file names if different from the names in the original asset. If NULL, texture file names loaded from original asset will be saved.
		\return GFSDK_RETURN_OK is returned if file write was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveHairInstanceToFile(
		gfsdk_cstr							filename, 
		const GFSDK_HairInstanceID			instanceID, 
		const GFSDK_HairWorksInfo*			pInfo = 0,
		const gfsdk_cstr*					pTextureNames = 0) = 0;

	/**
		\brief get access to loaded asset data.  
		\param[in] assetID asset identifier to get the descriptor
		\return The pointer to the internal asset descriptor will be returned upon a valid assetID, otherwise a NULL will be returned.
		\note Users should not write values to this pointer, it should be only used for reference and verification purpose.
	*/
	virtual const GFSDK_HairAssetDescriptor* GetHairAssetDescriptor(const GFSDK_HairAssetID assetID) = 0;

	/**
		\brief copy some parts of assets from one asset to another
		\param[in] fromAssetID asset id to copy property from
		\param[in] toAssetID asset id to copy property to
		\note Useful for importing certain part of asset data.  fromAssetID and toAssetID cannot be the same.
		\return GFSDK_RETURN_OK is returned if copy operation was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyAsset(
		const GFSDK_HairAssetID		fromAssetID, 
		const GFSDK_HairAssetID		toAssetID,
		GFSDK_HairAssetCopySettings settings = GFSDK_HairAssetCopySettings()
		) = 0;

	/**
		\brief Get hair default instance descriptor from the asset.
		\param [in] hairAssetID hair asset id that holds the default instance descriptor
		\param [in] materialId material id if there exist multiple materials
		\param [inout] descriptor Hair instance descriptor to copy the data to.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyInstanceDescriptorFromAsset(
		const GFSDK_HairAssetID			hairAssetID, 
		GFSDK_HairInstanceDescriptor&	descriptor, 
		gfsdk_U32						materialId = 0) = 0;

	/**
		\brief resample number of cvs to target number
		\param[in] assetID asset identifier to resample
		\param[in] targetNbPointsPerHair number of cvs for each hair
		\return GFSDK_RETURN_OK is returned if resampling was successfull.
	*/
	virtual GFSDK_HAIR_RETURNCODES ResampleGuideHairs(
		const GFSDK_HairAssetID			assetID, 
		gfsdk_U16						targetNbPointsPerHair) = 0;

	/*=============================================================================================
		HAIR SHADER CACHE MANAGEMENT

		HairWorks provides options to create optimized shader for each specific asset.
		By removing unused features, performance can be significantly improved. 
		This 'cooking' process can be performed before game runs and does not require D3D device or context.
		This process can be done as preprocess once all the assets are locked for game release.

		Use the following functions to create, store, and load optimized shader caches.
		NOTE: If shader cache is not defined, HairWorks will run in unoptimized mode.

	=============================================================================================*/
	/**
		\brief clear entire shader cache database
		\details call this function in the beginning of shader cache cooking process.
		\return GFSDK_RETURN_OK is returned if cache was properly initialized and cleared.
	*/
	virtual GFSDK_HAIR_RETURNCODES ClearShaderCache(
		) = 0;

	/**
		\brief add new shader cache based on specified shader settings
		\details add shader to the cache with specified settings
		\param[in] settings flags that affect shader cache generation.  If matching shader already exists, this will be skipped.
		\return GFSDK_RETURN_OK is returned if cache was added or it already exists.
	*/
	virtual GFSDK_HAIR_RETURNCODES AddToShaderCache(
		const GFSDK_HairShaderCacheSettings& settings
		) = 0;

	/**
		\brief Save serialized shader cache data to given memory buffer.
		\details Once caches has been added, use this function to get serialized cache buffer. Users can write this data to their own file format for future use.
		\param[out] ppMemoryBuffer Cache buffer will be allocated using HairWorks allocator, and will be filled with cache data.
		\param[out] memoryBufferSizeBytes size of cache buffer is returned.
		\return GFSDK_RETURN_OK is returned if cache was properly serialized.
	*/
	virtual GFSDK_HAIR_RETURNCODES SaveShaderCacheToMemory(
		void**							ppMemoryBuffer, 
		size_t&							memoryBufferSizeBytes
		) = 0;

	/**
		\brief Check if shader cache is used or not for the specified instance
		\param[in] instanceID hair instance id to examine shader cache status
		\param[out] statusCode 0: cache is not found, 1: cache is found, but shaders are not created, 2: cache is found and shader is used.
		\return GFSDK_RETURN_OK is returned if the operation succeeded.
	*/
	virtual GFSDK_HAIR_RETURNCODES CheckShaderCacheStatus( 
		GFSDK_HairInstanceID			instanceID, 
		int&							status
		) = 0;

	/**
		\brief Load previously cooked shader cache.
		\details This fills internal shader cache from serialized data that was generated by SaveShaderCacheToMemory() function calls.
		\see CreateShadersFromShaderCache must be called to actually create D3D shader from the caches.
		\param[in] pMemoryBuffer memory buffer to load cache data from.
		\param[in] append If true, shader cache is appended to existing data. If false, loaded data overwrites the caches.
		\return GFSDK_RETURN_OK is returned if cache data is valid and shader caches were properly initialized.
	*/
	virtual GFSDK_HAIR_RETURNCODES LoadShaderCacheFromMemory(
		const void*						pMemoryBuffer,
		bool							append = false
	) = 0;

	/**
		\brief Create actual D3D shaders from shader cache.
		\note This should be used after a valid D3DDevice was given with InitRenderResources().
		\return GFSDK_RETURN_OK is returned if shader creation was successful.
	*/
	virtual GFSDK_HAIR_RETURNCODES CreateShadersFromShaderCache() = 0;

	/*=============================================================================================
		RENDERER INITIALIZATION

		Once the game starts running and DX device is prepared, we should call InitRenderResources() once for HairSDK to 
		consequently manage internal DX resources.
	=============================================================================================*/

	/**
		\breif Initialize DX11 device and internal render state variables and shaders
		\param [in] pd3dDevice The DX11 device that HairWorks should use to create all the DX11 resources
		\param [in] pd3dContext When d3d context is know at time of calling this function, set it here. If not use SetCurrentContext() later.
					
		\return GFSDK_RETURN_OK is returned when rendering resources has been successfully initialized.
	*/
	virtual GFSDK_HAIR_RETURNCODES InitRenderResources( ID3D11Device *pd3dDevice, ID3D11DeviceContext* pd3dContext= 0) = 0;

	/**
		\brief Clean up all the internally used DX11 resources.
		\return GFSDK_RETURN_OK is returned when rendering resources has been successfully cleaned up.
	*/
	virtual GFSDK_HAIR_RETURNCODES FreeRenderResources() = 0;

	/**
		\brief set current D3D context. 
		\detail All subsequent hairworks calls will use this context for simulation and rendering
	*/
	virtual GFSDK_HAIR_RETURNCODES SetCurrentContext(ID3D11DeviceContext* pd3dContext) = 0;

	/*=============================================================================================
		HAIR INSTANCE MANAGEMENT

		Given properly initialized HairSDK object and hair asset ID, we can now instantiate an actual 
		hair instance object anytime during the game play, allowing hair creatures to be dynamically 
		spawned/deleted on the fly.
		All the control parameters defined in the GFSDK_HairInstanceDescriptor can be updated anytime.
		Control textures for the parameters can be set either using D3D SRV, 
		and these can be set anytime once hair instance has been created.
	=============================================================================================*/

	/**
		\brief Create a hair instance from given asset type
		\param [in] hairAssetID hair asset type to create a hair instance from.  
					The assetID should have been generated from a successful call of HairSDK.LoadHairAsset().
		\param [out] newInstanceID If a hair instance was successfully created, an ID value is written to this variable.
		\return GFSDK_RETURN_OK is returned when the new hair instance was successfully created.
	*/
	virtual GFSDK_HAIR_RETURNCODES CreateHairInstance( const GFSDK_HairAssetID hairAssetID, GFSDK_HairInstanceID* newInstanceID) = 0;

	/**
		\brief Delete a given hair instance
		\param [in] hairInstanceID hair instance to delete
		\return GFSDK_RETURN_OK is returned when the hair instance was successfully destroyed.
	*/
	virtual GFSDK_HAIR_RETURNCODES FreeHairInstance( const GFSDK_HairInstanceID hairInstanceID ) = 0;

	/**
		\brief Get currently used instance descriptor for the chosen hair instance 
		\param [in] hairInstanceID hair instance id to get the instance descriptor
		\param [inout] descriptor Hair instance descriptor to copy the data to.
	*/
	virtual GFSDK_HAIR_RETURNCODES CopyCurrentInstanceDescriptor(const GFSDK_HairInstanceID hairInstanceID, GFSDK_HairInstanceDescriptor& descriptor, gfsdk_U32 materialId = 0) = 0;

	/**
		\brief Update hair instance parameters
		\details One can change rendering/simulation parameters by updating hair instance descriptor.  
					This can be called at any time during runtime, but typically called before 
					either HairSDK.RenderHairs() or HairSDK.StepSimulation() calls.
		\param [in] hairInstanceID hair instance to update.
		\param [in] descriptor hair instance descriptor to update.
		\param [in] [optional] which material set to update when there are multiple material sets
		\return GFSDK_RETURN_OK is returned when the hair instance parameters were successfully updated.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateInstanceDescriptor( const GFSDK_HairInstanceID hairInstanceID, const GFSDK_HairInstanceDescriptor &descriptor, gfsdk_U32 materialId = 0) = 0;

	/**
		\brief Set material to use or blend during simulation and rendering
		\details For transition between multiple materials, one can either directly set the material ID and transition weight with respect to the default material (id = 0).
				This can be useful to implement transition from dry to wet material, etc.
		\param [in] hairInstanceID hair instance to update.
		\param [in] materialId which material to use. If this value is 0 (default), the weight is ignored.
		\param [in] weight for non-default material, this value is used to interpolate between default and this material.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetCurrentMaterial( const GFSDK_HairInstanceID hairInstanceID, gfsdk_U32 materialId, gfsdk_F32 weight = 1.0f) = 0;

	/**
		\brief Set texture resource for control textures
		\param [in] hairInstanceID hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [in] pResource shader resource view created for the input texture, note texture resource should be managed by game itself.
		\return GFSDK_RETURN_OK is returned when the hair control texture was successfully updated.
	*/ 
	virtual GFSDK_HAIR_RETURNCODES SetTextureSRV(const GFSDK_HairInstanceID hairInstanceID, const GFSDK_HAIR_TEXTURE_TYPE textureType, ID3D11ShaderResourceView* pResource) = 0;

	/**
		\brief Get texture resource for control textures
		\param [in] hairInstanceID hair instance to update texture
		\param [in] textureType	which control texture to update?
		\param [out] ppResource shader resource view for stored control textures are copied, if avaialble.  Otherwise NULL value will be written.
		\return GFSDK_RETURN_OK is returned when the hair control texture was successfully updated.
		\note This function does not change reference counter for SRV. The returned pointer should not be stored for later use.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetTextureSRV(const GFSDK_HairInstanceID hairInstanceID, const GFSDK_HAIR_TEXTURE_TYPE textureType, ID3D11ShaderResourceView** pResource) = 0;

	/**
		\brief Get shader resources that may be needed for pixel shader optimization.
		\param [in] hairInstanceID hair instance to get resources from
		\param [in] resourceType which resource to get?
		\param [in] ppResource shader resource view created for the given resource type and hair instance.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetShaderSRV(
		const GFSDK_HairInstanceID				hairInstanceID, 
		const GFSDK_HAIR_SHADER_RESOURCE_TYPE	resourceType, 
		ID3D11ShaderResourceView**				ppResource
		) = 0;

	/*=============================================================================================
		ANIMATION AND SIMULATION

		To move and animate hairs, a typical process is to give it an animation first, by updating 
		bones used to skin animated hair shapes.  The bone data can be either in the form of 
		standard linear matrices (HairSDK.UpdateSkinningMatrices) or dual quaterions (HairSDK.UpdateSkinningDQs).
		Once skinning bones are set, we call HairSDK.StepSimulation() to further simulation motion of hairs for each frame.
		We allow maximum of 4 bones per each hair, see GFSDK_HairAssetDescriptor.m_pBoneIndices and GFSDK_HairAssetDescriptor.m_pBoneWeights.
	=============================================================================================*/

	/**
		\brief update skinning bone matrices by linear matrices
		\param [in] hairInstanceID hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the GFSDK_HairAssetDescriptor.
		\param [in] boneMatrices array of linear bone matrices
		\return GFSDK_RETURN_OK is returned when the hair skinning bones have been successfully updated.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateSkinningMatrices( 
		const GFSDK_HairInstanceID			hairInstanceID, 
		const gfsdk_U32						numBones, 
		const gfsdk_float4x4*				boneMatrices, 
		GFSDK_HAIR_TELEPORT_MODE			teleportMode = GFSDK_HAIR_TELEPORT_MODE_NONE ) = 0;

	/**
		\brief update skinning bone matrices by dual quaternions
		\param [in] hairInstanceID hair instance to update the bone data
		\param [in] numBones number of bones.  This should match the number of bones defined in the GFSDK_HairAssetDescriptor.
		\param [in] boneMatrices array of dual quaternions.
		\return GFSDK_RETURN_OK is returned when the hair skinning bones have been successfully updated.
	*/
	virtual GFSDK_HAIR_RETURNCODES UpdateSkinningDQs( const GFSDK_HairInstanceID hairInstanceID, const gfsdk_U32 numBones, const gfsdk_dualquaternion *dqs ) = 0;

	/**
		\brief Runs simulation for all currently active hair instances for one frame.
		\details Compute GPU skinning for hair and run hair simulation for all the active hair instances.
		\param [in] pd3dContext D3D context where the simulation should happen.
		\param [in] timeStepSize simulation time step size in second for one frame.  Typically we sync with display fps (60).
		\param [in] worldReference This is useful when world containing hair itself is moving, but motion due to moving world is not desired and needs to be canceled out. 
		\return GFSDK_RETURN_OK is returned when the hair simulation was sucessfully finished.
	*/
	virtual GFSDK_HAIR_RETURNCODES StepSimulation( gfsdk_F32 timeStepSize = 1.0f / 60.0f, const gfsdk_float4x4* worldRefrence = 0) = 0;

	/**
		\brief Returns a conservative bounds for hairs.
		\param [in] hairInstanceID hair instance to get the bounds information
		\param [inout] bbMin If not NULL, miminum bounds will be written here.
		\param [inout] bbMax If not NULL, maximum bounds will be written here.
		\param [in] growthMeshOnly If true, only growth mesh bound (approximate) will be returned.
		\return GFSDK_RETURN_OK is returned when bounds computation was successfully finished.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBounds( const GFSDK_HairInstanceID hairInstanceID, gfsdk_float3* bbMin, gfsdk_float3* bbMax, bool growthMeshOnly = false) = 0;

	/*=============================================================================================
		RENDERING HAIRS

		To render hairs, we first set global environment such as camera (HairSDK.SetViewProjection).
		For each hair instance, we then call HairSDK.RenderHairs() function to render hairs to current render target.
		Note that it is also important to set camera properly for the Level of Detail (LOD) controls, as 
		most LOD controls are based on distance to the camera.

	=============================================================================================*/

	/**
		\brief set camera projection matrices
		\param [in] view The standard camera view matrix (same order as D3D)
		\param [in] proj The standard camera projection matrix (same order as D3D)
		\return GFSDK_RETURN_OK is returned when camera matrices were properly set.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetViewProjection(const gfsdk_float4x4 *view, const gfsdk_float4x4 *proj, float FOV = 70.0f) = 0;

	/**
		\brief fill constant buffer for custom hair shading
		\details This function fills constant buffer data structure GFSDK_HairShaderConstantBuffer for binding custom constant buffer in connection with custom hair pixel shader.
		\param [in] hairInstanceID hair instance to render
		\param [out] pConstantBuffer The context of provided constant buffer structure will be filled.
		\note SetViewProjection() function should be called before using this function to get proper view/camera data in the constant buffer.
	*/
	virtual GFSDK_HAIR_RETURNCODES PrepareShaderConstantBuffer(const GFSDK_HairInstanceID, GFSDK_HairShaderConstantBuffer* pConstantBuffer) = 0;

	/** 
		\brief render a hair instance to the current render target.
		\details This function does the main hair rendering.  
		\param [in] pd3dContext current D3D context to render hairs
		\param [in] hairInstanceID hair instance to render
		\return GFSDK_RETURN_OK is returned if hair rendering finishes successfully.
	*/
	virtual GFSDK_HAIR_RETURNCODES RenderHairs( const GFSDK_HairInstanceID, const GFSDK_HairShaderSettings* pShaderSettings = 0) = 0;		

	/**
		\brief render visualization functions
		\param [in] hairInstanceID hair instance to render
		\return GFSDK_RETURN_OK is returned if hair rendering finishes successfully.
	*/
	virtual GFSDK_HAIR_RETURNCODES RenderVisualization( const GFSDK_HairInstanceID instanceId) = 0;

	/**
		\brief start custom msaa step for hair rendering
		\details This step switches render target to internal MSAA buffer.  
		\return GFSDK_RETURN_OK is returned if MSAA setup was successfully prepared.
	*/
	virtual GFSDK_HAIR_RETURNCODES StartMSAARendering(UINT sampleCount = 0, bool depthCompareLess = false) = 0;

	/**
		\brief finish custom msaa step for hair rendering.
		\details This step composite msaa generated hair colors and depth on the current render target
		\return GFSDK_RETURN_OK is returned if MSAA was properly finalized.
	*/
	virtual GFSDK_HAIR_RETURNCODES FinishMSAARendering(void) = 0;

	/**
		\brief draw color buffer from MSAA resolve
		\details This step composite msaa generated hair colors to the current render target
		\param [in] useCustomDepthStencilState whether to use custom depth stencil state or not
		\return GFSDK_RETURN_OK is returned if MSAA color was successfully drawn.
	*/
	virtual GFSDK_HAIR_RETURNCODES DrawMSAAColor(bool useCustomDepthStencilState = false) = 0;

	/**
		\brief draw color buffer from MSAA resolve
		\details This step composite msaa generated hair depth to the current render target
		\return GFSDK_RETURN_OK is returned if depth was successfully drawn.
	*/
	virtual GFSDK_HAIR_RETURNCODES DrawMSAAPostDepth(bool emitPartialFramgment = true) = 0;

	/*=============================================================================================
		UTILITY FUNCTIONS

		Use the following functions to query further info/states of the HairWorks runtime.
		These functions are not need to just run the HairWorks, but could be useful for debugging/profiling purposes.
	=============================================================================================*/
	/**
		\brief Use this function to get the build string which includes build location and date/time
	*/
	virtual gfsdk_cstr GetBuildString() = 0;


	/**
		\brief get number of bones used in the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [out] boneSize number of bones gets written to this variable
		\return GFSDK_RETURN_OK is returned when hair asset id is valid and bone size was properly written.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBoneSize( const GFSDK_HairAssetID assetID, gfsdk_U32* boneSize ) = 0;

	/**
		\brief get bone name from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [in] boneID bone id to use
		\param [out] pBoneName bone name gets copied into this variable.
		\return GFSDK_RETURN_OK is returned when hair asset id is valid and bone name was properly written.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetBoneName( const GFSDK_HairAssetID assetID, const gfsdk_U32 boneID, gfsdk_char* pBoneName) = 0;

	/**
		\brief get texture file name from the specified hair asset
		\param [in] assetID hair asset ID to use
		\param [in] textureID texture id to use
		\param [out] pTextureName texture name gets copied into this variable.
		\return GFSDK_RETURN_OK is returned when hair asset id is valid and texture name was properly written.
	*/
	virtual GFSDK_HAIR_RETURNCODES GetTextureName( const GFSDK_HairAssetID assetID, const GFSDK_HAIR_TEXTURE_TYPE textureID, gfsdk_char* pTextureName) = 0;

	/**
	/*
		\brief get statistics about a hair instance
		\param[in] pd3dContext d3dcontext where this stat would be computed
		\param[in] instanceID hair instance id to pull stats from
		\param[out] stats pointer to GFSDK_HairStats struct
		\return GFSDK_RETURN_OK is returned when hair instance id is valid and stats are computed.
	*/
	virtual GFSDK_HAIR_RETURNCODES ComputeStats(const GFSDK_HairInstanceID instanceID, GFSDK_HairStats *stats) = 0;

	/**
		global density scale control to support lower end card
	*/
	virtual GFSDK_HAIR_RETURNCODES SetGlobalDensityQuality(float scale = 1.0f) = 0;

	/**
		global detail LOD control to support lower end card
	*/
	virtual GFSDK_HAIR_RETURNCODES SetGlobalDetailLODFactor(float factor = 1.0f) = 0;

	/**
		global density limit to support lower end card
	*/
	virtual GFSDK_HAIR_RETURNCODES SetGlobalDensityLimit(float limit = 10.0f) = 0;

	/**
		global width limit to support lower end card
	*/
	virtual GFSDK_HAIR_RETURNCODES SetGlobalWidthLimit(float limit = 10.0f) = 0;

	/**
		\brief global spline multiplier delta to support lower end card
		\param[in] changes asset's spline multiplier as follows. 1(-2), 2(-1), 3(0), 4(+1).
		For example, if delta is 2, each asset's spline multiplier decreases by 1.
	*/
	virtual GFSDK_HAIR_RETURNCODES SetGlobalStrandSmoothness(gfsdk_U32 delta) = 0;

};

/*
	\brief Use this function to load HairSDK from dll
	\param [in] dllPath Path to the GFSDK_HairWorks.*.dll file
	\param [in] version Version should match between this header and the dll
	\param [in] pCustomAllocator If not NULL, HairWorks will use this allocator for all internal CPU memory allocation
	\param [in] pCustomLogHandler If not NULL, HairWorks will use this log handler to process the log messages
	\return The HairWorks SDK instance pointer will be returned.
	*/
inline GFSDK_HairSDK* GFSDK_LoadHairSDK(gfsdk_cstr dllPath,
										gfsdk_U32 version = GFSDK_HAIRWORKS_VERSION,
										gfsdk_new_delete_t* pCustomAllocator = 0,
										GFSDK_HAIR_LogHandler* pCustomLogHandler = 0,
                                        int debugMode = 0
										)
{
	typedef GFSDK_HairSDK* (__cdecl * GET_HAIR_SDK_PROC)(gfsdk_U32, gfsdk_new_delete_t*, GFSDK_HAIR_LogHandler*, int);

	HMODULE hairDLLModule = LoadLibraryA(dllPath);

	if (hairDLLModule)
	{
		GET_HAIR_SDK_PROC pCreateProc = (GET_HAIR_SDK_PROC)GetProcAddress(hairDLLModule, "GFSDK_HairWorks_CreateClassInterface");

		if (!pCreateProc)
		{
			FreeLibrary( hairDLLModule);
			hairDLLModule = NULL;
			if (pCustomLogHandler) pCustomLogHandler->Log(GFSDK_HAIR_LOG_ERROR, "HairWorks dll file not found", 0, 0);
		}
		else
			return pCreateProc(version, pCustomAllocator, pCustomLogHandler, debugMode);
	}

	return 0;
}

extern "C"
{
	// Entry point to create the class based interface
	__GFSDK_EXPORT__ GFSDK_HairSDK *GFSDK_HairWorks_CreateClassInterface(gfsdk_U32 version_number, gfsdk_new_delete_t* pCustomAllocator, GFSDK_HAIR_LogHandler* pCustomLogHandler, int debugMode);
}

#endif
